
-----------
QUERY:
--
-- AGGREGATES
--

-- directory paths are passed to us in environment variables
-- \getenv abs_srcdir PG_ABS_SRCDIR

-- avoid bit-exact output here because operations may not be bit-exact.
SET extra_float_digits = 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "extra_float_digits"

Did you mean: "threads"

-----------
QUERY:


-- prepare some test data
CREATE TABLE aggtest (
	a 			int2,
	b			float4
);
RESULT:
	[]

-----------
QUERY:


-- \set filename /* REPLACED */ PG_ABS_SRCDIR '/data/agg.data'
COPY aggtest FROM /* REPLACED */ PG_ABS_SRCDIR '/data/agg.data';
RESULT:
	[]

-----------
QUERY:


ANALYZE aggtest;
RESULT:
	[]

-----------
QUERY:



SELECT avg(four) AS avg_1 FROM onek;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:


SELECT avg(a) AS avg_32 FROM aggtest WHERE a < 100;
RESULT:
	[(32.666666666666664,)]

-----------
QUERY:


SELECT any_value(v) FROM (VALUES (1), (2), (3)) AS v (v);
RESULT:
	[(1,)]

-----------
QUERY:

SELECT any_value(v) FROM (VALUES (NULL)) AS v (v);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT any_value(v) FROM (VALUES (NULL), (1), (2)) AS v (v);
RESULT:
	[(1,)]

-----------
QUERY:

SELECT any_value(v) FROM (VALUES (array['hello', 'world'])) AS v (v);
RESULT:
	[(['hello', 'world'],)]

-----------
QUERY:


-- In 7.1, avg(float4) is computed using float8 arithmetic.
-- Round the result to 3 digits to avoid platform-specific results.

SELECT avg(b)::numeric(10,3) AS avg_107_943 FROM aggtest;
RESULT:
	[(Decimal('107.943'),)]

-----------
QUERY:


SELECT avg(gpa) AS avg_3_4 FROM ONLY student;
RESULT:
	ERROR - Catalog Error: Table with name student does not exist!
Did you mean "aggtest"?

-----------
QUERY:



SELECT sum(four) AS sum_1500 FROM onek;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:

SELECT sum(a) AS sum_198 FROM aggtest;
RESULT:
	[(198,)]

-----------
QUERY:

SELECT sum(b) AS avg_431_773 FROM aggtest;
RESULT:
	[(431.77260909229517,)]

-----------
QUERY:

SELECT sum(gpa) AS avg_6_8 FROM ONLY student;
RESULT:
	ERROR - Catalog Error: Table with name student does not exist!
Did you mean "aggtest"?

-----------
QUERY:


SELECT max(four) AS max_3 FROM onek;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:

SELECT max(a) AS max_100 FROM aggtest;
RESULT:
	[(100,)]

-----------
QUERY:

SELECT max(aggtest.b) AS max_324_78 FROM aggtest;
RESULT:
	[(324.7799987792969,)]

-----------
QUERY:

SELECT max(student.gpa) AS max_3_7 FROM student;
RESULT:
	ERROR - Catalog Error: Table with name student does not exist!
Did you mean "aggtest"?

-----------
QUERY:


SELECT stddev_pop(b) FROM aggtest;
RESULT:
	[(131.10703231895047,)]

-----------
QUERY:

SELECT stddev_samp(b) FROM aggtest;
RESULT:
	[(151.38936080399804,)]

-----------
QUERY:

SELECT var_pop(b) FROM aggtest;
RESULT:
	[(17189.053923482323,)]

-----------
QUERY:

SELECT var_samp(b) FROM aggtest;
RESULT:
	[(22918.738564643096,)]

-----------
QUERY:


SELECT stddev_pop(b::numeric) FROM aggtest;
RESULT:
	[(131.10695265960345,)]

-----------
QUERY:

SELECT stddev_samp(b::numeric) FROM aggtest;
RESULT:
	[(151.38926882130716,)]

-----------
QUERY:

SELECT var_pop(b::numeric) FROM aggtest;
RESULT:
	[(17189.0330356875,)]

-----------
QUERY:

SELECT var_samp(b::numeric) FROM aggtest;
RESULT:
	[(22918.71071425,)]

-----------
QUERY:


-- population variance is defined for a single tuple, sample variance
-- is not
SELECT var_pop(1.0::float8), var_samp(2.0::float8);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT stddev_pop(3.0::float8), stddev_samp(4.0::float8);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT var_pop('inf'::float8), var_samp('inf'::float8);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT stddev_pop('inf'::float8), stddev_samp('inf'::float8);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT var_pop('nan'::float8), var_samp('nan'::float8);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT stddev_pop('nan'::float8), stddev_samp('nan'::float8);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT var_pop(1.0::float4), var_samp(2.0::float4);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT stddev_pop(3.0::float4), stddev_samp(4.0::float4);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT var_pop('inf'::float4), var_samp('inf'::float4);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT stddev_pop('inf'::float4), stddev_samp('inf'::float4);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT var_pop('nan'::float4), var_samp('nan'::float4);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT stddev_pop('nan'::float4), stddev_samp('nan'::float4);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT var_pop(1.0::numeric), var_samp(2.0::numeric);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT stddev_pop(3.0::numeric), stddev_samp(4.0::numeric);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT var_pop('inf'::numeric), var_samp('inf'::numeric);
RESULT:
	ERROR - Conversion Error: Could not convert string "inf" to DECIMAL(18,3)

-----------
QUERY:

SELECT stddev_pop('inf'::numeric), stddev_samp('inf'::numeric);
RESULT:
	ERROR - Conversion Error: Could not convert string "inf" to DECIMAL(18,3)

-----------
QUERY:

SELECT var_pop('nan'::numeric), var_samp('nan'::numeric);
RESULT:
	ERROR - Conversion Error: Could not convert string "nan" to DECIMAL(18,3)

-----------
QUERY:

SELECT stddev_pop('nan'::numeric), stddev_samp('nan'::numeric);
RESULT:
	ERROR - Conversion Error: Could not convert string "nan" to DECIMAL(18,3)

-----------
QUERY:


-- verify correct results for null and NaN inputs
select sum(null::int4) from generate_series(1,3);
RESULT:
	[(None,)]

-----------
QUERY:

select sum(null::int8) from generate_series(1,3);
RESULT:
	[(None,)]

-----------
QUERY:

select sum(null::numeric) from generate_series(1,3);
RESULT:
	[(None,)]

-----------
QUERY:

select sum(null::float8) from generate_series(1,3);
RESULT:
	[(None,)]

-----------
QUERY:

select avg(null::int4) from generate_series(1,3);
RESULT:
	[(None,)]

-----------
QUERY:

select avg(null::int8) from generate_series(1,3);
RESULT:
	[(None,)]

-----------
QUERY:

select avg(null::numeric) from generate_series(1,3);
RESULT:
	[(None,)]

-----------
QUERY:

select avg(null::float8) from generate_series(1,3);
RESULT:
	[(None,)]

-----------
QUERY:

select sum('NaN'::numeric) from generate_series(1,3);
RESULT:
	ERROR - Conversion Error: Could not convert string "NaN" to DECIMAL(18,3)

-----------
QUERY:

select avg('NaN'::numeric) from generate_series(1,3);
RESULT:
	ERROR - Conversion Error: Could not convert string "NaN" to DECIMAL(18,3)

-----------
QUERY:


-- verify correct results for infinite inputs
SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
FROM (VALUES ('1'), ('infinity')) v(x);
RESULT:
	ERROR - Out of Range Error: VARPOP is out of range!

-----------
QUERY:

SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
FROM (VALUES ('infinity'), ('1')) v(x);
RESULT:
	ERROR - Out of Range Error: VARPOP is out of range!

-----------
QUERY:

SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
FROM (VALUES ('infinity'), ('infinity')) v(x);
RESULT:
	ERROR - Out of Range Error: VARPOP is out of range!

-----------
QUERY:

SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
FROM (VALUES ('-infinity'), ('infinity')) v(x);
RESULT:
	ERROR - Out of Range Error: VARPOP is out of range!

-----------
QUERY:

SELECT sum(x::float8), avg(x::float8), var_pop(x::float8)
FROM (VALUES ('-infinity'), ('-infinity')) v(x);
RESULT:
	ERROR - Out of Range Error: VARPOP is out of range!

-----------
QUERY:

SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
FROM (VALUES ('1'), ('infinity')) v(x);
RESULT:
	ERROR - Conversion Error: Could not convert string "infinity" to DECIMAL(18,3)

-----------
QUERY:

SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
FROM (VALUES ('infinity'), ('1')) v(x);
RESULT:
	ERROR - Conversion Error: Could not convert string "infinity" to DECIMAL(18,3)

-----------
QUERY:

SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
FROM (VALUES ('infinity'), ('infinity')) v(x);
RESULT:
	ERROR - Conversion Error: Could not convert string "infinity" to DECIMAL(18,3)

-----------
QUERY:

SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
FROM (VALUES ('-infinity'), ('infinity')) v(x);
RESULT:
	ERROR - Conversion Error: Could not convert string "-infinity" to DECIMAL(18,3)

-----------
QUERY:

SELECT sum(x::numeric), avg(x::numeric), var_pop(x::numeric)
FROM (VALUES ('-infinity'), ('-infinity')) v(x);
RESULT:
	ERROR - Conversion Error: Could not convert string "-infinity" to DECIMAL(18,3)

-----------
QUERY:


-- test accuracy with a large input offset
SELECT avg(x::float8), var_pop(x::float8)
FROM (VALUES (100000003), (100000004), (100000006), (100000007)) v(x);
RESULT:
	[(100000005.0, 2.5000000055879354)]

-----------
QUERY:

SELECT avg(x::float8), var_pop(x::float8)
FROM (VALUES (7000000000005), (7000000000007)) v(x);
RESULT:
	[(7000000000006.0, 1.0)]

-----------
QUERY:


-- SQL2003 binary aggregates
SELECT regr_count(b, a) FROM aggtest;
RESULT:
	[(4,)]

-----------
QUERY:

SELECT regr_sxx(b, a) FROM aggtest;
RESULT:
	[(5099.0,)]

-----------
QUERY:

SELECT regr_syy(b, a) FROM aggtest;
RESULT:
	[(68756.21569392929,)]

-----------
QUERY:

SELECT regr_sxy(b, a) FROM aggtest;
RESULT:
	[(2614.5158215500414,)]

-----------
QUERY:

SELECT regr_avgx(b, a), regr_avgy(b, a) FROM aggtest;
RESULT:
	[(49.5, 107.94315227307379)]

-----------
QUERY:

SELECT regr_r2(b, a) FROM aggtest;
RESULT:
	[(0.019497798203180258,)]

-----------
QUERY:

SELECT regr_slope(b, a), regr_intercept(b, a) FROM aggtest;
RESULT:
	[(0.5127507004412711, 82.56199260123087)]

-----------
QUERY:

SELECT covar_pop(b, a), covar_samp(b, a) FROM aggtest;
RESULT:
	[(653.6289553875104, 871.5052738500139)]

-----------
QUERY:

SELECT corr(b, a) FROM aggtest;
RESULT:
	[(0.1396345165178734,)]

-----------
QUERY:


-- check single-tuple behavior
SELECT covar_pop(1::float8,2::float8), covar_samp(3::float8,4::float8);
RESULT:
	[(0.0, None)]

-----------
QUERY:

SELECT covar_pop(1::float8,'inf'::float8), covar_samp(3::float8,'inf'::float8);
RESULT:
	[(nan, None)]

-----------
QUERY:

SELECT covar_pop(1::float8,'nan'::float8), covar_samp(3::float8,'nan'::float8);
RESULT:
	[(nan, None)]

-----------
QUERY:


-- test accum and combine functions directly
CREATE TABLE regr_test (x float8, y float8);
RESULT:
	[]

-----------
QUERY:

INSERT INTO regr_test VALUES (10,150),(20,250),(30,350),(80,540),(100,200);
RESULT:
	[]

-----------
QUERY:

SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
FROM regr_test WHERE x IN (10,20,30,80);
RESULT:
	[(4, 140.0, 2900.0, 1290.0, 83075.0, 15050.0)]

-----------
QUERY:

SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
FROM regr_test;
RESULT:
	[(5, 240.0, 6280.0, 1490.0, 95080.0, 8680.0)]

-----------
QUERY:

SELECT float8_accum('{4,140,2900}'::float8[], 100);
RESULT:
	ERROR - Catalog Error: Scalar Function with name float8_accum does not exist!
Did you mean "lcm"?

-----------
QUERY:

SELECT float8_regr_accum('{4,140,2900,1290,83075,15050}'::float8[], 200, 100);
RESULT:
	ERROR - Catalog Error: Scalar Function with name float8_regr_accum does not exist!
Did you mean "filter"?

-----------
QUERY:

SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
FROM regr_test WHERE x IN (10,20,30);
RESULT:
	[(3, 60.0, 200.0, 750.0, 20000.0, 2000.0)]

-----------
QUERY:

SELECT count(*), sum(x), regr_sxx(y,x), sum(y),regr_syy(y,x), regr_sxy(y,x)
FROM regr_test WHERE x IN (80,100);
RESULT:
	[(2, 180.0, 200.0, 740.0, 57800.0, -3400.0)]

-----------
QUERY:

SELECT float8_combine('{3,60,200}'::float8[], '{0,0,0}'::float8[]);
RESULT:
	ERROR - Catalog Error: Scalar Function with name float8_combine does not exist!
Did you mean "combine"?

-----------
QUERY:

SELECT float8_combine('{0,0,0}'::float8[], '{2,180,200}'::float8[]);
RESULT:
	ERROR - Catalog Error: Scalar Function with name float8_combine does not exist!
Did you mean "combine"?

-----------
QUERY:

SELECT float8_combine('{3,60,200}'::float8[], '{2,180,200}'::float8[]);
RESULT:
	ERROR - Catalog Error: Scalar Function with name float8_combine does not exist!
Did you mean "combine"?

-----------
QUERY:

SELECT float8_regr_combine('{3,60,200,750,20000,2000}'::float8[],
                           '{0,0,0,0,0,0}'::float8[]);
RESULT:
	ERROR - Catalog Error: Scalar Function with name float8_regr_combine does not exist!
Did you mean "arg_min"?

-----------
QUERY:

SELECT float8_regr_combine('{0,0,0,0,0,0}'::float8[],
                           '{2,180,200,740,57800,-3400}'::float8[]);
RESULT:
	ERROR - Catalog Error: Scalar Function with name float8_regr_combine does not exist!
Did you mean "arg_min"?

-----------
QUERY:

SELECT float8_regr_combine('{3,60,200,750,20000,2000}'::float8[],
                           '{2,180,200,740,57800,-3400}'::float8[]);
RESULT:
	ERROR - Catalog Error: Scalar Function with name float8_regr_combine does not exist!
Did you mean "arg_min"?

-----------
QUERY:

DROP TABLE regr_test;
RESULT:
	[]

-----------
QUERY:


-- test count, distinct
SELECT count(four) AS cnt_1000 FROM onek;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:

SELECT count(DISTINCT four) AS cnt_4 FROM onek;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:


select ten, count(*), sum(four) from onek
group by ten order by ten;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:


select ten, count(four), sum(DISTINCT four) from onek
group by ten order by ten;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:


-- user-defined aggregates
SELECT newavg(four) AS avg_1 FROM onek;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:

SELECT newsum(four) AS sum_1500 FROM onek;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:

SELECT newcnt(four) AS cnt_1000 FROM onek;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:

SELECT newcnt(*) AS cnt_1000 FROM onek;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:

SELECT oldcnt(*) AS cnt_1000 FROM onek;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:

SELECT sum2(q1,q2) FROM int8_tbl;
RESULT:
	ERROR - Catalog Error: Scalar Function with name sum2 does not exist!
Did you mean "sum"?

-----------
QUERY:


-- test for outer-level aggregates

-- this should work
select ten, sum(distinct four) from onek a
group by ten
having exists (select 1 from onek b where sum(distinct a.four) = b.four);
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:


-- this should fail because subquery has an agg of its own in WHERE
select ten, sum(distinct four) from onek a
group by ten
having exists (select 1 from onek b
               where sum(distinct a.four + b.four) = b.four);
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?

-----------
QUERY:


-- Test handling of sublinks within outer-level aggregates.
-- Per bug report from Daniel Grace.
select
  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1)))
from tenk1 o;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:


-- Test handling of Params within aggregate arguments in hashed aggregation.
-- Per bug report from Jeevan Chalke.
explain (verbose, costs off)
select s1, s2, sm
from generate_series(1, 3) s1,
     lateral (select s2, sum(s1 + s2) sm
              from generate_series(1, 3) s2 group by s2) ss
order by 1, 2;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: verbose

-----------
QUERY:

select s1, s2, sm
from generate_series(1, 3) s1,
     lateral (select s2, sum(s1 + s2) sm
              from generate_series(1, 3) s2 group by s2) ss
order by 1, 2;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '+(STRUCT(generate_series BIGINT), STRUCT(generate_series BIGINT))'. You might need to add explicit type casts.
	Candidate functions:
	+(TINYINT) -> TINYINT
	+(TINYINT, TINYINT) -> TINYINT
	+(SMALLINT) -> SMALLINT
	+(SMALLINT, SMALLINT) -> SMALLINT
	+(INTEGER) -> INTEGER
	+(INTEGER, INTEGER) -> INTEGER
	+(BIGINT) -> BIGINT
	+(BIGINT, BIGINT) -> BIGINT
	+(HUGEINT) -> HUGEINT
	+(HUGEINT, HUGEINT) -> HUGEINT
	+(FLOAT) -> FLOAT
	+(FLOAT, FLOAT) -> FLOAT
	+(DOUBLE) -> DOUBLE
	+(DOUBLE, DOUBLE) -> DOUBLE
	+(DECIMAL) -> DECIMAL
	+(DECIMAL, DECIMAL) -> DECIMAL
	+(UTINYINT) -> UTINYINT
	+(UTINYINT, UTINYINT) -> UTINYINT
	+(USMALLINT) -> USMALLINT
	+(USMALLINT, USMALLINT) -> USMALLINT
	+(UINTEGER) -> UINTEGER
	+(UINTEGER, UINTEGER) -> UINTEGER
	+(UBIGINT) -> UBIGINT
	+(UBIGINT, UBIGINT) -> UBIGINT
	+(UHUGEINT) -> UHUGEINT
	+(UHUGEINT, UHUGEINT) -> UHUGEINT
	+(DATE, INTEGER) -> DATE
	+(INTEGER, DATE) -> DATE
	+(INTERVAL, INTERVAL) -> INTERVAL
	+(DATE, INTERVAL) -> TIMESTAMP
	+(INTERVAL, DATE) -> TIMESTAMP
	+(TIME, INTERVAL) -> TIME
	+(INTERVAL, TIME) -> TIME
	+(TIMESTAMP, INTERVAL) -> TIMESTAMP
	+(INTERVAL, TIMESTAMP) -> TIMESTAMP
	+(TIME WITH TIME ZONE, INTERVAL) -> TIME WITH TIME ZONE
	+(INTERVAL, TIME WITH TIME ZONE) -> TIME WITH TIME ZONE
	+(TIME, DATE) -> TIMESTAMP
	+(DATE, TIME) -> TIMESTAMP
	+(TIME WITH TIME ZONE, DATE) -> TIMESTAMP WITH TIME ZONE
	+(DATE, TIME WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE
	+(ANY[], ANY[]) -> ANY[]
	+(TIMESTAMP WITH TIME ZONE, INTERVAL) -> TIMESTAMP WITH TIME ZONE
	+(INTERVAL, TIMESTAMP WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE


-----------
QUERY:


explain (verbose, costs off)
select array(select sum(x+y) s
            from generate_series(1,3) y group by y order by s)
  from generate_series(1,3) x;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: verbose

-----------
QUERY:

select array(select sum(x+y) s
            from generate_series(1,3) y group by y order by s)
  from generate_series(1,3) x;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '+(STRUCT(generate_series BIGINT), STRUCT(generate_series BIGINT))'. You might need to add explicit type casts.
	Candidate functions:
	+(TINYINT) -> TINYINT
	+(TINYINT, TINYINT) -> TINYINT
	+(SMALLINT) -> SMALLINT
	+(SMALLINT, SMALLINT) -> SMALLINT
	+(INTEGER) -> INTEGER
	+(INTEGER, INTEGER) -> INTEGER
	+(BIGINT) -> BIGINT
	+(BIGINT, BIGINT) -> BIGINT
	+(HUGEINT) -> HUGEINT
	+(HUGEINT, HUGEINT) -> HUGEINT
	+(FLOAT) -> FLOAT
	+(FLOAT, FLOAT) -> FLOAT
	+(DOUBLE) -> DOUBLE
	+(DOUBLE, DOUBLE) -> DOUBLE
	+(DECIMAL) -> DECIMAL
	+(DECIMAL, DECIMAL) -> DECIMAL
	+(UTINYINT) -> UTINYINT
	+(UTINYINT, UTINYINT) -> UTINYINT
	+(USMALLINT) -> USMALLINT
	+(USMALLINT, USMALLINT) -> USMALLINT
	+(UINTEGER) -> UINTEGER
	+(UINTEGER, UINTEGER) -> UINTEGER
	+(UBIGINT) -> UBIGINT
	+(UBIGINT, UBIGINT) -> UBIGINT
	+(UHUGEINT) -> UHUGEINT
	+(UHUGEINT, UHUGEINT) -> UHUGEINT
	+(DATE, INTEGER) -> DATE
	+(INTEGER, DATE) -> DATE
	+(INTERVAL, INTERVAL) -> INTERVAL
	+(DATE, INTERVAL) -> TIMESTAMP
	+(INTERVAL, DATE) -> TIMESTAMP
	+(TIME, INTERVAL) -> TIME
	+(INTERVAL, TIME) -> TIME
	+(TIMESTAMP, INTERVAL) -> TIMESTAMP
	+(INTERVAL, TIMESTAMP) -> TIMESTAMP
	+(TIME WITH TIME ZONE, INTERVAL) -> TIME WITH TIME ZONE
	+(INTERVAL, TIME WITH TIME ZONE) -> TIME WITH TIME ZONE
	+(TIME, DATE) -> TIMESTAMP
	+(DATE, TIME) -> TIMESTAMP
	+(TIME WITH TIME ZONE, DATE) -> TIMESTAMP WITH TIME ZONE
	+(DATE, TIME WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE
	+(ANY[], ANY[]) -> ANY[]
	+(TIMESTAMP WITH TIME ZONE, INTERVAL) -> TIMESTAMP WITH TIME ZONE
	+(INTERVAL, TIMESTAMP WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE


-----------
QUERY:


--
-- test for bitwise integer aggregates
--
CREATE TEMPORARY TABLE bitwise_test(
  i2 INT2,
  i4 INT4,
  i8 INT8,
  i INTEGER,
  x INT2,
  y BIT(4)
);
RESULT:
	ERROR - Parser Error: Type BIT does not support any modifiers!

-----------
QUERY:


-- empty case
SELECT
  BIT_AND(i2) AS "?",
  BIT_OR(i4)  AS "?",
  BIT_XOR(i8) AS "?"
FROM bitwise_test;
RESULT:
	ERROR - Catalog Error: Table with name bitwise_test does not exist!
Did you mean "aggtest"?

-----------
QUERY:


COPY bitwise_test FROM STDIN NULL 'null';
RESULT:
	ERROR - Catalog Error: Table with name bitwise_test does not exist!
Did you mean "aggtest"?

-----------
QUERY:

1	1	1	1	1	B0101
3	3	3	null	2	B0100
7	7	7	3	4	B1100
-- \.

SELECT
  BIT_AND(i2) AS "1",
  BIT_AND(i4) AS "1",
  BIT_AND(i8) AS "1",
  BIT_AND(i)  AS "?",
  BIT_AND(x)  AS "0",
  BIT_AND(y)  AS "0100",

  BIT_OR(i2)  AS "7",
  BIT_OR(i4)  AS "7",
  BIT_OR(i8)  AS "7",
  BIT_OR(i)   AS "?",
  BIT_OR(x)   AS "7",
  BIT_OR(y)   AS "1101",

  BIT_XOR(i2) AS "5",
  BIT_XOR(i4) AS "5",
  BIT_XOR(i8) AS "5",
  BIT_XOR(i)  AS "?",
  BIT_XOR(x)  AS "7",
  BIT_XOR(y)  AS "1101"
FROM bitwise_test;
RESULT:
	ERROR - Parser Error: syntax error at or near "1"

-----------
QUERY:


--
-- test boolean aggregates
--
-- first test all possible transition and final states

SELECT
  -- boolean and transitions
  -- null because strict
  booland_statefunc(NULL, NULL)  IS NULL AS "t",
  booland_statefunc(TRUE, NULL)  IS NULL AS "t",
  booland_statefunc(FALSE, NULL) IS NULL AS "t",
  booland_statefunc(NULL, TRUE)  IS NULL AS "t",
  booland_statefunc(NULL, FALSE) IS NULL AS "t",
  -- and actual computations
  booland_statefunc(TRUE, TRUE) AS "t",
  NOT booland_statefunc(TRUE, FALSE) AS "t",
  NOT booland_statefunc(FALSE, TRUE) AS "t",
  NOT booland_statefunc(FALSE, FALSE) AS "t";
RESULT:
	ERROR - Catalog Error: Scalar Function with name booland_statefunc does not exist!
Did you mean "bool_and"?

-----------
QUERY:


SELECT
  -- boolean or transitions
  -- null because strict
  boolor_statefunc(NULL, NULL)  IS NULL AS "t",
  boolor_statefunc(TRUE, NULL)  IS NULL AS "t",
  boolor_statefunc(FALSE, NULL) IS NULL AS "t",
  boolor_statefunc(NULL, TRUE)  IS NULL AS "t",
  boolor_statefunc(NULL, FALSE) IS NULL AS "t",
  -- actual computations
  boolor_statefunc(TRUE, TRUE) AS "t",
  boolor_statefunc(TRUE, FALSE) AS "t",
  boolor_statefunc(FALSE, TRUE) AS "t",
  NOT boolor_statefunc(FALSE, FALSE) AS "t";
RESULT:
	ERROR - Catalog Error: Scalar Function with name boolor_statefunc does not exist!
Did you mean "bool_and"?

-----------
QUERY:


CREATE TEMPORARY TABLE bool_test(
  b1 BOOL,
  b2 BOOL,
  b3 BOOL,
  b4 BOOL);
RESULT:
	[]

-----------
QUERY:


-- empty case
SELECT
  BOOL_AND(b1)   AS "n",
  BOOL_OR(b3)    AS "n"
FROM bool_test;
RESULT:
	[(None, None)]

-----------
QUERY:


COPY bool_test FROM STDIN NULL 'null';
RESULT:
	ERROR - IO Error: No files found that match the pattern "/dev/stdin"

-----------
QUERY:

TRUE	null	FALSE	null
FALSE	TRUE	null	null
null	TRUE	FALSE	null
-- \.

SELECT
  BOOL_AND(b1)     AS "f",
  BOOL_AND(b2)     AS "t",
  BOOL_AND(b3)     AS "f",
  BOOL_AND(b4)     AS "n",
  BOOL_AND(NOT b2) AS "f",
  BOOL_AND(NOT b3) AS "t"
FROM bool_test;
RESULT:
	ERROR - Parser Error: syntax error at or near "TRUE"

-----------
QUERY:


SELECT
  EVERY(b1)     AS "f",
  EVERY(b2)     AS "t",
  EVERY(b3)     AS "f",
  EVERY(b4)     AS "n",
  EVERY(NOT b2) AS "f",
  EVERY(NOT b3) AS "t"
FROM bool_test;
RESULT:
	ERROR - Catalog Error: Scalar Function with name every does not exist!
Did you mean "even"?

-----------
QUERY:


SELECT
  BOOL_OR(b1)      AS "t",
  BOOL_OR(b2)      AS "t",
  BOOL_OR(b3)      AS "f",
  BOOL_OR(b4)      AS "n",
  BOOL_OR(NOT b2)  AS "f",
  BOOL_OR(NOT b3)  AS "t"
FROM bool_test;
RESULT:
	[(None, None, None, None, None, None)]

-----------
QUERY:


--
-- Test cases that should be optimized into indexscans instead of
-- the generic aggregate implementation.
--

-- Basic cases
explain (costs off)
  select min(unique1) from tenk1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select min(unique1) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

explain (costs off)
  select max(unique1) from tenk1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select max(unique1) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

explain (costs off)
  select max(unique1) from tenk1 where unique1 < 42;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select max(unique1) from tenk1 where unique1 < 42;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

explain (costs off)
  select max(unique1) from tenk1 where unique1 > 42;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select max(unique1) from tenk1 where unique1 > 42;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:


-- the planner may choose a generic aggregate here if parallel query is
-- enabled, since that plan will be parallel safe and the /* REPLACED */ ''optimized/* REPLACED */ ''
-- plan, which has almost identical cost, will not be.  we want to test
-- the optimized plan, so temporarily disable parallel query.
begin;
RESULT:
	[]

-----------
QUERY:

set local max_parallel_workers_per_gather = 0;
RESULT:
	ERROR - Not implemented Error: SET LOCAL is not implemented.

-----------
QUERY:

explain (costs off)
  select max(unique1) from tenk1 where unique1 > 42000;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select max(unique1) from tenk1 where unique1 > 42000;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

rollback;
RESULT:
	[]

-----------
QUERY:


-- multi-column index (uses tenk1_thous_tenthous)
explain (costs off)
  select max(tenthous) from tenk1 where thousand = 33;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select max(tenthous) from tenk1 where thousand = 33;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

explain (costs off)
  select min(tenthous) from tenk1 where thousand = 33;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select min(tenthous) from tenk1 where thousand = 33;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:


-- check parameter propagation into an indexscan subquery
explain (costs off)
  select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
    from int4_tbl;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select f1, (select min(unique1) from tenk1 where unique1 > f1) AS gt
  from int4_tbl;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:


-- check some cases that were handled incorrectly in 8.3.0
explain (costs off)
  select distinct max(unique2) from tenk1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select distinct max(unique2) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

explain (costs off)
  select max(unique2) from tenk1 order by 1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select max(unique2) from tenk1 order by 1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

explain (costs off)
  select max(unique2) from tenk1 order by max(unique2);
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select max(unique2) from tenk1 order by max(unique2);
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

explain (costs off)
  select max(unique2) from tenk1 order by max(unique2)+1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select max(unique2) from tenk1 order by max(unique2)+1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

explain (costs off)
  select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select max(unique2), generate_series(1,3) as g from tenk1 order by g desc;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:


-- interesting corner case: constant gets optimized into a seqscan
explain (costs off)
  select max(100) from tenk1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select max(100) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:


-- try it on an inheritance tree
create table minmaxtest(f1 int);
RESULT:
	[]

-----------
QUERY:

create table minmaxtest1() inherits (minmaxtest);
RESULT:
	ERROR - Parser Error: syntax error at or near "inherits"

-----------
QUERY:

create table minmaxtest2() inherits (minmaxtest);
RESULT:
	ERROR - Parser Error: syntax error at or near "inherits"

-----------
QUERY:

create table minmaxtest3() inherits (minmaxtest);
RESULT:
	ERROR - Parser Error: syntax error at or near "inherits"

-----------
QUERY:

create index minmaxtesti on minmaxtest(f1);
RESULT:
	[]

-----------
QUERY:

create index minmaxtest1i on minmaxtest1(f1);
RESULT:
	ERROR - Catalog Error: Table with name minmaxtest1 does not exist!
Did you mean "minmaxtest"?

-----------
QUERY:

create index minmaxtest2i on minmaxtest2(f1 desc);
RESULT:
	ERROR - Catalog Error: Table with name minmaxtest2 does not exist!
Did you mean "minmaxtest"?

-----------
QUERY:

create index minmaxtest3i on minmaxtest3(f1) where f1 is not null;
RESULT:
	ERROR - Catalog Error: Table with name minmaxtest3 does not exist!
Did you mean "minmaxtest"?

-----------
QUERY:


insert into minmaxtest values(11), (12);
RESULT:
	[]

-----------
QUERY:

insert into minmaxtest1 values(13), (14);
RESULT:
	ERROR - Catalog Error: Table with name minmaxtest1 does not exist!
Did you mean "minmaxtest"?

-----------
QUERY:

insert into minmaxtest2 values(15), (16);
RESULT:
	ERROR - Catalog Error: Table with name minmaxtest2 does not exist!
Did you mean "minmaxtest"?

-----------
QUERY:

insert into minmaxtest3 values(17), (18);
RESULT:
	ERROR - Catalog Error: Table with name minmaxtest3 does not exist!
Did you mean "minmaxtest"?

-----------
QUERY:


explain (costs off)
  select min(f1), max(f1) from minmaxtest;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select min(f1), max(f1) from minmaxtest;
RESULT:
	[(11, 12)]

-----------
QUERY:


-- DISTINCT doesn/* REPLACED */ ''t do anything useful here, but it shouldn/* REPLACED */ ''t fail
explain (costs off)
  select distinct min(f1), max(f1) from minmaxtest;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

select distinct min(f1), max(f1) from minmaxtest;
RESULT:
	[(11, 12)]

-----------
QUERY:


drop table minmaxtest cascade;
RESULT:
	[]

-----------
QUERY:


-- check for correct detection of nested-aggregate errors
select max(min(unique1)) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

select (select max(min(unique1)) from int8_tbl) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

select avg((select avg(a1.col1 order by (select avg(a2.col2) from tenk1 a3))
            from tenk1 a1(col1)))
from tenk1 a2(col2);
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:


--
-- Test removal of redundant GROUP BY columns
--

create temp table t1 (a int, b int, c int, d int, primary key (a, b));
RESULT:
	[]

-----------
QUERY:

create temp table t2 (x int, y int, z int, primary key (x, y));
RESULT:
	[]

-----------
QUERY:

create temp table t3 (a int, b int, c int, primary key(a, b) deferrable);
RESULT:
	[]

-----------
QUERY:


-- Non-primary-key columns can be removed from GROUP BY
explain (costs off) select * from t1 group by a,b,c,d;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- No removal can happen if the complete PK is not present in GROUP BY
explain (costs off) select a,c from t1 group by a,c,d;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- Test removal across multiple relations
explain (costs off) select *
from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.y,t2.z;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- Test case where t1 can be optimized but not t2
explain (costs off) select t1.*,t2.x,t2.z
from t1 inner join t2 on t1.a = t2.x and t1.b = t2.y
group by t1.a,t1.b,t1.c,t1.d,t2.x,t2.z;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- Cannot optimize when PK is deferrable
explain (costs off) select * from t3 group by a,b,c;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


create temp table t1c () inherits (t1);
RESULT:
	ERROR - Parser Error: syntax error at or near "inherits"

-----------
QUERY:


-- Ensure we don/* REPLACED */ ''t remove any columns when t1 has a child table
explain (costs off) select * from t1 group by a,b,c,d;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- Okay to remove columns if we/* REPLACED */ ''re only querying the parent.
explain (costs off) select * from only t1 group by a,b,c,d;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


create temp table p_t1 (
  a int,
  b int,
  c int,
  d int,
  primary key(a,b)
) partition by list(a);
RESULT:
	ERROR - Parser Error: syntax error at or near "partition"

-----------
QUERY:

create temp table p_t1_1 partition of p_t1 for values in(1);
RESULT:
	ERROR - Parser Error: syntax error at or near "partition"

-----------
QUERY:

create temp table p_t1_2 partition of p_t1 for values in(2);
RESULT:
	ERROR - Parser Error: syntax error at or near "partition"

-----------
QUERY:


-- Ensure we can remove non-PK columns for partitioned tables.
explain (costs off) select * from p_t1 group by a,b,c,d;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


drop table t1 cascade;
RESULT:
	[]

-----------
QUERY:

drop table t2;
RESULT:
	[]

-----------
QUERY:

drop table t3;
RESULT:
	[]

-----------
QUERY:

drop table p_t1;
RESULT:
	ERROR - Catalog Error: Table with name p_t1 does not exist!
Did you mean "pg_am"?

-----------
QUERY:


--
-- Test GROUP BY matching of join columns that are type-coerced due to USING
--

create temp table t1(f1 int, f2 int);
RESULT:
	[]

-----------
QUERY:

create temp table t2(f1 bigint, f2 oid);
RESULT:
	[]

-----------
QUERY:


select f1 from t1 left join t2 using (f1) group by f1;
RESULT:
	[]

-----------
QUERY:

select f1 from t1 left join t2 using (f1) group by t1.f1;
RESULT:
	[]

-----------
QUERY:

select t1.f1 from t1 left join t2 using (f1) group by t1.f1;
RESULT:
	[]

-----------
QUERY:

-- only this one should fail:
select t1.f1 from t1 left join t2 using (f1) group by f1;
RESULT:
	[]

-----------
QUERY:


-- check case where we have to inject nullingrels into coerced join alias
select f1, count(*) from
t1 x(x0,x1) left join (t1 left join t2 using(f1)) on (x0 = 0)
group by f1;
RESULT:
	[]

-----------
QUERY:


-- same, for a RelabelType coercion
select f2, count(*) from
t1 x(x0,x1) left join (t1 left join t2 using(f2)) on (x0 = 0)
group by f2;
RESULT:
	[]

-----------
QUERY:


drop table t1, t2;
RESULT:
	ERROR - Not implemented Error: Can only drop one object at a time

-----------
QUERY:


--
-- Test planner/* REPLACED */ ''s selection of pathkeys for ORDER BY aggregates
--

-- Ensure we order by four.  This suits the most aggregate functions.
explain (costs off)
select sum(two order by two),max(four order by four), min(four order by four)
from tenk1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- Ensure we order by two.  It/* REPLACED */ ''s a tie between ordering by two and four but
-- we tiebreak on the aggregate/* REPLACED */ ''s position.
explain (costs off)
select
  sum(two order by two), max(four order by four),
  min(four order by four), max(two order by two)
from tenk1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- Similar to above, but tiebreak on ordering by four
explain (costs off)
select
  max(four order by four), sum(two order by two),
  min(four order by four), max(two order by two)
from tenk1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- Ensure this one orders by ten since there are 3 aggregates that require ten
-- vs two that suit two and four.
explain (costs off)
select
  max(four order by four), sum(two order by two),
  min(four order by four), max(two order by two),
  sum(ten order by ten), min(ten order by ten), max(ten order by ten)
from tenk1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- Try a case involving a GROUP BY clause where the GROUP BY column is also
-- part of an aggregate/* REPLACED */ ''s ORDER BY clause.  We want a sort order that works
-- for the GROUP BY along with the first and the last aggregate.
explain (costs off)
select
  sum(unique1 order by ten, two), sum(unique1 order by four),
  sum(unique1 order by two, four)
from tenk1
group by ten;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- Ensure that we never choose to provide presorted input to an Aggref with
-- a volatile function in the ORDER BY / DISTINCT clause.  We want to ensure
-- these sorts are performed individually rather than at the query level.
explain (costs off)
select
  sum(unique1 order by two), sum(unique1 order by four),
  sum(unique1 order by four, two), sum(unique1 order by two, random()),
  sum(unique1 order by two, random(), random() + 1)
from tenk1
group by ten;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- Ensure consecutive NULLs are properly treated as distinct from each other
select array_agg(distinct val)
from (select null as val from generate_series(1, 2));
RESULT:
	[([None],)]

-----------
QUERY:


-- Ensure no ordering is requested when enable_presorted_aggregate is off
set enable_presorted_aggregate to off;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_presorted_aggregate"

Did you mean: "enable_progress_bar"

-----------
QUERY:

explain (costs off)
select sum(two order by two) from tenk1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

reset enable_presorted_aggregate;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_presorted_aggregate"

Did you mean: "enable_progress_bar"

-----------
QUERY:


--
-- Test combinations of DISTINCT and/or ORDER BY
--

select array_agg(a order by b)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
RESULT:
	[([3, 4, 2, 1],)]

-----------
QUERY:

select array_agg(a order by a)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
RESULT:
	[([1, 2, 3, 4],)]

-----------
QUERY:

select array_agg(a order by a desc)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
RESULT:
	[([4, 3, 2, 1],)]

-----------
QUERY:

select array_agg(b order by a desc)
  from (values (1,4),(2,3),(3,1),(4,2)) v(a,b);
RESULT:
	[([2, 1, 3, 4],)]

-----------
QUERY:


select array_agg(distinct a)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
RESULT:
	[([None, 1, 2, 3],)]

-----------
QUERY:

select array_agg(distinct a order by a)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
RESULT:
	[([1, 2, 3, None],)]

-----------
QUERY:

select array_agg(distinct a order by a desc)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
RESULT:
	[([3, 2, 1, None],)]

-----------
QUERY:

select array_agg(distinct a order by a desc nulls last)
  from (values (1),(2),(1),(3),(null),(2)) v(a);
RESULT:
	[([3, 2, 1, None],)]

-----------
QUERY:


-- multi-arg aggs, strict/nonstrict, distinct/order by

select aggfstr(a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfstr does not exist!
Did you mean "last"?

-----------
QUERY:

select aggfns(a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?

-----------
QUERY:


select aggfstr(distinct a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfstr does not exist!
Did you mean "last"?

-----------
QUERY:

select aggfns(distinct a,b,c)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?

-----------
QUERY:


select aggfstr(distinct a,b,c order by b)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfstr does not exist!
Did you mean "last"?

-----------
QUERY:

select aggfns(distinct a,b,c order by b)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,3) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?

-----------
QUERY:


-- test specific code paths

select aggfns(distinct a,a,c order by c using ~<~,a)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
RESULT:
	ERROR - Not implemented Error: Unimplemented order by type

-----------
QUERY:

select aggfns(distinct a,a,c order by c using ~<~)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
RESULT:
	ERROR - Not implemented Error: Unimplemented order by type

-----------
QUERY:

select aggfns(distinct a,a,c order by a)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?

-----------
QUERY:

select aggfns(distinct a,b,c order by a,c using ~<~,b)
  from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
       generate_series(1,2) i;
RESULT:
	ERROR - Not implemented Error: Unimplemented order by type

-----------
QUERY:


-- test a more complex permutation that has previous caused issues
select
    string_agg(distinct 'a', ','),
    sum((
        select sum(1)
        from (values(1)) b(id)
        where a.id = b.id
)) from unnest(array[1]) a(id);
RESULT:
	[('a', 1)]

-----------
QUERY:


-- check node I/O via view creation and usage, also deparsing logic

create view agg_view1 as
  select aggfns(a,b,c)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?
LINE 6:   select aggfns(a,b,c)
                 ^

-----------
QUERY:


select * from agg_view1;
RESULT:
	ERROR - Catalog Error: Table with name agg_view1 does not exist!
Did you mean "pg_views"?

-----------
QUERY:

select pg_get_viewdef('agg_view1'::regclass);
RESULT:
	ERROR - Catalog Error: Type with name regclass does not exist!
Did you mean "real"?

-----------
QUERY:


create or replace view agg_view1 as
  select aggfns(distinct a,b,c)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
         generate_series(1,3) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?
LINE 4:   select aggfns(distinct a,b,c)
                 ^

-----------
QUERY:


select * from agg_view1;
RESULT:
	ERROR - Catalog Error: Table with name agg_view1 does not exist!
Did you mean "pg_views"?

-----------
QUERY:

select pg_get_viewdef('agg_view1'::regclass);
RESULT:
	ERROR - Catalog Error: Type with name regclass does not exist!
Did you mean "real"?

-----------
QUERY:


create or replace view agg_view1 as
  select aggfns(distinct a,b,c order by b)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
         generate_series(1,3) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?
LINE 4:   select aggfns(distinct a,b,c order by b)
                 ^

-----------
QUERY:


select * from agg_view1;
RESULT:
	ERROR - Catalog Error: Table with name agg_view1 does not exist!
Did you mean "pg_views"?

-----------
QUERY:

select pg_get_viewdef('agg_view1'::regclass);
RESULT:
	ERROR - Catalog Error: Type with name regclass does not exist!
Did you mean "real"?

-----------
QUERY:


create or replace view agg_view1 as
  select aggfns(a,b,c order by b+1)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?
LINE 4:   select aggfns(a,b,c order by b+1)
                 ^

-----------
QUERY:


select * from agg_view1;
RESULT:
	ERROR - Catalog Error: Table with name agg_view1 does not exist!
Did you mean "pg_views"?

-----------
QUERY:

select pg_get_viewdef('agg_view1'::regclass);
RESULT:
	ERROR - Catalog Error: Type with name regclass does not exist!
Did you mean "real"?

-----------
QUERY:


create or replace view agg_view1 as
  select aggfns(a,a,c order by b)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?
LINE 4:   select aggfns(a,a,c order by b)
                 ^

-----------
QUERY:


select * from agg_view1;
RESULT:
	ERROR - Catalog Error: Table with name agg_view1 does not exist!
Did you mean "pg_views"?

-----------
QUERY:

select pg_get_viewdef('agg_view1'::regclass);
RESULT:
	ERROR - Catalog Error: Type with name regclass does not exist!
Did you mean "real"?

-----------
QUERY:


create or replace view agg_view1 as
  select aggfns(a,b,c order by c using ~<~)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c);
RESULT:
	ERROR - Not implemented Error: Unimplemented order by type

-----------
QUERY:


select * from agg_view1;
RESULT:
	ERROR - Catalog Error: Table with name agg_view1 does not exist!
Did you mean "pg_views"?

-----------
QUERY:

select pg_get_viewdef('agg_view1'::regclass);
RESULT:
	ERROR - Catalog Error: Type with name regclass does not exist!
Did you mean "real"?

-----------
QUERY:


create or replace view agg_view1 as
  select aggfns(distinct a,b,c order by a,c using ~<~,b)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
         generate_series(1,2) i;
RESULT:
	ERROR - Not implemented Error: Unimplemented order by type

-----------
QUERY:


select * from agg_view1;
RESULT:
	ERROR - Catalog Error: Table with name agg_view1 does not exist!
Did you mean "pg_views"?

-----------
QUERY:

select pg_get_viewdef('agg_view1'::regclass);
RESULT:
	ERROR - Catalog Error: Type with name regclass does not exist!
Did you mean "real"?

-----------
QUERY:


drop view agg_view1;
RESULT:
	ERROR - Catalog Error: View with name agg_view1 does not exist!
Did you mean "pg_views"?

-----------
QUERY:


-- incorrect DISTINCT usage errors

select aggfns(distinct a,b,c order by i)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?

-----------
QUERY:

select aggfns(distinct a,b,c order by a,b+1)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?

-----------
QUERY:

select aggfns(distinct a,b,c order by a,b,i,c)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?

-----------
QUERY:

select aggfns(distinct a,a,c order by a,b)
  from (values (1,1,'foo')) v(a,b,c), generate_series(1,2) i;
RESULT:
	ERROR - Catalog Error: Scalar Function with name aggfns does not exist!
Did you mean "abs"?

-----------
QUERY:


-- string_agg tests
select string_agg(a,',') from (values('aaaa'),('bbbb'),('cccc')) g(a);
RESULT:
	[('aaaa,bbbb,cccc',)]

-----------
QUERY:

select string_agg(a,',') from (values('aaaa'),(null),('bbbb'),('cccc')) g(a);
RESULT:
	[('aaaa,bbbb,cccc',)]

-----------
QUERY:

select string_agg(a,'AB') from (values(null),(null),('bbbb'),('cccc')) g(a);
RESULT:
	[('bbbbABcccc',)]

-----------
QUERY:

select string_agg(a,',') from (values(null),(null)) g(a);
RESULT:
	[(None,)]

-----------
QUERY:


-- check some implicit casting cases, as per bug #5564
select string_agg(distinct f1, ',' order by f1) from varchar_tbl;
RESULT:
	[('a,ab,abcd,abcd    ',)]

-----------
QUERY:
  -- ok
select string_agg(distinct f1::text, ',' order by f1) from varchar_tbl;
RESULT:
	[('a,ab,abcd,abcd    ',)]

-----------
QUERY:
  -- not ok
select string_agg(distinct f1, ',' order by f1::text) from varchar_tbl;
RESULT:
	[('a,ab,abcd,abcd    ',)]

-----------
QUERY:
  -- not ok
select string_agg(distinct f1::text, ',' order by f1::text) from varchar_tbl;
RESULT:
	[('a,ab,abcd,abcd    ',)]

-----------
QUERY:
  -- ok

-- string_agg bytea tests
create table bytea_test_table(v bytea);
RESULT:
	[]

-----------
QUERY:


select string_agg(v, '') from bytea_test_table;
RESULT:
	[(None,)]

-----------
QUERY:


insert into bytea_test_table values(decode('ff','hex'));
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types 'decode(STRING_LITERAL, STRING_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	decode(BLOB) -> VARCHAR

LINE 3: insert into bytea_test_table values(decode('ff','hex'));
                                            ^

-----------
QUERY:


insert into bytea_test_table values(decode('aa','hex'));
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types 'decode(STRING_LITERAL, STRING_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	decode(BLOB) -> VARCHAR

LINE 3: insert into bytea_test_table values(decode('aa','hex'));
                                            ^

-----------
QUERY:


drop table bytea_test_table;
RESULT:
	[]

-----------
QUERY:


-- Test parallel string_agg and array_agg
create table pagg_test (x int, y int);
RESULT:
	[]

-----------
QUERY:

insert into pagg_test
select (case x % 4 when 1 then null else x end), x % 10
from generate_series(1,5000) x;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '%(STRUCT(generate_series BIGINT), INTEGER_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	%(TINYINT, TINYINT) -> TINYINT
	%(SMALLINT, SMALLINT) -> SMALLINT
	%(INTEGER, INTEGER) -> INTEGER
	%(BIGINT, BIGINT) -> BIGINT
	%(HUGEINT, HUGEINT) -> HUGEINT
	%(FLOAT, FLOAT) -> FLOAT
	%(DOUBLE, DOUBLE) -> DOUBLE
	%(UTINYINT, UTINYINT) -> UTINYINT
	%(USMALLINT, USMALLINT) -> USMALLINT
	%(UINTEGER, UINTEGER) -> UINTEGER
	%(UBIGINT, UBIGINT) -> UBIGINT
	%(UHUGEINT, UHUGEINT) -> UHUGEINT

LINE 3: select (case x % 4 when 1 then ...
                       ^

-----------
QUERY:


set parallel_setup_cost TO 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "parallel_setup_cost"

Did you mean: "profile_output"

-----------
QUERY:

set parallel_tuple_cost TO 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "parallel_tuple_cost"

Did you mean: "profile_output"

-----------
QUERY:

set parallel_leader_participation TO 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "parallel_leader_participation"

Did you mean: "Calendar"

-----------
QUERY:

set min_parallel_table_scan_size = 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "min_parallel_table_scan_size"

Did you mean: "binary_as_string"

-----------
QUERY:

set bytea_output = 'escape';
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "bytea_output"

Did you mean: "explain_output"

-----------
QUERY:

set max_parallel_workers_per_gather = 2;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "max_parallel_workers_per_gather"

Did you mean: "worker_threads"

-----------
QUERY:


-- create a view as we otherwise have to repeat this query a few times.
create view v_pagg_test AS
select
	y,
	min(t) AS tmin,max(t) AS tmax,count(distinct t) AS tndistinct,
	min(b) AS bmin,max(b) AS bmax,count(distinct b) AS bndistinct,
	min(a) AS amin,max(a) AS amax,count(distinct a) AS andistinct,
	min(aa) AS aamin,max(aa) AS aamax,count(distinct aa) AS aandistinct
from (
	select
		y,
		unnest(regexp_split_to_array(a1.t, ','))::int AS t,
		unnest(regexp_split_to_array(a1.b::text, ',')) AS b,
		unnest(a1.a) AS a,
		unnest(a1.aa) AS aa
	from (
		select
			y,
			string_agg(x::text, ',') AS t,
			string_agg(x::text::bytea, ',') AS b,
			array_agg(x) AS a,
			array_agg(ARRAY[x]) AS aa
		from pagg_test
		group by y
	) a1
) a2
group by y;
RESULT:
	[]

-----------
QUERY:


-- Ensure results are correct.
select * from v_pagg_test order by y;
RESULT:
	[]

-----------
QUERY:


-- Ensure parallel aggregation is actually being used.
explain (costs off) select * from v_pagg_test order by y;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


set max_parallel_workers_per_gather = 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "max_parallel_workers_per_gather"

Did you mean: "worker_threads"

-----------
QUERY:


-- Ensure results are the same without parallel aggregation.
select * from v_pagg_test order by y;
RESULT:
	[]

-----------
QUERY:


-- Clean up
reset max_parallel_workers_per_gather;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "max_parallel_workers_per_gather"

Did you mean: "worker_threads"

-----------
QUERY:

reset bytea_output;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "bytea_output"

Did you mean: "explain_output"

-----------
QUERY:

reset min_parallel_table_scan_size;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "min_parallel_table_scan_size"

Did you mean: "binary_as_string"

-----------
QUERY:

reset parallel_leader_participation;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "parallel_leader_participation"

Did you mean: "Calendar"

-----------
QUERY:

reset parallel_tuple_cost;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "parallel_tuple_cost"

Did you mean: "profile_output"

-----------
QUERY:

reset parallel_setup_cost;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "parallel_setup_cost"

Did you mean: "profile_output"

-----------
QUERY:


drop view v_pagg_test;
RESULT:
	[]

-----------
QUERY:

drop table pagg_test;
RESULT:
	[]

-----------
QUERY:


-- FILTER tests

select min(unique1) filter (where unique1 > 100) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:


select sum(1/ten) filter (where ten > 0) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:


select ten, sum(distinct four) filter (where four::text ~ '123') from onek a
group by ten;
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "t1"?

-----------
QUERY:


select ten, sum(distinct four) filter (where four > 10) from onek a
group by ten
having exists (select 1 from onek b where sum(distinct a.four) = b.four);
RESULT:
	ERROR - Catalog Error: Table with name onek does not exist!
Did you mean "t1"?

-----------
QUERY:


select max(foo COLLATE "C") filter (where (bar collate "POSIX") > '0')
from (values ('a', 'b')) AS v(foo,bar);
RESULT:
	[('a',)]

-----------
QUERY:


select any_value(v) filter (where v > 2) from (values (1), (2), (3)) as v (v);
RESULT:
	[(3,)]

-----------
QUERY:


-- outer reference in FILTER (PostgreSQL extension)
select (select count(*)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c);
RESULT:
	[(1,), (1,)]

-----------
QUERY:
 -- inner query is aggregation query
select (select count(*) filter (where outer_c <> 0)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c);
RESULT:
	[(2,)]

-----------
QUERY:
 -- outer query is aggregation query
select (select count(inner_c) filter (where outer_c <> 0)
        from (values (1)) t0(inner_c))
from (values (2),(3)) t1(outer_c);
RESULT:
	[(1,), (1,)]

-----------
QUERY:
 -- inner query is aggregation query
select
  (select max((select i.unique2 from tenk1 i where i.unique1 = o.unique1))
     filter (where o.unique1 < 10))
from tenk1 o;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:
					-- outer query is aggregation query

-- subquery in FILTER clause (PostgreSQL extension)
select sum(unique1) FILTER (WHERE
  unique1 IN (SELECT unique1 FROM onek where unique1 < 100)) FROM tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:


-- exercise lots of aggregate parts with FILTER
select aggfns(distinct a,b,c order by a,c using ~<~,b) filter (where a > 1)
    from (values (1,3,'foo'),(0,null,null),(2,2,'bar'),(3,1,'baz')) v(a,b,c),
    generate_series(1,2) i;
RESULT:
	ERROR - Not implemented Error: Unimplemented order by type

-----------
QUERY:


-- check handling of bare boolean Var in FILTER
select max(0) filter (where b1) from bool_test;
RESULT:
	[(None,)]

-----------
QUERY:

select (select max(0) filter (where b1)) from bool_test;
RESULT:
	[(None,)]

-----------
QUERY:


-- check for correct detection of nested-aggregate errors in FILTER
select max(unique1) filter (where sum(ten) > 0) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:

select (select max(unique1) filter (where sum(ten) > 0) from int8_tbl) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:

select max(unique1) filter (where bool_or(ten > 0)) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:

select (select max(unique1) filter (where bool_or(ten > 0)) from int8_tbl) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:



-- ordered-set aggregates

select p, percentile_cont(p) within group (order by x::float8)
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
RESULT:
	ERROR - Binder Error: QUANTILE can only take constant parameters

-----------
QUERY:


select p, percentile_cont(p order by p) within group (order by x)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
RESULT:
	ERROR - Parser Error: cannot use multiple ORDER BY clauses with WITHIN GROUP

-----------
QUERY:


select p, sum() within group (order by x::float8)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "sum".

-----------
QUERY:


select p, percentile_cont(p,p)  -- error
from generate_series(1,5) x,
     (values (0::float8),(0.1),(0.25),(0.4),(0.5),(0.6),(0.75),(0.9),(1)) v(p)
group by p order by p;
RESULT:
	ERROR - Catalog Error: Scalar Function with name percentile_cont does not exist!
Did you mean "quantile_cont"?

-----------
QUERY:


select percentile_cont(0.5) within group (order by b) from aggtest;
RESULT:
	[(53.4484977722168,)]

-----------
QUERY:

select percentile_cont(0.5) within group (order by b), sum(b) from aggtest;
RESULT:
	[(53.4484977722168, 431.77260909229517)]

-----------
QUERY:

select percentile_cont(0.5) within group (order by thousand) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:

select percentile_disc(0.5) within group (order by thousand) from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:

select rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "rank".

-----------
QUERY:

select cume_dist(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "cume_dist".

-----------
QUERY:

select percent_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4),(5)) v(x);
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "percent_rank".

-----------
QUERY:

select dense_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "dense_rank".

-----------
QUERY:


select percentile_disc(array[0,0.1,0.25,0.5,0.75,0.9,1]) within group (order by thousand)
from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:

select percentile_cont(array[0,0.25,0.5,0.75,1]) within group (order by thousand)
from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:

select percentile_disc(array[[null,1,0.5],[0.75,0.25,null]]) within group (order by thousand)
from tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:

select percentile_cont(array[0,1,0.25,0.75,0.5,1,0.3,0.32,0.35,0.38,0.4]) within group (order by x)
from generate_series(1,6) x;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types 'quantile_cont(STRUCT(generate_series BIGINT), DECIMAL(12,2)[])'. You might need to add explicit type casts.
	Candidate functions:
	quantile_cont(DECIMAL, DOUBLE) -> DECIMAL
	quantile_cont(DECIMAL, DOUBLE[]) -> DECIMAL[]
	quantile_cont(TINYINT, DOUBLE) -> DOUBLE
	quantile_cont(TINYINT, DOUBLE[]) -> DOUBLE[]
	quantile_cont(SMALLINT, DOUBLE) -> DOUBLE
	quantile_cont(SMALLINT, DOUBLE[]) -> DOUBLE[]
	quantile_cont(INTEGER, DOUBLE) -> DOUBLE
	quantile_cont(INTEGER, DOUBLE[]) -> DOUBLE[]
	quantile_cont(BIGINT, DOUBLE) -> DOUBLE
	quantile_cont(BIGINT, DOUBLE[]) -> DOUBLE[]
	quantile_cont(HUGEINT, DOUBLE) -> DOUBLE
	quantile_cont(HUGEINT, DOUBLE[]) -> DOUBLE[]
	quantile_cont(FLOAT, DOUBLE) -> FLOAT
	quantile_cont(FLOAT, DOUBLE[]) -> FLOAT[]
	quantile_cont(DOUBLE, DOUBLE) -> DOUBLE
	quantile_cont(DOUBLE, DOUBLE[]) -> DOUBLE[]
	quantile_cont(DATE, DOUBLE) -> TIMESTAMP
	quantile_cont(DATE, DOUBLE[]) -> TIMESTAMP[]
	quantile_cont(TIMESTAMP, DOUBLE) -> TIMESTAMP
	quantile_cont(TIMESTAMP, DOUBLE[]) -> TIMESTAMP[]
	quantile_cont(TIME, DOUBLE) -> TIME
	quantile_cont(TIME, DOUBLE[]) -> TIME[]
	quantile_cont(TIMESTAMP WITH TIME ZONE, DOUBLE) -> TIMESTAMP WITH TIME ZONE
	quantile_cont(TIMESTAMP WITH TIME ZONE, DOUBLE[]) -> TIMESTAMP WITH TIME ZONE[]
	quantile_cont(TIME WITH TIME ZONE, DOUBLE) -> TIME WITH TIME ZONE
	quantile_cont(TIME WITH TIME ZONE, DOUBLE[]) -> TIME WITH TIME ZONE[]


-----------
QUERY:


select ten, mode() within group (order by string4) from tenk1 group by ten;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:


select percentile_disc(array[0.25,0.5,0.75]) within group (order by x)
from unnest('{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}'::text[]) u(x);
RESULT:
	ERROR - Conversion Error: Type VARCHAR with value '{fred,jim,fred,jack,jill,fred,jill,jim,jim,sheila,jim,sheila}' can't be cast to the destination type LIST

-----------
QUERY:


-- check collation propagates up in suitable cases:
select pg_collation_for(percentile_disc(1) within group (order by x collate "POSIX"))
  from (values ('fred'),('jim')) v(x);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_collation_for does not exist!
Did you mean "position"?

-----------
QUERY:


-- ordered-set aggs created with CREATE AGGREGATE
select test_rank(3) within group (order by x)
from (values (1),(1),(2),(2),(3),(3),(4)) v(x);
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "test_rank".

-----------
QUERY:

select test_percentile_disc(0.5) within group (order by thousand) from tenk1;
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "test_percentile_disc".

-----------
QUERY:


-- ordered-set aggs can/* REPLACED */ ''t use ungrouped vars in direct args:
select rank(x) within group (order by x) from generate_series(1,5) x;
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "rank".

-----------
QUERY:


-- outer-level agg can/* REPLACED */ ''t use a grouped arg of a lower level, either:
select array(select percentile_disc(a) within group (order by x)
               from (values (0.3),(0.7)) v(a) group by a)
  from generate_series(1,5) g(x);
RESULT:
	ERROR - Binder Error: QUANTILE can only take constant parameters

-----------
QUERY:


-- agg in the direct args is a grouping violation, too:
select rank(sum(x)) within group (order by x) from generate_series(1,5) x;
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "rank".

-----------
QUERY:


-- hypothetical-set type unification and argument-count failures:
select rank(3) within group (order by x) from (values ('fred'),('jim')) v(x);
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "rank".

-----------
QUERY:

select rank(3) within group (order by stringu1,stringu2) from tenk1;
RESULT:
	ERROR - Parser Error: Cannot use multiple ORDER BY clauses with WITHIN GROUP

-----------
QUERY:

select rank('fred') within group (order by x) from generate_series(1,5) x;
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "rank".

-----------
QUERY:

select rank('adam'::text collate "C") within group (order by x collate "POSIX")
  from (values ('fred'),('jim')) v(x);
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "rank".

-----------
QUERY:

-- hypothetical-set type unification successes:
select rank('adam'::varchar) within group (order by x) from (values ('fred'),('jim')) v(x);
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "rank".

-----------
QUERY:

select rank('3') within group (order by x) from generate_series(1,5) x;
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "rank".

-----------
QUERY:


-- divide by zero check
select percent_rank(0) within group (order by x) from generate_series(1,0) x;
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "percent_rank".

-----------
QUERY:


-- deparse and multiple features:
create view aggordview1 as
select ten,
       percentile_disc(0.5) within group (order by thousand) as p50,
       percentile_disc(0.5) within group (order by thousand) filter (where hundred=1) as px,
       rank(5,'AZZZZ',50) within group (order by hundred, string4 desc, hundred)
  from tenk1
 group by ten order by ten;
RESULT:
	ERROR - Parser Error: Cannot use multiple ORDER BY clauses with WITHIN GROUP

-----------
QUERY:


select pg_get_viewdef('aggordview1');
RESULT:
	ERROR - Conversion Error: Could not convert string 'aggordview1' to INT64

-----------
QUERY:

select * from aggordview1 order by ten;
RESULT:
	ERROR - Catalog Error: Table with name aggordview1 does not exist!
Did you mean "pg_views"?

-----------
QUERY:

drop view aggordview1;
RESULT:
	ERROR - Catalog Error: View with name aggordview1 does not exist!
Did you mean "pg_views"?

-----------
QUERY:


-- variadic aggregates
select least_agg(q1,q2) from int8_tbl;
RESULT:
	ERROR - Catalog Error: Scalar Function with name least_agg does not exist!
Did you mean "least"?

-----------
QUERY:

select least_agg(variadic array[q1,q2]) from int8_tbl;
RESULT:
	ERROR - Catalog Error: Scalar Function with name least_agg does not exist!
Did you mean "least"?

-----------
QUERY:


select cleast_agg(q1,q2) from int8_tbl;
RESULT:
	ERROR - Catalog Error: Scalar Function with name cleast_agg does not exist!
Did you mean "least"?

-----------
QUERY:

select cleast_agg(4.5,f1) from int4_tbl;
RESULT:
	ERROR - Catalog Error: Scalar Function with name cleast_agg does not exist!
Did you mean "least"?

-----------
QUERY:

select cleast_agg(variadic array[4.5,f1]) from int4_tbl;
RESULT:
	ERROR - Catalog Error: Scalar Function with name cleast_agg does not exist!
Did you mean "least"?

-----------
QUERY:

select pg_typeof(cleast_agg(variadic array[4.5,f1])) from int4_tbl;
RESULT:
	ERROR - Catalog Error: Scalar Function with name cleast_agg does not exist!
Did you mean "least"?

-----------
QUERY:


-- test aggregates with common transition functions share the same states
begin work;
RESULT:
	[]

-----------
QUERY:


create type avg_state as (total bigint, count bigint);
RESULT:
	ERROR - Parser Error: syntax error at or near "("

-----------
QUERY:


create or replace function avg_transfn(state avg_state, n int) returns avg_state as
$$
declare new_state avg_state;
begin
	raise notice 'avg_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state.total := n;
			new_state.count := 1;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state.total := state.total + n;
		state.count := state.count + 1;
		return state;
	end if;

	return null;
end
$$ language plpgsql;
RESULT:
	ERROR - Parser Error: syntax error at or near "avg_state"

-----------
QUERY:


create function avg_finalfn(state avg_state) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state.total / state.count;
	end if;
end
$$ language plpgsql;
RESULT:
	ERROR - Parser Error: syntax error at or near "avg_state"

-----------
QUERY:


create function sum_finalfn(state avg_state) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state.total;
	end if;
end
$$ language plpgsql;
RESULT:
	ERROR - Parser Error: syntax error at or near "avg_state"

-----------
QUERY:


create aggregate my_avg(int4)
(
   stype = avg_state,
   sfunc = avg_transfn,
   finalfunc = avg_finalfn
);
RESULT:
	ERROR - Parser Error: syntax error at or near "aggregate"

-----------
QUERY:


create aggregate my_sum(int4)
(
   stype = avg_state,
   sfunc = avg_transfn,
   finalfunc = sum_finalfn
);
RESULT:
	ERROR - Parser Error: syntax error at or near "aggregate"

-----------
QUERY:


-- aggregate state should be shared as aggs are the same.
select my_avg(one),my_avg(one) from (values(1),(3)) t(one);
RESULT:
	ERROR - Catalog Error: Scalar Function with name my_avg does not exist!
Did you mean "avg"?

-----------
QUERY:


-- aggregate state should be shared as transfn is the same for both aggs.
select my_avg(one),my_sum(one) from (values(1),(3)) t(one);
RESULT:
	ERROR - Catalog Error: Scalar Function with name my_avg does not exist!
Did you mean "avg"?

-----------
QUERY:


-- same as previous one, but with DISTINCT, which requires sorting the input.
select my_avg(distinct one),my_sum(distinct one) from (values(1),(3),(1)) t(one);
RESULT:
	ERROR - Catalog Error: Scalar Function with name my_avg does not exist!
Did you mean "avg"?

-----------
QUERY:


-- shouldn/* REPLACED */ ''t share states due to the distinctness not matching.
select my_avg(distinct one),my_sum(one) from (values(1),(3)) t(one);
RESULT:
	ERROR - Catalog Error: Scalar Function with name my_avg does not exist!
Did you mean "avg"?

-----------
QUERY:


-- shouldn/* REPLACED */ ''t share states due to the filter clause not matching.
select my_avg(one) filter (where one > 1),my_sum(one) from (values(1),(3)) t(one);
RESULT:
	ERROR - Catalog Error: Scalar Function with name my_avg does not exist!
Did you mean "avg"?

-----------
QUERY:


-- this should not share the state due to different input columns.
select my_avg(one),my_sum(two) from (values(1,2),(3,4)) t(one,two);
RESULT:
	ERROR - Catalog Error: Scalar Function with name my_avg does not exist!
Did you mean "avg"?

-----------
QUERY:


-- exercise cases where OSAs share state
select
  percentile_cont(0.5) within group (order by a),
  percentile_disc(0.5) within group (order by a)
from (values(1::float8),(3),(5),(7)) t(a);
RESULT:
	[(4.0, 3.0)]

-----------
QUERY:


select
  percentile_cont(0.25) within group (order by a),
  percentile_disc(0.5) within group (order by a)
from (values(1::float8),(3),(5),(7)) t(a);
RESULT:
	[(2.5, 3.0)]

-----------
QUERY:


-- these can/* REPLACED */ ''t share state currently
select
  rank(4) within group (order by a),
  dense_rank(4) within group (order by a)
from (values(1),(3),(5),(7)) t(a);
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "rank".

-----------
QUERY:


-- test that aggs with the same sfunc and initcond share the same agg state
create aggregate my_sum_init(int4)
(
   stype = avg_state,
   sfunc = avg_transfn,
   finalfunc = sum_finalfn,
   initcond = '(10,0)'
);
RESULT:
	ERROR - Parser Error: syntax error at or near "aggregate"

-----------
QUERY:


create aggregate my_avg_init(int4)
(
   stype = avg_state,
   sfunc = avg_transfn,
   finalfunc = avg_finalfn,
   initcond = '(10,0)'
);
RESULT:
	ERROR - Parser Error: syntax error at or near "aggregate"

-----------
QUERY:


create aggregate my_avg_init2(int4)
(
   stype = avg_state,
   sfunc = avg_transfn,
   finalfunc = avg_finalfn,
   initcond = '(4,0)'
);
RESULT:
	ERROR - Parser Error: syntax error at or near "aggregate"

-----------
QUERY:


-- state should be shared if INITCONDs are matching
select my_sum_init(one),my_avg_init(one) from (values(1),(3)) t(one);
RESULT:
	ERROR - Catalog Error: Scalar Function with name my_sum_init does not exist!
Did you mean "min"?

-----------
QUERY:


-- Varying INITCONDs should cause the states not to be shared.
select my_sum_init(one),my_avg_init2(one) from (values(1),(3)) t(one);
RESULT:
	ERROR - Catalog Error: Scalar Function with name my_sum_init does not exist!
Did you mean "min"?

-----------
QUERY:


rollback;
RESULT:
	[]

-----------
QUERY:


-- test aggregate state sharing to ensure it works if one aggregate has a
-- finalfn and the other one has none.
begin work;
RESULT:
	[]

-----------
QUERY:


create or replace function sum_transfn(state int4, n int4) returns int4 as
$$
declare new_state int4;
begin
	raise notice 'sum_transfn called with %', n;
	if state is null then
		if n is not null then
			new_state := n;
			return new_state;
		end if;
		return null;
	elsif n is not null then
		state := state + n;
		return state;
	end if;

	return null;
end
$$ language plpgsql;
RESULT:
	ERROR - Parser Error: syntax error at or near "int4"

-----------
QUERY:


create function halfsum_finalfn(state int4) returns int4 as
$$
begin
	if state is null then
		return NULL;
	else
		return state / 2;
	end if;
end
$$ language plpgsql;
RESULT:
	ERROR - Parser Error: syntax error at or near "int4"

-----------
QUERY:


create aggregate my_sum(int4)
(
   stype = int4,
   sfunc = sum_transfn
);
RESULT:
	ERROR - Parser Error: syntax error at or near "aggregate"

-----------
QUERY:


create aggregate my_half_sum(int4)
(
   stype = int4,
   sfunc = sum_transfn,
   finalfunc = halfsum_finalfn
);
RESULT:
	ERROR - Parser Error: syntax error at or near "aggregate"

-----------
QUERY:


-- Agg state should be shared even though my_sum has no finalfn
select my_sum(one),my_half_sum(one) from (values(1),(2),(3),(4)) t(one);
RESULT:
	ERROR - Catalog Error: Scalar Function with name my_sum does not exist!
Did you mean "sum"?

-----------
QUERY:


rollback;
RESULT:
	[]

-----------
QUERY:



-- test that the aggregate transition logic correctly handles
-- transition / combine functions returning NULL

-- First test the case of a normal transition function returning NULL
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION balkifnull(int8, int4)
RETURNS int8
STRICT
LANGUAGE plpgsql AS $$
BEGIN
    IF $1 IS NULL THEN
       RAISE 'erroneously called with NULL argument';
    END IF;
    RETURN NULL;
END$$;
RESULT:
	ERROR - Parser Error: syntax error at or near "RETURNS"

-----------
QUERY:


CREATE AGGREGATE balk(int4)
(
    SFUNC = balkifnull(int8, int4),
    STYPE = int8,
    PARALLEL = SAFE,
    INITCOND = '0'
);
RESULT:
	ERROR - Parser Error: syntax error at or near "AGGREGATE"

-----------
QUERY:


SELECT balk(hundred) FROM tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:


ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- GROUP BY optimization by reordering GROUP BY clauses
CREATE TABLE btg AS SELECT
  i % 10 AS x,
  i % 10 AS y,
  'abc' || i % 10 AS z,
  i AS w
FROM generate_series(1, 100) AS i;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '%(STRUCT(generate_series BIGINT), INTEGER_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	%(TINYINT, TINYINT) -> TINYINT
	%(SMALLINT, SMALLINT) -> SMALLINT
	%(INTEGER, INTEGER) -> INTEGER
	%(BIGINT, BIGINT) -> BIGINT
	%(HUGEINT, HUGEINT) -> HUGEINT
	%(FLOAT, FLOAT) -> FLOAT
	%(DOUBLE, DOUBLE) -> DOUBLE
	%(UTINYINT, UTINYINT) -> UTINYINT
	%(USMALLINT, USMALLINT) -> USMALLINT
	%(UINTEGER, UINTEGER) -> UINTEGER
	%(UBIGINT, UBIGINT) -> UBIGINT
	%(UHUGEINT, UHUGEINT) -> UHUGEINT

LINE 5:   i % 10 AS x,
            ^

-----------
QUERY:

CREATE INDEX btg_x_y_idx ON btg(x, y);
RESULT:
	ERROR - Catalog Error: Table with name btg does not exist!
Did you mean "t1"?

-----------
QUERY:

ANALYZE btg;
RESULT:
	ERROR - Catalog Error: Table with name btg does not exist!
Did you mean "t1"?
LINE 2: ANALYZE btg;
                ^

-----------
QUERY:


SET enable_hashagg = off;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_hashagg"

Did you mean: "enable_progress_bar"

-----------
QUERY:

SET enable_seqscan = off;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_seqscan"

Did you mean: "enable_object_cache"

-----------
QUERY:


-- Utilize the ordering of index scan to avoid a Sort operation
EXPLAIN (COSTS OFF)
SELECT count(*) FROM btg GROUP BY y, x;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:


-- Engage incremental sort
EXPLAIN (COSTS OFF)
SELECT count(*) FROM btg GROUP BY z, y, w, x;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:


-- Utilize the ordering of subquery scan to avoid a Sort operation
EXPLAIN (COSTS OFF) SELECT count(*)
FROM (SELECT * FROM btg ORDER BY x, y, w, z) AS q1
GROUP BY w, x, z, y;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:


-- Utilize the ordering of merge join to avoid a full Sort operation
SET enable_hashjoin = off;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_hashjoin"

Did you mean: "enable_profiling"

-----------
QUERY:

SET enable_nestloop = off;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_nestloop"

Did you mean: "enable_external_access"

-----------
QUERY:

EXPLAIN (COSTS OFF)
SELECT count(*)
  FROM btg t1 JOIN btg t2 ON t1.z = t2.z AND t1.w = t2.w AND t1.x = t2.x
  GROUP BY t1.x, t1.y, t1.z, t1.w;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:

RESET enable_nestloop;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_nestloop"

Did you mean: "enable_external_access"

-----------
QUERY:

RESET enable_hashjoin;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_hashjoin"

Did you mean: "enable_profiling"

-----------
QUERY:


-- Should work with and without GROUP-BY optimization
EXPLAIN (COSTS OFF)
SELECT count(*) FROM btg GROUP BY w, x, z, y ORDER BY y, x, z, w;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:


-- Utilize incremental sort to make the ORDER BY rule a bit cheaper
EXPLAIN (COSTS OFF)
SELECT count(*) FROM btg GROUP BY w, x, y, z ORDER BY x*x, z;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:


-- Test the case where the number of incoming subtree path keys is more than
-- the number of grouping keys.
CREATE INDEX btg_y_x_w_idx ON btg(y, x, w);
RESULT:
	ERROR - Catalog Error: Table with name btg does not exist!
Did you mean "t1"?

-----------
QUERY:

EXPLAIN (VERBOSE, COSTS OFF)
SELECT y, x, array_agg(distinct w)
  FROM btg WHERE y < 0 GROUP BY x, y;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: VERBOSE

-----------
QUERY:


-- Ensure that we do not select the aggregate pathkeys instead of the grouping
-- pathkeys
CREATE TABLE group_agg_pk AS SELECT
  i % 10 AS x,
  i % 2 AS y,
  i % 2 AS z,
  2 AS w,
  i % 10 AS f
FROM generate_series(1,100) AS i;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '%(STRUCT(generate_series BIGINT), INTEGER_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	%(TINYINT, TINYINT) -> TINYINT
	%(SMALLINT, SMALLINT) -> SMALLINT
	%(INTEGER, INTEGER) -> INTEGER
	%(BIGINT, BIGINT) -> BIGINT
	%(HUGEINT, HUGEINT) -> HUGEINT
	%(FLOAT, FLOAT) -> FLOAT
	%(DOUBLE, DOUBLE) -> DOUBLE
	%(UTINYINT, UTINYINT) -> UTINYINT
	%(USMALLINT, USMALLINT) -> USMALLINT
	%(UINTEGER, UINTEGER) -> UINTEGER
	%(UBIGINT, UBIGINT) -> UBIGINT
	%(UHUGEINT, UHUGEINT) -> UHUGEINT

LINE 6:   i % 10 AS x,
            ^

-----------
QUERY:

ANALYZE group_agg_pk;
RESULT:
	ERROR - Catalog Error: Table with name group_agg_pk does not exist!
Did you mean "pg_am"?
LINE 2: ANALYZE group_agg_pk;
                ^

-----------
QUERY:

SET enable_nestloop = off;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_nestloop"

Did you mean: "enable_external_access"

-----------
QUERY:

SET enable_hashjoin = off;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_hashjoin"

Did you mean: "enable_profiling"

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT avg(c1.f ORDER BY c1.x, c1.y)
FROM group_agg_pk c1 JOIN group_agg_pk c2 ON c1.x = c2.x
GROUP BY c1.w, c1.z;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:

SELECT avg(c1.f ORDER BY c1.x, c1.y)
FROM group_agg_pk c1 JOIN group_agg_pk c2 ON c1.x = c2.x
GROUP BY c1.w, c1.z;
RESULT:
	ERROR - Catalog Error: Table with name group_agg_pk does not exist!
Did you mean "pg_am"?

-----------
QUERY:


RESET enable_nestloop;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_nestloop"

Did you mean: "enable_external_access"

-----------
QUERY:

RESET enable_hashjoin;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_hashjoin"

Did you mean: "enable_profiling"

-----------
QUERY:

DROP TABLE group_agg_pk;
RESULT:
	ERROR - Catalog Error: Table with name group_agg_pk does not exist!
Did you mean "pg_am"?

-----------
QUERY:


-- Test the case where the the ordering of scan matches the ordering within the
-- aggregate but cannot be found in the group-by list
CREATE TABLE agg_sort_order (c1 int PRIMARY KEY, c2 int);
RESULT:
	[]

-----------
QUERY:

CREATE UNIQUE INDEX agg_sort_order_c2_idx ON agg_sort_order(c2);
RESULT:
	[]

-----------
QUERY:

INSERT INTO agg_sort_order SELECT i, i FROM generate_series(1,100)i;
RESULT:
	ERROR - Conversion Error: Unimplemented type for cast (STRUCT(generate_series BIGINT) -> INTEGER)
LINE 2: INSERT INTO agg_sort_order SELECT i, i FROM generate_series(1,100)i;
                                          ^

-----------
QUERY:

ANALYZE agg_sort_order;
RESULT:
	[]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT array_agg(c1 ORDER BY c2),c2
FROM agg_sort_order WHERE c2 < 100 GROUP BY c1 ORDER BY 2;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:


DROP TABLE agg_sort_order CASCADE;
RESULT:
	[]

-----------
QUERY:


DROP TABLE btg;
RESULT:
	ERROR - Catalog Error: Table with name btg does not exist!
Did you mean "t1"?

-----------
QUERY:


RESET enable_hashagg;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_hashagg"

Did you mean: "enable_progress_bar"

-----------
QUERY:

RESET enable_seqscan;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_seqscan"

Did you mean: "enable_object_cache"

-----------
QUERY:


-- Secondly test the case of a parallel aggregate combiner function
-- returning NULL. For that use normal transition function, but a
-- combiner function returning NULL.
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION balkifnull(int8, int8)
RETURNS int8
PARALLEL SAFE
STRICT
LANGUAGE plpgsql AS $$
BEGIN
    IF $1 IS NULL THEN
       RAISE 'erroneously called with NULL argument';
    END IF;
    RETURN NULL;
END$$;
RESULT:
	ERROR - Parser Error: syntax error at or near "RETURNS"

-----------
QUERY:


CREATE AGGREGATE balk(int4)
(
    SFUNC = int4_sum(int8, int4),
    STYPE = int8,
    COMBINEFUNC = balkifnull(int8, int8),
    PARALLEL = SAFE,
    INITCOND = '0'
);
RESULT:
	ERROR - Parser Error: syntax error at or near "AGGREGATE"

-----------
QUERY:


-- force use of parallelism
ALTER TABLE tenk1 set (parallel_workers = 4);
RESULT:
	ERROR - Not implemented Error: No support for that ALTER TABLE option yet!

-----------
QUERY:

SET LOCAL parallel_setup_cost=0;
RESULT:
	ERROR - Not implemented Error: SET LOCAL is not implemented.

-----------
QUERY:

SET LOCAL max_parallel_workers_per_gather=4;
RESULT:
	ERROR - Not implemented Error: SET LOCAL is not implemented.

-----------
QUERY:


EXPLAIN (COSTS OFF) SELECT balk(hundred) FROM tenk1;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:

SELECT balk(hundred) FROM tenk1;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:


ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- test multiple usage of an aggregate whose finalfn returns a R/W datum
BEGIN;
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION rwagg_sfunc(x anyarray, y anyarray) RETURNS anyarray
LANGUAGE plpgsql IMMUTABLE AS $$
BEGIN
    RETURN array_fill(y[1], ARRAY[4]);
END;
$$;
RESULT:
	ERROR - Parser Error: syntax error at or near "anyarray"

-----------
QUERY:


CREATE FUNCTION rwagg_finalfunc(x anyarray) RETURNS anyarray
LANGUAGE plpgsql STRICT IMMUTABLE AS $$
DECLARE
    res x%TYPE;
BEGIN
    -- assignment is essential for this test, it expands the array to R/W
    res := array_fill(x[1], ARRAY[4]);
    RETURN res;
END;
$$;
RESULT:
	ERROR - Parser Error: syntax error at or near "anyarray"

-----------
QUERY:


CREATE AGGREGATE rwagg(anyarray) (
    STYPE = anyarray,
    SFUNC = rwagg_sfunc,
    FINALFUNC = rwagg_finalfunc
);
RESULT:
	ERROR - Parser Error: syntax error at or near "AGGREGATE"

-----------
QUERY:


CREATE FUNCTION eatarray(x real[]) RETURNS real[]
LANGUAGE plpgsql STRICT IMMUTABLE AS $$
BEGIN
    x[1] := x[1] + 1;
    RETURN x;
END;
$$;
RESULT:
	ERROR - Parser Error: syntax error at or near "real"

-----------
QUERY:


SELECT eatarray(rwagg(ARRAY[1.0::real])), eatarray(rwagg(ARRAY[1.0::real]));
RESULT:
	ERROR - Catalog Error: Scalar Function with name eatarray does not exist!
Did you mean "era"?

-----------
QUERY:


ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- test coverage for aggregate combine/serial/deserial functions
BEGIN;
RESULT:
	[]

-----------
QUERY:


SET parallel_setup_cost = 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "parallel_setup_cost"

Did you mean: "profile_output"

-----------
QUERY:

SET parallel_tuple_cost = 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "parallel_tuple_cost"

Did you mean: "profile_output"

-----------
QUERY:

SET min_parallel_table_scan_size = 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "min_parallel_table_scan_size"

Did you mean: "binary_as_string"

-----------
QUERY:

SET max_parallel_workers_per_gather = 4;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "max_parallel_workers_per_gather"

Did you mean: "worker_threads"

-----------
QUERY:

SET parallel_leader_participation = off;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "parallel_leader_participation"

Did you mean: "Calendar"

-----------
QUERY:

SET enable_indexonlyscan = off;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_indexonlyscan"

Did you mean: "Calendar"

-----------
QUERY:


-- variance(int4) covers numeric_poly_combine
-- sum(int8) covers int8_avg_combine
-- regr_count(float8, float8) covers int8inc_float8_float8 and aggregates with > 1 arg
EXPLAIN (COSTS OFF, VERBOSE)
SELECT variance(unique1::int4), sum(unique1::int8), regr_count(unique1::float8, unique1::float8)
FROM (SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1) u;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:


SELECT variance(unique1::int4), sum(unique1::int8), regr_count(unique1::float8, unique1::float8)
FROM (SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1) u;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:


-- variance(int8) covers numeric_combine
-- avg(numeric) covers numeric_avg_combine
EXPLAIN (COSTS OFF, VERBOSE)
SELECT variance(unique1::int8), avg(unique1::numeric)
FROM (SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1) u;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:


SELECT variance(unique1::int8), avg(unique1::numeric)
FROM (SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1
      UNION ALL SELECT * FROM tenk1) u;
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:


ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- test coverage for dense_rank
SELECT dense_rank(x) WITHIN GROUP (ORDER BY x) FROM (VALUES (1),(1),(2),(2),(3),(3)) v(x) GROUP BY (x) ORDER BY 1;
RESULT:
	ERROR - Parser Error: Unknown ordered aggregate "dense_rank".

-----------
QUERY:



-- Ensure that the STRICT checks for aggregates does not take NULLness
-- of ORDER BY columns into account. See bug report around
-- 2a505161-2727-2473-7c46-591ed108ac52@email.cz
SELECT min(x ORDER BY y) FROM (VALUES(1, NULL)) AS d(x,y);
RESULT:
	[(1,)]

-----------
QUERY:

SELECT min(x ORDER BY y) FROM (VALUES(1, 2)) AS d(x,y);
RESULT:
	[(1,)]

-----------
QUERY:


-- check collation-sensitive matching between grouping expressions
select v||'a', case v||'a' when 'aa' then 1 else 0 end, count(*)
  from unnest(array['a','b']) u(v)
 group by v||'a' order by 1;
RESULT:
	[('aa', 1, 1), ('ba', 0, 1)]

-----------
QUERY:

select v||'a', case when v||'a' = 'aa' then 1 else 0 end, count(*)
  from unnest(array['a','b']) u(v)
 group by v||'a' order by 1;
RESULT:
	[('aa', 1, 1), ('ba', 0, 1)]

-----------
QUERY:


-- Make sure that generation of HashAggregate for uniqification purposes
-- does not lead to array overflow due to unexpected duplicate hash keys
-- see CAFeeJoKKu0u+A_A9R9316djW-YW3-+Gtgvy3ju655qRHR3jtdA@mail.gmail.com
set enable_memoize to off;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_memoize"

Did you mean: "enable_profiling"

-----------
QUERY:

explain (costs off)
  select 1 from tenk1
   where (hundred, thousand) in (select twothousand, twothousand from onek);
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

reset enable_memoize;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_memoize"

Did you mean: "enable_profiling"

-----------
QUERY:


--
-- Hash Aggregation Spill tests
--

set enable_sort=false;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_sort"

Did you mean: "enable_fsst_vectors"

-----------
QUERY:

set work_mem='64kB';
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "work_mem"

Did you mean: "worker_threads"

-----------
QUERY:


select unique1, count(*), sum(twothousand) from tenk1
group by unique1
having sum(fivethous) > 4975
order by sum(twothousand);
RESULT:
	ERROR - Catalog Error: Table with name tenk1 does not exist!
Did you mean "t1"?

-----------
QUERY:


set work_mem to default;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "work_mem"

Did you mean: "worker_threads"

-----------
QUERY:

set enable_sort to default;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_sort"

Did you mean: "enable_fsst_vectors"

-----------
QUERY:


--
-- Compare results between plans using sorting and plans using hash
-- aggregation. Force spilling in both cases by setting work_mem low.
--

set work_mem='64kB';
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "work_mem"

Did you mean: "worker_threads"

-----------
QUERY:


create table agg_data_2k as
select g from generate_series(0, 1999) g;
RESULT:
	[]

-----------
QUERY:

analyze agg_data_2k;
RESULT:
	[]

-----------
QUERY:


create table agg_data_20k as
select g from generate_series(0, 19999) g;
RESULT:
	[]

-----------
QUERY:

analyze agg_data_20k;
RESULT:
	[]

-----------
QUERY:


-- Produce results with sorting.

set enable_hashagg = false;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_hashagg"

Did you mean: "enable_progress_bar"

-----------
QUERY:


set jit_above_cost = 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "jit_above_cost"

Did you mean: "disabled_optimizers"

-----------
QUERY:


explain (costs off)
select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
  from agg_data_20k group by g%10000;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


create table agg_group_1 as
select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
  from agg_data_20k group by g%10000;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '%(STRUCT(generate_series BIGINT), INTEGER_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	%(TINYINT, TINYINT) -> TINYINT
	%(SMALLINT, SMALLINT) -> SMALLINT
	%(INTEGER, INTEGER) -> INTEGER
	%(BIGINT, BIGINT) -> BIGINT
	%(HUGEINT, HUGEINT) -> HUGEINT
	%(FLOAT, FLOAT) -> FLOAT
	%(DOUBLE, DOUBLE) -> DOUBLE
	%(UTINYINT, UTINYINT) -> UTINYINT
	%(USMALLINT, USMALLINT) -> USMALLINT
	%(UINTEGER, UINTEGER) -> UINTEGER
	%(UBIGINT, UBIGINT) -> UBIGINT
	%(UHUGEINT, UHUGEINT) -> UHUGEINT

LINE 5:   from agg_data_20k group by g%10000;
                                      ^

-----------
QUERY:


create table agg_group_2 as
select * from
  (values (100), (300), (500)) as r(a),
  lateral (
    select (g/2)::numeric as c1,
           array_agg(g::numeric) as c2,
	   count(*) as c3
    from agg_data_2k
    where g < r.a
    group by g/2) as s;
RESULT:
	ERROR - Binder Error: Cannot compare values of type STRUCT(generate_series BIGINT) and type INTEGER - an explicit cast is required
LINE 11:     where g < r.a
                     ^

-----------
QUERY:


set jit_above_cost to default;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "jit_above_cost"

Did you mean: "disabled_optimizers"

-----------
QUERY:


create table agg_group_3 as
select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3
  from agg_data_2k group by g/2;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '/(STRUCT(generate_series BIGINT), INTEGER_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	/(FLOAT, FLOAT) -> FLOAT
	/(DOUBLE, DOUBLE) -> DOUBLE
	/(INTERVAL, BIGINT) -> INTERVAL

LINE 5:   from agg_data_2k group by g/2;
                                     ^

-----------
QUERY:


create table agg_group_4 as
select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3
  from agg_data_2k group by g/2;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '/(STRUCT(generate_series BIGINT), INTEGER_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	/(FLOAT, FLOAT) -> FLOAT
	/(DOUBLE, DOUBLE) -> DOUBLE
	/(INTERVAL, BIGINT) -> INTERVAL

LINE 5:   from agg_data_2k group by g/2;
                                     ^

-----------
QUERY:


-- Produce results with hash aggregation

set enable_hashagg = true;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_hashagg"

Did you mean: "enable_progress_bar"

-----------
QUERY:

set enable_sort = false;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_sort"

Did you mean: "enable_fsst_vectors"

-----------
QUERY:


set jit_above_cost = 0;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "jit_above_cost"

Did you mean: "disabled_optimizers"

-----------
QUERY:


explain (costs off)
select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
  from agg_data_20k group by g%10000;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


create table agg_hash_1 as
select g%10000 as c1, sum(g::numeric) as c2, count(*) as c3
  from agg_data_20k group by g%10000;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '%(STRUCT(generate_series BIGINT), INTEGER_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	%(TINYINT, TINYINT) -> TINYINT
	%(SMALLINT, SMALLINT) -> SMALLINT
	%(INTEGER, INTEGER) -> INTEGER
	%(BIGINT, BIGINT) -> BIGINT
	%(HUGEINT, HUGEINT) -> HUGEINT
	%(FLOAT, FLOAT) -> FLOAT
	%(DOUBLE, DOUBLE) -> DOUBLE
	%(UTINYINT, UTINYINT) -> UTINYINT
	%(USMALLINT, USMALLINT) -> USMALLINT
	%(UINTEGER, UINTEGER) -> UINTEGER
	%(UBIGINT, UBIGINT) -> UBIGINT
	%(UHUGEINT, UHUGEINT) -> UHUGEINT

LINE 5:   from agg_data_20k group by g%10000;
                                      ^

-----------
QUERY:


create table agg_hash_2 as
select * from
  (values (100), (300), (500)) as r(a),
  lateral (
    select (g/2)::numeric as c1,
           array_agg(g::numeric) as c2,
	   count(*) as c3
    from agg_data_2k
    where g < r.a
    group by g/2) as s;
RESULT:
	ERROR - Binder Error: Cannot compare values of type STRUCT(generate_series BIGINT) and type INTEGER - an explicit cast is required
LINE 11:     where g < r.a
                     ^

-----------
QUERY:


set jit_above_cost to default;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "jit_above_cost"

Did you mean: "disabled_optimizers"

-----------
QUERY:


create table agg_hash_3 as
select (g/2)::numeric as c1, sum(7::int4) as c2, count(*) as c3
  from agg_data_2k group by g/2;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '/(STRUCT(generate_series BIGINT), INTEGER_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	/(FLOAT, FLOAT) -> FLOAT
	/(DOUBLE, DOUBLE) -> DOUBLE
	/(INTERVAL, BIGINT) -> INTERVAL

LINE 5:   from agg_data_2k group by g/2;
                                     ^

-----------
QUERY:


create table agg_hash_4 as
select (g/2)::numeric as c1, array_agg(g::numeric) as c2, count(*) as c3
  from agg_data_2k group by g/2;
RESULT:
	ERROR - Binder Error: No function matches the given name and argument types '/(STRUCT(generate_series BIGINT), INTEGER_LITERAL)'. You might need to add explicit type casts.
	Candidate functions:
	/(FLOAT, FLOAT) -> FLOAT
	/(DOUBLE, DOUBLE) -> DOUBLE
	/(INTERVAL, BIGINT) -> INTERVAL

LINE 5:   from agg_data_2k group by g/2;
                                     ^

-----------
QUERY:


set enable_sort = true;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "enable_sort"

Did you mean: "enable_fsst_vectors"

-----------
QUERY:

set work_mem to default;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "work_mem"

Did you mean: "worker_threads"

-----------
QUERY:


-- Compare group aggregation results to hash aggregation results

(select * from agg_hash_1 except select * from agg_group_1)
  union all
(select * from agg_group_1 except select * from agg_hash_1);
RESULT:
	ERROR - Catalog Error: Table with name agg_hash_1 does not exist!
Did you mean "pg_am"?

-----------
QUERY:


(select * from agg_hash_2 except select * from agg_group_2)
  union all
(select * from agg_group_2 except select * from agg_hash_2);
RESULT:
	ERROR - Catalog Error: Table with name agg_hash_2 does not exist!
Did you mean "agg_data_2k"?

-----------
QUERY:


(select * from agg_hash_3 except select * from agg_group_3)
  union all
(select * from agg_group_3 except select * from agg_hash_3);
RESULT:
	ERROR - Catalog Error: Table with name agg_hash_3 does not exist!
Did you mean "pg_am"?

-----------
QUERY:


(select * from agg_hash_4 except select * from agg_group_4)
  union all
(select * from agg_group_4 except select * from agg_hash_4);
RESULT:
	ERROR - Catalog Error: Table with name agg_hash_4 does not exist!
Did you mean "pg_am"?

-----------
QUERY:


drop table agg_group_1;
RESULT:
	ERROR - Catalog Error: Table with name agg_group_1 does not exist!
Did you mean "pg_proc"?

-----------
QUERY:

drop table agg_group_2;
RESULT:
	ERROR - Catalog Error: Table with name agg_group_2 does not exist!
Did you mean "pg_proc"?

-----------
QUERY:

drop table agg_group_3;
RESULT:
	ERROR - Catalog Error: Table with name agg_group_3 does not exist!
Did you mean "pg_proc"?

-----------
QUERY:

drop table agg_group_4;
RESULT:
	ERROR - Catalog Error: Table with name agg_group_4 does not exist!
Did you mean "pg_proc"?

-----------
QUERY:

drop table agg_hash_1;
RESULT:
	ERROR - Catalog Error: Table with name agg_hash_1 does not exist!
Did you mean "pg_am"?

-----------
QUERY:

drop table agg_hash_2;
RESULT:
	ERROR - Catalog Error: Table with name agg_hash_2 does not exist!
Did you mean "agg_data_2k"?

-----------
QUERY:

drop table agg_hash_3;
RESULT:
	ERROR - Catalog Error: Table with name agg_hash_3 does not exist!
Did you mean "pg_am"?

-----------
QUERY:

drop table agg_hash_4;
RESULT:
	ERROR - Catalog Error: Table with name agg_hash_4 does not exist!
Did you mean "pg_am"?
