-- START setup from test_setup 
--
-- TEST_SETUP --- prepare environment expected by regression test scripts
--
-- directory paths and dlsuffix are passed to us in environment variables
\getenv abs_srcdir PG_ABS_SRCDIR
\getenv libdir PG_LIBDIR
\getenv dlsuffix PG_DLSUFFIX
\set regresslib :libdir '/regress' :dlsuffix
--
-- synchronous_commit=off delays when hint bits may be set. Some plans change
-- depending on the number of all-visible pages, which in turn can be
-- influenced by the delayed hint bits. Force synchronous_commit=on to avoid
-- that source of variability.
--
SET synchronous_commit = on;
--
-- Postgres formerly made the public schema read/write by default,
-- and most of the core regression tests still expect that.
--
GRANT ALL ON SCHEMA public TO public;
-- Create a tablespace we can use in tests.
SET allow_in_place_tablespaces = true;
CREATE TABLESPACE regress_tblspace LOCATION '';
--
-- These tables have traditionally been referenced by many tests,
-- so create and populate them.  Insert only non-error values here.
-- (Some subsequent tests try to insert erroneous values.  That's okay
-- because the table won't actually change.  Do not change the contents
-- of these tables in later tests, as it may affect other tests.)
--
CREATE TABLE CHAR_TBL(f1 char(4));
INSERT INTO CHAR_TBL (f1) VALUES
  ('a'),
  ('ab'),
  ('abcd'),
  ('abcd    ');
VACUUM CHAR_TBL;
CREATE TABLE FLOAT8_TBL(f1 float8);
INSERT INTO FLOAT8_TBL(f1) VALUES
  ('0.0'),
  ('-34.84'),
  ('-1004.30'),
  ('-1.2345678901234e+200'),
  ('-1.2345678901234e-200');
VACUUM FLOAT8_TBL;
CREATE TABLE INT2_TBL(f1 int2);
INSERT INTO INT2_TBL(f1) VALUES
  ('0   '),
  ('  1234 '),
  ('    -1234'),
  ('32767'),  -- largest and smallest values
  ('-32767');
VACUUM INT2_TBL;
CREATE TABLE INT4_TBL(f1 int4);
INSERT INTO INT4_TBL(f1) VALUES
  ('   0  '),
  ('123456     '),
  ('    -123456'),
  ('2147483647'),  -- largest and smallest values
  ('-2147483647');
VACUUM INT4_TBL;
CREATE TABLE INT8_TBL(q1 int8, q2 int8);
INSERT INTO INT8_TBL VALUES
  ('  123   ','  456'),
  ('123   ','4567890123456789'),
  ('4567890123456789','123'),
  (+4567890123456789,'4567890123456789'),
  ('+4567890123456789','-4567890123456789');
VACUUM INT8_TBL;
CREATE TABLE POINT_TBL(f1 point);
INSERT INTO POINT_TBL(f1) VALUES
  ('(0.0,0.0)'),
  ('(-10.0,0.0)'),
  ('(-3.0,4.0)'),
  ('(5.1, 34.5)'),
  ('(-5.0,-12.0)'),
  ('(1e-300,-1e-300)'),  -- To underflow
  ('(1e+300,Inf)'),  -- To overflow
  ('(Inf,1e+300)'),  -- Transposed
  (' ( Nan , NaN ) '),
  ('10.0,10.0');
-- We intentionally don't vacuum point_tbl here; geometry depends on that
CREATE TABLE TEXT_TBL (f1 text);
INSERT INTO TEXT_TBL VALUES
  ('doh!'),
  ('hi de ho neighbor');
VACUUM TEXT_TBL;
CREATE TABLE VARCHAR_TBL(f1 varchar(4));
INSERT INTO VARCHAR_TBL (f1) VALUES
  ('a'),
  ('ab'),
  ('abcd'),
  ('abcd    ');
VACUUM VARCHAR_TBL;
CREATE TABLE onek (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
\set filename :abs_srcdir '/data/onek.data'
COPY onek FROM :'filename';
VACUUM ANALYZE onek;
CREATE TABLE onek2 AS SELECT * FROM onek;
VACUUM ANALYZE onek2;
CREATE TABLE tenk1 (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
\set filename :abs_srcdir '/data/tenk.data'
COPY tenk1 FROM :'filename';
VACUUM ANALYZE tenk1;
CREATE TABLE tenk2 AS SELECT * FROM tenk1;
VACUUM ANALYZE tenk2;
CREATE TABLE person (
	name 		text,
	age			int4,
	location 	point
);
\set filename :abs_srcdir '/data/person.data'
COPY person FROM :'filename';
VACUUM ANALYZE person;
CREATE TABLE emp (
	salary 		int4,
	manager 	name
) INHERITS (person);
\set filename :abs_srcdir '/data/emp.data'
COPY emp FROM :'filename';
VACUUM ANALYZE emp;
CREATE TABLE student (
	gpa 		float8
) INHERITS (person);
\set filename :abs_srcdir '/data/student.data'
COPY student FROM :'filename';
VACUUM ANALYZE student;
CREATE TABLE stud_emp (
	percent 	int4
) INHERITS (emp, student);
NOTICE:  merging multiple inherited definitions of column "name"
NOTICE:  merging multiple inherited definitions of column "age"
NOTICE:  merging multiple inherited definitions of column "location"
\set filename :abs_srcdir '/data/stud_emp.data'
COPY stud_emp FROM :'filename';
VACUUM ANALYZE stud_emp;
CREATE TABLE road (
	name		text,
	thepath 	path
);
\set filename :abs_srcdir '/data/streets.data'
COPY road FROM :'filename';
VACUUM ANALYZE road;
CREATE TABLE ihighway () INHERITS (road);
INSERT INTO ihighway
   SELECT *
   FROM ONLY road
   WHERE name ~ 'I- .*';
VACUUM ANALYZE ihighway;
CREATE TABLE shighway (
	surface		text
) INHERITS (road);
INSERT INTO shighway
   SELECT *, 'asphalt'
   FROM ONLY road
   WHERE name ~ 'State Hwy.*';
VACUUM ANALYZE shighway;
--
-- We must have some enum type in the database for opr_sanity and type_sanity.
--
create type stoplight as enum ('red', 'yellow', 'green');
--
-- Also create some non-built-in range types.
--
create type float8range as range (subtype = float8, subtype_diff = float8mi);
create type textrange as range (subtype = text, collation = "C");
--
-- Create some C functions that will be used by various tests.
--
CREATE FUNCTION binary_coercible(oid, oid)
    RETURNS bool
    AS :'regresslib', 'binary_coercible'
    LANGUAGE C STRICT STABLE PARALLEL SAFE;
CREATE FUNCTION ttdummy ()
    RETURNS trigger
    AS :'regresslib'
    LANGUAGE C;
-- Use hand-rolled hash functions and operator classes to get predictable
-- result on different machines.  The hash function for int4 simply returns
-- the sum of the values passed to it and the one for text returns the length
-- of the non-empty string value passed to it or 0.
create function part_hashint4_noop(value int4, seed int8)
    returns int8 as $$
    select value + seed;
    $$ language sql strict immutable parallel safe;
create operator class part_test_int4_ops for type int4 using hash as
    operator 1 =,
    function 2 part_hashint4_noop(int4, int8);
create function part_hashtext_length(value text, seed int8)
    returns int8 as $$
    select length(coalesce(value, ''))::int8
    $$ language sql strict immutable parallel safe;
create operator class part_test_text_ops for type text using hash as
    operator 1 =,
    function 2 part_hashtext_length(text, int8);
--
-- These functions are used in tests that used to use md5(), which we now
-- mostly avoid so that the tests will pass in FIPS mode.
--
create function fipshash(bytea)
    returns text
    strict immutable parallel safe leakproof
    return substr(encode(sha256($1), 'hex'), 1, 32);
create function fipshash(text)
    returns text
    strict immutable parallel safe leakproof
    return substr(encode(sha256($1::bytea), 'hex'), 1, 32);
-- END setup from test_setup 
-- START setup from create_index 
--
-- CREATE_INDEX
-- Create ancillary data structures (i.e. indices)
--
-- directory paths are passed to us in environment variables
\getenv abs_srcdir PG_ABS_SRCDIR
--
-- BTREE
--
CREATE INDEX onek_unique1 ON onek USING btree(unique1 int4_ops);
CREATE INDEX IF NOT EXISTS onek_unique1 ON onek USING btree(unique1 int4_ops);
NOTICE:  relation "onek_unique1" already exists, skipping
CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops);
ERROR:  syntax error at or near "ON"
LINE 1: CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_...
                                   ^
CREATE INDEX onek_unique2 ON onek USING btree(unique2 int4_ops);
CREATE INDEX onek_hundred ON onek USING btree(hundred int4_ops);
CREATE INDEX onek_stringu1 ON onek USING btree(stringu1 name_ops);
CREATE INDEX tenk1_unique1 ON tenk1 USING btree(unique1 int4_ops);
CREATE INDEX tenk1_unique2 ON tenk1 USING btree(unique2 int4_ops);
CREATE INDEX tenk1_hundred ON tenk1 USING btree(hundred int4_ops);
CREATE INDEX tenk1_thous_tenthous ON tenk1 (thousand, tenthous);
CREATE INDEX tenk2_unique1 ON tenk2 USING btree(unique1 int4_ops);
CREATE INDEX tenk2_unique2 ON tenk2 USING btree(unique2 int4_ops);
CREATE INDEX tenk2_hundred ON tenk2 USING btree(hundred int4_ops);
CREATE INDEX rix ON road USING btree (name text_ops);
CREATE INDEX iix ON ihighway USING btree (name text_ops);
CREATE INDEX six ON shighway USING btree (name text_ops);
-- test comments
COMMENT ON INDEX six_wrong IS 'bad index';
ERROR:  relation "six_wrong" does not exist
COMMENT ON INDEX six IS 'good index';
COMMENT ON INDEX six IS NULL;
--
-- BTREE partial indices
--
CREATE INDEX onek2_u1_prtl ON onek2 USING btree(unique1 int4_ops)
	where unique1 < 20 or unique1 > 980;
CREATE INDEX onek2_u2_prtl ON onek2 USING btree(unique2 int4_ops)
	where stringu1 < 'B';
CREATE INDEX onek2_stu1_prtl ON onek2 USING btree(stringu1 name_ops)
	where onek2.stringu1 >= 'J' and onek2.stringu1 < 'K';
--
-- GiST (rtree-equivalent opclasses only)
--
CREATE TABLE slow_emp4000 (
	home_base	 box
);
CREATE TABLE fast_emp4000 (
	home_base	 box
);
\set filename :abs_srcdir '/data/rect.data'
COPY slow_emp4000 FROM :'filename';
INSERT INTO fast_emp4000 SELECT * FROM slow_emp4000;
ANALYZE slow_emp4000;
ANALYZE fast_emp4000;
CREATE INDEX grect2ind ON fast_emp4000 USING gist (home_base);
-- we want to work with a point_tbl that includes a null
CREATE TEMP TABLE point_tbl AS SELECT * FROM public.point_tbl;
INSERT INTO POINT_TBL(f1) VALUES (NULL);
CREATE INDEX gpointind ON point_tbl USING gist (f1);
CREATE TEMP TABLE gpolygon_tbl AS
    SELECT polygon(home_base) AS f1 FROM slow_emp4000;
INSERT INTO gpolygon_tbl VALUES ( '(1000,0,0,1000)' );
INSERT INTO gpolygon_tbl VALUES ( '(0,1000,1000,1000)' );
CREATE TEMP TABLE gcircle_tbl AS
    SELECT circle(home_base) AS f1 FROM slow_emp4000;
CREATE INDEX ggpolygonind ON gpolygon_tbl USING gist (f1);
CREATE INDEX ggcircleind ON gcircle_tbl USING gist (f1);
--
-- Test GiST indexes
--
-- get non-indexed results for comparison purposes
SET enable_seqscan = ON;
SET enable_indexscan = OFF;
SET enable_bitmapscan = OFF;
SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
       home_base       
-----------------------
 (337,455),(240,359)
 (1444,403),(1346,344)
(2 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
 count 
-------
     2
(1 row)

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
 count 
-------
   278
(1 row)

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
 count 
-------
     2
(1 row)

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
 count 
-------
     2
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
 count 
-------
     5
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
 count 
-------
     1
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
 count 
-------
     4
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
 count 
-------
     1
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
 count 
-------
     5
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
 count 
-------
     1
(1 row)

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (Infinity,1e+300)
 (1e+300,Infinity)
 (NaN,NaN)
 
(11 rows)

SELECT * FROM point_tbl WHERE f1 IS NULL;
 f1 
----
 
(1 row)

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (1e+300,Infinity)
 (Infinity,1e+300)
 (NaN,NaN)
(10 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                       f1                        
-------------------------------------------------
 ((240,359),(240,455),(337,455),(337,359))
 ((662,163),(662,187),(759,187),(759,163))
 ((1000,0),(0,1000))
 ((0,1000),(1000,1000))
 ((1346,344),(1346,403),(1444,403),(1444,344))
 ((278,1409),(278,1457),(369,1457),(369,1409))
 ((907,1156),(907,1201),(948,1201),(948,1156))
 ((1517,971),(1517,1043),(1594,1043),(1594,971))
 ((175,1820),(175,1850),(259,1850),(259,1820))
 ((2424,81),(2424,160),(2424,160),(2424,81))
(10 rows)

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 circle_center  | radius 
----------------+--------
 (288.5,407)    |     68
 (710.5,175)    |     50
 (323.5,1433)   |     51
 (927.5,1178.5) |     30
 (1395,373.5)   |     57
 (1555.5,1007)  |     53
 (217,1835)     |     45
 (489,2421.5)   |     22
 (2424,120.5)   |     40
 (751.5,2655)   |     20
(10 rows)

-- Now check the results from plain indexscan
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
EXPLAIN (COSTS OFF)
SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
                           QUERY PLAN                            
-----------------------------------------------------------------
 Sort
   Sort Key: ((home_base[0])[0])
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base <@ '(2000,1000),(200,200)'::box)
(4 rows)

SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
       home_base       
-----------------------
 (337,455),(240,359)
 (1444,403),(1346,344)
(2 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base && '(1000,1000),(0,0)'::box)
(3 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base IS NULL)
(3 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
 count 
-------
   278
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Index Scan using ggpolygonind on gpolygon_tbl
         Index Cond: (f1 && '((1000,1000),(0,0))'::polygon)
(3 rows)

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Scan using ggcircleind on gcircle_tbl
         Index Cond: (f1 && '<(500,500),500>'::circle)
(3 rows)

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '(100,100),(0,0)'::box)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '(100,100),(0,0)'::box)
(3 rows)

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '((0,0),(0,100),(100,100),(50,50),(100,0),(0,0))'::polygon)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
 count 
-------
     4
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '<(50,50),50>'::circle)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 << '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 >> '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
 count 
-------
     4
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 <<| '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 |>> '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
 count 
-------
     5
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 ~= '(-5,-12)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Order By: (f1 <-> '(0,1)'::point)
(2 rows)

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (Infinity,1e+300)
 (1e+300,Infinity)
 (NaN,NaN)
 
(11 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NULL;
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 IS NULL)
(2 rows)

SELECT * FROM point_tbl WHERE f1 IS NULL;
 f1 
----
 
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 IS NOT NULL)
   Order By: (f1 <-> '(0,1)'::point)
(3 rows)

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (Infinity,1e+300)
 (1e+300,Infinity)
 (NaN,NaN)
(10 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
                   QUERY PLAN                   
------------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 <@ '(10,10),(-10,-10)'::box)
   Order By: (f1 <-> '(0,1)'::point)
(3 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                     QUERY PLAN                      
-----------------------------------------------------
 Limit
   ->  Index Scan using ggpolygonind on gpolygon_tbl
         Order By: (f1 <-> '(0,0)'::point)
(3 rows)

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                       f1                        
-------------------------------------------------
 ((240,359),(240,455),(337,455),(337,359))
 ((662,163),(662,187),(759,187),(759,163))
 ((1000,0),(0,1000))
 ((0,1000),(1000,1000))
 ((1346,344),(1346,403),(1444,403),(1444,344))
 ((278,1409),(278,1457),(369,1457),(369,1409))
 ((907,1156),(907,1201),(948,1201),(948,1156))
 ((1517,971),(1517,1043),(1594,1043),(1594,971))
 ((175,1820),(175,1850),(259,1850),(259,1820))
 ((2424,81),(2424,160),(2424,160),(2424,81))
(10 rows)

EXPLAIN (COSTS OFF)
SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
                    QUERY PLAN                     
---------------------------------------------------
 Limit
   ->  Index Scan using ggcircleind on gcircle_tbl
         Order By: (f1 <-> '(200,300)'::point)
(3 rows)

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 circle_center  | radius 
----------------+--------
 (288.5,407)    |     68
 (710.5,175)    |     50
 (323.5,1433)   |     51
 (927.5,1178.5) |     30
 (1395,373.5)   |     57
 (1555.5,1007)  |     53
 (217,1835)     |     45
 (489,2421.5)   |     22
 (2424,120.5)   |     40
 (751.5,2655)   |     20
(10 rows)

EXPLAIN (COSTS OFF)
SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Function Scan on generate_series x
   SubPlan 1
     ->  Limit
           ->  Index Scan using ggpolygonind on gpolygon_tbl
                 Order By: (f1 <-> point((x.x)::double precision, (x.x)::double precision))
(5 rows)

SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
  point  |                     c                     
---------+-------------------------------------------
 (0,0)   | ((240,359),(240,455),(337,455),(337,359))
 (1,1)   | ((240,359),(240,455),(337,455),(337,359))
 (2,2)   | ((240,359),(240,455),(337,455),(337,359))
 (3,3)   | ((240,359),(240,455),(337,455),(337,359))
 (4,4)   | ((240,359),(240,455),(337,455),(337,359))
 (5,5)   | ((240,359),(240,455),(337,455),(337,359))
 (6,6)   | ((240,359),(240,455),(337,455),(337,359))
 (7,7)   | ((240,359),(240,455),(337,455),(337,359))
 (8,8)   | ((240,359),(240,455),(337,455),(337,359))
 (9,9)   | ((240,359),(240,455),(337,455),(337,359))
 (10,10) | ((240,359),(240,455),(337,455),(337,359))
(11 rows)

-- Now check the results from bitmap indexscan
SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: ((f1 <-> '(0,1)'::point))
   ->  Bitmap Heap Scan on point_tbl
         Recheck Cond: (f1 <@ '(10,10),(-10,-10)'::box)
         ->  Bitmap Index Scan on gpointind
               Index Cond: (f1 <@ '(10,10),(-10,-10)'::box)
(6 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
--
-- GIN over int[] and text[]
--
-- Note: GIN currently supports only bitmap scans, not plain indexscans
--
CREATE TABLE array_index_op_test (
	seqno		int4,
	i			int4[],
	t			text[]
);
\set filename :abs_srcdir '/data/array.data'
COPY array_index_op_test FROM :'filename';
ANALYZE array_index_op_test;
SELECT * FROM array_index_op_test WHERE i = '{NULL}' ORDER BY seqno;
 seqno |   i    |   t    
-------+--------+--------
   102 | {NULL} | {NULL}
(1 row)

SELECT * FROM array_index_op_test WHERE i @> '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i && '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
explain (costs off)
SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: seqno
   ->  Bitmap Heap Scan on array_index_op_test
         Recheck Cond: (i @> '{32}'::integer[])
         ->  Bitmap Index Scan on intarrayidx
               Index Cond: (i @> '{32}'::integer[])
(6 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
(8 rows)

SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
(8 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
(3 rows)

SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(11 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
 seqno |       i       |                                                             t                                                              
-------+---------------+----------------------------------------------------------------------------------------------------------------------------
    40 | {34}          | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
    74 | {32}          | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    98 | {38,34,32,89} | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   101 | {}            | {}
(4 rows)

SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
 seqno |    i    |                                                        t                                                        
-------+---------+-----------------------------------------------------------------------------------------------------------------
    95 | {47,77} | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
(1 row)

SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
 seqno |                i                |                                                                                                       t                                                                                                        
-------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
     2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
     3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
     4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
     5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
     7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
     8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
     9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
    10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
    11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
    14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    16 | {14,63,85,11}                   | {AAAAAA66777}
    17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
    18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
    21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
    22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
    23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
    24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
    25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
    26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
    27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
    28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
    29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
    30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
    32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
    33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
    34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
    35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
    36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
    37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
    38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
    39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
    40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
    41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
    42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
    43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
    44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
    45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
    47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
    48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
    49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
    50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
    51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
    52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
    55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
    56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
    57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
    58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
    59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
    60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
    61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
    62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
    63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
    64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
    67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
    68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
    69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
    70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
    71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
    72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
    76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
    79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
    81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
    82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
    84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
    85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
    86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
    87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
    88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
    91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
    92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
    93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
    94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
    95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
    96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
    97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
    99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
   101 | {}                              | {}
   102 | {NULL}                          | {NULL}
(102 rows)

SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
explain (costs off)
SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: seqno
   ->  Bitmap Heap Scan on array_index_op_test
         Recheck Cond: (t @> '{AAAAAAAA72908}'::text[])
         ->  Bitmap Index Scan on textarrayidx
               Index Cond: (t @> '{AAAAAAAA72908}'::text[])
(6 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
 seqno |           i           |                                                                     t                                                                      
-------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
(4 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
 seqno |           i           |                                                                     t                                                                      
-------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
(4 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
 seqno |        i         |                                 t                                  
-------+------------------+--------------------------------------------------------------------
    15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
    79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
(3 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
 seqno |        i         |                                 t                                  
-------+------------------+--------------------------------------------------------------------
    15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
    79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
(3 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
 seqno |  i   |                                 t                                  
-------+------+--------------------------------------------------------------------
    79 | {45} | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
(1 row)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
 seqno |           i           |                                                                     t                                                                      
-------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
    15 | {17,14,16,63,67}      | {AA6416,AAAAAAAAAA646,AAAAA95309}
    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    96 | {23,97,43}            | {AAAAAAAAAA646,A87088}
(6 rows)

SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
 seqno |         i          |                                                     t                                                     
-------+--------------------+-----------------------------------------------------------------------------------------------------------
    22 | {11,6,56,62,53,30} | {AAAAAAAA72908}
    45 | {99,45}            | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
   101 | {}                 | {}
(3 rows)

SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
 seqno |     i      |           t            
-------+------------+------------------------
    96 | {23,97,43} | {AAAAAAAAAA646,A87088}
(1 row)

SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
 seqno |                i                |                                                                                                       t                                                                                                        
-------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
     2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
     3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
     4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
     5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
     7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
     8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
     9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
    10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
    11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
    14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    16 | {14,63,85,11}                   | {AAAAAA66777}
    17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
    18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
    21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
    22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
    23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
    24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
    25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
    26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
    27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
    28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
    29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
    30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
    32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
    33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
    34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
    35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
    36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
    37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
    38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
    39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
    40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
    41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
    42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
    43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
    44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
    45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
    47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
    48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
    49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
    50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
    51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
    52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
    55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
    56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
    57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
    58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
    59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
    60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
    61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
    62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
    63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
    64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
    67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
    68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
    69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
    70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
    71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
    72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
    76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
    79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
    81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
    82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
    84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
    85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
    86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
    87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
    88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
    91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
    92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
    93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
    94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
    95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
    96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
    97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
    99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
   101 | {}                              | {}
   102 | {NULL}                          | {NULL}
(102 rows)

SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

-- And try it with a multicolumn GIN index
DROP INDEX intarrayidx, textarrayidx;
CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
 seqno |               i                |                                                                              t                                                                              
-------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
    19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
   100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(7 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
 seqno |               i                |                                                                              t                                                                              
-------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
    19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
   100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(7 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
 seqno |              i              |                                      t                                       
-------+-----------------------------+------------------------------------------------------------------------------
   100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(1 row)

SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
 seqno |              i              |                                      t                                       
-------+-----------------------------+------------------------------------------------------------------------------
   100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(1 row)

SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
--
-- Try a GIN index with a lot of items with same key. (GIN creates a posting
-- tree when there are enough duplicates)
--
CREATE TABLE array_gin_test (a int[]);
INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
 count 
-------
  2000
(1 row)

DROP TABLE array_gin_test;
--
-- Test GIN index's reloptions
--
CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
  WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
\d+ gin_relopts_test
                Index "public.gin_relopts_test"
 Column |  Type   | Key? | Definition | Storage | Stats target 
--------+---------+------+------------+---------+--------------
 i      | integer | yes  | i          | plain   | 
gin, for table "public.array_index_op_test"
Options: fastupdate=on, gin_pending_list_limit=128

--
-- HASH
--
CREATE UNLOGGED TABLE unlogged_hash_table (id int4);
CREATE INDEX unlogged_hash_index ON unlogged_hash_table USING hash (id int4_ops);
DROP TABLE unlogged_hash_table;
-- CREATE INDEX hash_ovfl_index ON hash_ovfl_heap USING hash (x int4_ops);
-- Test hash index build tuplesorting.  Force hash tuplesort using low
-- maintenance_work_mem setting and fillfactor:
SET maintenance_work_mem = '1MB';
CREATE INDEX hash_tuplesort_idx ON tenk1 USING hash (stringu1 name_ops) WITH (fillfactor = 10);
EXPLAIN (COSTS OFF)
SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on tenk1
         Recheck Cond: (stringu1 = 'TVAAAA'::name)
         ->  Bitmap Index Scan on hash_tuplesort_idx
               Index Cond: (stringu1 = 'TVAAAA'::name)
(5 rows)

SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
 count 
-------
    14
(1 row)

DROP INDEX hash_tuplesort_idx;
RESET maintenance_work_mem;
--
-- Test unique null behavior
--
CREATE TABLE unique_tbl (i int, t text);
CREATE UNIQUE INDEX unique_idx1 ON unique_tbl (i) NULLS DISTINCT;
CREATE UNIQUE INDEX unique_idx2 ON unique_tbl (i) NULLS NOT DISTINCT;
INSERT INTO unique_tbl VALUES (1, 'one');
INSERT INTO unique_tbl VALUES (2, 'two');
INSERT INTO unique_tbl VALUES (3, 'three');
INSERT INTO unique_tbl VALUES (4, 'four');
INSERT INTO unique_tbl VALUES (5, 'one');
INSERT INTO unique_tbl (t) VALUES ('six');
INSERT INTO unique_tbl (t) VALUES ('seven');  -- error from unique_idx2
ERROR:  duplicate key value violates unique constraint "unique_idx2"
DETAIL:  Key (i)=(null) already exists.
DROP INDEX unique_idx1, unique_idx2;
INSERT INTO unique_tbl (t) VALUES ('seven');
-- build indexes on filled table
CREATE UNIQUE INDEX unique_idx3 ON unique_tbl (i) NULLS DISTINCT;  -- ok
CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;  -- error
ERROR:  could not create unique index "unique_idx4"
DETAIL:  Key (i)=(null) is duplicated.
DELETE FROM unique_tbl WHERE t = 'seven';
CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;  -- ok now
\d unique_tbl
             Table "public.unique_tbl"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 i      | integer |           |          | 
 t      | text    |           |          | 
Indexes:
    "unique_idx3" UNIQUE, btree (i)
    "unique_idx4" UNIQUE, btree (i) NULLS NOT DISTINCT

\d unique_idx3
      Index "public.unique_idx3"
 Column |  Type   | Key? | Definition 
--------+---------+------+------------
 i      | integer | yes  | i
unique, btree, for table "public.unique_tbl"

\d unique_idx4
      Index "public.unique_idx4"
 Column |  Type   | Key? | Definition 
--------+---------+------+------------
 i      | integer | yes  | i
unique nulls not distinct, btree, for table "public.unique_tbl"

SELECT pg_get_indexdef('unique_idx3'::regclass);
                           pg_get_indexdef                            
----------------------------------------------------------------------
 CREATE UNIQUE INDEX unique_idx3 ON public.unique_tbl USING btree (i)
(1 row)

SELECT pg_get_indexdef('unique_idx4'::regclass);
                                     pg_get_indexdef                                     
-----------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX unique_idx4 ON public.unique_tbl USING btree (i) NULLS NOT DISTINCT
(1 row)

DROP TABLE unique_tbl;
--
-- Test functional index
--
CREATE TABLE func_index_heap (f1 text, f2 text);
CREATE UNIQUE INDEX func_index_index on func_index_heap (textcat(f1,f2));
INSERT INTO func_index_heap VALUES('ABC','DEF');
INSERT INTO func_index_heap VALUES('AB','CDEFG');
INSERT INTO func_index_heap VALUES('QWE','RTY');
-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
ERROR:  duplicate key value violates unique constraint "func_index_index"
DETAIL:  Key (textcat(f1, f2))=(ABCDEF) already exists.
-- but this shouldn't:
INSERT INTO func_index_heap VALUES('QWERTY');
-- while we're here, see that the metadata looks sane
\d func_index_heap
         Table "public.func_index_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "func_index_index" UNIQUE, btree (textcat(f1, f2))

\d func_index_index
     Index "public.func_index_index"
 Column  | Type | Key? |   Definition    
---------+------+------+-----------------
 textcat | text | yes  | textcat(f1, f2)
unique, btree, for table "public.func_index_heap"

--
-- Same test, expressional index
--
DROP TABLE func_index_heap;
CREATE TABLE func_index_heap (f1 text, f2 text);
CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
INSERT INTO func_index_heap VALUES('ABC','DEF');
INSERT INTO func_index_heap VALUES('AB','CDEFG');
INSERT INTO func_index_heap VALUES('QWE','RTY');
-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
ERROR:  duplicate key value violates unique constraint "func_index_index"
DETAIL:  Key ((f1 || f2))=(ABCDEF) already exists.
-- but this shouldn't:
INSERT INTO func_index_heap VALUES('QWERTY');
-- while we're here, see that the metadata looks sane
\d func_index_heap
         Table "public.func_index_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "func_index_index" UNIQUE, btree ((f1 || f2))

\d func_index_index
  Index "public.func_index_index"
 Column | Type | Key? | Definition 
--------+------+------+------------
 expr   | text | yes  | (f1 || f2)
unique, btree, for table "public.func_index_heap"

-- this should fail because of unsafe column type (anonymous record)
create index on func_index_heap ((f1 || f2), (row(f1, f2)));
ERROR:  column "row" has pseudo-type record
--
-- Test unique index with included columns
--
CREATE TABLE covering_index_heap (f1 int, f2 int, f3 text);
CREATE UNIQUE INDEX covering_index_index on covering_index_heap (f1,f2) INCLUDE(f3);
INSERT INTO covering_index_heap VALUES(1,1,'AAA');
INSERT INTO covering_index_heap VALUES(1,2,'AAA');
-- this should fail because of unique index on f1,f2:
INSERT INTO covering_index_heap VALUES(1,2,'BBB');
ERROR:  duplicate key value violates unique constraint "covering_index_index"
DETAIL:  Key (f1, f2)=(1, 2) already exists.
-- and this shouldn't:
INSERT INTO covering_index_heap VALUES(1,4,'AAA');
-- Try to build index on table that already contains data
CREATE UNIQUE INDEX covering_pkey on covering_index_heap (f1,f2) INCLUDE(f3);
-- Try to use existing covering index as primary key
ALTER TABLE covering_index_heap ADD CONSTRAINT covering_pkey PRIMARY KEY USING INDEX
covering_pkey;
DROP TABLE covering_index_heap;
--
-- Try some concurrent index builds
--
-- Unfortunately this only tests about half the code paths because there are
-- no concurrent updates happening to the table at the same time.
CREATE TABLE concur_heap (f1 text, f2 text);
-- empty table
CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
NOTICE:  relation "concur_index1" already exists, skipping
INSERT INTO concur_heap VALUES  ('a','b');
INSERT INTO concur_heap VALUES  ('b','b');
-- unique index
CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
NOTICE:  relation "concur_index2" already exists, skipping
-- check if constraint is set up properly to be enforced
INSERT INTO concur_heap VALUES ('b','x');
ERROR:  duplicate key value violates unique constraint "concur_index2"
DETAIL:  Key (f1)=(b) already exists.
-- check if constraint is enforced properly at build time
CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
ERROR:  could not create unique index "concur_index3"
DETAIL:  Key (f2)=(b) is duplicated.
-- test that expression indexes and partial indexes work concurrently
CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
-- here we also check that you can default the index name
CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
-- You can't do a concurrent index build in a transaction
BEGIN;
CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- test where predicate is able to do a transactional update during
-- a concurrent build before switching pg_index state flags.
CREATE FUNCTION predicate_stable() RETURNS bool IMMUTABLE
LANGUAGE plpgsql AS $$
BEGIN
  EXECUTE 'SELECT txid_current()';
  RETURN true;
END; $$;
CREATE INDEX CONCURRENTLY concur_index8 ON concur_heap (f1)
  WHERE predicate_stable();
DROP INDEX concur_index8;
DROP FUNCTION predicate_stable();
-- But you can do a regular index build in a transaction
BEGIN;
CREATE INDEX std_index on concur_heap(f2);
COMMIT;
-- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
VACUUM FULL concur_heap;
REINDEX TABLE concur_heap;
ERROR:  could not create unique index "concur_index3"
DETAIL:  Key (f2)=(b) is duplicated.
DELETE FROM concur_heap WHERE f1 = 'b';
VACUUM FULL concur_heap;
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "concur_heap_expr_idx" btree ((f2 || f1))
    "concur_index1" btree (f2, f1)
    "concur_index2" UNIQUE, btree (f1)
    "concur_index3" UNIQUE, btree (f2) INVALID
    "concur_index4" btree (f2) WHERE f1 = 'a'::text
    "concur_index5" btree (f2) WHERE f1 = 'x'::text
    "std_index" btree (f2)

REINDEX TABLE concur_heap;
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "concur_heap_expr_idx" btree ((f2 || f1))
    "concur_index1" btree (f2, f1)
    "concur_index2" UNIQUE, btree (f1)
    "concur_index3" UNIQUE, btree (f2)
    "concur_index4" btree (f2) WHERE f1 = 'a'::text
    "concur_index5" btree (f2) WHERE f1 = 'x'::text
    "std_index" btree (f2)

-- Temporary tables with concurrent builds and on-commit actions
-- CONCURRENTLY used with CREATE INDEX and DROP INDEX is ignored.
-- PRESERVE ROWS, the default.
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
DROP INDEX CONCURRENTLY concur_temp_ind;
DROP TABLE concur_temp;
-- ON COMMIT DROP
BEGIN;
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT DROP;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
-- Fails when running in a transaction.
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- ON COMMIT DELETE ROWS
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT DELETE ROWS;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
DROP INDEX CONCURRENTLY concur_temp_ind;
DROP TABLE concur_temp;
--
-- Try some concurrent index drops
--
DROP INDEX CONCURRENTLY "concur_index2";				-- works
DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
NOTICE:  index "concur_index2" does not exist, skipping
-- failures
DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
BEGIN;
DROP INDEX CONCURRENTLY "concur_index5";
ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
ROLLBACK;
-- successes
DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
DROP INDEX CONCURRENTLY "concur_index4";
DROP INDEX CONCURRENTLY "concur_index5";
DROP INDEX CONCURRENTLY "concur_index1";
DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "std_index" btree (f2)

DROP TABLE concur_heap;
--
-- Test ADD CONSTRAINT USING INDEX
--
CREATE TABLE cwi_test( a int , b varchar(10), c char);
-- add some data so that all tests have something to work with.
INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
\d cwi_test
                     Table "public.cwi_test"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           | not null | 
 b      | character varying(10) |           | not null | 
 c      | character(1)          |           |          | 
Indexes:
    "cwi_uniq_idx" PRIMARY KEY, btree (a, b)

\d cwi_uniq_idx
            Index "public.cwi_uniq_idx"
 Column |         Type          | Key? | Definition 
--------+-----------------------+------+------------
 a      | integer               | yes  | a
 b      | character varying(10) | yes  | b
primary key, btree, for table "public.cwi_test"

CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
		USING INDEX cwi_uniq2_idx;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
\d cwi_test
                     Table "public.cwi_test"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           | not null | 
 b      | character varying(10) |           | not null | 
 c      | character(1)          |           |          | 
Indexes:
    "cwi_replaced_pkey" PRIMARY KEY, btree (b, a)

\d cwi_replaced_pkey
          Index "public.cwi_replaced_pkey"
 Column |         Type          | Key? | Definition 
--------+-----------------------+------+------------
 b      | character varying(10) | yes  | b
 a      | integer               | yes  | a
primary key, btree, for table "public.cwi_test"

DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
-- Check that non-default index options are rejected
CREATE UNIQUE INDEX cwi_uniq3_idx ON cwi_test(a desc);
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;  -- fail
ERROR:  index "cwi_uniq3_idx" column number 1 does not have default sorting behavior
LINE 1: ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;
                                 ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
CREATE UNIQUE INDEX cwi_uniq4_idx ON cwi_test(b collate "POSIX");
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;  -- fail
ERROR:  index "cwi_uniq4_idx" column number 1 does not have default sorting behavior
LINE 1: ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;
                                 ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
DROP TABLE cwi_test;
-- ADD CONSTRAINT USING INDEX is forbidden on partitioned tables
CREATE TABLE cwi_test(a int) PARTITION BY hash (a);
create unique index on cwi_test (a);
alter table cwi_test add primary key using index cwi_test_a_idx ;
ERROR:  ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables
DROP TABLE cwi_test;
-- PRIMARY KEY constraint cannot be backed by a NULLS NOT DISTINCT index
CREATE TABLE cwi_test(a int, b int);
CREATE UNIQUE INDEX cwi_a_nnd ON cwi_test (a) NULLS NOT DISTINCT;
ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_a_nnd;
ERROR:  primary keys cannot use NULLS NOT DISTINCT indexes
DROP TABLE cwi_test;
--
-- Check handling of indexes on system columns
--
CREATE TABLE syscol_table (a INT);
-- System columns cannot be indexed
CREATE INDEX ON syscolcol_table (ctid);
ERROR:  relation "syscolcol_table" does not exist
-- nor used in expressions
CREATE INDEX ON syscol_table ((ctid >= '(1000,0)'));
ERROR:  index creation on system columns is not supported
-- nor used in predicates
CREATE INDEX ON syscol_table (a) WHERE ctid >= '(1000,0)';
ERROR:  index creation on system columns is not supported
DROP TABLE syscol_table;
--
-- Tests for IS NULL/IS NOT NULL with b-tree indexes
--
CREATE TABLE onek_with_null AS SELECT unique1, unique2 FROM onek;
INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = ON;
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
-- Check initial-positioning logic too
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
     147 |       0
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
     147 |       0
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
     147 |       0
     931 |       1
(2 rows)

SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
         |        
     278 |     999
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
     278 |     999
       0 |     998
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
       0 |     998
     744 |     997
(2 rows)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
DROP TABLE onek_with_null;
--
-- Check bitmap index path planning
--
EXPLAIN (COSTS OFF)
SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1
   Recheck Cond: (((thousand = 42) AND (tenthous = 1)) OR ((thousand = 42) AND (tenthous = 3)) OR ((thousand = 42) AND (tenthous = 42)))
   ->  BitmapOr
         ->  Bitmap Index Scan on tenk1_thous_tenthous
               Index Cond: ((thousand = 42) AND (tenthous = 1))
         ->  Bitmap Index Scan on tenk1_thous_tenthous
               Index Cond: ((thousand = 42) AND (tenthous = 3))
         ->  Bitmap Index Scan on tenk1_thous_tenthous
               Index Cond: ((thousand = 42) AND (tenthous = 42))
(9 rows)

SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
      42 |    5530 |   0 |    2 |   2 |      2 |      42 |       42 |          42 |        42 |       42 |  84 |   85 | QBAAAA   | SEIAAA   | OOOOxx
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on tenk1
         Recheck Cond: ((hundred = 42) AND ((thousand = 42) OR (thousand = 99)))
         ->  BitmapAnd
               ->  Bitmap Index Scan on tenk1_hundred
                     Index Cond: (hundred = 42)
               ->  BitmapOr
                     ->  Bitmap Index Scan on tenk1_thous_tenthous
                           Index Cond: (thousand = 42)
                     ->  Bitmap Index Scan on tenk1_thous_tenthous
                           Index Cond: (thousand = 99)
(11 rows)

SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
 count 
-------
    10
(1 row)

--
-- Check behavior with duplicate index column contents
--
CREATE TABLE dupindexcols AS
  SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
ANALYZE dupindexcols;
EXPLAIN (COSTS OFF)
  SELECT count(*) FROM dupindexcols
    WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on dupindexcols
         Recheck Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
         ->  Bitmap Index Scan on dupindexcols_i
               Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
(5 rows)

SELECT count(*) FROM dupindexcols
  WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
 count 
-------
    97
(1 row)

--
-- Check ordering of =ANY indexqual results (bug in 9.2.0)
--
explain (costs off)
SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
                      QUERY PLAN                       
-------------------------------------------------------
 Index Only Scan using tenk1_unique1 on tenk1
   Index Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
(2 rows)

SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
 unique1 
---------
       1
       7
      42
(3 rows)

explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
                      QUERY PLAN                       
-------------------------------------------------------
 Index Only Scan using tenk1_thous_tenthous on tenk1
   Index Cond: (thousand < 2)
   Filter: (tenthous = ANY ('{1001,3000}'::integer[]))
(3 rows)

SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

SET enable_indexonlyscan = OFF;
explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort
   Sort Key: thousand
   ->  Index Scan using tenk1_thous_tenthous on tenk1
         Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
(4 rows)

SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

RESET enable_indexonlyscan;
--
-- Check elimination of constant-NULL subexpressions
--
explain (costs off)
  select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
                      QUERY PLAN                      
------------------------------------------------------
 Index Scan using tenk1_thous_tenthous on tenk1
   Index Cond: ((thousand = 1) AND (tenthous = 1001))
(2 rows)

--
-- Check matching of boolean index columns to WHERE conditions and sort keys
--
create temp table boolindex (b bool, i int, unique(b, i), junk float);
explain (costs off)
  select * from boolindex order by b, i limit 10;
                      QUERY PLAN                       
-------------------------------------------------------
 Limit
   ->  Index Scan using boolindex_b_i_key on boolindex
(2 rows)

explain (costs off)
  select * from boolindex where b order by i limit 10;
                      QUERY PLAN                       
-------------------------------------------------------
 Limit
   ->  Index Scan using boolindex_b_i_key on boolindex
         Index Cond: (b = true)
(3 rows)

explain (costs off)
  select * from boolindex where b = true order by i desc limit 10;
                           QUERY PLAN                           
----------------------------------------------------------------
 Limit
   ->  Index Scan Backward using boolindex_b_i_key on boolindex
         Index Cond: (b = true)
(3 rows)

explain (costs off)
  select * from boolindex where not b order by i limit 10;
                      QUERY PLAN                       
-------------------------------------------------------
 Limit
   ->  Index Scan using boolindex_b_i_key on boolindex
         Index Cond: (b = false)
(3 rows)

explain (costs off)
  select * from boolindex where b is true order by i desc limit 10;
                           QUERY PLAN                           
----------------------------------------------------------------
 Limit
   ->  Index Scan Backward using boolindex_b_i_key on boolindex
         Index Cond: (b = true)
(3 rows)

explain (costs off)
  select * from boolindex where b is false order by i desc limit 10;
                           QUERY PLAN                           
----------------------------------------------------------------
 Limit
   ->  Index Scan Backward using boolindex_b_i_key on boolindex
         Index Cond: (b = false)
(3 rows)

--
-- REINDEX (VERBOSE)
--
CREATE TABLE reindex_verbose(id integer primary key);
\set VERBOSITY terse \\ -- suppress machine-dependent details
REINDEX (VERBOSE) TABLE reindex_verbose;
INFO:  index "reindex_verbose_pkey" was reindexed
\set VERBOSITY default
DROP TABLE reindex_verbose;
--
-- REINDEX CONCURRENTLY
--
CREATE TABLE concur_reindex_tab (c1 int);
-- REINDEX
REINDEX TABLE concur_reindex_tab; -- notice
NOTICE:  table "concur_reindex_tab" has no indexes to reindex
REINDEX (CONCURRENTLY) TABLE concur_reindex_tab; -- notice
NOTICE:  table "concur_reindex_tab" has no indexes that can be reindexed concurrently
ALTER TABLE concur_reindex_tab ADD COLUMN c2 text; -- add toast index
-- Normal index with integer column
CREATE UNIQUE INDEX concur_reindex_ind1 ON concur_reindex_tab(c1);
-- Normal index with text column
CREATE INDEX concur_reindex_ind2 ON concur_reindex_tab(c2);
-- UNIQUE index with expression
CREATE UNIQUE INDEX concur_reindex_ind3 ON concur_reindex_tab(abs(c1));
-- Duplicate column names
CREATE INDEX concur_reindex_ind4 ON concur_reindex_tab(c1, c1, c2);
-- Create table for check on foreign key dependence switch with indexes swapped
ALTER TABLE concur_reindex_tab ADD PRIMARY KEY USING INDEX concur_reindex_ind1;
CREATE TABLE concur_reindex_tab2 (c1 int REFERENCES concur_reindex_tab);
INSERT INTO concur_reindex_tab VALUES  (1, 'a');
INSERT INTO concur_reindex_tab VALUES  (2, 'a');
-- Reindex concurrently of exclusion constraint currently not supported
CREATE TABLE concur_reindex_tab3 (c1 int, c2 int4range, EXCLUDE USING gist (c2 WITH &&));
INSERT INTO concur_reindex_tab3 VALUES  (3, '[1,2]');
REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl;  -- error
ERROR:  concurrent index creation for exclusion constraints is not supported
REINDEX TABLE CONCURRENTLY concur_reindex_tab3;  -- succeeds with warning
WARNING:  cannot reindex exclusion constraint index "public.concur_reindex_tab3_c2_excl" concurrently, skipping
INSERT INTO concur_reindex_tab3 VALUES  (4, '[2,4]');
ERROR:  conflicting key value violates exclusion constraint "concur_reindex_tab3_c2_excl"
DETAIL:  Key (c2)=([2,5)) conflicts with existing key (c2)=([1,3)).
-- Check materialized views
CREATE MATERIALIZED VIEW concur_reindex_matview AS SELECT * FROM concur_reindex_tab;
-- Dependency lookup before and after the follow-up REINDEX commands.
-- These should remain consistent.
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_tab'::regclass,
            'concur_reindex_ind1'::regclass,
	    'concur_reindex_ind2'::regclass,
	    'concur_reindex_ind3'::regclass,
	    'concur_reindex_ind4'::regclass,
	    'concur_reindex_matview'::regclass)
  ORDER BY 1, 2;
                   obj                    |                           objref                           | deptype 
------------------------------------------+------------------------------------------------------------+---------
 index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
 index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | table concur_reindex_tab                                   | a
 index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
 materialized view concur_reindex_matview | schema public                                              | n
 table concur_reindex_tab                 | schema public                                              | n
(8 rows)

REINDEX INDEX CONCURRENTLY concur_reindex_ind1;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
REINDEX TABLE CONCURRENTLY concur_reindex_matview;
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_tab'::regclass,
            'concur_reindex_ind1'::regclass,
	    'concur_reindex_ind2'::regclass,
	    'concur_reindex_ind3'::regclass,
	    'concur_reindex_ind4'::regclass,
	    'concur_reindex_matview'::regclass)
  ORDER BY 1, 2;
                   obj                    |                           objref                           | deptype 
------------------------------------------+------------------------------------------------------------+---------
 index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
 index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | table concur_reindex_tab                                   | a
 index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
 materialized view concur_reindex_matview | schema public                                              | n
 table concur_reindex_tab                 | schema public                                              | n
(8 rows)

-- Check that comments are preserved
CREATE TABLE testcomment (i int);
CREATE INDEX testcomment_idx1 ON testcomment (i);
COMMENT ON INDEX testcomment_idx1 IS 'test comment';
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

REINDEX TABLE testcomment;
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

REINDEX TABLE CONCURRENTLY testcomment ;
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

DROP TABLE testcomment;
-- Check that indisclustered updates are preserved
CREATE TABLE concur_clustered(i int);
CREATE INDEX concur_clustered_i_idx ON concur_clustered(i);
ALTER TABLE concur_clustered CLUSTER ON concur_clustered_i_idx;
REINDEX TABLE CONCURRENTLY concur_clustered;
SELECT indexrelid::regclass, indisclustered FROM pg_index
  WHERE indrelid = 'concur_clustered'::regclass;
       indexrelid       | indisclustered 
------------------------+----------------
 concur_clustered_i_idx | t
(1 row)

DROP TABLE concur_clustered;
-- Check that indisreplident updates are preserved.
CREATE TABLE concur_replident(i int NOT NULL);
CREATE UNIQUE INDEX concur_replident_i_idx ON concur_replident(i);
ALTER TABLE concur_replident REPLICA IDENTITY
  USING INDEX concur_replident_i_idx;
SELECT indexrelid::regclass, indisreplident FROM pg_index
  WHERE indrelid = 'concur_replident'::regclass;
       indexrelid       | indisreplident 
------------------------+----------------
 concur_replident_i_idx | t
(1 row)

REINDEX TABLE CONCURRENTLY concur_replident;
SELECT indexrelid::regclass, indisreplident FROM pg_index
  WHERE indrelid = 'concur_replident'::regclass;
       indexrelid       | indisreplident 
------------------------+----------------
 concur_replident_i_idx | t
(1 row)

DROP TABLE concur_replident;
-- Check that opclass parameters are preserved
CREATE TABLE concur_appclass_tab(i tsvector, j tsvector, k tsvector);
CREATE INDEX concur_appclass_ind on concur_appclass_tab
  USING gist (i tsvector_ops (siglen='1000'), j tsvector_ops (siglen='500'));
CREATE INDEX concur_appclass_ind_2 on concur_appclass_tab
  USING gist (k tsvector_ops (siglen='300'), j tsvector_ops);
REINDEX TABLE CONCURRENTLY concur_appclass_tab;
\d concur_appclass_tab
         Table "public.concur_appclass_tab"
 Column |   Type   | Collation | Nullable | Default 
--------+----------+-----------+----------+---------
 i      | tsvector |           |          | 
 j      | tsvector |           |          | 
 k      | tsvector |           |          | 
Indexes:
    "concur_appclass_ind" gist (i tsvector_ops (siglen='1000'), j tsvector_ops (siglen='500'))
    "concur_appclass_ind_2" gist (k tsvector_ops (siglen='300'), j)

DROP TABLE concur_appclass_tab;
-- Partitions
-- Create some partitioned tables
CREATE TABLE concur_reindex_part (c1 int, c2 int) PARTITION BY RANGE (c1);
CREATE TABLE concur_reindex_part_0 PARTITION OF concur_reindex_part
  FOR VALUES FROM (0) TO (10) PARTITION BY list (c2);
CREATE TABLE concur_reindex_part_0_1 PARTITION OF concur_reindex_part_0
  FOR VALUES IN (1);
CREATE TABLE concur_reindex_part_0_2 PARTITION OF concur_reindex_part_0
  FOR VALUES IN (2);
-- This partitioned table will have no partitions.
CREATE TABLE concur_reindex_part_10 PARTITION OF concur_reindex_part
  FOR VALUES FROM (10) TO (20) PARTITION BY list (c2);
-- Create some partitioned indexes
CREATE INDEX concur_reindex_part_index ON ONLY concur_reindex_part (c1);
CREATE INDEX concur_reindex_part_index_0 ON ONLY concur_reindex_part_0 (c1);
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_0;
-- This partitioned index will have no partitions.
CREATE INDEX concur_reindex_part_index_10 ON ONLY concur_reindex_part_10 (c1);
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_10;
CREATE INDEX concur_reindex_part_index_0_1 ON ONLY concur_reindex_part_0_1 (c1);
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_1;
CREATE INDEX concur_reindex_part_index_0_2 ON ONLY concur_reindex_part_0_2 (c1);
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

-- REINDEX should preserve dependencies of partition tree.
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_part'::regclass,
            'concur_reindex_part_0'::regclass,
            'concur_reindex_part_0_1'::regclass,
            'concur_reindex_part_0_2'::regclass,
            'concur_reindex_part_index'::regclass,
            'concur_reindex_part_index_0'::regclass,
            'concur_reindex_part_index_0_1'::regclass,
            'concur_reindex_part_index_0_2'::regclass)
  ORDER BY 1, 2;
                   obj                    |                   objref                   | deptype 
------------------------------------------+--------------------------------------------+---------
 column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
 column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
 index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
 index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
 index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
 index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
 index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
 index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
 index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
 index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
 table concur_reindex_part                | schema public                              | n
 table concur_reindex_part_0              | schema public                              | n
 table concur_reindex_part_0              | table concur_reindex_part                  | a
 table concur_reindex_part_0_1            | schema public                              | n
 table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
 table concur_reindex_part_0_2            | schema public                              | n
 table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
(19 rows)

REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1;
REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2;
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_part'::regclass,
            'concur_reindex_part_0'::regclass,
            'concur_reindex_part_0_1'::regclass,
            'concur_reindex_part_0_2'::regclass,
            'concur_reindex_part_index'::regclass,
            'concur_reindex_part_index_0'::regclass,
            'concur_reindex_part_index_0_1'::regclass,
            'concur_reindex_part_index_0_2'::regclass)
  ORDER BY 1, 2;
                   obj                    |                   objref                   | deptype 
------------------------------------------+--------------------------------------------+---------
 column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
 column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
 index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
 index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
 index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
 index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
 index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
 index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
 index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
 index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
 table concur_reindex_part                | schema public                              | n
 table concur_reindex_part_0              | schema public                              | n
 table concur_reindex_part_0              | table concur_reindex_part                  | a
 table concur_reindex_part_0_1            | schema public                              | n
 table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
 table concur_reindex_part_0_2            | schema public                              | n
 table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
(19 rows)

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

-- REINDEX for partitioned indexes
-- REINDEX TABLE fails for partitioned indexes
-- Top-most parent index
REINDEX TABLE concur_reindex_part_index; -- error
ERROR:  "concur_reindex_part_index" is not a table or materialized view
REINDEX TABLE CONCURRENTLY concur_reindex_part_index; -- error
ERROR:  "concur_reindex_part_index" is not a table or materialized view
-- Partitioned index with no leaves
REINDEX TABLE concur_reindex_part_index_10; -- error
ERROR:  "concur_reindex_part_index_10" is not a table or materialized view
REINDEX TABLE CONCURRENTLY concur_reindex_part_index_10; -- error
ERROR:  "concur_reindex_part_index_10" is not a table or materialized view
-- Cannot run in a transaction block
BEGIN;
REINDEX INDEX concur_reindex_part_index;
ERROR:  REINDEX INDEX cannot run inside a transaction block
CONTEXT:  while reindexing partitioned index "public.concur_reindex_part_index"
ROLLBACK;
-- Helper functions to track changes of relfilenodes in a partition tree.
-- Create a table tracking the relfilenode state.
CREATE OR REPLACE FUNCTION create_relfilenode_part(relname text, indname text)
  RETURNS VOID AS
  $func$
  BEGIN
  EXECUTE format('
    CREATE TABLE %I AS
      SELECT oid, relname, relfilenode, relkind, reltoastrelid
      FROM pg_class
      WHERE oid IN
         (SELECT relid FROM pg_partition_tree(''%I''));',
	 relname, indname);
  END
  $func$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION compare_relfilenode_part(tabname text)
  RETURNS TABLE (relname name, relkind "char", state text) AS
  $func$
  BEGIN
    RETURN QUERY EXECUTE
      format(
        'SELECT  b.relname,
                 b.relkind,
                 CASE WHEN a.relfilenode = b.relfilenode THEN ''relfilenode is unchanged''
                 ELSE ''relfilenode has changed'' END
           -- Do not join with OID here as CONCURRENTLY changes it.
           FROM %I b JOIN pg_class a ON b.relname = a.relname
           ORDER BY 1;', tabname);
  END
  $func$ LANGUAGE plpgsql;
--  Check that expected relfilenodes are changed, non-concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX INDEX concur_reindex_part_index;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
-- concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX INDEX CONCURRENTLY concur_reindex_part_index;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
-- REINDEX for partitioned tables
-- REINDEX INDEX fails for partitioned tables
-- Top-most parent
REINDEX INDEX concur_reindex_part; -- error
ERROR:  "concur_reindex_part" is not an index
REINDEX INDEX CONCURRENTLY concur_reindex_part; -- error
ERROR:  "concur_reindex_part" is not an index
-- Partitioned with no leaves
REINDEX INDEX concur_reindex_part_10; -- error
ERROR:  "concur_reindex_part_10" is not an index
REINDEX INDEX CONCURRENTLY concur_reindex_part_10; -- error
ERROR:  "concur_reindex_part_10" is not an index
-- Cannot run in a transaction block
BEGIN;
REINDEX TABLE concur_reindex_part;
ERROR:  REINDEX TABLE cannot run inside a transaction block
CONTEXT:  while reindexing partitioned table "public.concur_reindex_part"
ROLLBACK;
-- Check that expected relfilenodes are changed, non-concurrent case.
-- Note that the partition tree changes of the *indexes* need to be checked.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX TABLE concur_reindex_part;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
-- concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX TABLE CONCURRENTLY concur_reindex_part;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
DROP FUNCTION create_relfilenode_part;
DROP FUNCTION compare_relfilenode_part;
-- Cleanup of partition tree used for REINDEX test.
DROP TABLE concur_reindex_part;
-- Check errors
-- Cannot run inside a transaction block
BEGIN;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
REINDEX TABLE CONCURRENTLY pg_class; -- no catalog relation
ERROR:  cannot reindex system catalogs concurrently
REINDEX INDEX CONCURRENTLY pg_class_oid_index; -- no catalog index
ERROR:  cannot reindex system catalogs concurrently
-- These are the toast table and index of pg_authid.
REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260; -- no catalog toast table
ERROR:  cannot reindex system catalogs concurrently
REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index; -- no catalog toast index
ERROR:  cannot reindex system catalogs concurrently
REINDEX SYSTEM CONCURRENTLY postgres; -- not allowed for SYSTEM
ERROR:  cannot reindex system catalogs concurrently
REINDEX (CONCURRENTLY) SYSTEM postgres; -- ditto
ERROR:  cannot reindex system catalogs concurrently
REINDEX (CONCURRENTLY) SYSTEM;  -- ditto
ERROR:  cannot reindex system catalogs concurrently
-- Warns about catalog relations
REINDEX SCHEMA CONCURRENTLY pg_catalog;
WARNING:  cannot reindex system catalogs concurrently, skipping all
-- Not the current database
REINDEX DATABASE not_current_database;
ERROR:  can only reindex the currently open database
-- Check the relation status, there should not be invalid indexes
\d concur_reindex_tab
         Table "public.concur_reindex_tab"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           | not null | 
 c2     | text    |           |          | 
Indexes:
    "concur_reindex_ind1" PRIMARY KEY, btree (c1)
    "concur_reindex_ind2" btree (c2)
    "concur_reindex_ind3" UNIQUE, btree (abs(c1))
    "concur_reindex_ind4" btree (c1, c1, c2)
Referenced by:
    TABLE "concur_reindex_tab2" CONSTRAINT "concur_reindex_tab2_c1_fkey" FOREIGN KEY (c1) REFERENCES concur_reindex_tab(c1)

DROP MATERIALIZED VIEW concur_reindex_matview;
DROP TABLE concur_reindex_tab, concur_reindex_tab2, concur_reindex_tab3;
-- Check handling of invalid indexes
CREATE TABLE concur_reindex_tab4 (c1 int);
INSERT INTO concur_reindex_tab4 VALUES (1), (1), (2);
-- This trick creates an invalid index.
CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
ERROR:  could not create unique index "concur_reindex_ind5"
DETAIL:  Key (c1)=(1) is duplicated.
-- Reindexing concurrently this index fails with the same failure.
-- The extra index created is itself invalid, and can be dropped.
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
ERROR:  could not create unique index "concur_reindex_ind5_ccnew"
DETAIL:  Key (c1)=(1) is duplicated.
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 
Indexes:
    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
    "concur_reindex_ind5_ccnew" UNIQUE, btree (c1) INVALID

DROP INDEX concur_reindex_ind5_ccnew;
-- This makes the previous failure go away, so the index can become valid.
DELETE FROM concur_reindex_tab4 WHERE c1 = 1;
-- The invalid index is not processed when running REINDEX TABLE.
REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
WARNING:  skipping reindex of invalid index "public.concur_reindex_ind5"
HINT:  Use DROP INDEX or REINDEX INDEX.
NOTICE:  table "concur_reindex_tab4" has no indexes that can be reindexed concurrently
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 
Indexes:
    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID

-- But it is fixed with REINDEX INDEX.
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 
Indexes:
    "concur_reindex_ind5" UNIQUE, btree (c1)

DROP TABLE concur_reindex_tab4;
-- Check handling of indexes with expressions and predicates.  The
-- definitions of the rebuilt indexes should match the original
-- definitions.
CREATE TABLE concur_exprs_tab (c1 int , c2 boolean);
INSERT INTO concur_exprs_tab (c1, c2) VALUES (1369652450, FALSE),
  (414515746, TRUE),
  (897778963, FALSE);
CREATE UNIQUE INDEX concur_exprs_index_expr
  ON concur_exprs_tab ((c1::text COLLATE "C"));
CREATE UNIQUE INDEX concur_exprs_index_pred ON concur_exprs_tab (c1)
  WHERE (c1::text > 500000000::text COLLATE "C");
CREATE UNIQUE INDEX concur_exprs_index_pred_2
  ON concur_exprs_tab ((1 / c1))
  WHERE ('-H') >= (c2::TEXT) COLLATE "C";
ALTER INDEX concur_exprs_index_expr ALTER COLUMN 1 SET STATISTICS 100;
ANALYZE concur_exprs_tab;
SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
  'concur_exprs_index_expr'::regclass,
  'concur_exprs_index_pred'::regclass,
  'concur_exprs_index_pred_2'::regclass)
  GROUP BY starelid ORDER BY starelid::regclass::text;
        starelid         | count 
-------------------------+-------
 concur_exprs_index_expr |     1
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                                 pg_get_indexdef                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
(1 row)

REINDEX TABLE CONCURRENTLY concur_exprs_tab;
SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                                 pg_get_indexdef                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
(1 row)

-- ALTER TABLE recreates the indexes, which should keep their collations.
ALTER TABLE concur_exprs_tab ALTER c2 TYPE TEXT;
SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                             pg_get_indexdef                                                              
------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= (c2 COLLATE "C"))
(1 row)

-- Statistics should remain intact.
SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
  'concur_exprs_index_expr'::regclass,
  'concur_exprs_index_pred'::regclass,
  'concur_exprs_index_pred_2'::regclass)
  GROUP BY starelid ORDER BY starelid::regclass::text;
        starelid         | count 
-------------------------+-------
 concur_exprs_index_expr |     1
(1 row)

-- attstattarget should remain intact
SELECT attrelid::regclass, attnum, attstattarget
  FROM pg_attribute WHERE attrelid IN (
    'concur_exprs_index_expr'::regclass,
    'concur_exprs_index_pred'::regclass,
    'concur_exprs_index_pred_2'::regclass)
  ORDER BY attrelid::regclass::text, attnum;
         attrelid          | attnum | attstattarget 
---------------------------+--------+---------------
 concur_exprs_index_expr   |      1 |           100
 concur_exprs_index_pred   |      1 |              
 concur_exprs_index_pred_2 |      1 |              
(3 rows)

DROP TABLE concur_exprs_tab;
-- Temporary tables and on-commit actions, where CONCURRENTLY is ignored.
-- ON COMMIT PRESERVE ROWS, the default.
CREATE TEMP TABLE concur_temp_tab_1 (c1 int, c2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp_tab_1 VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX concur_temp_ind_1 ON concur_temp_tab_1(c2);
REINDEX TABLE CONCURRENTLY concur_temp_tab_1;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
-- Still fails in transaction blocks
BEGIN;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- ON COMMIT DELETE ROWS
CREATE TEMP TABLE concur_temp_tab_2 (c1 int, c2 text)
  ON COMMIT DELETE ROWS;
CREATE INDEX concur_temp_ind_2 ON concur_temp_tab_2(c2);
REINDEX TABLE CONCURRENTLY concur_temp_tab_2;
REINDEX INDEX CONCURRENTLY concur_temp_ind_2;
-- ON COMMIT DROP
BEGIN;
CREATE TEMP TABLE concur_temp_tab_3 (c1 int, c2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp_tab_3 VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX concur_temp_ind_3 ON concur_temp_tab_3(c2);
-- Fails when running in a transaction
REINDEX INDEX CONCURRENTLY concur_temp_ind_3;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- REINDEX SCHEMA processes all temporary relations
CREATE TABLE reindex_temp_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
  FROM pg_class
  WHERE relname IN ('concur_temp_ind_1', 'concur_temp_ind_2');
SELECT pg_my_temp_schema()::regnamespace as temp_schema_name \gset
REINDEX SCHEMA CONCURRENTLY :temp_schema_name;
SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_temp_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
      relname      | relkind |          case           
-------------------+---------+-------------------------
 concur_temp_ind_1 | i       | relfilenode has changed
 concur_temp_ind_2 | i       | relfilenode has changed
(2 rows)

DROP TABLE concur_temp_tab_1, concur_temp_tab_2, reindex_temp_before;
--
-- REINDEX SCHEMA
--
REINDEX SCHEMA schema_to_reindex; -- failure, schema does not exist
ERROR:  schema "schema_to_reindex" does not exist
CREATE SCHEMA schema_to_reindex;
SET search_path = 'schema_to_reindex';
CREATE TABLE table1(col1 SERIAL PRIMARY KEY);
INSERT INTO table1 SELECT generate_series(1,400);
CREATE TABLE table2(col1 SERIAL PRIMARY KEY, col2 TEXT NOT NULL);
INSERT INTO table2 SELECT generate_series(1,400), 'abc';
CREATE INDEX ON table2(col2);
CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
CREATE INDEX ON matview(col1);
CREATE VIEW view AS SELECT col2 FROM table2;
CREATE TABLE reindex_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelid
FROM pg_class WHERE oid IN
	(SELECT reltoastrelid FROM reindex_before WHERE reltoastrelid > 0);
INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE_index', relfilenode, relkind, reltoastrelid
FROM pg_class where oid in
	(select indexrelid from pg_index where indrelid in
		(select reltoastrelid from reindex_before where reltoastrelid > 0));
REINDEX SCHEMA schema_to_reindex;
CREATE TABLE reindex_after AS SELECT oid, relname, relfilenode, relkind
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
       relname        | relkind |           case           
----------------------+---------+--------------------------
 matview              | m       | relfilenode is unchanged
 matview_col1_idx     | i       | relfilenode has changed
 pg_toast_TABLE       | t       | relfilenode is unchanged
 pg_toast_TABLE_index | i       | relfilenode has changed
 table1               | r       | relfilenode is unchanged
 table1_col1_seq      | S       | relfilenode is unchanged
 table1_pkey          | i       | relfilenode has changed
 table2               | r       | relfilenode is unchanged
 table2_col1_seq      | S       | relfilenode is unchanged
 table2_col2_idx      | i       | relfilenode has changed
 table2_pkey          | i       | relfilenode has changed
 view                 | v       | relfilenode is unchanged
(12 rows)

REINDEX SCHEMA schema_to_reindex;
BEGIN;
REINDEX SCHEMA schema_to_reindex; -- failure, cannot run in a transaction
ERROR:  REINDEX SCHEMA cannot run inside a transaction block
END;
-- concurrently
REINDEX SCHEMA CONCURRENTLY schema_to_reindex;
-- Failure for unauthorized user
CREATE ROLE regress_reindexuser NOLOGIN;
SET SESSION ROLE regress_reindexuser;
REINDEX SCHEMA schema_to_reindex;
ERROR:  must be owner of schema schema_to_reindex
-- Permission failures with toast tables and indexes (pg_authid here)
RESET ROLE;
GRANT USAGE ON SCHEMA pg_toast TO regress_reindexuser;
SET SESSION ROLE regress_reindexuser;
REINDEX TABLE pg_toast.pg_toast_1260;
ERROR:  permission denied for table pg_toast_1260
REINDEX INDEX pg_toast.pg_toast_1260_index;
ERROR:  permission denied for index pg_toast_1260_index
-- Clean up
RESET ROLE;
REVOKE USAGE ON SCHEMA pg_toast FROM regress_reindexuser;
DROP ROLE regress_reindexuser;
DROP SCHEMA schema_to_reindex CASCADE;
NOTICE:  drop cascades to 6 other objects
DETAIL:  drop cascades to table table1
drop cascades to table table2
drop cascades to materialized view matview
drop cascades to view view
drop cascades to table reindex_before
drop cascades to table reindex_after
-- END setup from create_index 
-- START setup from  geometry 
--
-- GEOMETRY
--
-- Back off displayed precision a little bit to reduce platform-to-platform
-- variation in results.
SET extra_float_digits TO -3;
--
-- Points
--
SELECT center(f1) AS center
   FROM BOX_TBL;
ERROR:  relation "box_tbl" does not exist
LINE 2:    FROM BOX_TBL;
                ^
SELECT (@@ f1) AS center
   FROM BOX_TBL;
ERROR:  relation "box_tbl" does not exist
LINE 2:    FROM BOX_TBL;
                ^
SELECT point(f1) AS center
   FROM CIRCLE_TBL;
ERROR:  relation "circle_tbl" does not exist
LINE 2:    FROM CIRCLE_TBL;
                ^
SELECT (@@ f1) AS center
   FROM CIRCLE_TBL;
ERROR:  relation "circle_tbl" does not exist
LINE 2:    FROM CIRCLE_TBL;
                ^
SELECT (@@ f1) AS center
   FROM POLYGON_TBL
   WHERE (# f1) > 2;
ERROR:  relation "polygon_tbl" does not exist
LINE 2:    FROM POLYGON_TBL
                ^
-- "is horizontal" function
SELECT p1.f1
   FROM POINT_TBL p1
   WHERE ishorizontal(p1.f1, point '(0,0)');
        f1        
------------------
 (0,0)
 (-10,0)
 (1e-300,-1e-300)
(3 rows)

-- "is horizontal" operator
SELECT p1.f1
   FROM POINT_TBL p1
   WHERE p1.f1 ?- point '(0,0)';
        f1        
------------------
 (0,0)
 (-10,0)
 (1e-300,-1e-300)
(3 rows)

-- "is vertical" function
SELECT p1.f1
   FROM POINT_TBL p1
   WHERE isvertical(p1.f1, point '(5.1,34.5)');
     f1     
------------
 (5.1,34.5)
(1 row)

-- "is vertical" operator
SELECT p1.f1
   FROM POINT_TBL p1
   WHERE p1.f1 ?| point '(5.1,34.5)';
     f1     
------------
 (5.1,34.5)
(1 row)

-- Slope
SELECT p1.f1, p2.f1, slope(p1.f1, p2.f1) FROM POINT_TBL p1, POINT_TBL p2;
        f1         |        f1         |     slope      
-------------------+-------------------+----------------
 (0,0)             | (0,0)             |       Infinity
 (0,0)             | (-10,0)           |              0
 (0,0)             | (-3,4)            | -1.33333333333
 (0,0)             | (5.1,34.5)        |  6.76470588235
 (0,0)             | (-5,-12)          |            2.4
 (0,0)             | (1e-300,-1e-300)  |       Infinity
 (0,0)             | (1e+300,Infinity) |       Infinity
 (0,0)             | (Infinity,1e+300) |              0
 (0,0)             | (NaN,NaN)         |            NaN
 (0,0)             | (10,10)           |              1
 (0,0)             |                   |               
 (-10,0)           | (0,0)             |              0
 (-10,0)           | (-10,0)           |       Infinity
 (-10,0)           | (-3,4)            | 0.571428571429
 (-10,0)           | (5.1,34.5)        |  2.28476821192
 (-10,0)           | (-5,-12)          |           -2.4
 (-10,0)           | (1e-300,-1e-300)  |              0
 (-10,0)           | (1e+300,Infinity) |       Infinity
 (-10,0)           | (Infinity,1e+300) |              0
 (-10,0)           | (NaN,NaN)         |            NaN
 (-10,0)           | (10,10)           |            0.5
 (-10,0)           |                   |               
 (-3,4)            | (0,0)             | -1.33333333333
 (-3,4)            | (-10,0)           | 0.571428571429
 (-3,4)            | (-3,4)            |       Infinity
 (-3,4)            | (5.1,34.5)        |  3.76543209877
 (-3,4)            | (-5,-12)          |              8
 (-3,4)            | (1e-300,-1e-300)  | -1.33333333333
 (-3,4)            | (1e+300,Infinity) |       Infinity
 (-3,4)            | (Infinity,1e+300) |              0
 (-3,4)            | (NaN,NaN)         |            NaN
 (-3,4)            | (10,10)           | 0.461538461538
 (-3,4)            |                   |               
 (5.1,34.5)        | (0,0)             |  6.76470588235
 (5.1,34.5)        | (-10,0)           |  2.28476821192
 (5.1,34.5)        | (-3,4)            |  3.76543209877
 (5.1,34.5)        | (5.1,34.5)        |       Infinity
 (5.1,34.5)        | (-5,-12)          |  4.60396039604
 (5.1,34.5)        | (1e-300,-1e-300)  |  6.76470588235
 (5.1,34.5)        | (1e+300,Infinity) |       Infinity
 (5.1,34.5)        | (Infinity,1e+300) |              0
 (5.1,34.5)        | (NaN,NaN)         |            NaN
 (5.1,34.5)        | (10,10)           |             -5
 (5.1,34.5)        |                   |               
 (-5,-12)          | (0,0)             |            2.4
 (-5,-12)          | (-10,0)           |           -2.4
 (-5,-12)          | (-3,4)            |              8
 (-5,-12)          | (5.1,34.5)        |  4.60396039604
 (-5,-12)          | (-5,-12)          |       Infinity
 (-5,-12)          | (1e-300,-1e-300)  |            2.4
 (-5,-12)          | (1e+300,Infinity) |       Infinity
 (-5,-12)          | (Infinity,1e+300) |              0
 (-5,-12)          | (NaN,NaN)         |            NaN
 (-5,-12)          | (10,10)           |  1.46666666667
 (-5,-12)          |                   |               
 (1e-300,-1e-300)  | (0,0)             |       Infinity
 (1e-300,-1e-300)  | (-10,0)           |              0
 (1e-300,-1e-300)  | (-3,4)            | -1.33333333333
 (1e-300,-1e-300)  | (5.1,34.5)        |  6.76470588235
 (1e-300,-1e-300)  | (-5,-12)          |            2.4
 (1e-300,-1e-300)  | (1e-300,-1e-300)  |       Infinity
 (1e-300,-1e-300)  | (1e+300,Infinity) |       Infinity
 (1e-300,-1e-300)  | (Infinity,1e+300) |              0
 (1e-300,-1e-300)  | (NaN,NaN)         |            NaN
 (1e-300,-1e-300)  | (10,10)           |              1
 (1e-300,-1e-300)  |                   |               
 (1e+300,Infinity) | (0,0)             |       Infinity
 (1e+300,Infinity) | (-10,0)           |       Infinity
 (1e+300,Infinity) | (-3,4)            |       Infinity
 (1e+300,Infinity) | (5.1,34.5)        |       Infinity
 (1e+300,Infinity) | (-5,-12)          |       Infinity
 (1e+300,Infinity) | (1e-300,-1e-300)  |       Infinity
 (1e+300,Infinity) | (1e+300,Infinity) |       Infinity
 (1e+300,Infinity) | (Infinity,1e+300) |            NaN
 (1e+300,Infinity) | (NaN,NaN)         |            NaN
 (1e+300,Infinity) | (10,10)           |       Infinity
 (1e+300,Infinity) |                   |               
 (Infinity,1e+300) | (0,0)             |              0
 (Infinity,1e+300) | (-10,0)           |              0
 (Infinity,1e+300) | (-3,4)            |              0
 (Infinity,1e+300) | (5.1,34.5)        |              0
 (Infinity,1e+300) | (-5,-12)          |              0
 (Infinity,1e+300) | (1e-300,-1e-300)  |              0
 (Infinity,1e+300) | (1e+300,Infinity) |            NaN
 (Infinity,1e+300) | (Infinity,1e+300) |       Infinity
 (Infinity,1e+300) | (NaN,NaN)         |            NaN
 (Infinity,1e+300) | (10,10)           |              0
 (Infinity,1e+300) |                   |               
 (NaN,NaN)         | (0,0)             |            NaN
 (NaN,NaN)         | (-10,0)           |            NaN
 (NaN,NaN)         | (-3,4)            |            NaN
 (NaN,NaN)         | (5.1,34.5)        |            NaN
 (NaN,NaN)         | (-5,-12)          |            NaN
 (NaN,NaN)         | (1e-300,-1e-300)  |            NaN
 (NaN,NaN)         | (1e+300,Infinity) |            NaN
 (NaN,NaN)         | (Infinity,1e+300) |            NaN
 (NaN,NaN)         | (NaN,NaN)         |            NaN
 (NaN,NaN)         | (10,10)           |            NaN
 (NaN,NaN)         |                   |               
 (10,10)           | (0,0)             |              1
 (10,10)           | (-10,0)           |            0.5
 (10,10)           | (-3,4)            | 0.461538461538
 (10,10)           | (5.1,34.5)        |             -5
 (10,10)           | (-5,-12)          |  1.46666666667
 (10,10)           | (1e-300,-1e-300)  |              1
 (10,10)           | (1e+300,Infinity) |       Infinity
 (10,10)           | (Infinity,1e+300) |              0
 (10,10)           | (NaN,NaN)         |            NaN
 (10,10)           | (10,10)           |       Infinity
 (10,10)           |                   |               
                   | (0,0)             |               
                   | (-10,0)           |               
                   | (-3,4)            |               
                   | (5.1,34.5)        |               
                   | (-5,-12)          |               
                   | (1e-300,-1e-300)  |               
                   | (1e+300,Infinity) |               
                   | (Infinity,1e+300) |               
                   | (NaN,NaN)         |               
                   | (10,10)           |               
                   |                   |               
(121 rows)

-- Add point
SELECT p1.f1, p2.f1, p1.f1 + p2.f1 FROM POINT_TBL p1, POINT_TBL p2;
        f1         |        f1         |      ?column?       
-------------------+-------------------+---------------------
 (0,0)             | (0,0)             | (0,0)
 (0,0)             | (-10,0)           | (-10,0)
 (0,0)             | (-3,4)            | (-3,4)
 (0,0)             | (5.1,34.5)        | (5.1,34.5)
 (0,0)             | (-5,-12)          | (-5,-12)
 (0,0)             | (1e-300,-1e-300)  | (1e-300,-1e-300)
 (0,0)             | (1e+300,Infinity) | (1e+300,Infinity)
 (0,0)             | (Infinity,1e+300) | (Infinity,1e+300)
 (0,0)             | (NaN,NaN)         | (NaN,NaN)
 (0,0)             | (10,10)           | (10,10)
 (0,0)             |                   | 
 (-10,0)           | (0,0)             | (-10,0)
 (-10,0)           | (-10,0)           | (-20,0)
 (-10,0)           | (-3,4)            | (-13,4)
 (-10,0)           | (5.1,34.5)        | (-4.9,34.5)
 (-10,0)           | (-5,-12)          | (-15,-12)
 (-10,0)           | (1e-300,-1e-300)  | (-10,-1e-300)
 (-10,0)           | (1e+300,Infinity) | (1e+300,Infinity)
 (-10,0)           | (Infinity,1e+300) | (Infinity,1e+300)
 (-10,0)           | (NaN,NaN)         | (NaN,NaN)
 (-10,0)           | (10,10)           | (0,10)
 (-10,0)           |                   | 
 (-3,4)            | (0,0)             | (-3,4)
 (-3,4)            | (-10,0)           | (-13,4)
 (-3,4)            | (-3,4)            | (-6,8)
 (-3,4)            | (5.1,34.5)        | (2.1,38.5)
 (-3,4)            | (-5,-12)          | (-8,-8)
 (-3,4)            | (1e-300,-1e-300)  | (-3,4)
 (-3,4)            | (1e+300,Infinity) | (1e+300,Infinity)
 (-3,4)            | (Infinity,1e+300) | (Infinity,1e+300)
 (-3,4)            | (NaN,NaN)         | (NaN,NaN)
 (-3,4)            | (10,10)           | (7,14)
 (-3,4)            |                   | 
 (5.1,34.5)        | (0,0)             | (5.1,34.5)
 (5.1,34.5)        | (-10,0)           | (-4.9,34.5)
 (5.1,34.5)        | (-3,4)            | (2.1,38.5)
 (5.1,34.5)        | (5.1,34.5)        | (10.2,69)
 (5.1,34.5)        | (-5,-12)          | (0.1,22.5)
 (5.1,34.5)        | (1e-300,-1e-300)  | (5.1,34.5)
 (5.1,34.5)        | (1e+300,Infinity) | (1e+300,Infinity)
 (5.1,34.5)        | (Infinity,1e+300) | (Infinity,1e+300)
 (5.1,34.5)        | (NaN,NaN)         | (NaN,NaN)
 (5.1,34.5)        | (10,10)           | (15.1,44.5)
 (5.1,34.5)        |                   | 
 (-5,-12)          | (0,0)             | (-5,-12)
 (-5,-12)          | (-10,0)           | (-15,-12)
 (-5,-12)          | (-3,4)            | (-8,-8)
 (-5,-12)          | (5.1,34.5)        | (0.1,22.5)
 (-5,-12)          | (-5,-12)          | (-10,-24)
 (-5,-12)          | (1e-300,-1e-300)  | (-5,-12)
 (-5,-12)          | (1e+300,Infinity) | (1e+300,Infinity)
 (-5,-12)          | (Infinity,1e+300) | (Infinity,1e+300)
 (-5,-12)          | (NaN,NaN)         | (NaN,NaN)
 (-5,-12)          | (10,10)           | (5,-2)
 (-5,-12)          |                   | 
 (1e-300,-1e-300)  | (0,0)             | (1e-300,-1e-300)
 (1e-300,-1e-300)  | (-10,0)           | (-10,-1e-300)
 (1e-300,-1e-300)  | (-3,4)            | (-3,4)
 (1e-300,-1e-300)  | (5.1,34.5)        | (5.1,34.5)
 (1e-300,-1e-300)  | (-5,-12)          | (-5,-12)
 (1e-300,-1e-300)  | (1e-300,-1e-300)  | (2e-300,-2e-300)
 (1e-300,-1e-300)  | (1e+300,Infinity) | (1e+300,Infinity)
 (1e-300,-1e-300)  | (Infinity,1e+300) | (Infinity,1e+300)
 (1e-300,-1e-300)  | (NaN,NaN)         | (NaN,NaN)
 (1e-300,-1e-300)  | (10,10)           | (10,10)
 (1e-300,-1e-300)  |                   | 
 (1e+300,Infinity) | (0,0)             | (1e+300,Infinity)
 (1e+300,Infinity) | (-10,0)           | (1e+300,Infinity)
 (1e+300,Infinity) | (-3,4)            | (1e+300,Infinity)
 (1e+300,Infinity) | (5.1,34.5)        | (1e+300,Infinity)
 (1e+300,Infinity) | (-5,-12)          | (1e+300,Infinity)
 (1e+300,Infinity) | (1e-300,-1e-300)  | (1e+300,Infinity)
 (1e+300,Infinity) | (1e+300,Infinity) | (2e+300,Infinity)
 (1e+300,Infinity) | (Infinity,1e+300) | (Infinity,Infinity)
 (1e+300,Infinity) | (NaN,NaN)         | (NaN,NaN)
 (1e+300,Infinity) | (10,10)           | (1e+300,Infinity)
 (1e+300,Infinity) |                   | 
 (Infinity,1e+300) | (0,0)             | (Infinity,1e+300)
 (Infinity,1e+300) | (-10,0)           | (Infinity,1e+300)
 (Infinity,1e+300) | (-3,4)            | (Infinity,1e+300)
 (Infinity,1e+300) | (5.1,34.5)        | (Infinity,1e+300)
 (Infinity,1e+300) | (-5,-12)          | (Infinity,1e+300)
 (Infinity,1e+300) | (1e-300,-1e-300)  | (Infinity,1e+300)
 (Infinity,1e+300) | (1e+300,Infinity) | (Infinity,Infinity)
 (Infinity,1e+300) | (Infinity,1e+300) | (Infinity,2e+300)
 (Infinity,1e+300) | (NaN,NaN)         | (NaN,NaN)
 (Infinity,1e+300) | (10,10)           | (Infinity,1e+300)
 (Infinity,1e+300) |                   | 
 (NaN,NaN)         | (0,0)             | (NaN,NaN)
 (NaN,NaN)         | (-10,0)           | (NaN,NaN)
 (NaN,NaN)         | (-3,4)            | (NaN,NaN)
 (NaN,NaN)         | (5.1,34.5)        | (NaN,NaN)
 (NaN,NaN)         | (-5,-12)          | (NaN,NaN)
 (NaN,NaN)         | (1e-300,-1e-300)  | (NaN,NaN)
 (NaN,NaN)         | (1e+300,Infinity) | (NaN,NaN)
 (NaN,NaN)         | (Infinity,1e+300) | (NaN,NaN)
 (NaN,NaN)         | (NaN,NaN)         | (NaN,NaN)
 (NaN,NaN)         | (10,10)           | (NaN,NaN)
 (NaN,NaN)         |                   | 
 (10,10)           | (0,0)             | (10,10)
 (10,10)           | (-10,0)           | (0,10)
 (10,10)           | (-3,4)            | (7,14)
 (10,10)           | (5.1,34.5)        | (15.1,44.5)
 (10,10)           | (-5,-12)          | (5,-2)
 (10,10)           | (1e-300,-1e-300)  | (10,10)
 (10,10)           | (1e+300,Infinity) | (1e+300,Infinity)
 (10,10)           | (Infinity,1e+300) | (Infinity,1e+300)
 (10,10)           | (NaN,NaN)         | (NaN,NaN)
 (10,10)           | (10,10)           | (20,20)
 (10,10)           |                   | 
                   | (0,0)             | 
                   | (-10,0)           | 
                   | (-3,4)            | 
                   | (5.1,34.5)        | 
                   | (-5,-12)          | 
                   | (1e-300,-1e-300)  | 
                   | (1e+300,Infinity) | 
                   | (Infinity,1e+300) | 
                   | (NaN,NaN)         | 
                   | (10,10)           | 
                   |                   | 
(121 rows)

-- Subtract point
SELECT p1.f1, p2.f1, p1.f1 - p2.f1 FROM POINT_TBL p1, POINT_TBL p2;
        f1         |        f1         |       ?column?       
-------------------+-------------------+----------------------
 (0,0)             | (0,0)             | (0,0)
 (0,0)             | (-10,0)           | (10,0)
 (0,0)             | (-3,4)            | (3,-4)
 (0,0)             | (5.1,34.5)        | (-5.1,-34.5)
 (0,0)             | (-5,-12)          | (5,12)
 (0,0)             | (1e-300,-1e-300)  | (-1e-300,1e-300)
 (0,0)             | (1e+300,Infinity) | (-1e+300,-Infinity)
 (0,0)             | (Infinity,1e+300) | (-Infinity,-1e+300)
 (0,0)             | (NaN,NaN)         | (NaN,NaN)
 (0,0)             | (10,10)           | (-10,-10)
 (0,0)             |                   | 
 (-10,0)           | (0,0)             | (-10,0)
 (-10,0)           | (-10,0)           | (0,0)
 (-10,0)           | (-3,4)            | (-7,-4)
 (-10,0)           | (5.1,34.5)        | (-15.1,-34.5)
 (-10,0)           | (-5,-12)          | (-5,12)
 (-10,0)           | (1e-300,-1e-300)  | (-10,1e-300)
 (-10,0)           | (1e+300,Infinity) | (-1e+300,-Infinity)
 (-10,0)           | (Infinity,1e+300) | (-Infinity,-1e+300)
 (-10,0)           | (NaN,NaN)         | (NaN,NaN)
 (-10,0)           | (10,10)           | (-20,-10)
 (-10,0)           |                   | 
 (-3,4)            | (0,0)             | (-3,4)
 (-3,4)            | (-10,0)           | (7,4)
 (-3,4)            | (-3,4)            | (0,0)
 (-3,4)            | (5.1,34.5)        | (-8.1,-30.5)
 (-3,4)            | (-5,-12)          | (2,16)
 (-3,4)            | (1e-300,-1e-300)  | (-3,4)
 (-3,4)            | (1e+300,Infinity) | (-1e+300,-Infinity)
 (-3,4)            | (Infinity,1e+300) | (-Infinity,-1e+300)
 (-3,4)            | (NaN,NaN)         | (NaN,NaN)
 (-3,4)            | (10,10)           | (-13,-6)
 (-3,4)            |                   | 
 (5.1,34.5)        | (0,0)             | (5.1,34.5)
 (5.1,34.5)        | (-10,0)           | (15.1,34.5)
 (5.1,34.5)        | (-3,4)            | (8.1,30.5)
 (5.1,34.5)        | (5.1,34.5)        | (0,0)
 (5.1,34.5)        | (-5,-12)          | (10.1,46.5)
 (5.1,34.5)        | (1e-300,-1e-300)  | (5.1,34.5)
 (5.1,34.5)        | (1e+300,Infinity) | (-1e+300,-Infinity)
 (5.1,34.5)        | (Infinity,1e+300) | (-Infinity,-1e+300)
 (5.1,34.5)        | (NaN,NaN)         | (NaN,NaN)
 (5.1,34.5)        | (10,10)           | (-4.9,24.5)
 (5.1,34.5)        |                   | 
 (-5,-12)          | (0,0)             | (-5,-12)
 (-5,-12)          | (-10,0)           | (5,-12)
 (-5,-12)          | (-3,4)            | (-2,-16)
 (-5,-12)          | (5.1,34.5)        | (-10.1,-46.5)
 (-5,-12)          | (-5,-12)          | (0,0)
 (-5,-12)          | (1e-300,-1e-300)  | (-5,-12)
 (-5,-12)          | (1e+300,Infinity) | (-1e+300,-Infinity)
 (-5,-12)          | (Infinity,1e+300) | (-Infinity,-1e+300)
 (-5,-12)          | (NaN,NaN)         | (NaN,NaN)
 (-5,-12)          | (10,10)           | (-15,-22)
 (-5,-12)          |                   | 
 (1e-300,-1e-300)  | (0,0)             | (1e-300,-1e-300)
 (1e-300,-1e-300)  | (-10,0)           | (10,-1e-300)
 (1e-300,-1e-300)  | (-3,4)            | (3,-4)
 (1e-300,-1e-300)  | (5.1,34.5)        | (-5.1,-34.5)
 (1e-300,-1e-300)  | (-5,-12)          | (5,12)
 (1e-300,-1e-300)  | (1e-300,-1e-300)  | (0,0)
 (1e-300,-1e-300)  | (1e+300,Infinity) | (-1e+300,-Infinity)
 (1e-300,-1e-300)  | (Infinity,1e+300) | (-Infinity,-1e+300)
 (1e-300,-1e-300)  | (NaN,NaN)         | (NaN,NaN)
 (1e-300,-1e-300)  | (10,10)           | (-10,-10)
 (1e-300,-1e-300)  |                   | 
 (1e+300,Infinity) | (0,0)             | (1e+300,Infinity)
 (1e+300,Infinity) | (-10,0)           | (1e+300,Infinity)
 (1e+300,Infinity) | (-3,4)            | (1e+300,Infinity)
 (1e+300,Infinity) | (5.1,34.5)        | (1e+300,Infinity)
 (1e+300,Infinity) | (-5,-12)          | (1e+300,Infinity)
 (1e+300,Infinity) | (1e-300,-1e-300)  | (1e+300,Infinity)
 (1e+300,Infinity) | (1e+300,Infinity) | (0,NaN)
 (1e+300,Infinity) | (Infinity,1e+300) | (-Infinity,Infinity)
 (1e+300,Infinity) | (NaN,NaN)         | (NaN,NaN)
 (1e+300,Infinity) | (10,10)           | (1e+300,Infinity)
 (1e+300,Infinity) |                   | 
 (Infinity,1e+300) | (0,0)             | (Infinity,1e+300)
 (Infinity,1e+300) | (-10,0)           | (Infinity,1e+300)
 (Infinity,1e+300) | (-3,4)            | (Infinity,1e+300)
 (Infinity,1e+300) | (5.1,34.5)        | (Infinity,1e+300)
 (Infinity,1e+300) | (-5,-12)          | (Infinity,1e+300)
 (Infinity,1e+300) | (1e-300,-1e-300)  | (Infinity,1e+300)
 (Infinity,1e+300) | (1e+300,Infinity) | (Infinity,-Infinity)
 (Infinity,1e+300) | (Infinity,1e+300) | (NaN,0)
 (Infinity,1e+300) | (NaN,NaN)         | (NaN,NaN)
 (Infinity,1e+300) | (10,10)           | (Infinity,1e+300)
 (Infinity,1e+300) |                   | 
 (NaN,NaN)         | (0,0)             | (NaN,NaN)
 (NaN,NaN)         | (-10,0)           | (NaN,NaN)
 (NaN,NaN)         | (-3,4)            | (NaN,NaN)
 (NaN,NaN)         | (5.1,34.5)        | (NaN,NaN)
 (NaN,NaN)         | (-5,-12)          | (NaN,NaN)
 (NaN,NaN)         | (1e-300,-1e-300)  | (NaN,NaN)
 (NaN,NaN)         | (1e+300,Infinity) | (NaN,NaN)
 (NaN,NaN)         | (Infinity,1e+300) | (NaN,NaN)
 (NaN,NaN)         | (NaN,NaN)         | (NaN,NaN)
 (NaN,NaN)         | (10,10)           | (NaN,NaN)
 (NaN,NaN)         |                   | 
 (10,10)           | (0,0)             | (10,10)
 (10,10)           | (-10,0)           | (20,10)
 (10,10)           | (-3,4)            | (13,6)
 (10,10)           | (5.1,34.5)        | (4.9,-24.5)
 (10,10)           | (-5,-12)          | (15,22)
 (10,10)           | (1e-300,-1e-300)  | (10,10)
 (10,10)           | (1e+300,Infinity) | (-1e+300,-Infinity)
 (10,10)           | (Infinity,1e+300) | (-Infinity,-1e+300)
 (10,10)           | (NaN,NaN)         | (NaN,NaN)
 (10,10)           | (10,10)           | (0,0)
 (10,10)           |                   | 
                   | (0,0)             | 
                   | (-10,0)           | 
                   | (-3,4)            | 
                   | (5.1,34.5)        | 
                   | (-5,-12)          | 
                   | (1e-300,-1e-300)  | 
                   | (1e+300,Infinity) | 
                   | (Infinity,1e+300) | 
                   | (NaN,NaN)         | 
                   | (10,10)           | 
                   |                   | 
(121 rows)

-- Multiply with point
SELECT p1.f1, p2.f1, p1.f1 * p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p1.f1[0] BETWEEN 1 AND 1000;
     f1     |        f1         |       ?column?        
------------+-------------------+-----------------------
 (5.1,34.5) | (0,0)             | (0,0)
 (5.1,34.5) | (-10,0)           | (-51,-345)
 (5.1,34.5) | (-3,4)            | (-153.3,-83.1)
 (5.1,34.5) | (5.1,34.5)        | (-1164.24,351.9)
 (5.1,34.5) | (-5,-12)          | (388.5,-233.7)
 (5.1,34.5) | (1e-300,-1e-300)  | (3.96e-299,2.94e-299)
 (5.1,34.5) | (1e+300,Infinity) | (-Infinity,Infinity)
 (5.1,34.5) | (Infinity,1e+300) | (Infinity,Infinity)
 (5.1,34.5) | (NaN,NaN)         | (NaN,NaN)
 (5.1,34.5) | (10,10)           | (-294,396)
 (5.1,34.5) |                   | 
 (10,10)    | (0,0)             | (0,0)
 (10,10)    | (-10,0)           | (-100,-100)
 (10,10)    | (-3,4)            | (-70,10)
 (10,10)    | (5.1,34.5)        | (-294,396)
 (10,10)    | (-5,-12)          | (70,-170)
 (10,10)    | (1e-300,-1e-300)  | (2e-299,0)
 (10,10)    | (1e+300,Infinity) | (-Infinity,Infinity)
 (10,10)    | (Infinity,1e+300) | (Infinity,Infinity)
 (10,10)    | (NaN,NaN)         | (NaN,NaN)
 (10,10)    | (10,10)           | (0,200)
 (10,10)    |                   | 
(22 rows)

-- Underflow error
SELECT p1.f1, p2.f1, p1.f1 * p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p1.f1[0] < 1;
ERROR:  value out of range: underflow
-- Divide by point
SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1[0] BETWEEN 1 AND 1000;
        f1         |     f1     |                 ?column?                  
-------------------+------------+-------------------------------------------
 (0,0)             | (5.1,34.5) | (0,0)
 (-10,0)           | (5.1,34.5) | (-0.0419318237877,0.283656455034)
 (-3,4)            | (5.1,34.5) | (0.100883034877,0.101869666025)
 (5.1,34.5)        | (5.1,34.5) | (1,0)
 (-5,-12)          | (5.1,34.5) | (-0.361353657935,0.0915100389719)
 (1e-300,-1e-300)  | (5.1,34.5) | (-2.41724631247e-302,-3.25588278822e-302)
 (1e+300,Infinity) | (5.1,34.5) | (Infinity,Infinity)
 (Infinity,1e+300) | (5.1,34.5) | (Infinity,-Infinity)
 (NaN,NaN)         | (5.1,34.5) | (NaN,NaN)
 (10,10)           | (5.1,34.5) | (0.325588278822,-0.241724631247)
                   | (5.1,34.5) | 
 (0,0)             | (10,10)    | (0,0)
 (-10,0)           | (10,10)    | (-0.5,0.5)
 (-3,4)            | (10,10)    | (0.05,0.35)
 (5.1,34.5)        | (10,10)    | (1.98,1.47)
 (-5,-12)          | (10,10)    | (-0.85,-0.35)
 (1e-300,-1e-300)  | (10,10)    | (0,-1e-301)
 (1e+300,Infinity) | (10,10)    | (Infinity,Infinity)
 (Infinity,1e+300) | (10,10)    | (Infinity,-Infinity)
 (NaN,NaN)         | (10,10)    | (NaN,NaN)
 (10,10)           | (10,10)    | (1,0)
                   | (10,10)    | 
(22 rows)

-- Overflow error
SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1[0] > 1000;
ERROR:  value out of range: overflow
-- Division by 0 error
SELECT p1.f1, p2.f1, p1.f1 / p2.f1 FROM POINT_TBL p1, POINT_TBL p2 WHERE p2.f1 ~= '(0,0)'::point;
ERROR:  division by zero
-- Distance to line
SELECT p.f1, l.s, p.f1 <-> l.s AS dist_pl, l.s <-> p.f1 AS dist_lp FROM POINT_TBL p, LINE_TBL l;
ERROR:  relation "line_tbl" does not exist
LINE 1: ...ist_pl, l.s <-> p.f1 AS dist_lp FROM POINT_TBL p, LINE_TBL l...
                                                             ^
-- Distance to line segment
SELECT p.f1, l.s, p.f1 <-> l.s AS dist_ps, l.s <-> p.f1 AS dist_sp FROM POINT_TBL p, LSEG_TBL l;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: ...ist_ps, l.s <-> p.f1 AS dist_sp FROM POINT_TBL p, LSEG_TBL l...
                                                             ^
-- Distance to box
SELECT p.f1, b.f1, p.f1 <-> b.f1 AS dist_pb, b.f1 <-> p.f1 AS dist_bp FROM POINT_TBL p, BOX_TBL b;
ERROR:  relation "box_tbl" does not exist
LINE 1: ...st_pb, b.f1 <-> p.f1 AS dist_bp FROM POINT_TBL p, BOX_TBL b;
                                                             ^
-- Distance to path
SELECT p.f1, p1.f1, p.f1 <-> p1.f1 AS dist_ppath, p1.f1 <-> p.f1 AS dist_pathp FROM POINT_TBL p, PATH_TBL p1;
ERROR:  relation "path_tbl" does not exist
LINE 1: ...h, p1.f1 <-> p.f1 AS dist_pathp FROM POINT_TBL p, PATH_TBL p...
                                                             ^
-- Distance to polygon
SELECT p.f1, p1.f1, p.f1 <-> p1.f1 AS dist_ppoly, p1.f1 <-> p.f1 AS dist_polyp FROM POINT_TBL p, POLYGON_TBL p1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: ...y, p1.f1 <-> p.f1 AS dist_polyp FROM POINT_TBL p, POLYGON_TB...
                                                             ^
-- Construct line through two points
SELECT p1.f1, p2.f1, line(p1.f1, p2.f1)
  FROM POINT_TBL p1, POINT_TBL p2 WHERE p1.f1 <> p2.f1;
        f1         |        f1         |                  line                  
-------------------+-------------------+----------------------------------------
 (0,0)             | (-10,0)           | {0,-1,0}
 (0,0)             | (-3,4)            | {-1.33333333333,-1,0}
 (0,0)             | (5.1,34.5)        | {6.76470588235,-1,0}
 (0,0)             | (-5,-12)          | {2.4,-1,0}
 (0,0)             | (1e+300,Infinity) | {-1,0,0}
 (0,0)             | (Infinity,1e+300) | {0,-1,0}
 (0,0)             | (NaN,NaN)         | {NaN,-1,NaN}
 (0,0)             | (10,10)           | {1,-1,0}
 (-10,0)           | (0,0)             | {0,-1,0}
 (-10,0)           | (-3,4)            | {0.571428571429,-1,5.71428571429}
 (-10,0)           | (5.1,34.5)        | {2.28476821192,-1,22.8476821192}
 (-10,0)           | (-5,-12)          | {-2.4,-1,-24}
 (-10,0)           | (1e-300,-1e-300)  | {0,-1,0}
 (-10,0)           | (1e+300,Infinity) | {-1,0,-10}
 (-10,0)           | (Infinity,1e+300) | {0,-1,0}
 (-10,0)           | (NaN,NaN)         | {NaN,-1,NaN}
 (-10,0)           | (10,10)           | {0.5,-1,5}
 (-3,4)            | (0,0)             | {-1.33333333333,-1,0}
 (-3,4)            | (-10,0)           | {0.571428571429,-1,5.71428571429}
 (-3,4)            | (5.1,34.5)        | {3.76543209877,-1,15.2962962963}
 (-3,4)            | (-5,-12)          | {8,-1,28}
 (-3,4)            | (1e-300,-1e-300)  | {-1.33333333333,-1,0}
 (-3,4)            | (1e+300,Infinity) | {-1,0,-3}
 (-3,4)            | (Infinity,1e+300) | {0,-1,4}
 (-3,4)            | (NaN,NaN)         | {NaN,-1,NaN}
 (-3,4)            | (10,10)           | {0.461538461538,-1,5.38461538462}
 (5.1,34.5)        | (0,0)             | {6.76470588235,-1,0}
 (5.1,34.5)        | (-10,0)           | {2.28476821192,-1,22.8476821192}
 (5.1,34.5)        | (-3,4)            | {3.76543209877,-1,15.2962962963}
 (5.1,34.5)        | (-5,-12)          | {4.60396039604,-1,11.0198019802}
 (5.1,34.5)        | (1e-300,-1e-300)  | {6.76470588235,-1,0}
 (5.1,34.5)        | (1e+300,Infinity) | {-1,0,5.1}
 (5.1,34.5)        | (Infinity,1e+300) | {0,-1,34.5}
 (5.1,34.5)        | (NaN,NaN)         | {NaN,-1,NaN}
 (5.1,34.5)        | (10,10)           | {-5,-1,60}
 (-5,-12)          | (0,0)             | {2.4,-1,0}
 (-5,-12)          | (-10,0)           | {-2.4,-1,-24}
 (-5,-12)          | (-3,4)            | {8,-1,28}
 (-5,-12)          | (5.1,34.5)        | {4.60396039604,-1,11.0198019802}
 (-5,-12)          | (1e-300,-1e-300)  | {2.4,-1,0}
 (-5,-12)          | (1e+300,Infinity) | {-1,0,-5}
 (-5,-12)          | (Infinity,1e+300) | {0,-1,-12}
 (-5,-12)          | (NaN,NaN)         | {NaN,-1,NaN}
 (-5,-12)          | (10,10)           | {1.46666666667,-1,-4.66666666667}
 (1e-300,-1e-300)  | (-10,0)           | {0,-1,-1e-300}
 (1e-300,-1e-300)  | (-3,4)            | {-1.33333333333,-1,3.33333333333e-301}
 (1e-300,-1e-300)  | (5.1,34.5)        | {6.76470588235,-1,-7.76470588235e-300}
 (1e-300,-1e-300)  | (-5,-12)          | {2.4,-1,-3.4e-300}
 (1e-300,-1e-300)  | (1e+300,Infinity) | {-1,0,1e-300}
 (1e-300,-1e-300)  | (Infinity,1e+300) | {0,-1,-1e-300}
 (1e-300,-1e-300)  | (NaN,NaN)         | {NaN,-1,NaN}
 (1e-300,-1e-300)  | (10,10)           | {1,-1,-2e-300}
 (1e+300,Infinity) | (0,0)             | {-1,0,1e+300}
 (1e+300,Infinity) | (-10,0)           | {-1,0,1e+300}
 (1e+300,Infinity) | (-3,4)            | {-1,0,1e+300}
 (1e+300,Infinity) | (5.1,34.5)        | {-1,0,1e+300}
 (1e+300,Infinity) | (-5,-12)          | {-1,0,1e+300}
 (1e+300,Infinity) | (1e-300,-1e-300)  | {-1,0,1e+300}
 (1e+300,Infinity) | (Infinity,1e+300) | {NaN,-1,NaN}
 (1e+300,Infinity) | (NaN,NaN)         | {NaN,-1,NaN}
 (1e+300,Infinity) | (10,10)           | {-1,0,1e+300}
 (Infinity,1e+300) | (0,0)             | {0,-1,1e+300}
 (Infinity,1e+300) | (-10,0)           | {0,-1,1e+300}
 (Infinity,1e+300) | (-3,4)            | {0,-1,1e+300}
 (Infinity,1e+300) | (5.1,34.5)        | {0,-1,1e+300}
 (Infinity,1e+300) | (-5,-12)          | {0,-1,1e+300}
 (Infinity,1e+300) | (1e-300,-1e-300)  | {0,-1,1e+300}
 (Infinity,1e+300) | (1e+300,Infinity) | {NaN,-1,NaN}
 (Infinity,1e+300) | (NaN,NaN)         | {NaN,-1,NaN}
 (Infinity,1e+300) | (10,10)           | {0,-1,1e+300}
 (NaN,NaN)         | (0,0)             | {NaN,-1,NaN}
 (NaN,NaN)         | (-10,0)           | {NaN,-1,NaN}
 (NaN,NaN)         | (-3,4)            | {NaN,-1,NaN}
 (NaN,NaN)         | (5.1,34.5)        | {NaN,-1,NaN}
 (NaN,NaN)         | (-5,-12)          | {NaN,-1,NaN}
 (NaN,NaN)         | (1e-300,-1e-300)  | {NaN,-1,NaN}
 (NaN,NaN)         | (1e+300,Infinity) | {NaN,-1,NaN}
 (NaN,NaN)         | (Infinity,1e+300) | {NaN,-1,NaN}
 (NaN,NaN)         | (10,10)           | {NaN,-1,NaN}
 (10,10)           | (0,0)             | {1,-1,0}
 (10,10)           | (-10,0)           | {0.5,-1,5}
 (10,10)           | (-3,4)            | {0.461538461538,-1,5.38461538462}
 (10,10)           | (5.1,34.5)        | {-5,-1,60}
 (10,10)           | (-5,-12)          | {1.46666666667,-1,-4.66666666667}
 (10,10)           | (1e-300,-1e-300)  | {1,-1,0}
 (10,10)           | (1e+300,Infinity) | {-1,0,10}
 (10,10)           | (Infinity,1e+300) | {0,-1,10}
 (10,10)           | (NaN,NaN)         | {NaN,-1,NaN}
(88 rows)

-- Closest point to line
SELECT p.f1, l.s, p.f1 ## l.s FROM POINT_TBL p, LINE_TBL l;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT p.f1, l.s, p.f1 ## l.s FROM POINT_TBL p, LINE_TBL l;
                                                        ^
-- Closest point to line segment
SELECT p.f1, l.s, p.f1 ## l.s FROM POINT_TBL p, LSEG_TBL l;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT p.f1, l.s, p.f1 ## l.s FROM POINT_TBL p, LSEG_TBL l;
                                                        ^
-- Closest point to box
SELECT p.f1, b.f1, p.f1 ## b.f1 FROM POINT_TBL p, BOX_TBL b;
ERROR:  relation "box_tbl" does not exist
LINE 1: SELECT p.f1, b.f1, p.f1 ## b.f1 FROM POINT_TBL p, BOX_TBL b;
                                                          ^
-- On line
SELECT p.f1, l.s FROM POINT_TBL p, LINE_TBL l WHERE p.f1 <@ l.s;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT p.f1, l.s FROM POINT_TBL p, LINE_TBL l WHERE p.f1 <@ ...
                                           ^
-- On line segment
SELECT p.f1, l.s FROM POINT_TBL p, LSEG_TBL l WHERE p.f1 <@ l.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT p.f1, l.s FROM POINT_TBL p, LSEG_TBL l WHERE p.f1 <@ ...
                                           ^
-- On path
SELECT p.f1, p1.f1 FROM POINT_TBL p, PATH_TBL p1 WHERE p.f1 <@ p1.f1;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p.f1, p1.f1 FROM POINT_TBL p, PATH_TBL p1 WHERE p.f1 ...
                                             ^
--
-- Lines
--
-- Vertical
SELECT s FROM LINE_TBL WHERE ?| s;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT s FROM LINE_TBL WHERE ?| s;
                      ^
-- Horizontal
SELECT s FROM LINE_TBL WHERE ?- s;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT s FROM LINE_TBL WHERE ?- s;
                      ^
-- Same as line
SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s = l2.s;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s =...
                               ^
-- Parallel to line
SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s ?|| l2.s;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s ?...
                               ^
-- Perpendicular to line
SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s ?-| l2.s;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s ?...
                               ^
-- Distance to line
SELECT l1.s, l2.s, l1.s <-> l2.s FROM LINE_TBL l1, LINE_TBL l2;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT l1.s, l2.s, l1.s <-> l2.s FROM LINE_TBL l1, LINE_TBL ...
                                              ^
-- Intersect with line
SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s ?# l2.s;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LINE_TBL l1, LINE_TBL l2 WHERE l1.s ?...
                               ^
-- Intersect with box
SELECT l.s, b.f1 FROM LINE_TBL l, BOX_TBL b WHERE l.s ?# b.f1;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT l.s, b.f1 FROM LINE_TBL l, BOX_TBL b WHERE l.s ?# b.f...
                              ^
-- Intersection point with line
SELECT l1.s, l2.s, l1.s # l2.s FROM LINE_TBL l1, LINE_TBL l2;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT l1.s, l2.s, l1.s # l2.s FROM LINE_TBL l1, LINE_TBL l2...
                                            ^
-- Closest point to line segment
SELECT l.s, l1.s, l.s ## l1.s FROM LINE_TBL l, LSEG_TBL l1;
ERROR:  relation "line_tbl" does not exist
LINE 1: SELECT l.s, l1.s, l.s ## l1.s FROM LINE_TBL l, LSEG_TBL l1;
                                           ^
--
-- Line segments
--
-- intersection
SELECT p.f1, l.s, l.s # p.f1 AS intersection
   FROM LSEG_TBL l, POINT_TBL p;
ERROR:  relation "lseg_tbl" does not exist
LINE 2:    FROM LSEG_TBL l, POINT_TBL p;
                ^
-- Length
SELECT s, @-@ s FROM LSEG_TBL;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT s, @-@ s FROM LSEG_TBL;
                             ^
-- Vertical
SELECT s FROM LSEG_TBL WHERE ?| s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT s FROM LSEG_TBL WHERE ?| s;
                      ^
-- Horizontal
SELECT s FROM LSEG_TBL WHERE ?- s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT s FROM LSEG_TBL WHERE ?- s;
                      ^
-- Center
SELECT s, @@ s FROM LSEG_TBL;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT s, @@ s FROM LSEG_TBL;
                            ^
-- To point
SELECT s, s::point FROM LSEG_TBL;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT s, s::point FROM LSEG_TBL;
                                ^
-- Has points less than line segment
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s < l2.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s <...
                               ^
-- Has points less than or equal to line segment
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s <= l2.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s <...
                               ^
-- Has points equal to line segment
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s = l2.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s =...
                               ^
-- Has points greater than or equal to line segment
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s >= l2.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s >...
                               ^
-- Has points greater than line segment
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s > l2.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s >...
                               ^
-- Has points not equal to line segment
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s != l2.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s !...
                               ^
-- Parallel with line segment
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s ?|| l2.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s ?...
                               ^
-- Perpendicular with line segment
SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s ?-| l2.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s FROM LSEG_TBL l1, LSEG_TBL l2 WHERE l1.s ?...
                               ^
-- Distance to line
SELECT l.s, l1.s, l.s <-> l1.s AS dist_sl, l1.s <-> l.s AS dist_ls FROM LSEG_TBL l, LINE_TBL l1;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: ...<-> l1.s AS dist_sl, l1.s <-> l.s AS dist_ls FROM LSEG_TBL l...
                                                             ^
-- Distance to line segment
SELECT l1.s, l2.s, l1.s <-> l2.s FROM LSEG_TBL l1, LSEG_TBL l2;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s, l1.s <-> l2.s FROM LSEG_TBL l1, LSEG_TBL ...
                                              ^
-- Distance to box
SELECT l.s, b.f1, l.s <-> b.f1 AS dist_sb, b.f1 <-> l.s AS dist_bs FROM LSEG_TBL l, BOX_TBL b;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: ...<-> b.f1 AS dist_sb, b.f1 <-> l.s AS dist_bs FROM LSEG_TBL l...
                                                             ^
-- Intersect with line segment
SELECT l.s, l1.s FROM LSEG_TBL l, LINE_TBL l1 WHERE l.s ?# l1.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l.s, l1.s FROM LSEG_TBL l, LINE_TBL l1 WHERE l.s ?# l...
                              ^
-- Intersect with box
SELECT l.s, b.f1 FROM LSEG_TBL l, BOX_TBL b WHERE l.s ?# b.f1;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l.s, b.f1 FROM LSEG_TBL l, BOX_TBL b WHERE l.s ?# b.f...
                              ^
-- Intersection point with line segment
SELECT l1.s, l2.s, l1.s # l2.s FROM LSEG_TBL l1, LSEG_TBL l2;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s, l1.s # l2.s FROM LSEG_TBL l1, LSEG_TBL l2...
                                            ^
-- Closest point to line segment
SELECT l1.s, l2.s, l1.s ## l2.s FROM LSEG_TBL l1, LSEG_TBL l2;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l1.s, l2.s, l1.s ## l2.s FROM LSEG_TBL l1, LSEG_TBL l...
                                             ^
-- Closest point to box
SELECT l.s, b.f1, l.s ## b.f1 FROM LSEG_TBL l, BOX_TBL b;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l.s, b.f1, l.s ## b.f1 FROM LSEG_TBL l, BOX_TBL b;
                                           ^
-- On line
SELECT l.s, l1.s FROM LSEG_TBL l, LINE_TBL l1 WHERE l.s <@ l1.s;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l.s, l1.s FROM LSEG_TBL l, LINE_TBL l1 WHERE l.s <@ l...
                              ^
-- On box
SELECT l.s, b.f1 FROM LSEG_TBL l, BOX_TBL b WHERE l.s <@ b.f1;
ERROR:  relation "lseg_tbl" does not exist
LINE 1: SELECT l.s, b.f1 FROM LSEG_TBL l, BOX_TBL b WHERE l.s <@ b.f...
                              ^
--
-- Boxes
--
SELECT box(f1) AS box FROM CIRCLE_TBL;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT box(f1) AS box FROM CIRCLE_TBL;
                                   ^
-- translation
SELECT b.f1 + p.f1 AS translation
   FROM BOX_TBL b, POINT_TBL p;
ERROR:  relation "box_tbl" does not exist
LINE 2:    FROM BOX_TBL b, POINT_TBL p;
                ^
SELECT b.f1 - p.f1 AS translation
   FROM BOX_TBL b, POINT_TBL p;
ERROR:  relation "box_tbl" does not exist
LINE 2:    FROM BOX_TBL b, POINT_TBL p;
                ^
-- Multiply with point
SELECT b.f1, p.f1, b.f1 * p.f1 FROM BOX_TBL b, POINT_TBL p WHERE p.f1[0] BETWEEN 1 AND 1000;
ERROR:  relation "box_tbl" does not exist
LINE 1: SELECT b.f1, p.f1, b.f1 * p.f1 FROM BOX_TBL b, POINT_TBL p W...
                                            ^
-- Overflow error
SELECT b.f1, p.f1, b.f1 * p.f1 FROM BOX_TBL b, POINT_TBL p WHERE p.f1[0] > 1000;
ERROR:  relation "box_tbl" does not exist
LINE 1: SELECT b.f1, p.f1, b.f1 * p.f1 FROM BOX_TBL b, POINT_TBL p W...
                                            ^
-- Divide by point
SELECT b.f1, p.f1, b.f1 / p.f1 FROM BOX_TBL b, POINT_TBL p WHERE p.f1[0] BETWEEN 1 AND 1000;
ERROR:  relation "box_tbl" does not exist
LINE 1: SELECT b.f1, p.f1, b.f1 / p.f1 FROM BOX_TBL b, POINT_TBL p W...
                                            ^
-- To box
SELECT f1::box
	FROM POINT_TBL;
                 f1                  
-------------------------------------
 (0,0),(0,0)
 (-10,0),(-10,0)
 (-3,4),(-3,4)
 (5.1,34.5),(5.1,34.5)
 (-5,-12),(-5,-12)
 (1e-300,-1e-300),(1e-300,-1e-300)
 (1e+300,Infinity),(1e+300,Infinity)
 (Infinity,1e+300),(Infinity,1e+300)
 (NaN,NaN),(NaN,NaN)
 (10,10),(10,10)
 
(11 rows)

SELECT bound_box(a.f1, b.f1)
	FROM BOX_TBL a, BOX_TBL b;
ERROR:  relation "box_tbl" does not exist
LINE 2:  FROM BOX_TBL a, BOX_TBL b;
              ^
-- Below box
SELECT b1.f1, b2.f1, b1.f1 <^ b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
ERROR:  relation "box_tbl" does not exist
LINE 1: SELECT b1.f1, b2.f1, b1.f1 <^ b2.f1 FROM BOX_TBL b1, BOX_TBL...
                                                 ^
-- Above box
SELECT b1.f1, b2.f1, b1.f1 >^ b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
ERROR:  relation "box_tbl" does not exist
LINE 1: SELECT b1.f1, b2.f1, b1.f1 >^ b2.f1 FROM BOX_TBL b1, BOX_TBL...
                                                 ^
-- Intersection point with box
SELECT b1.f1, b2.f1, b1.f1 # b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
ERROR:  relation "box_tbl" does not exist
LINE 1: SELECT b1.f1, b2.f1, b1.f1 # b2.f1 FROM BOX_TBL b1, BOX_TBL ...
                                                ^
-- Diagonal
SELECT f1, diagonal(f1) FROM BOX_TBL;
ERROR:  relation "box_tbl" does not exist
LINE 1: SELECT f1, diagonal(f1) FROM BOX_TBL;
                                     ^
-- Distance to box
SELECT b1.f1, b2.f1, b1.f1 <-> b2.f1 FROM BOX_TBL b1, BOX_TBL b2;
ERROR:  relation "box_tbl" does not exist
LINE 1: SELECT b1.f1, b2.f1, b1.f1 <-> b2.f1 FROM BOX_TBL b1, BOX_TB...
                                                  ^
--
-- Paths
--
-- Points
SELECT f1, npoints(f1) FROM PATH_TBL;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT f1, npoints(f1) FROM PATH_TBL;
                                    ^
-- Area
SELECT f1, area(f1) FROM PATH_TBL;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT f1, area(f1) FROM PATH_TBL;
                                 ^
-- Length
SELECT f1, @-@ f1 FROM PATH_TBL;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT f1, @-@ f1 FROM PATH_TBL;
                               ^
-- To polygon
SELECT f1, f1::polygon FROM PATH_TBL WHERE isclosed(f1);
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT f1, f1::polygon FROM PATH_TBL WHERE isclosed(f1);
                                    ^
-- Open path cannot be converted to polygon error
SELECT f1, f1::polygon FROM PATH_TBL WHERE isopen(f1);
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT f1, f1::polygon FROM PATH_TBL WHERE isopen(f1);
                                    ^
-- Has points less than path
SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f1 < p2.f1;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f...
                                 ^
-- Has points less than or equal to path
SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f1 <= p2.f1;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f...
                                 ^
-- Has points equal to path
SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f1 = p2.f1;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f...
                                 ^
-- Has points greater than or equal to path
SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f1 >= p2.f1;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f...
                                 ^
-- Has points greater than path
SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f1 > p2.f1;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM PATH_TBL p1, PATH_TBL p2 WHERE p1.f...
                                 ^
-- Add path
SELECT p1.f1, p2.f1, p1.f1 + p2.f1 FROM PATH_TBL p1, PATH_TBL p2;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1, p1.f1 + p2.f1 FROM PATH_TBL p1, PATH_TB...
                                                ^
-- Add point
SELECT p.f1, p1.f1, p.f1 + p1.f1 FROM PATH_TBL p, POINT_TBL p1;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p.f1, p1.f1, p.f1 + p1.f1 FROM PATH_TBL p, POINT_TBL ...
                                              ^
-- Subtract point
SELECT p.f1, p1.f1, p.f1 - p1.f1 FROM PATH_TBL p, POINT_TBL p1;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p.f1, p1.f1, p.f1 - p1.f1 FROM PATH_TBL p, POINT_TBL ...
                                              ^
-- Multiply with point
SELECT p.f1, p1.f1, p.f1 * p1.f1 FROM PATH_TBL p, POINT_TBL p1;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p.f1, p1.f1, p.f1 * p1.f1 FROM PATH_TBL p, POINT_TBL ...
                                              ^
-- Divide by point
SELECT p.f1, p1.f1, p.f1 / p1.f1 FROM PATH_TBL p, POINT_TBL p1 WHERE p1.f1[0] BETWEEN 1 AND 1000;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p.f1, p1.f1, p.f1 / p1.f1 FROM PATH_TBL p, POINT_TBL ...
                                              ^
-- Division by 0 error
SELECT p.f1, p1.f1, p.f1 / p1.f1 FROM PATH_TBL p, POINT_TBL p1 WHERE p1.f1 ~= '(0,0)'::point;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p.f1, p1.f1, p.f1 / p1.f1 FROM PATH_TBL p, POINT_TBL ...
                                              ^
-- Distance to path
SELECT p1.f1, p2.f1, p1.f1 <-> p2.f1 FROM PATH_TBL p1, PATH_TBL p2;
ERROR:  relation "path_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1, p1.f1 <-> p2.f1 FROM PATH_TBL p1, PATH_...
                                                  ^
--
-- Polygons
--
-- containment
SELECT p.f1, poly.f1, poly.f1 @> p.f1 AS contains
   FROM POLYGON_TBL poly, POINT_TBL p;
ERROR:  relation "polygon_tbl" does not exist
LINE 2:    FROM POLYGON_TBL poly, POINT_TBL p;
                ^
SELECT p.f1, poly.f1, p.f1 <@ poly.f1 AS contained
   FROM POLYGON_TBL poly, POINT_TBL p;
ERROR:  relation "polygon_tbl" does not exist
LINE 2:    FROM POLYGON_TBL poly, POINT_TBL p;
                ^
SELECT npoints(f1) AS npoints, f1 AS polygon
   FROM POLYGON_TBL;
ERROR:  relation "polygon_tbl" does not exist
LINE 2:    FROM POLYGON_TBL;
                ^
SELECT polygon(f1)
   FROM BOX_TBL;
ERROR:  relation "box_tbl" does not exist
LINE 2:    FROM BOX_TBL;
                ^
SELECT polygon(f1)
   FROM PATH_TBL WHERE isclosed(f1);
ERROR:  relation "path_tbl" does not exist
LINE 2:    FROM PATH_TBL WHERE isclosed(f1);
                ^
SELECT f1 AS open_path, polygon( pclose(f1)) AS polygon
   FROM PATH_TBL
   WHERE isopen(f1);
ERROR:  relation "path_tbl" does not exist
LINE 2:    FROM PATH_TBL
                ^
-- To box
SELECT f1, f1::box FROM POLYGON_TBL;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT f1, f1::box FROM POLYGON_TBL;
                                ^
-- To path
SELECT f1, f1::path FROM POLYGON_TBL;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT f1, f1::path FROM POLYGON_TBL;
                                 ^
-- Same as polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 ~= p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Contained by polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 <@ p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Contains polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 @> p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Overlap with polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 && p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Left of polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 << p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Overlap of left of polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 &< p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Right of polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 >> p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Overlap of right of polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 &> p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Below polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 <<| p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Overlap or below polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 &<| p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Above polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 |>> p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Overlap or above polygon
SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHERE p1.f1 |&> p2.f1;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2 WHER...
                                 ^
-- Distance to polygon
SELECT p1.f1, p2.f1, p1.f1 <-> p2.f1 FROM POLYGON_TBL p1, POLYGON_TBL p2;
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT p1.f1, p2.f1, p1.f1 <-> p2.f1 FROM POLYGON_TBL p1, PO...
                                                  ^
--
-- Circles
--
SELECT circle(f1, 50.0)
   FROM POINT_TBL;
         circle         
------------------------
 <(0,0),50>
 <(-10,0),50>
 <(-3,4),50>
 <(5.1,34.5),50>
 <(-5,-12),50>
 <(1e-300,-1e-300),50>
 <(1e+300,Infinity),50>
 <(Infinity,1e+300),50>
 <(NaN,NaN),50>
 <(10,10),50>
 
(11 rows)

SELECT circle(f1)
   FROM BOX_TBL;
ERROR:  relation "box_tbl" does not exist
LINE 2:    FROM BOX_TBL;
                ^
SELECT circle(f1)
   FROM POLYGON_TBL
   WHERE (# f1) >= 3;
ERROR:  relation "polygon_tbl" does not exist
LINE 2:    FROM POLYGON_TBL
                ^
SELECT c1.f1 AS circle, p1.f1 AS point, (p1.f1 <-> c1.f1) AS distance
   FROM CIRCLE_TBL c1, POINT_TBL p1
   WHERE (p1.f1 <-> c1.f1) > 0
   ORDER BY distance, area(c1.f1), p1.f1[0];
ERROR:  relation "circle_tbl" does not exist
LINE 2:    FROM CIRCLE_TBL c1, POINT_TBL p1
                ^
-- To polygon
SELECT f1, f1::polygon FROM CIRCLE_TBL WHERE f1 >= '<(0,0),1>';
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT f1, f1::polygon FROM CIRCLE_TBL WHERE f1 >= '<(0,0),1...
                                    ^
-- To polygon with less points
SELECT f1, polygon(8, f1) FROM CIRCLE_TBL WHERE f1 >= '<(0,0),1>';
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT f1, polygon(8, f1) FROM CIRCLE_TBL WHERE f1 >= '<(0,0...
                                       ^
-- Error for insufficient number of points
SELECT f1, polygon(1, f1) FROM CIRCLE_TBL WHERE f1 >= '<(0,0),1>';
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT f1, polygon(1, f1) FROM CIRCLE_TBL WHERE f1 >= '<(0,0...
                                       ^
-- Zero radius error
SELECT f1, polygon(10, f1) FROM CIRCLE_TBL WHERE f1 < '<(0,0),1>';
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT f1, polygon(10, f1) FROM CIRCLE_TBL WHERE f1 < '<(0,0...
                                        ^
-- Same as circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 ~= c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Overlap with circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 && c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Overlap or left of circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 &< c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Left of circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 << c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Right of circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 >> c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Overlap or right of circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 &> c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Contained by circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 <@ c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Contain by circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 @> c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Below circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 <<| c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Above circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 |>> c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Overlap or below circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 &<| c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Overlap or above circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 |&> c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Area equal with circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 = c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Area not equal with circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 != c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Area less than circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 < c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Area greater than circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 > c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Area less than or equal circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 <= c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Area greater than or equal circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 >= c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Area less than circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 < c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Area greater than circle
SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE c1.f1 < c2.f1;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c1.f1, c2.f1 FROM CIRCLE_TBL c1, CIRCLE_TBL c2 WHERE ...
                                 ^
-- Add point
SELECT c.f1, p.f1, c.f1 + p.f1 FROM CIRCLE_TBL c, POINT_TBL p;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c.f1, p.f1, c.f1 + p.f1 FROM CIRCLE_TBL c, POINT_TBL ...
                                            ^
-- Subtract point
SELECT c.f1, p.f1, c.f1 - p.f1 FROM CIRCLE_TBL c, POINT_TBL p;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c.f1, p.f1, c.f1 - p.f1 FROM CIRCLE_TBL c, POINT_TBL ...
                                            ^
-- Multiply with point
SELECT c.f1, p.f1, c.f1 * p.f1 FROM CIRCLE_TBL c, POINT_TBL p;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c.f1, p.f1, c.f1 * p.f1 FROM CIRCLE_TBL c, POINT_TBL ...
                                            ^
-- Divide by point
SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1[0] BETWEEN 1 AND 1000;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL ...
                                            ^
-- Overflow error
SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1[0] > 1000;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL ...
                                            ^
-- Division by 0 error
SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL p WHERE p.f1 ~= '(0,0)'::point;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c.f1, p.f1, c.f1 / p.f1 FROM CIRCLE_TBL c, POINT_TBL ...
                                            ^
-- Distance to polygon
SELECT c.f1, p.f1, c.f1 <-> p.f1 FROM CIRCLE_TBL c, POLYGON_TBL p;
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT c.f1, p.f1, c.f1 <-> p.f1 FROM CIRCLE_TBL c, POLYGON_...
                                              ^
-- Check index behavior for circles
CREATE INDEX gcircleind ON circle_tbl USING gist (f1);
ERROR:  relation "circle_tbl" does not exist
SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
    ORDER BY area(f1);
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
                      ^
EXPLAIN (COSTS OFF)
SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
    ORDER BY area(f1);
ERROR:  relation "circle_tbl" does not exist
LINE 2: SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
                      ^
SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
    ORDER BY area(f1);
ERROR:  relation "circle_tbl" does not exist
LINE 1: SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
                      ^
-- Check index behavior for polygons
CREATE INDEX gpolygonind ON polygon_tbl USING gist (f1);
ERROR:  relation "polygon_tbl" does not exist
SELECT * FROM polygon_tbl WHERE f1 @> '((1,1),(2,2),(2,1))'::polygon
    ORDER BY (poly_center(f1))[0];
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT * FROM polygon_tbl WHERE f1 @> '((1,1),(2,2),(2,1))':...
                      ^
EXPLAIN (COSTS OFF)
SELECT * FROM polygon_tbl WHERE f1 @> '((1,1),(2,2),(2,1))'::polygon
    ORDER BY (poly_center(f1))[0];
ERROR:  relation "polygon_tbl" does not exist
LINE 2: SELECT * FROM polygon_tbl WHERE f1 @> '((1,1),(2,2),(2,1))':...
                      ^
SELECT * FROM polygon_tbl WHERE f1 @> '((1,1),(2,2),(2,1))'::polygon
    ORDER BY (poly_center(f1))[0];
ERROR:  relation "polygon_tbl" does not exist
LINE 1: SELECT * FROM polygon_tbl WHERE f1 @> '((1,1),(2,2),(2,1))':...
                      ^
-- test non-error-throwing API for some core types
SELECT pg_input_is_valid('(1', 'circle');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT * FROM pg_input_error_info('1,', 'circle');
                  message                   | detail | hint | sql_error_code 
--------------------------------------------+--------+------+----------------
 invalid input syntax for type circle: "1," |        |      | 22P02
(1 row)

SELECT pg_input_is_valid('(1,2),-1', 'circle');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT * FROM pg_input_error_info('(1,2),-1', 'circle');
                     message                      | detail | hint | sql_error_code 
--------------------------------------------------+--------+------+----------------
 invalid input syntax for type circle: "(1,2),-1" |        |      | 22P02
(1 row)

-- END setup from  geometry 
-- START setup from create_index_spgist 
--
-- SP-GiST index tests
--
CREATE TABLE quad_point_tbl AS
    SELECT point(unique1,unique2) AS p FROM tenk1;
ERROR:  relation "tenk1" does not exist
LINE 2:     SELECT point(unique1,unique2) AS p FROM tenk1;
                                                    ^
INSERT INTO quad_point_tbl
    SELECT '(333.0,400.0)'::point FROM generate_series(1,1000);
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: INSERT INTO quad_point_tbl
                    ^
INSERT INTO quad_point_tbl VALUES (NULL), (NULL), (NULL);
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: INSERT INTO quad_point_tbl VALUES (NULL), (NULL), (NULL);
                    ^
CREATE INDEX sp_quad_ind ON quad_point_tbl USING spgist (p);
ERROR:  relation "quad_point_tbl" does not exist
CREATE TABLE kd_point_tbl AS SELECT * FROM quad_point_tbl;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: CREATE TABLE kd_point_tbl AS SELECT * FROM quad_point_tbl;
                                                   ^
CREATE INDEX sp_kd_ind ON kd_point_tbl USING spgist (p kd_point_ops);
ERROR:  relation "kd_point_tbl" does not exist
CREATE TABLE radix_text_tbl AS
    SELECT name AS t FROM road WHERE name !~ '^[0-9]';
ERROR:  relation "road" does not exist
LINE 2:     SELECT name AS t FROM road WHERE name !~ '^[0-9]';
                                  ^
INSERT INTO radix_text_tbl
    SELECT 'P0123456789abcdef' FROM generate_series(1,1000);
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: INSERT INTO radix_text_tbl
                    ^
INSERT INTO radix_text_tbl VALUES ('P0123456789abcde');
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: INSERT INTO radix_text_tbl VALUES ('P0123456789abcde');
                    ^
INSERT INTO radix_text_tbl VALUES ('P0123456789abcdefF');
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: INSERT INTO radix_text_tbl VALUES ('P0123456789abcdefF');
                    ^
CREATE INDEX sp_radix_ind ON radix_text_tbl USING spgist (t);
ERROR:  relation "radix_text_tbl" does not exist
-- get non-indexed results for comparison purposes
SET enable_seqscan = ON;
SET enable_indexscan = OFF;
SET enable_bitmapscan = OFF;
SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
                             ^
SELECT count(*) FROM quad_point_tbl;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl;
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)'...
                             ^
CREATE TEMP TABLE quad_point_tbl_ord_seq1 AS
SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p
FROM quad_point_tbl;
ERROR:  relation "quad_point_tbl" does not exist
LINE 3: FROM quad_point_tbl;
             ^
CREATE TEMP TABLE quad_point_tbl_ord_seq2 AS
SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p
FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 3: FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
             ^
CREATE TEMP TABLE quad_point_tbl_ord_seq3 AS
SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, p
FROM quad_point_tbl WHERE p IS NOT NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 3: FROM quad_point_tbl WHERE p IS NOT NULL;
             ^
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ^@  'Worth';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ^@  'Worth';
                             ^
-- Now check the results from plain indexscan
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl;
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl;
                             ^
SELECT count(*) FROM quad_point_tbl;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl;
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)'...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)'...
                             ^
EXPLAIN (COSTS OFF)
SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p
FROM quad_point_tbl;
ERROR:  relation "quad_point_tbl" does not exist
LINE 3: FROM quad_point_tbl;
             ^
CREATE TEMP TABLE quad_point_tbl_ord_idx1 AS
SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p
FROM quad_point_tbl;
ERROR:  relation "quad_point_tbl" does not exist
LINE 3: FROM quad_point_tbl;
             ^
SELECT * FROM quad_point_tbl_ord_seq1 seq FULL JOIN quad_point_tbl_ord_idx1 idx
ON seq.n = idx.n
WHERE seq.dist IS DISTINCT FROM idx.dist;
ERROR:  relation "quad_point_tbl_ord_seq1" does not exist
LINE 1: SELECT * FROM quad_point_tbl_ord_seq1 seq FULL JOIN quad_poi...
                      ^
EXPLAIN (COSTS OFF)
SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p
FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 3: FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
             ^
CREATE TEMP TABLE quad_point_tbl_ord_idx2 AS
SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p
FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 3: FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
             ^
SELECT * FROM quad_point_tbl_ord_seq2 seq FULL JOIN quad_point_tbl_ord_idx2 idx
ON seq.n = idx.n
WHERE seq.dist IS DISTINCT FROM idx.dist;
ERROR:  relation "quad_point_tbl_ord_seq2" does not exist
LINE 1: SELECT * FROM quad_point_tbl_ord_seq2 seq FULL JOIN quad_poi...
                      ^
EXPLAIN (COSTS OFF)
SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, p
FROM quad_point_tbl WHERE p IS NOT NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 3: FROM quad_point_tbl WHERE p IS NOT NULL;
             ^
CREATE TEMP TABLE quad_point_tbl_ord_idx3 AS
SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, p
FROM quad_point_tbl WHERE p IS NOT NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 3: FROM quad_point_tbl WHERE p IS NOT NULL;
             ^
SELECT * FROM quad_point_tbl_ord_seq3 seq FULL JOIN quad_point_tbl_ord_idx3 idx
ON seq.n = idx.n
WHERE seq.dist IS DISTINCT FROM idx.dist;
ERROR:  relation "quad_point_tbl_ord_seq3" does not exist
LINE 1: SELECT * FROM quad_point_tbl_ord_seq3 seq FULL JOIN quad_poi...
                      ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1...
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1...
                             ^
SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)'...
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)'...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)'...
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)'...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
                             ^
EXPLAIN (COSTS OFF)
SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p
FROM kd_point_tbl;
ERROR:  relation "kd_point_tbl" does not exist
LINE 3: FROM kd_point_tbl;
             ^
CREATE TEMP TABLE kd_point_tbl_ord_idx1 AS
SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p
FROM kd_point_tbl;
ERROR:  relation "kd_point_tbl" does not exist
LINE 3: FROM kd_point_tbl;
             ^
SELECT * FROM quad_point_tbl_ord_seq1 seq FULL JOIN kd_point_tbl_ord_idx1 idx
ON seq.n = idx.n
WHERE seq.dist IS DISTINCT FROM idx.dist;
ERROR:  relation "quad_point_tbl_ord_seq1" does not exist
LINE 1: SELECT * FROM quad_point_tbl_ord_seq1 seq FULL JOIN kd_point...
                      ^
EXPLAIN (COSTS OFF)
SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p
FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 3: FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
             ^
CREATE TEMP TABLE kd_point_tbl_ord_idx2 AS
SELECT row_number() OVER (ORDER BY p <-> '0,0') n, p <-> '0,0' dist, p
FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 3: FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
             ^
SELECT * FROM quad_point_tbl_ord_seq2 seq FULL JOIN kd_point_tbl_ord_idx2 idx
ON seq.n = idx.n
WHERE seq.dist IS DISTINCT FROM idx.dist;
ERROR:  relation "quad_point_tbl_ord_seq2" does not exist
LINE 1: SELECT * FROM quad_point_tbl_ord_seq2 seq FULL JOIN kd_point...
                      ^
EXPLAIN (COSTS OFF)
SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, p
FROM kd_point_tbl WHERE p IS NOT NULL;
ERROR:  relation "kd_point_tbl" does not exist
LINE 3: FROM kd_point_tbl WHERE p IS NOT NULL;
             ^
CREATE TEMP TABLE kd_point_tbl_ord_idx3 AS
SELECT row_number() OVER (ORDER BY p <-> '333,400') n, p <-> '333,400' dist, p
FROM kd_point_tbl WHERE p IS NOT NULL;
ERROR:  relation "kd_point_tbl" does not exist
LINE 3: FROM kd_point_tbl WHERE p IS NOT NULL;
             ^
SELECT * FROM quad_point_tbl_ord_seq3 seq FULL JOIN kd_point_tbl_ord_idx3 idx
ON seq.n = idx.n
WHERE seq.dist IS DISTINCT FROM idx.dist;
ERROR:  relation "quad_point_tbl_ord_seq3" does not exist
LINE 1: SELECT * FROM quad_point_tbl_ord_seq3 seq FULL JOIN kd_point...
                      ^
-- test KNN scan with included columns
-- the distance numbers are not exactly the same across platforms
SET extra_float_digits = 0;
CREATE INDEX ON quad_point_tbl_ord_seq1 USING spgist(p) INCLUDE(dist);
ERROR:  relation "quad_point_tbl_ord_seq1" does not exist
EXPLAIN (COSTS OFF)
SELECT p, dist FROM quad_point_tbl_ord_seq1 ORDER BY p <-> '0,0' LIMIT 10;
ERROR:  relation "quad_point_tbl_ord_seq1" does not exist
LINE 2: SELECT p, dist FROM quad_point_tbl_ord_seq1 ORDER BY p <-> '...
                            ^
SELECT p, dist FROM quad_point_tbl_ord_seq1 ORDER BY p <-> '0,0' LIMIT 10;
ERROR:  relation "quad_point_tbl_ord_seq1" does not exist
LINE 1: SELECT p, dist FROM quad_point_tbl_ord_seq1 ORDER BY p <-> '...
                            ^
RESET extra_float_digits;
-- check ORDER BY distance to NULL
SELECT (SELECT p FROM kd_point_tbl ORDER BY p <-> pt, p <-> '0,0' LIMIT 1)
FROM (VALUES (point '1,2'), (NULL), ('1234,5678')) pts(pt);
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT (SELECT p FROM kd_point_tbl ORDER BY p <-> pt, p <-> ...
                              ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t ^@  'Worth';
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ^@  'Worth';
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE starts_with(t, 'Worth');
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE starts_with(t, 'Wo...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE starts_with(t, 'Worth');
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE starts_with(t, 'Wo...
                             ^
-- Now check the results from bitmap indexscan
SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p IS NULL;
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p IS NOT NULL;
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl;
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl;
                             ^
SELECT count(*) FROM quad_point_tbl;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl;
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p <@ box '(200,200...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000,1000)' @> p;
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE box '(200,200,1000...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p << '(5000, 4000)...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p >> '(5000, 4000)...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p <<| '(5000, 4000...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p |>> '(5000, 4000...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 2: SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)'...
                             ^
SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)';
ERROR:  relation "quad_point_tbl" does not exist
LINE 1: SELECT count(*) FROM quad_point_tbl WHERE p ~= '(4585, 365)'...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1...
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1000,1000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p <@ box '(200,200,1...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1...
                             ^
SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1000)' @> p;
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE box '(200,200,1000,1...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p << '(5000, 4000)';
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p >> '(5000, 4000)';
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)'...
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p <<| '(5000, 4000)'...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)'...
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p |>> '(5000, 4000)'...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 2: SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
                             ^
SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
ERROR:  relation "kd_point_tbl" does not exist
LINE 1: SELECT count(*) FROM kd_point_tbl WHERE p ~= '(4585, 365)';
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdef';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcde';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789abcdefF';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t = 'P0123456789ab...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t <    'Aztec     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~<~  'Aztec     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t <=   'Aztec     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~<=~ 'Aztec     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec                         Ct  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t =    'Aztec     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t =    'Worth     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t >=   'Worth     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~>=~ 'Worth     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t >    'Worth     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth     ...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth                         St  ';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ~>~  'Worth     ...
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE t ^@  'Worth';
                             ^
SELECT count(*) FROM radix_text_tbl WHERE t ^@	 'Worth';
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE t ^@  'Worth';
                             ^
EXPLAIN (COSTS OFF)
SELECT count(*) FROM radix_text_tbl WHERE starts_with(t, 'Worth');
ERROR:  relation "radix_text_tbl" does not exist
LINE 2: SELECT count(*) FROM radix_text_tbl WHERE starts_with(t, 'Wo...
                             ^
SELECT count(*) FROM radix_text_tbl WHERE starts_with(t, 'Worth');
ERROR:  relation "radix_text_tbl" does not exist
LINE 1: SELECT count(*) FROM radix_text_tbl WHERE starts_with(t, 'Wo...
                             ^
RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
-- END setup from create_index_spgist 
-- START setup from hash_index 
--
-- HASH_INDEX
--
-- directory paths are passed to us in environment variables
\getenv abs_srcdir PG_ABS_SRCDIR
CREATE TABLE hash_i4_heap (
	seqno 		int4,
	random 		int4
);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE hash_i4_heap (
                     ^
CREATE TABLE hash_name_heap (
	seqno 		int4,
	random 		name
);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE hash_name_heap (
                     ^
CREATE TABLE hash_txt_heap (
	seqno 		int4,
	random 		text
);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE hash_txt_heap (
                     ^
CREATE TABLE hash_f8_heap (
	seqno		int4,
	random 		float8
);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE hash_f8_heap (
                     ^
\set filename :abs_srcdir '/data/hash.data'
COPY hash_i4_heap FROM :'filename';
ERROR:  relation "hash_i4_heap" does not exist
COPY hash_name_heap FROM :'filename';
ERROR:  relation "hash_name_heap" does not exist
COPY hash_txt_heap FROM :'filename';
ERROR:  relation "hash_txt_heap" does not exist
COPY hash_f8_heap FROM :'filename';
ERROR:  relation "hash_f8_heap" does not exist
-- the data in this file has a lot of duplicates in the index key
-- fields, leading to long bucket chains and lots of table expansion.
-- this is therefore a stress test of the bucket overflow code (unlike
-- the data in hash.data, which has unique index keys).
--
-- \set filename :abs_srcdir '/data/hashovfl.data'
-- COPY hash_ovfl_heap FROM :'filename';
ANALYZE hash_i4_heap;
ERROR:  relation "hash_i4_heap" does not exist
ANALYZE hash_name_heap;
ERROR:  relation "hash_name_heap" does not exist
ANALYZE hash_txt_heap;
ERROR:  relation "hash_txt_heap" does not exist
ANALYZE hash_f8_heap;
ERROR:  relation "hash_f8_heap" does not exist
CREATE INDEX hash_i4_index ON hash_i4_heap USING hash (random int4_ops);
ERROR:  relation "hash_i4_heap" does not exist
CREATE INDEX hash_name_index ON hash_name_heap USING hash (random name_ops);
ERROR:  relation "hash_name_heap" does not exist
CREATE INDEX hash_txt_index ON hash_txt_heap USING hash (random text_ops);
ERROR:  relation "hash_txt_heap" does not exist
CREATE INDEX hash_f8_index ON hash_f8_heap USING hash (random float8_ops)
  WITH (fillfactor=60);
ERROR:  relation "hash_f8_heap" does not exist
--
-- Also try building functional, expressional, and partial indexes on
-- tables that already contain data.
--
create unique index hash_f8_index_1 on hash_f8_heap(abs(random));
ERROR:  relation "hash_f8_heap" does not exist
create unique index hash_f8_index_2 on hash_f8_heap((seqno + 1), random);
ERROR:  relation "hash_f8_heap" does not exist
create unique index hash_f8_index_3 on hash_f8_heap(random) where seqno > 1000;
ERROR:  relation "hash_f8_heap" does not exist
--
-- hash index
-- grep 843938989 hash.data
--
SELECT * FROM hash_i4_heap
   WHERE hash_i4_heap.random = 843938989;
ERROR:  relation "hash_i4_heap" does not exist
LINE 1: SELECT * FROM hash_i4_heap
                      ^
--
-- hash index
-- grep 66766766 hash.data
--
SELECT * FROM hash_i4_heap
   WHERE hash_i4_heap.random = 66766766;
ERROR:  relation "hash_i4_heap" does not exist
LINE 1: SELECT * FROM hash_i4_heap
                      ^
--
-- hash index
-- grep 1505703298 hash.data
--
SELECT * FROM hash_name_heap
   WHERE hash_name_heap.random = '1505703298'::name;
ERROR:  relation "hash_name_heap" does not exist
LINE 1: SELECT * FROM hash_name_heap
                      ^
--
-- hash index
-- grep 7777777 hash.data
--
SELECT * FROM hash_name_heap
   WHERE hash_name_heap.random = '7777777'::name;
ERROR:  relation "hash_name_heap" does not exist
LINE 1: SELECT * FROM hash_name_heap
                      ^
--
-- hash index
-- grep 1351610853 hash.data
--
SELECT * FROM hash_txt_heap
   WHERE hash_txt_heap.random = '1351610853'::text;
ERROR:  relation "hash_txt_heap" does not exist
LINE 1: SELECT * FROM hash_txt_heap
                      ^
--
-- hash index
-- grep 111111112222222233333333 hash.data
--
SELECT * FROM hash_txt_heap
   WHERE hash_txt_heap.random = '111111112222222233333333'::text;
ERROR:  relation "hash_txt_heap" does not exist
LINE 1: SELECT * FROM hash_txt_heap
                      ^
--
-- hash index
-- grep 444705537 hash.data
--
SELECT * FROM hash_f8_heap
   WHERE hash_f8_heap.random = '444705537'::float8;
ERROR:  relation "hash_f8_heap" does not exist
LINE 1: SELECT * FROM hash_f8_heap
                      ^
--
-- hash index
-- grep 88888888 hash.data
--
SELECT * FROM hash_f8_heap
   WHERE hash_f8_heap.random = '88888888'::float8;
ERROR:  relation "hash_f8_heap" does not exist
LINE 1: SELECT * FROM hash_f8_heap
                      ^
--
-- hash index
-- grep '^90[^0-9]' hashovfl.data
--
-- SELECT count(*) AS i988 FROM hash_ovfl_heap
--    WHERE x = 90;
--
-- hash index
-- grep '^1000[^0-9]' hashovfl.data
--
-- SELECT count(*) AS i0 FROM hash_ovfl_heap
--    WHERE x = 1000;
--
-- HASH
--
UPDATE hash_i4_heap
   SET random = 1
   WHERE hash_i4_heap.seqno = 1492;
ERROR:  relation "hash_i4_heap" does not exist
LINE 1: UPDATE hash_i4_heap
               ^
SELECT h.seqno AS i1492, h.random AS i1
   FROM hash_i4_heap h
   WHERE h.random = 1;
ERROR:  relation "hash_i4_heap" does not exist
LINE 2:    FROM hash_i4_heap h
                ^
UPDATE hash_i4_heap
   SET seqno = 20000
   WHERE hash_i4_heap.random = 1492795354;
ERROR:  relation "hash_i4_heap" does not exist
LINE 1: UPDATE hash_i4_heap
               ^
SELECT h.seqno AS i20000
   FROM hash_i4_heap h
   WHERE h.random = 1492795354;
ERROR:  relation "hash_i4_heap" does not exist
LINE 2:    FROM hash_i4_heap h
                ^
UPDATE hash_name_heap
   SET random = '0123456789abcdef'::name
   WHERE hash_name_heap.seqno = 6543;
ERROR:  relation "hash_name_heap" does not exist
LINE 1: UPDATE hash_name_heap
               ^
SELECT h.seqno AS i6543, h.random AS c0_to_f
   FROM hash_name_heap h
   WHERE h.random = '0123456789abcdef'::name;
ERROR:  relation "hash_name_heap" does not exist
LINE 2:    FROM hash_name_heap h
                ^
UPDATE hash_name_heap
   SET seqno = 20000
   WHERE hash_name_heap.random = '76652222'::name;
ERROR:  relation "hash_name_heap" does not exist
LINE 1: UPDATE hash_name_heap
               ^
--
-- this is the row we just replaced; index scan should return zero rows
--
SELECT h.seqno AS emptyset
   FROM hash_name_heap h
   WHERE h.random = '76652222'::name;
ERROR:  relation "hash_name_heap" does not exist
LINE 2:    FROM hash_name_heap h
                ^
UPDATE hash_txt_heap
   SET random = '0123456789abcdefghijklmnop'::text
   WHERE hash_txt_heap.seqno = 4002;
ERROR:  relation "hash_txt_heap" does not exist
LINE 1: UPDATE hash_txt_heap
               ^
SELECT h.seqno AS i4002, h.random AS c0_to_p
   FROM hash_txt_heap h
   WHERE h.random = '0123456789abcdefghijklmnop'::text;
ERROR:  relation "hash_txt_heap" does not exist
LINE 2:    FROM hash_txt_heap h
                ^
UPDATE hash_txt_heap
   SET seqno = 20000
   WHERE hash_txt_heap.random = '959363399'::text;
ERROR:  relation "hash_txt_heap" does not exist
LINE 1: UPDATE hash_txt_heap
               ^
SELECT h.seqno AS t20000
   FROM hash_txt_heap h
   WHERE h.random = '959363399'::text;
ERROR:  relation "hash_txt_heap" does not exist
LINE 2:    FROM hash_txt_heap h
                ^
UPDATE hash_f8_heap
   SET random = '-1234.1234'::float8
   WHERE hash_f8_heap.seqno = 8906;
ERROR:  relation "hash_f8_heap" does not exist
LINE 1: UPDATE hash_f8_heap
               ^
SELECT h.seqno AS i8096, h.random AS f1234_1234
   FROM hash_f8_heap h
   WHERE h.random = '-1234.1234'::float8;
ERROR:  relation "hash_f8_heap" does not exist
LINE 2:    FROM hash_f8_heap h
                ^
UPDATE hash_f8_heap
   SET seqno = 20000
   WHERE hash_f8_heap.random = '488912369'::float8;
ERROR:  relation "hash_f8_heap" does not exist
LINE 1: UPDATE hash_f8_heap
               ^
SELECT h.seqno AS f20000
   FROM hash_f8_heap h
   WHERE h.random = '488912369'::float8;
ERROR:  relation "hash_f8_heap" does not exist
LINE 2:    FROM hash_f8_heap h
                ^
-- UPDATE hash_ovfl_heap
--    SET x = 1000
--   WHERE x = 90;
-- this vacuums the index as well
-- VACUUM hash_ovfl_heap;
-- SELECT count(*) AS i0 FROM hash_ovfl_heap
--   WHERE x = 90;
-- SELECT count(*) AS i988 FROM hash_ovfl_heap
--  WHERE x = 1000;
--
-- Cause some overflow insert and splits.
--
CREATE TABLE hash_split_heap (keycol INT);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE hash_split_heap (keycol INT);
                     ^
INSERT INTO hash_split_heap SELECT 1 FROM generate_series(1, 500) a;
ERROR:  relation "hash_split_heap" does not exist
LINE 1: INSERT INTO hash_split_heap SELECT 1 FROM generate_series(1,...
                    ^
CREATE INDEX hash_split_index on hash_split_heap USING HASH (keycol);
ERROR:  relation "hash_split_heap" does not exist
INSERT INTO hash_split_heap SELECT 1 FROM generate_series(1, 5000) a;
ERROR:  relation "hash_split_heap" does not exist
LINE 1: INSERT INTO hash_split_heap SELECT 1 FROM generate_series(1,...
                    ^
-- Let's do a backward scan.
BEGIN;
SET enable_seqscan = OFF;
SET enable_bitmapscan = OFF;
DECLARE c CURSOR FOR SELECT * from hash_split_heap WHERE keycol = 1;
ERROR:  relation "hash_split_heap" does not exist
LINE 1: DECLARE c CURSOR FOR SELECT * from hash_split_heap WHERE key...
                                           ^
MOVE FORWARD ALL FROM c;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
MOVE BACKWARD 10000 FROM c;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
MOVE BACKWARD ALL FROM c;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
CLOSE c;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
END;
-- DELETE, INSERT, VACUUM.
DELETE FROM hash_split_heap WHERE keycol = 1;
ERROR:  relation "hash_split_heap" does not exist
LINE 1: DELETE FROM hash_split_heap WHERE keycol = 1;
                    ^
INSERT INTO hash_split_heap SELECT a/2 FROM generate_series(1, 25000) a;
ERROR:  relation "hash_split_heap" does not exist
LINE 1: INSERT INTO hash_split_heap SELECT a/2 FROM generate_series(...
                    ^
VACUUM hash_split_heap;
ERROR:  relation "hash_split_heap" does not exist
-- Rebuild the index using a different fillfactor
ALTER INDEX hash_split_index SET (fillfactor = 10);
ERROR:  relation "hash_split_index" does not exist
REINDEX INDEX hash_split_index;
ERROR:  relation "hash_split_index" does not exist
-- Clean up.
DROP TABLE hash_split_heap;
ERROR:  table "hash_split_heap" does not exist
-- Testcases for removing overflow pages.
CREATE TABLE hash_cleanup_heap(keycol INT);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE hash_cleanup_heap(keycol INT);
                     ^
CREATE INDEX hash_cleanup_index on hash_cleanup_heap USING HASH (keycol);
ERROR:  relation "hash_cleanup_heap" does not exist
-- Insert tuples to both the primary bucket page and overflow pages.
INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(1, 500) as i;
ERROR:  relation "hash_cleanup_heap" does not exist
LINE 1: INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(...
                    ^
-- Fill overflow pages by "dead" tuples.
BEGIN;
INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(1, 1000) as i;
ERROR:  relation "hash_cleanup_heap" does not exist
LINE 1: INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(...
                    ^
ROLLBACK;
-- Checkpoint will ensure that all hash buffers are cleaned before we try
-- to remove overflow pages.
CHECKPOINT;
-- This will squeeze the bucket and remove overflow pages.
VACUUM hash_cleanup_heap;
ERROR:  relation "hash_cleanup_heap" does not exist
TRUNCATE hash_cleanup_heap;
ERROR:  relation "hash_cleanup_heap" does not exist
-- Insert a few tuples so that the primary bucket page doesn't get full and
-- tuples can be moved to it.
INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(1, 50) as i;
ERROR:  relation "hash_cleanup_heap" does not exist
LINE 1: INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(...
                    ^
-- Fill overflow pages by "dead" tuples.
BEGIN;
INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(1, 1500) as i;
ERROR:  relation "hash_cleanup_heap" does not exist
LINE 1: INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(...
                    ^
ROLLBACK;
-- And insert some tuples again. During squeeze operation, these will be moved
-- to the primary bucket allowing to test freeing intermediate overflow pages.
INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(1, 500) as i;
ERROR:  relation "hash_cleanup_heap" does not exist
LINE 1: INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(...
                    ^
CHECKPOINT;
VACUUM hash_cleanup_heap;
ERROR:  relation "hash_cleanup_heap" does not exist
TRUNCATE hash_cleanup_heap;
ERROR:  relation "hash_cleanup_heap" does not exist
-- Insert tuples to both the primary bucket page and overflow pages.
INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(1, 500) as i;
ERROR:  relation "hash_cleanup_heap" does not exist
LINE 1: INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(...
                    ^
-- Fill overflow pages by "dead" tuples.
BEGIN;
INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(1, 1500) as i;
ERROR:  relation "hash_cleanup_heap" does not exist
LINE 1: INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(...
                    ^
ROLLBACK;
-- And insert some tuples again. During squeeze operation, these will be moved
-- to other overflow pages and also allow overflow pages filled by dead tuples
-- to be freed. Note the main purpose of this test is to test the case where
-- we don't need to move any tuple from the overflow page being freed.
INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(1, 50) as i;
ERROR:  relation "hash_cleanup_heap" does not exist
LINE 1: INSERT INTO hash_cleanup_heap SELECT 1 FROM generate_series(...
                    ^
CHECKPOINT;
VACUUM hash_cleanup_heap;
ERROR:  relation "hash_cleanup_heap" does not exist
-- Clean up.
DROP TABLE hash_cleanup_heap;
ERROR:  table "hash_cleanup_heap" does not exist
-- Index on temp table.
CREATE TEMP TABLE hash_temp_heap (x int, y int);
INSERT INTO hash_temp_heap VALUES (1,1);
CREATE INDEX hash_idx ON hash_temp_heap USING hash (x);
DROP TABLE hash_temp_heap CASCADE;
-- Float4 type.
CREATE TABLE hash_heap_float4 (x float4, y int);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE hash_heap_float4 (x float4, y int);
                     ^
INSERT INTO hash_heap_float4 VALUES (1.1,1);
ERROR:  relation "hash_heap_float4" does not exist
LINE 1: INSERT INTO hash_heap_float4 VALUES (1.1,1);
                    ^
CREATE INDEX hash_idx ON hash_heap_float4 USING hash (x);
ERROR:  relation "hash_heap_float4" does not exist
DROP TABLE hash_heap_float4 CASCADE;
ERROR:  table "hash_heap_float4" does not exist
-- Test out-of-range fillfactor values
CREATE INDEX hash_f8_index2 ON hash_f8_heap USING hash (random float8_ops)
	WITH (fillfactor=9);
ERROR:  relation "hash_f8_heap" does not exist
CREATE INDEX hash_f8_index2 ON hash_f8_heap USING hash (random float8_ops)
	WITH (fillfactor=101);
ERROR:  relation "hash_f8_heap" does not exist
-- END setup from hash_index 
-- START setup from brin
 
CREATE TABLE brintest (byteacol bytea,
	charcol "char",
	namecol name,
	int8col bigint,
	int2col smallint,
	int4col integer,
	textcol text,
	oidcol oid,
	tidcol tid,
	float4col real,
	float8col double precision,
	macaddrcol macaddr,
	inetcol inet,
	cidrcol cidr,
	bpcharcol character,
	datecol date,
	timecol time without time zone,
	timestampcol timestamp without time zone,
	timestamptzcol timestamp with time zone,
	intervalcol interval,
	timetzcol time with time zone,
	bitcol bit(10),
	varbitcol bit varying(16),
	numericcol numeric,
	uuidcol uuid,
	int4rangecol int4range,
	lsncol pg_lsn,
	boxcol box
) WITH (fillfactor=10, autovacuum_enabled=off);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE brintest (byteacol bytea,
                     ^
INSERT INTO brintest SELECT
	repeat(stringu1, 8)::bytea,
	substr(stringu1, 1, 1)::"char",
	stringu1::name, 142857 * tenthous,
	thousand,
	twothousand,
	repeat(stringu1, 8),
	unique1::oid,
	format('(%s,%s)', tenthous, twenty)::tid,
	(four + 1.0)/(hundred+1),
	odd::float8 / (tenthous + 1),
	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr,
	inet '10.2.3.4/24' + tenthous,
	cidr '10.2.3/24' + tenthous,
	substr(stringu1, 1, 1)::bpchar,
	date '1995-08-15' + tenthous,
	time '01:20:30' + thousand * interval '18.5 second',
	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours',
	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour',
	justify_days(justify_hours(tenthous * interval '12 minutes')),
	timetz '01:30:20+02' + hundred * interval '15 seconds',
	thousand::bit(10),
	tenthous::bit(16)::varbit,
	tenthous::numeric(36,30) * fivethous * even / (hundred + 1),
	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid,
	int4range(thousand, twothousand),
	format('%s/%s%s', odd, even, tenthous)::pg_lsn,
	box(point(odd, even), point(thousand, twothousand))
FROM tenk1 ORDER BY unique2 LIMIT 100;
ERROR:  relation "brintest" does not exist
LINE 1: INSERT INTO brintest SELECT
                    ^
-- throw in some NULL's and different values
INSERT INTO brintest (inetcol, cidrcol, int4rangecol) SELECT
	inet 'fe80::6e40:8ff:fea9:8c46' + tenthous,
	cidr 'fe80::6e40:8ff:fea9:8c46' + tenthous,
	'empty'::int4range
FROM tenk1 ORDER BY thousand, tenthous LIMIT 25;
ERROR:  relation "brintest" does not exist
LINE 1: INSERT INTO brintest (inetcol, cidrcol, int4rangecol) SELECT
                    ^
CREATE INDEX brinidx ON brintest USING brin (
	byteacol,
	charcol,
	namecol,
	int8col,
	int2col,
	int4col,
	textcol,
	oidcol,
	tidcol,
	float4col,
	float8col,
	macaddrcol,
	inetcol inet_inclusion_ops,
	inetcol inet_minmax_ops,
	cidrcol inet_inclusion_ops,
	cidrcol inet_minmax_ops,
	bpcharcol,
	datecol,
	timecol,
	timestampcol,
	timestamptzcol,
	intervalcol,
	timetzcol,
	bitcol,
	varbitcol,
	numericcol,
	uuidcol,
	int4rangecol,
	lsncol,
	boxcol
) with (pages_per_range = 1);
ERROR:  relation "brintest" does not exist
CREATE TABLE brinopers (colname name, typ text,
	op text[], value text[], matches int[],
	check (cardinality(op) = cardinality(value)),
	check (cardinality(op) = cardinality(matches)));
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE brinopers (colname name, typ text,
                     ^
INSERT INTO brinopers VALUES
	('byteacol', 'bytea',
	 '{>, >=, =, <=, <}',
	 '{AAAAAA, AAAAAA, BNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAA, ZZZZZZ, ZZZZZZ}',
	 '{100, 100, 1, 100, 100}'),
	('charcol', '"char"',
	 '{>, >=, =, <=, <}',
	 '{A, A, M, Z, Z}',
	 '{97, 100, 6, 100, 98}'),
	('namecol', 'name',
	 '{>, >=, =, <=, <}',
	 '{AAAAAA, AAAAAA, MAAAAA, ZZAAAA, ZZAAAA}',
	 '{100, 100, 2, 100, 100}'),
	('int2col', 'int2',
	 '{>, >=, =, <=, <}',
	 '{0, 0, 800, 999, 999}',
	 '{100, 100, 1, 100, 100}'),
	('int2col', 'int4',
	 '{>, >=, =, <=, <}',
	 '{0, 0, 800, 999, 1999}',
	 '{100, 100, 1, 100, 100}'),
	('int2col', 'int8',
	 '{>, >=, =, <=, <}',
	 '{0, 0, 800, 999, 1428427143}',
	 '{100, 100, 1, 100, 100}'),
	('int4col', 'int2',
	 '{>, >=, =, <=, <}',
	 '{0, 0, 800, 1999, 1999}',
	 '{100, 100, 1, 100, 100}'),
	('int4col', 'int4',
	 '{>, >=, =, <=, <}',
	 '{0, 0, 800, 1999, 1999}',
	 '{100, 100, 1, 100, 100}'),
	('int4col', 'int8',
	 '{>, >=, =, <=, <}',
	 '{0, 0, 800, 1999, 1428427143}',
	 '{100, 100, 1, 100, 100}'),
	('int8col', 'int2',
	 '{>, >=}',
	 '{0, 0}',
	 '{100, 100}'),
	('int8col', 'int4',
	 '{>, >=}',
	 '{0, 0}',
	 '{100, 100}'),
	('int8col', 'int8',
	 '{>, >=, =, <=, <}',
	 '{0, 0, 1257141600, 1428427143, 1428427143}',
	 '{100, 100, 1, 100, 100}'),
	('textcol', 'text',
	 '{>, >=, =, <=, <}',
	 '{ABABAB, ABABAB, BNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAABNAAAA, ZZAAAA, ZZAAAA}',
	 '{100, 100, 1, 100, 100}'),
	('oidcol', 'oid',
	 '{>, >=, =, <=, <}',
	 '{0, 0, 8800, 9999, 9999}',
	 '{100, 100, 1, 100, 100}'),
	('tidcol', 'tid',
	 '{>, >=, =, <=, <}',
	 '{"(0,0)", "(0,0)", "(8800,0)", "(9999,19)", "(9999,19)"}',
	 '{100, 100, 1, 100, 100}'),
	('float4col', 'float4',
	 '{>, >=, =, <=, <}',
	 '{0.0103093, 0.0103093, 1, 1, 1}',
	 '{100, 100, 4, 100, 96}'),
	('float4col', 'float8',
	 '{>, >=, =, <=, <}',
	 '{0.0103093, 0.0103093, 1, 1, 1}',
	 '{100, 100, 4, 100, 96}'),
	('float8col', 'float4',
	 '{>, >=, =, <=, <}',
	 '{0, 0, 0, 1.98, 1.98}',
	 '{99, 100, 1, 100, 100}'),
	('float8col', 'float8',
	 '{>, >=, =, <=, <}',
	 '{0, 0, 0, 1.98, 1.98}',
	 '{99, 100, 1, 100, 100}'),
	('macaddrcol', 'macaddr',
	 '{>, >=, =, <=, <}',
	 '{00:00:01:00:00:00, 00:00:01:00:00:00, 2c:00:2d:00:16:00, ff:fe:00:00:00:00, ff:fe:00:00:00:00}',
	 '{99, 100, 2, 100, 100}'),
	('inetcol', 'inet',
	 '{&&, =, <, <=, >, >=, >>=, >>, <<=, <<}',
	 '{10/8, 10.2.14.231/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14.231/24, 10.2.14.231/25, 10.2.14.231/8, 0/0}',
	 '{100, 1, 100, 100, 125, 125, 2, 2, 100, 100}'),
	('inetcol', 'inet',
	 '{&&, >>=, <<=, =}',
	 '{fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46, fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46}',
	 '{25, 1, 25, 1}'),
	('inetcol', 'cidr',
	 '{&&, <, <=, >, >=, >>=, >>, <<=, <<}',
	 '{10/8, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14/24, 10.2.14/25, 10/8, 0/0}',
	 '{100, 100, 100, 125, 125, 2, 2, 100, 100}'),
	('inetcol', 'cidr',
	 '{&&, >>=, <<=, =}',
	 '{fe80::/32, fe80::6e40:8ff:fea9:8c46, fe80::/32, fe80::6e40:8ff:fea9:8c46}',
	 '{25, 1, 25, 1}'),
	('cidrcol', 'inet',
	 '{&&, =, <, <=, >, >=, >>=, >>, <<=, <<}',
	 '{10/8, 10.2.14/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14.231/24, 10.2.14.231/25, 10.2.14.231/8, 0/0}',
	 '{100, 2, 100, 100, 125, 125, 2, 2, 100, 100}'),
	('cidrcol', 'inet',
	 '{&&, >>=, <<=, =}',
	 '{fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46, fe80::6e40:8ff:fea9:a673/32, fe80::6e40:8ff:fea9:8c46}',
	 '{25, 1, 25, 1}'),
	('cidrcol', 'cidr',
	 '{&&, =, <, <=, >, >=, >>=, >>, <<=, <<}',
	 '{10/8, 10.2.14/24, 255.255.255.255, 255.255.255.255, 0.0.0.0, 0.0.0.0, 10.2.14/24, 10.2.14/25, 10/8, 0/0}',
	 '{100, 2, 100, 100, 125, 125, 2, 2, 100, 100}'),
	('cidrcol', 'cidr',
	 '{&&, >>=, <<=, =}',
	 '{fe80::/32, fe80::6e40:8ff:fea9:8c46, fe80::/32, fe80::6e40:8ff:fea9:8c46}',
	 '{25, 1, 25, 1}'),
	('bpcharcol', 'bpchar',
	 '{>, >=, =, <=, <}',
	 '{A, A, W, Z, Z}',
	 '{97, 100, 6, 100, 98}'),
	('datecol', 'date',
	 '{>, >=, =, <=, <}',
	 '{1995-08-15, 1995-08-15, 2009-12-01, 2022-12-30, 2022-12-30}',
	 '{100, 100, 1, 100, 100}'),
	('timecol', 'time',
	 '{>, >=, =, <=, <}',
	 '{01:20:30, 01:20:30, 02:28:57, 06:28:31.5, 06:28:31.5}',
	 '{100, 100, 1, 100, 100}'),
	('timestampcol', 'timestamp',
	 '{>, >=, =, <=, <}',
	 '{1942-07-23 03:05:09, 1942-07-23 03:05:09, 1964-03-24 19:26:45, 1984-01-20 22:42:21, 1984-01-20 22:42:21}',
	 '{100, 100, 1, 100, 100}'),
	('timestampcol', 'timestamptz',
	 '{>, >=, =, <=, <}',
	 '{1942-07-23 03:05:09, 1942-07-23 03:05:09, 1964-03-24 19:26:45, 1984-01-20 22:42:21, 1984-01-20 22:42:21}',
	 '{100, 100, 1, 100, 100}'),
	('timestamptzcol', 'timestamptz',
	 '{>, >=, =, <=, <}',
	 '{1972-10-10 03:00:00-04, 1972-10-10 03:00:00-04, 1972-10-19 09:00:00-07, 1972-11-20 19:00:00-03, 1972-11-20 19:00:00-03}',
	 '{100, 100, 1, 100, 100}'),
	('intervalcol', 'interval',
	 '{>, >=, =, <=, <}',
	 '{00:00:00, 00:00:00, 1 mons 13 days 12:24, 2 mons 23 days 07:48:00, 1 year}',
	 '{100, 100, 1, 100, 100}'),
	('timetzcol', 'timetz',
	 '{>, >=, =, <=, <}',
	 '{01:30:20+02, 01:30:20+02, 01:35:50+02, 23:55:05+02, 23:55:05+02}',
	 '{99, 100, 2, 100, 100}'),
	('bitcol', 'bit(10)',
	 '{>, >=, =, <=, <}',
	 '{0000000010, 0000000010, 0011011110, 1111111000, 1111111000}',
	 '{100, 100, 1, 100, 100}'),
	('varbitcol', 'varbit(16)',
	 '{>, >=, =, <=, <}',
	 '{0000000000000100, 0000000000000100, 0001010001100110, 1111111111111000, 1111111111111000}',
	 '{100, 100, 1, 100, 100}'),
	('numericcol', 'numeric',
	 '{>, >=, =, <=, <}',
	 '{0.00, 0.01, 2268164.347826086956521739130434782609, 99470151.9, 99470151.9}',
	 '{100, 100, 1, 100, 100}'),
	('uuidcol', 'uuid',
	 '{>, >=, =, <=, <}',
	 '{00040004-0004-0004-0004-000400040004, 00040004-0004-0004-0004-000400040004, 52225222-5222-5222-5222-522252225222, 99989998-9998-9998-9998-999899989998, 99989998-9998-9998-9998-999899989998}',
	 '{100, 100, 1, 100, 100}'),
	('int4rangecol', 'int4range',
	 '{<<, &<, &&, &>, >>, @>, <@, =, <, <=, >, >=}',
	 '{"[10000,)","[10000,)","(,]","[3,4)","[36,44)","(1500,1501]","[3,4)","[222,1222)","[36,44)","[43,1043)","[367,4466)","[519,)"}',
	 '{53, 53, 53, 53, 50, 22, 72, 1, 74, 75, 34, 21}'),
	('int4rangecol', 'int4range',
	 '{@>, <@, =, <=, >, >=}',
	 '{empty, empty, empty, empty, empty, empty}',
	 '{125, 72, 72, 72, 53, 125}'),
	('int4rangecol', 'int4',
	 '{@>}',
	 '{1500}',
	 '{22}'),
	('lsncol', 'pg_lsn',
	 '{>, >=, =, <=, <, IS, IS NOT}',
	 '{0/1200, 0/1200, 44/455222, 198/1999799, 198/1999799, NULL, NULL}',
	 '{100, 100, 1, 100, 100, 25, 100}'),
	('boxcol', 'point',
	 '{@>}',
	 '{"(500,43)"}',
	 '{11}'),
	('boxcol', 'box',
	 '{<<, &<, &&, &>, >>, <<|, &<|, |&>, |>>, @>, <@, ~=}',
	 '{"((1000,2000),(3000,4000))","((1,2),(3000,4000))","((1,2),(3000,4000))","((1,2),(3000,4000))","((1,2),(3,4))","((1000,2000),(3000,4000))","((1,2000),(3,4000))","((1000,2),(3000,4))","((1,2),(3,4))","((1,2),(300,400))","((1,2),(3000,4000))","((222,1222),(44,45))"}',
	 '{100, 100, 100, 99, 96, 100, 100, 99, 96, 1, 99, 1}');
ERROR:  relation "brinopers" does not exist
LINE 1: INSERT INTO brinopers VALUES
                    ^
DO $x$
DECLARE
	r record;
	r2 record;
	cond text;
	idx_ctids tid[];
	ss_ctids tid[];
	count int;
	plan_ok bool;
	plan_line text;
BEGIN
	FOR r IN SELECT colname, oper, typ, value[ordinality], matches[ordinality] FROM brinopers, unnest(op) WITH ORDINALITY AS oper LOOP

		-- prepare the condition
		IF r.value IS NULL THEN
			cond := format('%I %s %L', r.colname, r.oper, r.value);
		ELSE
			cond := format('%I %s %L::%s', r.colname, r.oper, r.value, r.typ);
		END IF;

		-- run the query using the brin index
		SET enable_seqscan = 0;
		SET enable_bitmapscan = 1;

		plan_ok := false;
		FOR plan_line IN EXECUTE format($y$EXPLAIN SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) LOOP
			IF plan_line LIKE '%Bitmap Heap Scan on brintest%' THEN
				plan_ok := true;
			END IF;
		END LOOP;
		IF NOT plan_ok THEN
			RAISE WARNING 'did not get bitmap indexscan plan for %', r;
		END IF;

		EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond)
			INTO idx_ctids;

		-- run the query using a seqscan
		SET enable_seqscan = 1;
		SET enable_bitmapscan = 0;

		plan_ok := false;
		FOR plan_line IN EXECUTE format($y$EXPLAIN SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond) LOOP
			IF plan_line LIKE '%Seq Scan on brintest%' THEN
				plan_ok := true;
			END IF;
		END LOOP;
		IF NOT plan_ok THEN
			RAISE WARNING 'did not get seqscan plan for %', r;
		END IF;

		EXECUTE format($y$SELECT array_agg(ctid) FROM brintest WHERE %s $y$, cond)
			INTO ss_ctids;

		-- make sure both return the same results
		count := array_length(idx_ctids, 1);

		IF NOT (count = array_length(ss_ctids, 1) AND
				idx_ctids @> ss_ctids AND
				idx_ctids <@ ss_ctids) THEN
			-- report the results of each scan to make the differences obvious
			RAISE WARNING 'something not right in %: count %', r, count;
			SET enable_seqscan = 1;
			SET enable_bitmapscan = 0;
			FOR r2 IN EXECUTE 'SELECT ' || r.colname || ' FROM brintest WHERE ' || cond LOOP
				RAISE NOTICE 'seqscan: %', r2;
			END LOOP;

			SET enable_seqscan = 0;
			SET enable_bitmapscan = 1;
			FOR r2 IN EXECUTE 'SELECT ' || r.colname || ' FROM brintest WHERE ' || cond LOOP
				RAISE NOTICE 'bitmapscan: %', r2;
			END LOOP;
		END IF;

		-- make sure we found expected number of matches
		IF count != r.matches THEN RAISE WARNING 'unexpected number of results % for %', count, r; END IF;
	END LOOP;
END;
$x$;
ERROR:  relation "brinopers" does not exist
LINE 1: ... typ, value[ordinality], matches[ordinality] FROM brinopers,...
                                                             ^
QUERY:  SELECT colname, oper, typ, value[ordinality], matches[ordinality] FROM brinopers, unnest(op) WITH ORDINALITY AS oper
CONTEXT:  PL/pgSQL function inline_code_block line 12 at FOR over SELECT rows
RESET enable_seqscan;
RESET enable_bitmapscan;
INSERT INTO brintest SELECT
	repeat(stringu1, 42)::bytea,
	substr(stringu1, 1, 1)::"char",
	stringu1::name, 142857 * tenthous,
	thousand,
	twothousand,
	repeat(stringu1, 42),
	unique1::oid,
	format('(%s,%s)', tenthous, twenty)::tid,
	(four + 1.0)/(hundred+1),
	odd::float8 / (tenthous + 1),
	format('%s:00:%s:00:%s:00', to_hex(odd), to_hex(even), to_hex(hundred))::macaddr,
	inet '10.2.3.4' + tenthous,
	cidr '10.2.3/24' + tenthous,
	substr(stringu1, 1, 1)::bpchar,
	date '1995-08-15' + tenthous,
	time '01:20:30' + thousand * interval '18.5 second',
	timestamp '1942-07-23 03:05:09' + tenthous * interval '36.38 hours',
	timestamptz '1972-10-10 03:00' + thousand * interval '1 hour',
	justify_days(justify_hours(tenthous * interval '12 minutes')),
	timetz '01:30:20' + hundred * interval '15 seconds',
	thousand::bit(10),
	tenthous::bit(16)::varbit,
	tenthous::numeric(36,30) * fivethous * even / (hundred + 1),
	format('%s%s-%s-%s-%s-%s%s%s', to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'), to_char(tenthous, 'FM0000'))::uuid,
	int4range(thousand, twothousand),
	format('%s/%s%s', odd, even, tenthous)::pg_lsn,
	box(point(odd, even), point(thousand, twothousand))
FROM tenk1 ORDER BY unique2 LIMIT 5 OFFSET 5;
ERROR:  relation "brintest" does not exist
LINE 1: INSERT INTO brintest SELECT
                    ^
SELECT brin_desummarize_range('brinidx', 0);
ERROR:  relation "brinidx" does not exist
LINE 1: SELECT brin_desummarize_range('brinidx', 0);
                                      ^
VACUUM brintest;  -- force a summarization cycle in brinidx
ERROR:  relation "brintest" does not exist
UPDATE brintest SET int8col = int8col * int4col;
ERROR:  relation "brintest" does not exist
LINE 1: UPDATE brintest SET int8col = int8col * int4col;
               ^
UPDATE brintest SET textcol = '' WHERE textcol IS NOT NULL;
ERROR:  relation "brintest" does not exist
LINE 1: UPDATE brintest SET textcol = '' WHERE textcol IS NOT NULL;
               ^
-- Tests for brin_summarize_new_values
SELECT brin_summarize_new_values('brintest'); -- error, not an index
ERROR:  relation "brintest" does not exist
LINE 1: SELECT brin_summarize_new_values('brintest');
                                         ^
SELECT brin_summarize_new_values('tenk1_unique1'); -- error, not a BRIN index
ERROR:  relation "tenk1_unique1" does not exist
LINE 1: SELECT brin_summarize_new_values('tenk1_unique1');
                                         ^
SELECT brin_summarize_new_values('brinidx'); -- ok, no change expected
ERROR:  relation "brinidx" does not exist
LINE 1: SELECT brin_summarize_new_values('brinidx');
                                         ^
-- Tests for brin_desummarize_range
SELECT brin_desummarize_range('brinidx', -1); -- error, invalid range
ERROR:  relation "brinidx" does not exist
LINE 1: SELECT brin_desummarize_range('brinidx', -1);
                                      ^
SELECT brin_desummarize_range('brinidx', 0);
ERROR:  relation "brinidx" does not exist
LINE 1: SELECT brin_desummarize_range('brinidx', 0);
                                      ^
SELECT brin_desummarize_range('brinidx', 0);
ERROR:  relation "brinidx" does not exist
LINE 1: SELECT brin_desummarize_range('brinidx', 0);
                                      ^
SELECT brin_desummarize_range('brinidx', 100000000);
ERROR:  relation "brinidx" does not exist
LINE 1: SELECT brin_desummarize_range('brinidx', 100000000);
                                      ^
-- Test brin_summarize_range
CREATE TABLE brin_summarize (
    value int
) WITH (fillfactor=10, autovacuum_enabled=false);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE brin_summarize (
                     ^
CREATE INDEX brin_summarize_idx ON brin_summarize USING brin (value) WITH (pages_per_range=2);
ERROR:  relation "brin_summarize" does not exist
-- Fill a few pages
DO $$
DECLARE curtid tid;
BEGIN
  LOOP
    INSERT INTO brin_summarize VALUES (1) RETURNING ctid INTO curtid;
    EXIT WHEN curtid > tid '(2, 0)';
  END LOOP;
END;
$$;
ERROR:  relation "brin_summarize" does not exist
LINE 1: INSERT INTO brin_summarize VALUES (1) RETURNING ctid
                    ^
QUERY:  INSERT INTO brin_summarize VALUES (1) RETURNING ctid
CONTEXT:  PL/pgSQL function inline_code_block line 5 at SQL statement
-- summarize one range
SELECT brin_summarize_range('brin_summarize_idx', 0);
ERROR:  relation "brin_summarize_idx" does not exist
LINE 1: SELECT brin_summarize_range('brin_summarize_idx', 0);
                                    ^
-- nothing: already summarized
SELECT brin_summarize_range('brin_summarize_idx', 1);
ERROR:  relation "brin_summarize_idx" does not exist
LINE 1: SELECT brin_summarize_range('brin_summarize_idx', 1);
                                    ^
-- summarize one range
SELECT brin_summarize_range('brin_summarize_idx', 2);
ERROR:  relation "brin_summarize_idx" does not exist
LINE 1: SELECT brin_summarize_range('brin_summarize_idx', 2);
                                    ^
-- nothing: page doesn't exist in table
SELECT brin_summarize_range('brin_summarize_idx', 4294967295);
ERROR:  relation "brin_summarize_idx" does not exist
LINE 1: SELECT brin_summarize_range('brin_summarize_idx', 4294967295...
                                    ^
-- invalid block number values
SELECT brin_summarize_range('brin_summarize_idx', -1);
ERROR:  relation "brin_summarize_idx" does not exist
LINE 1: SELECT brin_summarize_range('brin_summarize_idx', -1);
                                    ^
SELECT brin_summarize_range('brin_summarize_idx', 4294967296);
ERROR:  relation "brin_summarize_idx" does not exist
LINE 1: SELECT brin_summarize_range('brin_summarize_idx', 4294967296...
                                    ^
-- test value merging in add_value
CREATE TABLE brintest_2 (n numrange);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE brintest_2 (n numrange);
                     ^
CREATE INDEX brinidx_2 ON brintest_2 USING brin (n);
ERROR:  relation "brintest_2" does not exist
INSERT INTO brintest_2 VALUES ('empty');
ERROR:  relation "brintest_2" does not exist
LINE 1: INSERT INTO brintest_2 VALUES ('empty');
                    ^
INSERT INTO brintest_2 VALUES (numrange(0, 2^1000::numeric));
ERROR:  relation "brintest_2" does not exist
LINE 1: INSERT INTO brintest_2 VALUES (numrange(0, 2^1000::numeric))...
                    ^
INSERT INTO brintest_2 VALUES ('(-1, 0)');
ERROR:  relation "brintest_2" does not exist
LINE 1: INSERT INTO brintest_2 VALUES ('(-1, 0)');
                    ^
SELECT brin_desummarize_range('brinidx', 0);
ERROR:  relation "brinidx" does not exist
LINE 1: SELECT brin_desummarize_range('brinidx', 0);
                                      ^
SELECT brin_summarize_range('brinidx', 0);
ERROR:  relation "brinidx" does not exist
LINE 1: SELECT brin_summarize_range('brinidx', 0);
                                    ^
DROP TABLE brintest_2;
ERROR:  table "brintest_2" does not exist
-- test brin cost estimates behave sanely based on correlation of values
CREATE TABLE brin_test (a INT, b INT);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE brin_test (a INT, b INT);
                     ^
INSERT INTO brin_test SELECT x/100,x%100 FROM generate_series(1,10000) x(x);
ERROR:  relation "brin_test" does not exist
LINE 1: INSERT INTO brin_test SELECT x/100,x%100 FROM generate_serie...
                    ^
CREATE INDEX brin_test_a_idx ON brin_test USING brin (a) WITH (pages_per_range = 2);
ERROR:  relation "brin_test" does not exist
CREATE INDEX brin_test_b_idx ON brin_test USING brin (b) WITH (pages_per_range = 2);
ERROR:  relation "brin_test" does not exist
VACUUM ANALYZE brin_test;
ERROR:  relation "brin_test" does not exist
-- Ensure brin index is used when columns are perfectly correlated
EXPLAIN (COSTS OFF) SELECT * FROM brin_test WHERE a = 1;
ERROR:  relation "brin_test" does not exist
LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM brin_test WHERE a = 1;
                                          ^
-- Ensure brin index is not used when values are not correlated
EXPLAIN (COSTS OFF) SELECT * FROM brin_test WHERE b = 1;
ERROR:  relation "brin_test" does not exist
LINE 1: EXPLAIN (COSTS OFF) SELECT * FROM brin_test WHERE b = 1;
                                          ^
-- make sure data are properly de-toasted in BRIN index
CREATE TABLE brintest_3 (a text, b text, c text, d text);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE brintest_3 (a text, b text, c text, d text);
                     ^
-- long random strings (~2000 chars each, so ~6kB for min/max on two
-- columns) to trigger toasting
WITH rand_value AS (SELECT string_agg(fipshash(i::text),'') AS val FROM generate_series(1,60) s(i))
INSERT INTO brintest_3
SELECT val, val, val, val FROM rand_value;
ERROR:  function fipshash(text) does not exist
LINE 1: WITH rand_value AS (SELECT string_agg(fipshash(i::text),'') ...
                                              ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
CREATE INDEX brin_test_toast_idx ON brintest_3 USING brin (b, c);
ERROR:  relation "brintest_3" does not exist
DELETE FROM brintest_3;
ERROR:  relation "brintest_3" does not exist
LINE 1: DELETE FROM brintest_3;
                    ^
-- We need to wait a bit for all transactions to complete, so that the
-- vacuum actually removes the TOAST rows. Creating an index concurrently
-- is a one way to achieve that, because it does exactly such wait.
CREATE INDEX CONCURRENTLY brin_test_temp_idx ON brintest_3(a);
ERROR:  relation "brintest_3" does not exist
DROP INDEX brin_test_temp_idx;
ERROR:  index "brin_test_temp_idx" does not exist
-- vacuum the table, to discard TOAST data
VACUUM brintest_3;
ERROR:  relation "brintest_3" does not exist
-- retry insert with a different random-looking (but deterministic) value
-- the value is different, and so should replace either min or max in the
-- brin summary
WITH rand_value AS (SELECT string_agg(fipshash((-i)::text),'') AS val FROM generate_series(1,60) s(i))
INSERT INTO brintest_3
SELECT val, val, val, val FROM rand_value;
ERROR:  function fipshash(text) does not exist
LINE 1: WITH rand_value AS (SELECT string_agg(fipshash((-i)::text),'...
                                              ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- now try some queries, accessing the brin index
SET enable_seqscan = off;
EXPLAIN (COSTS OFF)
SELECT * FROM brintest_3 WHERE b < '0';
ERROR:  relation "brintest_3" does not exist
LINE 2: SELECT * FROM brintest_3 WHERE b < '0';
                      ^
SELECT * FROM brintest_3 WHERE b < '0';
ERROR:  relation "brintest_3" does not exist
LINE 1: SELECT * FROM brintest_3 WHERE b < '0';
                      ^
DROP TABLE brintest_3;
ERROR:  table "brintest_3" does not exist
RESET enable_seqscan;
-- test an unlogged table, mostly to get coverage of brinbuildempty
CREATE UNLOGGED TABLE brintest_unlogged (n numrange);
ERROR:  no schema has been selected to create in
LINE 1: CREATE UNLOGGED TABLE brintest_unlogged (n numrange);
                              ^
CREATE INDEX brinidx_unlogged ON brintest_unlogged USING brin (n);
ERROR:  relation "brintest_unlogged" does not exist
INSERT INTO brintest_unlogged VALUES (numrange(0, 2^1000::numeric));
ERROR:  relation "brintest_unlogged" does not exist
LINE 1: INSERT INTO brintest_unlogged VALUES (numrange(0, 2^1000::nu...
                    ^
DROP TABLE brintest_unlogged;
ERROR:  table "brintest_unlogged" does not exist
-- test that the insert optimization works if no rows end up inserted
CREATE TABLE brin_insert_optimization (a int);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE brin_insert_optimization (a int);
                     ^
INSERT INTO brin_insert_optimization VALUES (1);
ERROR:  relation "brin_insert_optimization" does not exist
LINE 1: INSERT INTO brin_insert_optimization VALUES (1);
                    ^
CREATE INDEX ON brin_insert_optimization USING brin (a);
ERROR:  relation "brin_insert_optimization" does not exist
UPDATE brin_insert_optimization SET a = a;
ERROR:  relation "brin_insert_optimization" does not exist
LINE 1: UPDATE brin_insert_optimization SET a = a;
               ^
DROP TABLE brin_insert_optimization;
ERROR:  table "brin_insert_optimization" does not exist
-- END setup from brin
 
