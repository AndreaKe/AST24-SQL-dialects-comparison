--
-- BTREE_INDEX
--

-- directory paths are passed to us in environment variables
-- \getenv abs_srcdir ''/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests''

CREATE TABLE bt_i4_heap (
	seqno 		int4,
	random 		int4
)


CREATE TABLE bt_name_heap (
	seqno 		name,
	random 		int4
)
ERROR: 

CREATE TABLE bt_name_heap (
	seqno 		name,
	random 		int4
)

Catalog Error: Type with name name does not exist!
Did you mean "date"?


CREATE TABLE bt_txt_heap (
	seqno 		text,
	random 		int4
)


CREATE TABLE bt_f8_heap (
	seqno 		float8,
	random 		int4
)


-- \set filename /* REPLACED */ ''/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests'' ''/data/desc.data''
COPY bt_i4_heap FROM /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests/data/desc.data'


-- \set filename /* REPLACED */ ''/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests'' ''/data/hash.data''
COPY bt_name_heap FROM /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests/data/hash.data'
ERROR: 

-- \set filename /* REPLACED */ ''/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests'' ''/data/hash.data''
COPY bt_name_heap FROM /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests/data/hash.data'

Catalog Error: Table with name bt_name_heap does not exist!
Did you mean "bt_f8_heap"?


-- \set filename /* REPLACED */ ''/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests'' ''/data/desc.data''
COPY bt_txt_heap FROM /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests/data/desc.data'


-- \set filename /* REPLACED */ ''/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests'' ''/data/hash.data''
COPY bt_f8_heap FROM /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests/data/hash.data'


ANALYZE bt_i4_heap

ANALYZE bt_name_heap
ERROR: 
ANALYZE bt_name_heap

Catalog Error: Table with name bt_name_heap does not exist!
Did you mean "bt_f8_heap"?
LINE 2: ANALYZE bt_name_heap
                ^

ANALYZE bt_txt_heap

ANALYZE bt_f8_heap


--
-- BTREE ascending/descending cases
--
-- we load int4/text from pure descending data (each key is a new
-- low key) and name/f8 from pure ascending data (each key is a new
-- high key).  we had a bug where new low keys would sometimes be
-- ''lost''.
--
CREATE INDEX bt_i4_index ON bt_i4_heap USING btree (seqno int4_ops)
ERROR: 

--
-- BTREE ascending/descending cases
--
-- we load int4/text from pure descending data (each key is a new
-- low key) and name/f8 from pure ascending data (each key is a new
-- high key).  we had a bug where new low keys would sometimes be
-- ''lost''.
--
CREATE INDEX bt_i4_index ON bt_i4_heap USING btree (seqno int4_ops)

Not implemented Error: Index with opclass not supported yet!


CREATE INDEX bt_name_index ON bt_name_heap USING btree (seqno name_ops)
ERROR: 

CREATE INDEX bt_name_index ON bt_name_heap USING btree (seqno name_ops)

Not implemented Error: Index with opclass not supported yet!


CREATE INDEX bt_txt_index ON bt_txt_heap USING btree (seqno text_ops)
ERROR: 

CREATE INDEX bt_txt_index ON bt_txt_heap USING btree (seqno text_ops)

Not implemented Error: Index with opclass not supported yet!


CREATE INDEX bt_f8_index ON bt_f8_heap USING btree (seqno float8_ops)
ERROR: 

CREATE INDEX bt_f8_index ON bt_f8_heap USING btree (seqno float8_ops)

Not implemented Error: Index with opclass not supported yet!


--
-- test retrieval of min/max keys for each index
--

SELECT b.*
   FROM bt_i4_heap b
   WHERE b.seqno < 1
RESULT: 
	[(0, 1935401906)]


SELECT b.*
   FROM bt_i4_heap b
   WHERE b.seqno >= 9999
RESULT: 
	[(9999, 1227676208)]


SELECT b.*
   FROM bt_i4_heap b
   WHERE b.seqno = 4500
RESULT: 
	[(4500, 2080851358)]


SELECT b.*
   FROM bt_name_heap b
   WHERE b.seqno < '1'::name
ERROR: 

SELECT b.*
   FROM bt_name_heap b
   WHERE b.seqno < '1'::name

Catalog Error: Table with name bt_name_heap does not exist!
Did you mean "bt_f8_heap"?


SELECT b.*
   FROM bt_name_heap b
   WHERE b.seqno >= '9999'::name
ERROR: 

SELECT b.*
   FROM bt_name_heap b
   WHERE b.seqno >= '9999'::name

Catalog Error: Table with name bt_name_heap does not exist!
Did you mean "bt_f8_heap"?


SELECT b.*
   FROM bt_name_heap b
   WHERE b.seqno = '4500'::name
ERROR: 

SELECT b.*
   FROM bt_name_heap b
   WHERE b.seqno = '4500'::name

Catalog Error: Table with name bt_name_heap does not exist!
Did you mean "bt_f8_heap"?


SELECT b.*
   FROM bt_txt_heap b
   WHERE b.seqno < '1'::text
RESULT: 
	[('0', 1935401906)]


SELECT b.*
   FROM bt_txt_heap b
   WHERE b.seqno >= '9999'::text
RESULT: 
	[('9999', 1227676208)]


SELECT b.*
   FROM bt_txt_heap b
   WHERE b.seqno = '4500'::text
RESULT: 
	[('4500', 2080851358)]


SELECT b.*
   FROM bt_f8_heap b
   WHERE b.seqno < '1'::float8
RESULT: 
	[(0.0, 1935401906)]


SELECT b.*
   FROM bt_f8_heap b
   WHERE b.seqno >= '9999'::float8
RESULT: 
	[(9999.0, 1227676208)]


SELECT b.*
   FROM bt_f8_heap b
   WHERE b.seqno = '4500'::float8
RESULT: 
	[(4500.0, 2080851358)]


--
-- Add coverage for optimization of backwards scan index descents
--
-- Here we expect _bt_search to descend straight to a leaf page containing a
-- non-pivot tuple with the value ''47'', which comes last (after 11 similar
-- non-pivot tuples).  Query execution should only need to visit a single
-- leaf page here.
--
-- Test case relies on tenk1_hundred index having a leaf page whose high key
-- is ''(48, -inf)''.  We use a low cardinality index to make our test case less
-- sensitive to implementation details that may change in the future.
set enable_seqscan to false
ERROR: 

--
-- Add coverage for optimization of backwards scan index descents
--
-- Here we expect _bt_search to descend straight to a leaf page containing a
-- non-pivot tuple with the value ''47'', which comes last (after 11 similar
-- non-pivot tuples).  Query execution should only need to visit a single
-- leaf page here.
--
-- Test case relies on tenk1_hundred index having a leaf page whose high key
-- is ''(48, -inf)''.  We use a low cardinality index to make our test case less
-- sensitive to implementation details that may change in the future.
set enable_seqscan to false

Catalog Error: unrecognized configuration parameter "enable_seqscan"

Did you mean: "enable_object_cache"

set enable_indexscan to true
ERROR: 
set enable_indexscan to true

Catalog Error: unrecognized configuration parameter "enable_indexscan"

Did you mean: "Calendar"

set enable_bitmapscan to false
ERROR: 
set enable_bitmapscan to false

Catalog Error: unrecognized configuration parameter "enable_bitmapscan"

Did you mean: "enable_object_cache"

explain (costs off)
select hundred, twenty from tenk1 where hundred < 48 order by hundred desc limit 1
ERROR: 
explain (costs off)
select hundred, twenty from tenk1 where hundred < 48 order by hundred desc limit 1

Not implemented Error: Unimplemented explain type: costs

select hundred, twenty from tenk1 where hundred < 48 order by hundred desc limit 1
ERROR: 
select hundred, twenty from tenk1 where hundred < 48 order by hundred desc limit 1

Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?


-- This variant of the query need only return a single tuple located to the immediate
-- right of the ''(48, -inf)'' high key.  It also only needs to scan one single
-- leaf page (the right sibling of the page scanned by the last test case):
explain (costs off)
select hundred, twenty from tenk1 where hundred <= 48 order by hundred desc limit 1
ERROR: 

-- This variant of the query need only return a single tuple located to the immediate
-- right of the ''(48, -inf)'' high key.  It also only needs to scan one single
-- leaf page (the right sibling of the page scanned by the last test case):
explain (costs off)
select hundred, twenty from tenk1 where hundred <= 48 order by hundred desc limit 1

Not implemented Error: Unimplemented explain type: costs

select hundred, twenty from tenk1 where hundred <= 48 order by hundred desc limit 1
ERROR: 
select hundred, twenty from tenk1 where hundred <= 48 order by hundred desc limit 1

Catalog Error: Table with name tenk1 does not exist!
Did you mean "temp.information_schema.tables"?


--
-- Check correct optimization of LIKE (special index operator support)
-- for both indexscan and bitmapscan cases
--

set enable_seqscan to false
ERROR: 

--
-- Check correct optimization of LIKE (special index operator support)
-- for both indexscan and bitmapscan cases
--

set enable_seqscan to false

Catalog Error: unrecognized configuration parameter "enable_seqscan"

Did you mean: "enable_object_cache"

set enable_indexscan to true
ERROR: 
set enable_indexscan to true

Catalog Error: unrecognized configuration parameter "enable_indexscan"

Did you mean: "Calendar"

set enable_bitmapscan to false
ERROR: 
set enable_bitmapscan to false

Catalog Error: unrecognized configuration parameter "enable_bitmapscan"

Did you mean: "enable_object_cache"

explain (costs off)
select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1
ERROR: 
explain (costs off)
select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1

Not implemented Error: Unimplemented explain type: costs

select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1
RESULT: 
	[]

explain (costs off)
select proname from pg_proc where proname ilike '00%foo' order by 1
ERROR: 
explain (costs off)
select proname from pg_proc where proname ilike '00%foo' order by 1

Not implemented Error: Unimplemented explain type: costs

select proname from pg_proc where proname ilike '00%foo' order by 1
RESULT: 
	[]

explain (costs off)
select proname from pg_proc where proname ilike 'ri%foo' order by 1
ERROR: 
explain (costs off)
select proname from pg_proc where proname ilike 'ri%foo' order by 1

Not implemented Error: Unimplemented explain type: costs


set enable_indexscan to false
ERROR: 

set enable_indexscan to false

Catalog Error: unrecognized configuration parameter "enable_indexscan"

Did you mean: "Calendar"

set enable_bitmapscan to true
ERROR: 
set enable_bitmapscan to true

Catalog Error: unrecognized configuration parameter "enable_bitmapscan"

Did you mean: "enable_object_cache"

explain (costs off)
select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1
ERROR: 
explain (costs off)
select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1

Not implemented Error: Unimplemented explain type: costs

select proname from pg_proc where proname like E'RI\\_FKey%del' order by 1
RESULT: 
	[]

explain (costs off)
select proname from pg_proc where proname ilike '00%foo' order by 1
ERROR: 
explain (costs off)
select proname from pg_proc where proname ilike '00%foo' order by 1

Not implemented Error: Unimplemented explain type: costs

select proname from pg_proc where proname ilike '00%foo' order by 1
RESULT: 
	[]

explain (costs off)
select proname from pg_proc where proname ilike 'ri%foo' order by 1
ERROR: 
explain (costs off)
select proname from pg_proc where proname ilike 'ri%foo' order by 1

Not implemented Error: Unimplemented explain type: costs


reset enable_seqscan
ERROR: 

reset enable_seqscan

Catalog Error: unrecognized configuration parameter "enable_seqscan"

Did you mean: "enable_object_cache"

reset enable_indexscan
ERROR: 
reset enable_indexscan

Catalog Error: unrecognized configuration parameter "enable_indexscan"

Did you mean: "Calendar"

reset enable_bitmapscan
ERROR: 
reset enable_bitmapscan

Catalog Error: unrecognized configuration parameter "enable_bitmapscan"

Did you mean: "enable_object_cache"


-- Also check LIKE optimization with binary-compatible cases

create temp table btree_bpchar (f1 text collate "C")

create index on btree_bpchar(f1 bpchar_ops) WITH (deduplicate_items=on)
ERROR: 
create index on btree_bpchar(f1 bpchar_ops) WITH (deduplicate_items=on)

Not implemented Error: Index with opclass not supported yet!

insert into btree_bpchar values ('foo'), ('fool'), ('bar'), ('quux')

-- doesn''t match index:
explain (costs off)
select * from btree_bpchar where f1 like 'foo'
ERROR: 
-- doesn''t match index:
explain (costs off)
select * from btree_bpchar where f1 like 'foo'

Not implemented Error: Unimplemented explain type: costs

select * from btree_bpchar where f1 like 'foo'
RESULT: 
	[('foo',)]

explain (costs off)
select * from btree_bpchar where f1 like 'foo%'
ERROR: 
explain (costs off)
select * from btree_bpchar where f1 like 'foo%'

Not implemented Error: Unimplemented explain type: costs

select * from btree_bpchar where f1 like 'foo%'
RESULT: 
	[('foo',), ('fool',)]

-- these do match the index:
explain (costs off)
select * from btree_bpchar where f1::bpchar like 'foo'
ERROR: 
-- these do match the index:
explain (costs off)
select * from btree_bpchar where f1::bpchar like 'foo'

Not implemented Error: Unimplemented explain type: costs

select * from btree_bpchar where f1::bpchar like 'foo'
RESULT: 
	[('foo',)]

explain (costs off)
select * from btree_bpchar where f1::bpchar like 'foo%'
ERROR: 
explain (costs off)
select * from btree_bpchar where f1::bpchar like 'foo%'

Not implemented Error: Unimplemented explain type: costs

select * from btree_bpchar where f1::bpchar like 'foo%'
RESULT: 
	[('foo',), ('fool',)]


-- get test coverage for ''single value'' deduplication strategy:
insert into btree_bpchar select 'foo' from generate_series(1,1500)


--
-- Perform unique checking, with and without the use of deduplication
--
CREATE TABLE dedup_unique_test_table (a int) WITH (autovacuum_enabled=false)

CREATE UNIQUE INDEX dedup_unique ON dedup_unique_test_table (a) WITH (deduplicate_items=on)

CREATE UNIQUE INDEX plain_unique ON dedup_unique_test_table (a) WITH (deduplicate_items=off)
ERROR: 
CREATE UNIQUE INDEX plain_unique ON dedup_unique_test_table (a) WITH (deduplicate_items=off)

Not implemented Error: Value not implemented!

-- Generate enough garbage tuples in index to ensure that even the unique index
-- with deduplication enabled has to check multiple leaf pages during unique
-- checking (at least with a BLCKSZ of 8192 or less)
DO $$
BEGIN
    FOR r IN 1..1350 LOOP
        DELETE FROM dedup_unique_test_table;
        INSERT INTO dedup_unique_test_table SELECT 1;
    END LOOP;
END$$
ERROR: 
-- Generate enough garbage tuples in index to ensure that even the unique index
-- with deduplication enabled has to check multiple leaf pages during unique
-- checking (at least with a BLCKSZ of 8192 or less)
DO $$
BEGIN
    FOR r IN 1..1350 LOOP
        DELETE FROM dedup_unique_test_table;
        INSERT INTO dedup_unique_test_table SELECT 1;
    END LOOP;
END$$

Parser Error: syntax error at or near "DO"


-- Exercise the LP_DEAD-bit-set tuple deletion code with a posting list tuple.
-- The implementation prefers deleting existing items to merging any duplicate
-- tuples into a posting list, so we need an explicit test to make sure we get
-- coverage (note that this test also assumes BLCKSZ is 8192 or less):
DROP INDEX plain_unique
ERROR: 

-- Exercise the LP_DEAD-bit-set tuple deletion code with a posting list tuple.
-- The implementation prefers deleting existing items to merging any duplicate
-- tuples into a posting list, so we need an explicit test to make sure we get
-- coverage (note that this test also assumes BLCKSZ is 8192 or less):
DROP INDEX plain_unique

Catalog Error: Index with name plain_unique does not exist!
Did you mean "dedup_unique"?

DELETE FROM dedup_unique_test_table WHERE a = 1

INSERT INTO dedup_unique_test_table SELECT i FROM generate_series(0,450) i
ERROR: 
INSERT INTO dedup_unique_test_table SELECT i FROM generate_series(0,450) i

Conversion Error: Unimplemented type for cast (STRUCT(generate_series BIGINT) -> INTEGER)
LINE 2: ...ERT INTO dedup_unique_test_table SELECT i FROM generate_series(0,450) i
                                                  ^


--
-- Test B-tree fast path (cache rightmost leaf page) optimization.
--

-- First create a tree that''s at least three levels deep (i.e. has one level
-- between the root and leaf levels). The text inserted is long.  It won''t be
-- TOAST compressed because we use plain storage in the table.  Only a few
-- index tuples fit on each internal page, allowing us to get a tall tree with
-- few pages.  (A tall tree is required to trigger caching.)
--
-- The text column must be the leading column in the index, since suffix
-- truncation would otherwise truncate tuples on internal pages, leaving us
-- with a short tree.
create table btree_tall_tbl(id int4, t text)

alter table btree_tall_tbl alter COLUMN t set storage plain
ERROR: 
alter table btree_tall_tbl alter COLUMN t set storage plain

Not implemented Error: No support for that ALTER TABLE option yet!

create index btree_tall_idx on btree_tall_tbl (t, id) with (fillfactor = 10)

insert into btree_tall_tbl select g, repeat('x', 250)
from generate_series(1, 130) g
ERROR: 
insert into btree_tall_tbl select g, repeat('x', 250)
from generate_series(1, 130) g

Conversion Error: Unimplemented type for cast (STRUCT(generate_series BIGINT) -> INTEGER)
LINE 2: insert into btree_tall_tbl select g, repeat('x', 250)
                                          ^


--
-- Test for multilevel page deletion
--
CREATE TABLE delete_test_table (a bigint, b bigint, c bigint, d bigint)

INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,80000) i
ERROR: 
INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,80000) i

Conversion Error: Unimplemented type for cast (STRUCT(generate_series BIGINT) -> BIGINT)
LINE 2: INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,8000...
                                             ^

ALTER TABLE delete_test_table ADD PRIMARY KEY (a,b,c,d)
ERROR: 
ALTER TABLE delete_test_table ADD PRIMARY KEY (a,b,c,d)

Not implemented Error: No support for that ALTER TABLE option yet!

-- Delete most entries, and vacuum, deleting internal pages and creating ''fast
-- root''
DELETE FROM delete_test_table WHERE a < 79990

VACUUM delete_test_table


--
-- Test B-tree insertion with a metapage update (XLOG_BTREE_INSERT_META
-- WAL record type). This happens when a ''fast root'' page is split.  This
-- also creates coverage for nbtree FSM page recycling.
--
-- The vacuum above should''ve turned the leaf page into a fast root. We just
-- need to insert some rows to cause the fast root page to split.
INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,1000) i
ERROR: 

--
-- Test B-tree insertion with a metapage update (XLOG_BTREE_INSERT_META
-- WAL record type). This happens when a ''fast root'' page is split.  This
-- also creates coverage for nbtree FSM page recycling.
--
-- The vacuum above should''ve turned the leaf page into a fast root. We just
-- need to insert some rows to cause the fast root page to split.
INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,1000) i

Conversion Error: Unimplemented type for cast (STRUCT(generate_series BIGINT) -> BIGINT)
LINE 10: INSERT INTO delete_test_table SELECT i, 1, 2, 3 FROM generate_series(1,1000) i
...
                                              ^


-- Test unsupported btree opclass parameters
create index on btree_tall_tbl (id int4_ops(foo=1))
ERROR: 

-- Test unsupported btree opclass parameters
create index on btree_tall_tbl (id int4_ops(foo=1))

Parser Error: syntax error at or near "("


-- Test case of ALTER INDEX with abuse of column names for indexes.
-- This grammar is not officially supported, but the parser allows it.
CREATE INDEX btree_tall_idx2 ON btree_tall_tbl (id)

ALTER INDEX btree_tall_idx2 ALTER COLUMN id SET (n_distinct=100)
ERROR: 
ALTER INDEX btree_tall_idx2 ALTER COLUMN id SET (n_distinct=100)

Not implemented Error: No support for that ALTER TABLE option yet!

DROP INDEX btree_tall_idx2

-- Partitioned index
CREATE TABLE btree_part (id int4) PARTITION BY RANGE (id)
ERROR: 
-- Partitioned index
CREATE TABLE btree_part (id int4) PARTITION BY RANGE (id)

Parser Error: syntax error at or near "PARTITION"

CREATE INDEX btree_part_idx ON btree_part(id)
ERROR: 
CREATE INDEX btree_part_idx ON btree_part(id)

Catalog Error: Table with name btree_part does not exist!
Did you mean "btree_bpchar"?

ALTER INDEX btree_part_idx ALTER COLUMN id SET (n_distinct=100)
ERROR: 
ALTER INDEX btree_part_idx ALTER COLUMN id SET (n_distinct=100)

Not implemented Error: No support for that ALTER TABLE option yet!

DROP TABLE btree_part
ERROR: 
DROP TABLE btree_part

Catalog Error: Table with name btree_part does not exist!
Did you mean "btree_bpchar"?


