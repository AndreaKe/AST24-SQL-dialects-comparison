Guest DBMS identified: postgres
-----------
QUERY:
--
-- CREATE_INDEX
-- Create ancillary data structures (i.e. indices)
--

-- directory paths are passed to us in environment variables
-- \getenv abs_srcdir '/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests'

--
-- BTREE
--
CREATE INDEX onek_unique1 ON onek USING btree(unique1 int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX IF NOT EXISTS onek_unique1 ON onek USING btree(unique1 int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


CREATE INDEX onek_unique2 ON onek USING btree(unique2 int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX onek_hundred ON onek USING btree(hundred int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX onek_stringu1 ON onek USING btree(stringu1 name_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX tenk1_unique1 ON tenk1 USING btree(unique1 int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX tenk1_unique2 ON tenk1 USING btree(unique2 int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX tenk1_hundred ON tenk1 USING btree(hundred int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX tenk1_thous_tenthous ON tenk1 (thousand, tenthous);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX tenk2_unique1 ON tenk2 USING btree(unique1 int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX tenk2_unique2 ON tenk2 USING btree(unique2 int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX tenk2_hundred ON tenk2 USING btree(hundred int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX rix ON road USING btree (name text_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX iix ON ihighway USING btree (name text_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX six ON shighway USING btree (name text_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- test comments
COMMENT ON INDEX six_wrong IS 'bad index';
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

COMMENT ON INDEX six IS 'good index';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

COMMENT ON INDEX six IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- BTREE partial indices
--
CREATE INDEX onek2_u1_prtl ON onek2 USING btree(unique1 int4_ops)
	where unique1 < 20 or unique1 > 980;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX onek2_u2_prtl ON onek2 USING btree(unique2 int4_ops)
	where stringu1 < 'B';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX onek2_stu1_prtl ON onek2 USING btree(stringu1 name_ops)
	where onek2.stringu1 >= 'J' and onek2.stringu1 < 'K';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- GiST (rtree-equivalent opclasses only)
--

CREATE TABLE slow_emp4000 (
	home_base	 box
);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE TABLE fast_emp4000 (
	home_base	 box
);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- \set filename /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests' '/data/rect.data'
COPY slow_emp4000 FROM /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests/data/rect.data';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


INSERT INTO fast_emp4000 SELECT * FROM slow_emp4000;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


ANALYZE slow_emp4000;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

ANALYZE fast_emp4000;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX grect2ind ON fast_emp4000 USING gist (home_base);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- we want to work with a point_tbl that includes a null
CREATE TEMP TABLE point_tbl AS SELECT * FROM public.point_tbl;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

INSERT INTO POINT_TBL(f1) VALUES (NULL);
RESULT: [duckdb: ERROR, mySQL: SAME]

-----------
QUERY:


CREATE INDEX gpointind ON point_tbl USING gist (f1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE TEMP TABLE gpolygon_tbl AS
    SELECT polygon(home_base) AS f1 FROM slow_emp4000;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

INSERT INTO gpolygon_tbl VALUES ( '(1000,0,0,1000)' );
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

INSERT INTO gpolygon_tbl VALUES ( '(0,1000,1000,1000)' );
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE TEMP TABLE gcircle_tbl AS
    SELECT circle(home_base) AS f1 FROM slow_emp4000;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX ggpolygonind ON gpolygon_tbl USING gist (f1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX ggcircleind ON gcircle_tbl USING gist (f1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- Test GiST indexes
--

-- get non-indexed results for comparison purposes

SET enable_seqscan = ON;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_indexscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_bitmapscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT * FROM point_tbl WHERE f1 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- Now check the results from plain indexscan
SET enable_seqscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_indexscan = ON;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_bitmapscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM point_tbl WHERE f1 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- Now check the results from bitmap indexscan
SET enable_seqscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_indexscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_bitmapscan = ON;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


RESET enable_seqscan;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

RESET enable_indexscan;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

RESET enable_bitmapscan;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- GIN over int[] and text[]
--
-- Note: GIN currently supports only bitmap scans, not plain indexscans
--

CREATE TABLE array_index_op_test (
	seqno		int4,
	i			int4[],
	t			text[]
);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:


-- \set filename /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests' '/data/array.data'
COPY array_index_op_test FROM /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/AST24-SQL-dialects-comparison/postgres_tests/data/array.data';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

ANALYZE array_index_op_test;
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:


SELECT * FROM array_index_op_test WHERE i = '{NULL}' ORDER BY seqno;
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i @> '{NULL}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i && '{NULL}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SET enable_seqscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_indexscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_bitmapscan = ON;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


explain (costs off)
SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


explain (costs off)
SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- And try it with a multicolumn GIN index

DROP INDEX intarrayidx, textarrayidx;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:


RESET enable_seqscan;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

RESET enable_indexscan;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

RESET enable_bitmapscan;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- Try a GIN index with a lot of items with same key. (GIN creates a posting
-- tree when there are enough duplicates)
--
CREATE TABLE array_gin_test (a int[]);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:


INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


DROP TABLE array_gin_test;
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:


--
-- Test GIN index/* REPLACED */''s reloptions
--
CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
  WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- \d+ gin_relopts_test

--
-- HASH
--
CREATE UNLOGGED TABLE unlogged_hash_table (id int4);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX unlogged_hash_index ON unlogged_hash_table USING hash (id int4_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP TABLE unlogged_hash_table;
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:


-- CREATE INDEX hash_ovfl_index ON hash_ovfl_heap USING hash (x int4_ops) /* REPLACED */,

-- Test hash index build tuplesorting.  Force hash tuplesort using low
-- maintenance_work_mem setting and fillfactor:
SET maintenance_work_mem = '1MB';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX hash_tuplesort_idx ON tenk1 USING hash (stringu1 name_ops) WITH (fillfactor = 10);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

EXPLAIN (COSTS OFF)
SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP INDEX hash_tuplesort_idx;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

RESET maintenance_work_mem;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:



--
-- Test unique null behavior
--
CREATE TABLE unique_tbl (i int, t text);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


CREATE UNIQUE INDEX unique_idx1 ON unique_tbl (i) NULLS DISTINCT;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE UNIQUE INDEX unique_idx2 ON unique_tbl (i) NULLS NOT DISTINCT;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


INSERT INTO unique_tbl VALUES (1, 'one');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO unique_tbl VALUES (2, 'two');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO unique_tbl VALUES (3, 'three');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO unique_tbl VALUES (4, 'four');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO unique_tbl VALUES (5, 'one');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO unique_tbl (t) VALUES ('six');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO unique_tbl (t) VALUES ('seven');
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:
  -- error from unique_idx2

DROP INDEX unique_idx1, unique_idx2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


INSERT INTO unique_tbl (t) VALUES ('seven');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- build indexes on filled table
CREATE UNIQUE INDEX unique_idx3 ON unique_tbl (i) NULLS DISTINCT;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:
  -- ok
CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
  -- error

DELETE FROM unique_tbl WHERE t = 'seven';
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:
  -- ok now

-- \d unique_tbl
-- \d unique_idx3
-- \d unique_idx4
SELECT pg_get_indexdef('unique_idx3'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_get_indexdef('unique_idx4'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


DROP TABLE unique_tbl;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:



--
-- Test functional index
--
CREATE TABLE func_index_heap (f1 text, f2 text);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE UNIQUE INDEX func_index_index on func_index_heap (textcat(f1,f2));
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


INSERT INTO func_index_heap VALUES('ABC','DEF');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO func_index_heap VALUES('AB','CDEFG');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO func_index_heap VALUES('QWE','RTY');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- but this shouldn/* REPLACED */''t:
INSERT INTO func_index_heap VALUES('QWERTY');
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- while we/* REPLACED */''re here, see that the metadata looks sane
-- \d func_index_heap
-- \d func_index_index


--
-- Same test, expressional index
--
DROP TABLE func_index_heap;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE TABLE func_index_heap (f1 text, f2 text);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


INSERT INTO func_index_heap VALUES('ABC','DEF');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO func_index_heap VALUES('AB','CDEFG');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO func_index_heap VALUES('QWE','RTY');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- but this shouldn/* REPLACED */''t:
INSERT INTO func_index_heap VALUES('QWERTY');
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- while we/* REPLACED */''re here, see that the metadata looks sane
-- \d func_index_heap
-- \d func_index_index

-- this should fail because of unsafe column type (anonymous record)
create index on func_index_heap ((f1 || f2), (row(f1, f2)));
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:



--
-- Test unique index with included columns
--
CREATE TABLE covering_index_heap (f1 int, f2 int, f3 text);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE UNIQUE INDEX covering_index_index on covering_index_heap (f1,f2) INCLUDE(f3);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


INSERT INTO covering_index_heap VALUES(1,1,'AAA');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO covering_index_heap VALUES(1,2,'AAA');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- this should fail because of unique index on f1,f2:
INSERT INTO covering_index_heap VALUES(1,2,'BBB');
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- and this shouldn/* REPLACED */''t:
INSERT INTO covering_index_heap VALUES(1,4,'AAA');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Try to build index on table that already contains data
CREATE UNIQUE INDEX covering_pkey on covering_index_heap (f1,f2) INCLUDE(f3);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- Try to use existing covering index as primary key
ALTER TABLE covering_index_heap ADD CONSTRAINT covering_pkey PRIMARY KEY USING INDEX
covering_pkey;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP TABLE covering_index_heap;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


--
-- Try some concurrent index builds
--
-- Unfortunately this only tests about half the code paths because there are
-- no concurrent updates happening to the table at the same time.

CREATE TABLE concur_heap (f1 text, f2 text);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- empty table
CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

INSERT INTO concur_heap VALUES  ('a','b');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO concur_heap VALUES  ('b','b');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- unique index
CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- check if constraint is set up properly to be enforced
INSERT INTO concur_heap VALUES ('b','x');
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

-- check if constraint is enforced properly at build time
CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- test that expression indexes and partial indexes work concurrently
CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

-- here we also check that you can default the index name
CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
RESULT: [duckdb: ERROR, mySQL: SAME]

-----------
QUERY:

-- You can/* REPLACED */''t do a concurrent index build in a transaction
BEGIN;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
RESULT: [duckdb: ERROR, mySQL: SAME]

-----------
QUERY:

COMMIT;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- test where predicate is able to do a transactional update during
-- a concurrent build before switching pg_index state flags.
CREATE FUNCTION predicate_stable() RETURNS bool IMMUTABLE
LANGUAGE plpgsql AS $$
BEGIN
  EXECUTE 'SELECT txid_current()';
  RETURN true;
END; $$;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX CONCURRENTLY concur_index8 ON concur_heap (f1)
  WHERE predicate_stable();
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

DROP INDEX concur_index8;
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

DROP FUNCTION predicate_stable();
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- But you can do a regular index build in a transaction
BEGIN;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE INDEX std_index on concur_heap(f2);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

COMMIT;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
VACUUM FULL concur_heap;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE concur_heap;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

DELETE FROM concur_heap WHERE f1 = 'b';
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

VACUUM FULL concur_heap;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- \d concur_heap
REINDEX TABLE concur_heap;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- \d concur_heap

-- Temporary tables with concurrent builds and on-commit actions
-- CONCURRENTLY used with CREATE INDEX and DROP INDEX is ignored.
-- PRESERVE ROWS, the default.
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT PRESERVE ROWS;
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

DROP INDEX CONCURRENTLY concur_temp_ind;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP TABLE concur_temp;
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

-- ON COMMIT DROP
BEGIN;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT DROP;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- Fails when running in a transaction.
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

COMMIT;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- ON COMMIT DELETE ROWS
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT DELETE ROWS;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP INDEX CONCURRENTLY concur_temp_ind;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP TABLE concur_temp;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- Try some concurrent index drops
--
DROP INDEX CONCURRENTLY "concur_index2";
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:
				-- works
DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:
		-- notice

-- failures
DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

BEGIN;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

DROP INDEX CONCURRENTLY "concur_index5";
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

ROLLBACK;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- successes
DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP INDEX CONCURRENTLY "concur_index4";
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP INDEX CONCURRENTLY "concur_index5";
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP INDEX CONCURRENTLY "concur_index1";
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- \d concur_heap

DROP TABLE concur_heap;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


--
-- Test ADD CONSTRAINT USING INDEX
--

CREATE TABLE cwi_test( a int , b varchar(10), c char);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- add some data so that all tests have something to work with.

INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- \d cwi_test
-- \d cwi_uniq_idx

CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
		USING INDEX cwi_uniq2_idx;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- \d cwi_test
-- \d cwi_replaced_pkey

DROP INDEX cwi_replaced_pkey;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
	-- Should fail /* REPLACED */, a constraint depends on it

-- Check that non-default index options are rejected
CREATE UNIQUE INDEX cwi_uniq3_idx ON cwi_test(a desc);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
  -- fail
CREATE UNIQUE INDEX cwi_uniq4_idx ON cwi_test(b collate "POSIX");
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
  -- fail

DROP TABLE cwi_test;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- ADD CONSTRAINT USING INDEX is forbidden on partitioned tables
CREATE TABLE cwi_test(a int) PARTITION BY hash (a);
RESULT: [duckdb: ERROR, mySQL: SAME]

-----------
QUERY:

create unique index on cwi_test (a);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

alter table cwi_test add primary key using index cwi_test_a_idx ;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

DROP TABLE cwi_test;
RESULT: [duckdb: ERROR, mySQL: SAME]

-----------
QUERY:


-- PRIMARY KEY constraint cannot be backed by a NULLS NOT DISTINCT index
CREATE TABLE cwi_test(a int, b int);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE UNIQUE INDEX cwi_a_nnd ON cwi_test (a) NULLS NOT DISTINCT;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_a_nnd;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

DROP TABLE cwi_test;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


--
-- Check handling of indexes on system columns
--
CREATE TABLE syscol_table (a INT);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- System columns cannot be indexed
CREATE INDEX ON syscolcol_table (ctid);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- nor used in expressions
CREATE INDEX ON syscol_table ((ctid >= '(1000,0)'));
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- nor used in predicates
CREATE INDEX ON syscol_table (a) WHERE ctid >= '(1000,0)';
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


DROP TABLE syscol_table;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


--
-- Tests for IS NULL/IS NOT NULL with b-tree indexes
--

CREATE TABLE onek_with_null AS SELECT unique1, unique2 FROM onek;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SET enable_seqscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_indexscan = ON;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_bitmapscan = ON;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


DROP INDEX onek_nulltest;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


DROP INDEX onek_nulltest;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


DROP INDEX onek_nulltest;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


DROP INDEX onek_nulltest;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- Check initial-positioning logic too

CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SET enable_seqscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_indexscan = ON;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET enable_bitmapscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 LIMIT 2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 LIMIT 2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
  ORDER BY unique2 LIMIT 2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 DESC LIMIT 2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 DESC LIMIT 2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
  ORDER BY unique2 DESC LIMIT 2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


RESET enable_seqscan;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

RESET enable_indexscan;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

RESET enable_bitmapscan;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


DROP TABLE onek_with_null;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- Check bitmap index path planning
--

EXPLAIN (COSTS OFF)
SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- Check behavior with duplicate index column contents
--

CREATE TABLE dupindexcols AS
  SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

ANALYZE dupindexcols;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


EXPLAIN (COSTS OFF)
  SELECT count(*) FROM dupindexcols
    WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT count(*) FROM dupindexcols
  WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- Check ordering of =ANY indexqual results (bug in 9.2.0)
--

explain (costs off)
SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SET enable_indexonlyscan = OFF;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


RESET enable_indexonlyscan;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- Check elimination of constant-NULL subexpressions
--

explain (costs off)
  select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- Check matching of boolean index columns to WHERE conditions and sort keys
--

create temp table boolindex (b bool, i int, unique(b, i), junk float);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:


explain (costs off)
  select * from boolindex order by b, i limit 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

explain (costs off)
  select * from boolindex where b order by i limit 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

explain (costs off)
  select * from boolindex where b = true order by i desc limit 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

explain (costs off)
  select * from boolindex where not b order by i limit 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

explain (costs off)
  select * from boolindex where b is true order by i desc limit 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

explain (costs off)
  select * from boolindex where b is false order by i desc limit 10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- REINDEX (VERBOSE)
--
CREATE TABLE reindex_verbose(id integer primary key);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- \set VERBOSITY terse \\ -- suppress machine-dependent details
REINDEX (VERBOSE) TABLE reindex_verbose;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- \set VERBOSITY default
DROP TABLE reindex_verbose;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


--
-- REINDEX CONCURRENTLY
--
CREATE TABLE concur_reindex_tab (c1 int);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- REINDEX
REINDEX TABLE concur_reindex_tab;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:
 -- notice
REINDEX (CONCURRENTLY) TABLE concur_reindex_tab;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:
 -- notice
ALTER TABLE concur_reindex_tab ADD COLUMN c2 text;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- add toast index
-- Normal index with integer column
CREATE UNIQUE INDEX concur_reindex_ind1 ON concur_reindex_tab(c1);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Normal index with text column
CREATE INDEX concur_reindex_ind2 ON concur_reindex_tab(c2);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

-- UNIQUE index with expression
CREATE UNIQUE INDEX concur_reindex_ind3 ON concur_reindex_tab(abs(c1));
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

-- Duplicate column names
CREATE INDEX concur_reindex_ind4 ON concur_reindex_tab(c1, c1, c2);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

-- Create table for check on foreign key dependence switch with indexes swapped
ALTER TABLE concur_reindex_tab ADD PRIMARY KEY USING INDEX concur_reindex_ind1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE TABLE concur_reindex_tab2 (c1 int REFERENCES concur_reindex_tab);
RESULT: [duckdb: ERROR, mySQL: SAME]

-----------
QUERY:

INSERT INTO concur_reindex_tab VALUES  (1, 'a');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO concur_reindex_tab VALUES  (2, 'a');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Reindex concurrently of exclusion constraint currently not supported
CREATE TABLE concur_reindex_tab3 (c1 int, c2 int4range, EXCLUDE USING gist (c2 WITH &&));
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

INSERT INTO concur_reindex_tab3 VALUES  (3, '[1,2]');
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
  -- error
REINDEX TABLE CONCURRENTLY concur_reindex_tab3;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:
  -- succeeds with warning
INSERT INTO concur_reindex_tab3 VALUES  (4, '[2,4]');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Check materialized views
CREATE MATERIALIZED VIEW concur_reindex_matview AS SELECT * FROM concur_reindex_tab;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- Dependency lookup before and after the follow-up REINDEX commands.
-- These should remain consistent.
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_tab'::regclass,
            'concur_reindex_ind1'::regclass,
	    'concur_reindex_ind2'::regclass,
	    'concur_reindex_ind3'::regclass,
	    'concur_reindex_ind4'::regclass,
	    'concur_reindex_matview'::regclass)
  ORDER BY 1, 2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX INDEX CONCURRENTLY concur_reindex_ind1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_reindex_tab;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_reindex_matview;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_tab'::regclass,
            'concur_reindex_ind1'::regclass,
	    'concur_reindex_ind2'::regclass,
	    'concur_reindex_ind3'::regclass,
	    'concur_reindex_ind4'::regclass,
	    'concur_reindex_matview'::regclass)
  ORDER BY 1, 2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- Check that comments are preserved
CREATE TABLE testcomment (i int);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE INDEX testcomment_idx1 ON testcomment (i);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

COMMENT ON INDEX testcomment_idx1 IS 'test comment';
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE testcomment;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY testcomment ;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:

DROP TABLE testcomment;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Check that indisclustered updates are preserved
CREATE TABLE concur_clustered(i int);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE INDEX concur_clustered_i_idx ON concur_clustered(i);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

ALTER TABLE concur_clustered CLUSTER ON concur_clustered_i_idx;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_clustered;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT indexrelid::regclass, indisclustered FROM pg_index
  WHERE indrelid = 'concur_clustered'::regclass;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP TABLE concur_clustered;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Check that indisreplident updates are preserved.
CREATE TABLE concur_replident(i int NOT NULL);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE UNIQUE INDEX concur_replident_i_idx ON concur_replident(i);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

ALTER TABLE concur_replident REPLICA IDENTITY
  USING INDEX concur_replident_i_idx;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT indexrelid::regclass, indisreplident FROM pg_index
  WHERE indrelid = 'concur_replident'::regclass;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_replident;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT indexrelid::regclass, indisreplident FROM pg_index
  WHERE indrelid = 'concur_replident'::regclass;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP TABLE concur_replident;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Check that opclass parameters are preserved
CREATE TABLE concur_appclass_tab(i tsvector, j tsvector, k tsvector);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX concur_appclass_ind on concur_appclass_tab
  USING gist (i tsvector_ops (siglen='1000'), j tsvector_ops (siglen='500'));
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX concur_appclass_ind_2 on concur_appclass_tab
  USING gist (k tsvector_ops (siglen='300'), j tsvector_ops);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_appclass_tab;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- \d concur_appclass_tab
DROP TABLE concur_appclass_tab;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- Partitions
-- Create some partitioned tables
CREATE TABLE concur_reindex_part (c1 int, c2 int) PARTITION BY RANGE (c1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE TABLE concur_reindex_part_0 PARTITION OF concur_reindex_part
  FOR VALUES FROM (0) TO (10) PARTITION BY list (c2);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE TABLE concur_reindex_part_0_1 PARTITION OF concur_reindex_part_0
  FOR VALUES IN (1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE TABLE concur_reindex_part_0_2 PARTITION OF concur_reindex_part_0
  FOR VALUES IN (2);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- This partitioned table will have no partitions.
CREATE TABLE concur_reindex_part_10 PARTITION OF concur_reindex_part
  FOR VALUES FROM (10) TO (20) PARTITION BY list (c2);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- Create some partitioned indexes
CREATE INDEX concur_reindex_part_index ON ONLY concur_reindex_part (c1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX concur_reindex_part_index_0 ON ONLY concur_reindex_part_0 (c1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_0;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- This partitioned index will have no partitions.
CREATE INDEX concur_reindex_part_index_10 ON ONLY concur_reindex_part_10 (c1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_10;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX concur_reindex_part_index_0_1 ON ONLY concur_reindex_part_0_1 (c1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX concur_reindex_part_index_0_2 ON ONLY concur_reindex_part_0_2 (c1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- REINDEX should preserve dependencies of partition tree.
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_part'::regclass,
            'concur_reindex_part_0'::regclass,
            'concur_reindex_part_0_1'::regclass,
            'concur_reindex_part_0_2'::regclass,
            'concur_reindex_part_index'::regclass,
            'concur_reindex_part_index_0'::regclass,
            'concur_reindex_part_index_0_1'::regclass,
            'concur_reindex_part_index_0_2'::regclass)
  ORDER BY 1, 2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_part'::regclass,
            'concur_reindex_part_0'::regclass,
            'concur_reindex_part_0_1'::regclass,
            'concur_reindex_part_0_2'::regclass,
            'concur_reindex_part_index'::regclass,
            'concur_reindex_part_index_0'::regclass,
            'concur_reindex_part_index_0_1'::regclass,
            'concur_reindex_part_index_0_2'::regclass)
  ORDER BY 1, 2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- REINDEX for partitioned indexes
-- REINDEX TABLE fails for partitioned indexes
-- Top-most parent index
REINDEX TABLE concur_reindex_part_index;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- error
REINDEX TABLE CONCURRENTLY concur_reindex_part_index;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- error
-- Partitioned index with no leaves
REINDEX TABLE concur_reindex_part_index_10;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- error
REINDEX TABLE CONCURRENTLY concur_reindex_part_index_10;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- error
-- Cannot run in a transaction block
BEGIN;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX INDEX concur_reindex_part_index;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

ROLLBACK;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Helper functions to track changes of relfilenodes in a partition tree.
-- Create a table tracking the relfilenode state.
CREATE OR REPLACE FUNCTION create_relfilenode_part(relname text, indname text)
  RETURNS VOID AS
  $func$
  BEGIN
  EXECUTE format('
    CREATE TABLE %I AS
      SELECT oid, relname, relfilenode, relkind, reltoastrelid
      FROM pg_class
      WHERE oid IN
         (SELECT relid FROM pg_partition_tree(''%I''));
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
',
	 relname, indname);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

  END
  $func$ LANGUAGE plpgsql;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE OR REPLACE FUNCTION compare_relfilenode_part(tabname text)
  RETURNS TABLE (relname name, relkind "char", state text) AS
  $func$
  BEGIN
    RETURN QUERY EXECUTE
      format(
        'SELECT  b.relname,
                 b.relkind,
                 CASE WHEN a.relfilenode = b.relfilenode THEN ''relfilenode is unchanged''
                 ELSE ''relfilenode has changed'' END
           -- Do not join with OID here as CONCURRENTLY changes it.
           FROM %I b JOIN pg_class a ON b.relname = a.relname
           ORDER BY 1;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
', tabname);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

  END
  $func$ LANGUAGE plpgsql;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

--  Check that expected relfilenodes are changed, non-concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX INDEX concur_reindex_part_index;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM compare_relfilenode_part('reindex_index_status');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

DROP TABLE reindex_index_status;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX INDEX CONCURRENTLY concur_reindex_part_index;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM compare_relfilenode_part('reindex_index_status');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

DROP TABLE reindex_index_status;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- REINDEX for partitioned tables
-- REINDEX INDEX fails for partitioned tables
-- Top-most parent
REINDEX INDEX concur_reindex_part;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- error
REINDEX INDEX CONCURRENTLY concur_reindex_part;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- error
-- Partitioned with no leaves
REINDEX INDEX concur_reindex_part_10;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- error
REINDEX INDEX CONCURRENTLY concur_reindex_part_10;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- error
-- Cannot run in a transaction block
BEGIN;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX TABLE concur_reindex_part;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

ROLLBACK;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Check that expected relfilenodes are changed, non-concurrent case.
-- Note that the partition tree changes of the *indexes* need to be checked.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX TABLE concur_reindex_part;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM compare_relfilenode_part('reindex_index_status');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

DROP TABLE reindex_index_status;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_reindex_part;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT * FROM compare_relfilenode_part('reindex_index_status');
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

DROP TABLE reindex_index_status;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


DROP FUNCTION create_relfilenode_part;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

DROP FUNCTION compare_relfilenode_part;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- Cleanup of partition tree used for REINDEX test.
DROP TABLE concur_reindex_part;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- Check errors
-- Cannot run inside a transaction block
BEGIN;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_reindex_tab;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

COMMIT;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY pg_class;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- no catalog relation
REINDEX INDEX CONCURRENTLY pg_class_oid_index;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- no catalog index
-- These are the toast table and index of pg_authid.
REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- no catalog toast table
REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- no catalog toast index
REINDEX SYSTEM CONCURRENTLY postgres;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- not allowed for SYSTEM
REINDEX (CONCURRENTLY) SYSTEM postgres;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- ditto
REINDEX (CONCURRENTLY) SYSTEM;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
  -- ditto
-- Warns about catalog relations
REINDEX SCHEMA CONCURRENTLY pg_catalog;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- Not the current database
REINDEX DATABASE not_current_database;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- Check the relation status, there should not be invalid indexes
-- \d concur_reindex_tab
DROP MATERIALIZED VIEW concur_reindex_matview;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP TABLE concur_reindex_tab, concur_reindex_tab2, concur_reindex_tab3;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- Check handling of invalid indexes
CREATE TABLE concur_reindex_tab4 (c1 int);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO concur_reindex_tab4 VALUES (1), (1), (2);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- This trick creates an invalid index.
CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Reindexing concurrently this index fails with the same failure.
-- The extra index created is itself invalid, and can be dropped.
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- \d concur_reindex_tab4
DROP INDEX concur_reindex_ind5_ccnew;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- This makes the previous failure go away, so the index can become valid.
DELETE FROM concur_reindex_tab4 WHERE c1 = 1;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- The invalid index is not processed when running REINDEX TABLE.
REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- \d concur_reindex_tab4
-- But it is fixed with REINDEX INDEX.
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- \d concur_reindex_tab4
DROP TABLE concur_reindex_tab4;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- Check handling of indexes with expressions and predicates.  The
-- definitions of the rebuilt indexes should match the original
-- definitions.
CREATE TABLE concur_exprs_tab (c1 int , c2 boolean);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

INSERT INTO concur_exprs_tab (c1, c2) VALUES (1369652450, FALSE),
  (414515746, TRUE),
  (897778963, FALSE);
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE UNIQUE INDEX concur_exprs_index_expr
  ON concur_exprs_tab ((c1::text COLLATE "C"));
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

CREATE UNIQUE INDEX concur_exprs_index_pred ON concur_exprs_tab (c1)
  WHERE (c1::text > 500000000::text COLLATE "C");
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

CREATE UNIQUE INDEX concur_exprs_index_pred_2
  ON concur_exprs_tab ((1 / c1))
  WHERE ('-H') >= (c2::TEXT) COLLATE "C";
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

ALTER INDEX concur_exprs_index_expr ALTER COLUMN 1 SET STATISTICS 100;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

ANALYZE concur_exprs_tab;
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
  'concur_exprs_index_expr'::regclass,
  'concur_exprs_index_pred'::regclass,
  'concur_exprs_index_pred_2'::regclass)
  GROUP BY starelid ORDER BY starelid::regclass::text;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_exprs_tab;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- ALTER TABLE recreates the indexes, which should keep their collations.
ALTER TABLE concur_exprs_tab ALTER c2 TYPE TEXT;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- Statistics should remain intact.
SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
  'concur_exprs_index_expr'::regclass,
  'concur_exprs_index_pred'::regclass,
  'concur_exprs_index_pred_2'::regclass)
  GROUP BY starelid ORDER BY starelid::regclass::text;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- attstattarget should remain intact
SELECT attrelid::regclass, attnum, attstattarget
  FROM pg_attribute WHERE attrelid IN (
    'concur_exprs_index_expr'::regclass,
    'concur_exprs_index_pred'::regclass,
    'concur_exprs_index_pred_2'::regclass)
  ORDER BY attrelid::regclass::text, attnum;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP TABLE concur_exprs_tab;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- Temporary tables and on-commit actions, where CONCURRENTLY is ignored.
-- ON COMMIT PRESERVE ROWS, the default.
CREATE TEMP TABLE concur_temp_tab_1 (c1 int, c2 text)
  ON COMMIT PRESERVE ROWS;
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

INSERT INTO concur_temp_tab_1 VALUES (1, 'foo'), (2, 'bar');
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX concur_temp_ind_1 ON concur_temp_tab_1(c2);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_temp_tab_1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- Still fails in transaction blocks
BEGIN;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

COMMIT;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- ON COMMIT DELETE ROWS
CREATE TEMP TABLE concur_temp_tab_2 (c1 int, c2 text)
  ON COMMIT DELETE ROWS;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX concur_temp_ind_2 ON concur_temp_tab_2(c2);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE CONCURRENTLY concur_temp_tab_2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX INDEX CONCURRENTLY concur_temp_ind_2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

-- ON COMMIT DROP
BEGIN;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

CREATE TEMP TABLE concur_temp_tab_3 (c1 int, c2 text)
  ON COMMIT PRESERVE ROWS;
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

INSERT INTO concur_temp_tab_3 VALUES (1, 'foo'), (2, 'bar');
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX concur_temp_ind_3 ON concur_temp_tab_3(c2);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

-- Fails when running in a transaction
REINDEX INDEX CONCURRENTLY concur_temp_ind_3;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

COMMIT;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- REINDEX SCHEMA processes all temporary relations
CREATE TABLE reindex_temp_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
  FROM pg_class
  WHERE relname IN ('concur_temp_ind_1', 'concur_temp_ind_2');
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

SELECT pg_my_temp_schema()::regnamespace as temp_schema_name \gset
REINDEX SCHEMA CONCURRENTLY :temp_schema_name;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_temp_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:

DROP TABLE concur_temp_tab_1, concur_temp_tab_2, reindex_temp_before;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


--
-- REINDEX SCHEMA
--
REINDEX SCHEMA schema_to_reindex;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- failure, schema does not exist
CREATE SCHEMA schema_to_reindex;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

SET search_path = 'schema_to_reindex';
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

CREATE TABLE table1(col1 SERIAL PRIMARY KEY);
RESULT: [duckdb: ERROR, mySQL: SAME]

-----------
QUERY:

INSERT INTO table1 SELECT generate_series(1,400);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE TABLE table2(col1 SERIAL PRIMARY KEY, col2 TEXT NOT NULL);
RESULT: [duckdb: ERROR, mySQL: SAME]

-----------
QUERY:

INSERT INTO table2 SELECT generate_series(1,400), 'abc';
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX ON table2(col2);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE INDEX ON matview(col1);
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE VIEW view AS SELECT col2 FROM table2;
RESULT: [duckdb: ERROR, mySQL: SAME]

-----------
QUERY:

CREATE TABLE reindex_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelid
FROM pg_class WHERE oid IN
	(SELECT reltoastrelid FROM reindex_before WHERE reltoastrelid > 0);
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE_index', relfilenode, relkind, reltoastrelid
FROM pg_class where oid in
	(select indexrelid from pg_index where indrelid in
		(select reltoastrelid from reindex_before where reltoastrelid > 0));
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

REINDEX SCHEMA schema_to_reindex;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

CREATE TABLE reindex_after AS SELECT oid, relname, relfilenode, relkind
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:

SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
RESULT: [duckdb: DIFFERENT, mySQL: ERROR]

-----------
QUERY:

REINDEX SCHEMA schema_to_reindex;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

BEGIN;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX SCHEMA schema_to_reindex;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:
 -- failure, cannot run in a transaction
END;
RESULT: [duckdb: SAME, mySQL: ERROR]

-----------
QUERY:


-- concurrently
REINDEX SCHEMA CONCURRENTLY schema_to_reindex;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:


-- Failure for unauthorized user
CREATE ROLE regress_reindexuser NOLOGIN;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET SESSION ROLE regress_reindexuser;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX SCHEMA schema_to_reindex;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

-- Permission failures with toast tables and indexes (pg_authid here)
RESET ROLE;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

GRANT USAGE ON SCHEMA pg_toast TO regress_reindexuser;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

SET SESSION ROLE regress_reindexuser;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REINDEX TABLE pg_toast.pg_toast_1260;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:

REINDEX INDEX pg_toast.pg_toast_1260_index;
RESULT: [duckdb: SAME, mySQL: SAME]

-----------
QUERY:


-- Clean up
RESET ROLE;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

REVOKE USAGE ON SCHEMA pg_toast FROM regress_reindexuser;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP ROLE regress_reindexuser;
RESULT: [duckdb: ERROR, mySQL: ERROR]

-----------
QUERY:

DROP SCHEMA schema_to_reindex CASCADE;
RESULT: [duckdb: SAME, mySQL: ERROR]
=========================================
Summary for test case create_index/test.sql of postgres
=========================================

=================
Results for duckdb
SAME: 191 queries, which is 32.10%
DIFFERENT: 11 queries, which is 1.85%
ERROR: 393 queries, which is 66.05%

=================
Results for mySQL
SAME: 158 queries, which is 26.55%
DIFFERENT: 0 queries, which is 0.00%
ERROR: 437 queries, which is 73.45%
