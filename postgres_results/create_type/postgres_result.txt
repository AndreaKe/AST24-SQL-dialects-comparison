--
-- CREATE_TYPE
--

-- directory path and dlsuffix are passed to us in environment variables
-- \getenv libdir ''/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress''
-- \getenv dlsuffix ''.so''

-- \set regresslib /* REPLACED */ ''/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress'' ''/regress'' /* REPLACED */ ''.so''

--
-- Test the ''old style'' approach of making the I/O functions first,
-- with no explicit shell type creation.
--
CREATE FUNCTION widget_in(cstring)
   RETURNS widget
   AS /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/regress.so'
   LANGUAGE C STRICT IMMUTABLE


CREATE FUNCTION widget_out(widget)
   RETURNS cstring
   AS /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/regress.so'
   LANGUAGE C STRICT IMMUTABLE


CREATE FUNCTION int44in(cstring)
   RETURNS city_budget
   AS /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/regress.so'
   LANGUAGE C STRICT IMMUTABLE


CREATE FUNCTION int44out(city_budget)
   RETURNS cstring
   AS /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/regress.so'
   LANGUAGE C STRICT IMMUTABLE


CREATE TYPE widget (
   internallength = 24,
   input = widget_in,
   output = widget_out,
   typmod_in = numerictypmodin,
   typmod_out = numerictypmodout,
   alignment = double
)


CREATE TYPE city_budget (
   internallength = 16,
   input = int44in,
   output = int44out,
   element = int4,
   category = 'x',   -- just to verify the system will take it
   preferred = true  -- ditto
)


-- Test creation and destruction of shell types
CREATE TYPE shell

CREATE TYPE shell
ProgrammingError: 
CREATE TYPE shell

type "shell" already exists

   -- fail, type already present
DROP TYPE shell

DROP TYPE shell
ProgrammingError: 
DROP TYPE shell

type "shell" does not exist

     -- fail, type not exist

-- also, let''s leave one around for purposes of pg_dump testing
CREATE TYPE myshell


--
-- Test type-related default values (broken in releases before PG 7.2)
--
-- This part of the test also exercises the ''new style'' approach of making
-- a shell type and then filling it in.
--
CREATE TYPE int42

CREATE TYPE text_w_default


-- Make dummy I/O routines using the existing internal support for int4, text
CREATE FUNCTION int42_in(cstring)
   RETURNS int42
   AS 'int4in'
   LANGUAGE internal STRICT IMMUTABLE

CREATE FUNCTION int42_out(int42)
   RETURNS cstring
   AS 'int4out'
   LANGUAGE internal STRICT IMMUTABLE

CREATE FUNCTION text_w_default_in(cstring)
   RETURNS text_w_default
   AS 'textin'
   LANGUAGE internal STRICT IMMUTABLE

CREATE FUNCTION text_w_default_out(text_w_default)
   RETURNS cstring
   AS 'textout'
   LANGUAGE internal STRICT IMMUTABLE


CREATE TYPE int42 (
   internallength = 4,
   input = int42_in,
   output = int42_out,
   alignment = int4,
   default = 42,
   passedbyvalue
)


CREATE TYPE text_w_default (
   internallength = variable,
   input = text_w_default_in,
   output = text_w_default_out,
   alignment = int4,
   default = 'zippo'
)


CREATE TABLE default_test (f1 text_w_default, f2 int42)


INSERT INTO default_test DEFAULT VALUES


SELECT * FROM default_test
RESULT: 
	[('zippo', '42')]


-- We need a shell type to test some CREATE TYPE failure cases with
CREATE TYPE bogus_type


-- invalid: non-lowercase quoted identifiers
CREATE TYPE bogus_type (
	"Internallength" = 4,
	"Input" = int42_in,
	"Output" = int42_out,
	"Alignment" = int4,
	"Default" = 42,
	"Passedbyvalue"
)
ProgrammingError: 

-- invalid: non-lowercase quoted identifiers
CREATE TYPE bogus_type (
	"Internallength" = 4,
	"Input" = int42_in,
	"Output" = int42_out,
	"Alignment" = int4,
	"Default" = 42,
	"Passedbyvalue"
)

type input function must be specified



-- invalid: input/output function incompatibility
CREATE TYPE bogus_type (INPUT = array_in,
    OUTPUT = array_out,
    ELEMENT = int,
    INTERNALLENGTH = 32)
ProgrammingError: 

-- invalid: input/output function incompatibility
CREATE TYPE bogus_type (INPUT = array_in,
    OUTPUT = array_out,
    ELEMENT = int,
    INTERNALLENGTH = 32)

type input function array_in must return type bogus_type



DROP TYPE bogus_type


-- It no longer is possible to issue CREATE TYPE without making a shell first
CREATE TYPE bogus_type (INPUT = array_in,
    OUTPUT = array_out,
    ELEMENT = int,
    INTERNALLENGTH = 32)
ProgrammingError: 

-- It no longer is possible to issue CREATE TYPE without making a shell first
CREATE TYPE bogus_type (INPUT = array_in,
    OUTPUT = array_out,
    ELEMENT = int,
    INTERNALLENGTH = 32)

type "bogus_type" does not exist
HINT:  Create the type as a shell type, then create its I/O functions, then do a full CREATE TYPE.



-- Test stand-alone composite type

CREATE TYPE default_test_row AS (f1 text_w_default, f2 int42)


CREATE FUNCTION get_default_test() RETURNS SETOF default_test_row AS '
  SELECT * FROM default_test;
' LANGUAGE SQL


SELECT * FROM get_default_test()
RESULT: 
	[('zippo', '42')]


-- Test comments
COMMENT ON TYPE bad IS 'bad comment'
ProgrammingError: 

-- Test comments
COMMENT ON TYPE bad IS 'bad comment'

type "bad" does not exist


COMMENT ON TYPE default_test_row IS 'good comment'

COMMENT ON TYPE default_test_row IS NULL

COMMENT ON COLUMN default_test_row.nope IS 'bad comment'
ProgrammingError: 
COMMENT ON COLUMN default_test_row.nope IS 'bad comment'

column "nope" of relation "default_test_row" does not exist


COMMENT ON COLUMN default_test_row.f1 IS 'good comment'

COMMENT ON COLUMN default_test_row.f1 IS NULL


-- Check shell type create for existing types
CREATE TYPE text_w_default
ProgrammingError: 

-- Check shell type create for existing types
CREATE TYPE text_w_default

type "text_w_default" already exists

		-- should fail

DROP TYPE default_test_row CASCADE


DROP TABLE default_test


-- Check dependencies are established when creating a new type
CREATE TYPE base_type

CREATE FUNCTION base_fn_in(cstring) RETURNS base_type AS 'boolin'
    LANGUAGE internal IMMUTABLE STRICT

CREATE FUNCTION base_fn_out(base_type) RETURNS cstring AS 'boolout'
    LANGUAGE internal IMMUTABLE STRICT

CREATE TYPE base_type(INPUT = base_fn_in, OUTPUT = base_fn_out)

DROP FUNCTION base_fn_in(cstring)
ERROR: 
DROP FUNCTION base_fn_in(cstring)

cannot drop function base_fn_in(cstring) because other objects depend on it
DETAIL:  type base_type depends on function base_fn_in(cstring)
function base_fn_out(base_type) depends on type base_type
HINT:  Use DROP ... CASCADE to drop the dependent objects too.

 -- error
DROP FUNCTION base_fn_out(base_type)
ERROR:  -- error
DROP FUNCTION base_fn_out(base_type)

cannot drop function base_fn_out(base_type) because other objects depend on it
DETAIL:  type base_type depends on function base_fn_out(base_type)
function base_fn_in(cstring) depends on type base_type
HINT:  Use DROP ... CASCADE to drop the dependent objects too.

 -- error
DROP TYPE base_type
ERROR:  -- error
DROP TYPE base_type

cannot drop type base_type because other objects depend on it
DETAIL:  function base_fn_in(cstring) depends on type base_type
function base_fn_out(base_type) depends on type base_type
HINT:  Use DROP ... CASCADE to drop the dependent objects too.

 -- error
DROP TYPE base_type CASCADE


-- Check usage of typmod with a user-defined type
-- (we have borrowed numeric''s typmod functions)

CREATE TEMP TABLE mytab (foo widget(42,13,7))
ERROR: 

-- Check usage of typmod with a user-defined type
-- (we have borrowed numeric''s typmod functions)

CREATE TEMP TABLE mytab (foo widget(42,13,7))

invalid NUMERIC type modifier
LINE 6: CREATE TEMP TABLE mytab (foo widget(42,13,7))
                                     ^

     -- should fail
CREATE TEMP TABLE mytab (foo widget(42,13))


SELECT format_type(atttypid,atttypmod) FROM pg_attribute
WHERE attrelid = 'mytab'::regclass AND attnum > 0
RESULT: 
	[('widget(42,13)',)]


-- might as well exercise the widget type while we''re here
INSERT INTO mytab VALUES ('(1,2,3)'), ('(-44,5.5,12)')

TABLE mytab
RESULT: 
	[('(1,2,3)',), ('(-44,5.5,12)',)]


-- and test format_type() a bit more, too
select format_type('varchar'::regtype, 42)
RESULT: 
	[('character varying(38)',)]

select format_type('bpchar'::regtype, null)
RESULT: 
	[('character',)]

-- this behavior difference is intentional
select format_type('bpchar'::regtype, -1)
RESULT: 
	[('bpchar',)]


-- Test non-error-throwing APIs using widget, which still throws errors
SELECT pg_input_is_valid('(1,2,3)', 'widget')
RESULT: 
	[(True,)]

SELECT pg_input_is_valid('(1,2)', 'widget')
ERROR: 
SELECT pg_input_is_valid('(1,2)', 'widget')

invalid input syntax for type widget: "(1,2)"

  -- hard error expected
SELECT pg_input_is_valid('{"(1,2,3)"}', 'widget[]')
RESULT: 
	[(True,)]

SELECT pg_input_is_valid('{"(1,2)"}', 'widget[]')
ERROR: 
SELECT pg_input_is_valid('{"(1,2)"}', 'widget[]')

invalid input syntax for type widget: "(1,2)"

  -- hard error expected
SELECT pg_input_is_valid('("(1,2,3)")', 'mytab')
RESULT: 
	[(True,)]

SELECT pg_input_is_valid('("(1,2)")', 'mytab')
ERROR: 
SELECT pg_input_is_valid('("(1,2)")', 'mytab')

invalid input syntax for type widget: "(1,2)"

  -- hard error expected

-- Test creation of an operator over a user-defined type

CREATE FUNCTION pt_in_widget(point, widget)
   RETURNS bool
   AS /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/regress.so'
   LANGUAGE C STRICT


CREATE OPERATOR <% (
   leftarg = point,
   rightarg = widget,
   procedure = pt_in_widget,
   commutator = >% ,
   negator = >=%
)


SELECT point '(1,2)' <% widget '(0,0,3)' AS t,
       point '(1,2)' <% widget '(0,0,1)' AS f
RESULT: 
	[(True, False)]


-- exercise city_budget type
CREATE TABLE city (
	name		name,
	location 	box,
	budget 		city_budget
)


INSERT INTO city VALUES
('Podunk', '(1,2),(3,4)', '100,127,1000'),
('Gotham', '(1000,34),(1100,334)', '123456,127,-1000,6789')


TABLE city
RESULT: 
	[('Podunk', '(3,4),(1,2)', '100,127,1000,0'), ('Gotham', '(1100,334),(1000,34)', '123456,127,-1000,6789')]


--
-- Test CREATE/ALTER TYPE using a type that''s compatible with varchar,
-- so we can re-use those support functions
--
CREATE TYPE myvarchar


CREATE FUNCTION myvarcharin(cstring, oid, integer) RETURNS myvarchar
LANGUAGE internal IMMUTABLE PARALLEL SAFE STRICT AS 'varcharin'


CREATE FUNCTION myvarcharout(myvarchar) RETURNS cstring
LANGUAGE internal IMMUTABLE PARALLEL SAFE STRICT AS 'varcharout'


CREATE FUNCTION myvarcharsend(myvarchar) RETURNS bytea
LANGUAGE internal STABLE PARALLEL SAFE STRICT AS 'varcharsend'


CREATE FUNCTION myvarcharrecv(internal, oid, integer) RETURNS myvarchar
LANGUAGE internal STABLE PARALLEL SAFE STRICT AS 'varcharrecv'


-- fail, it''s still a shell:
ALTER TYPE myvarchar SET (storage = extended)
ProgrammingError: 

-- fail, it''s still a shell:
ALTER TYPE myvarchar SET (storage = extended)

type "myvarchar" is only a shell



CREATE TYPE myvarchar (
    input = myvarcharin,
    output = myvarcharout,
    alignment = integer,
    storage = main
)


-- want to check updating of a domain over the target type, too
CREATE DOMAIN myvarchardom AS myvarchar


ALTER TYPE myvarchar SET (storage = plain)
ProgrammingError: 

ALTER TYPE myvarchar SET (storage = plain)

cannot change type's storage to PLAIN

  -- not allowed

ALTER TYPE myvarchar SET (storage = extended)


ALTER TYPE myvarchar SET (
    send = myvarcharsend,
    receive = myvarcharrecv,
    typmod_in = varchartypmodin,
    typmod_out = varchartypmodout,
    -- these are bogus, but it''s safe as long as we don''t use the type:
    analyze = ts_typanalyze,
    subscript = raw_array_subscript_handler
)


SELECT typinput, typoutput, typreceive, typsend, typmodin, typmodout,
       typanalyze, typsubscript, typstorage
FROM pg_type WHERE typname = 'myvarchar'
RESULT: 
	[('myvarcharin', 'myvarcharout', 'myvarcharrecv', 'myvarcharsend', 'varchartypmodin', 'varchartypmodout', 'ts_typanalyze', 'raw_array_subscript_handler', 'x')]


SELECT typinput, typoutput, typreceive, typsend, typmodin, typmodout,
       typanalyze, typsubscript, typstorage
FROM pg_type WHERE typname = '_myvarchar'
RESULT: 
	[('array_in', 'array_out', 'array_recv', 'array_send', 'varchartypmodin', 'varchartypmodout', 'array_typanalyze', 'array_subscript_handler', 'x')]


SELECT typinput, typoutput, typreceive, typsend, typmodin, typmodout,
       typanalyze, typsubscript, typstorage
FROM pg_type WHERE typname = 'myvarchardom'
RESULT: 
	[('domain_in', 'myvarcharout', 'domain_recv', 'myvarcharsend', '-', '-', 'ts_typanalyze', '-', 'x')]


SELECT typinput, typoutput, typreceive, typsend, typmodin, typmodout,
       typanalyze, typsubscript, typstorage
FROM pg_type WHERE typname = '_myvarchardom'
RESULT: 
	[('array_in', 'array_out', 'array_recv', 'array_send', '-', '-', 'array_typanalyze', 'array_subscript_handler', 'x')]


-- ensure dependencies are straight
DROP FUNCTION myvarcharsend(myvarchar)
ERROR: 

-- ensure dependencies are straight
DROP FUNCTION myvarcharsend(myvarchar)

cannot drop function myvarcharsend(myvarchar) because other objects depend on it
DETAIL:  type myvarchar depends on function myvarcharsend(myvarchar)
function myvarcharin(cstring,oid,integer) depends on type myvarchar
function myvarcharout(myvarchar) depends on type myvarchar
function myvarcharrecv(internal,oid,integer) depends on type myvarchar
type myvarchardom depends on function myvarcharsend(myvarchar)
HINT:  Use DROP ... CASCADE to drop the dependent objects too.

  -- fail
DROP TYPE myvarchar
ERROR:   -- fail
DROP TYPE myvarchar

cannot drop type myvarchar because other objects depend on it
DETAIL:  function myvarcharin(cstring,oid,integer) depends on type myvarchar
function myvarcharout(myvarchar) depends on type myvarchar
function myvarcharsend(myvarchar) depends on type myvarchar
function myvarcharrecv(internal,oid,integer) depends on type myvarchar
type myvarchardom depends on type myvarchar
HINT:  Use DROP ... CASCADE to drop the dependent objects too.

  -- fail

DROP TYPE myvarchar CASCADE


