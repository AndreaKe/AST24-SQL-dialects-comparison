--
-- Test domains.
--

-- Test Comment / Drop
create domain domaindroptest int4

comment on domain domaindroptest is 'About to drop this..'


create domain dependenttypetest domaindroptest


-- fail because of dependent type
drop domain domaindroptest
ERROR: 

-- fail because of dependent type
drop domain domaindroptest

cannot drop type domaindroptest because other objects depend on it
DETAIL:  type dependenttypetest depends on type domaindroptest
HINT:  Use DROP ... CASCADE to drop the dependent objects too.



drop domain domaindroptest cascade


-- this should fail because already gone
drop domain domaindroptest cascade
ProgrammingError: 

-- this should fail because already gone
drop domain domaindroptest cascade

type "domaindroptest" does not exist




-- Test domain input.

-- Note: the point of checking both INSERT and COPY FROM is that INSERT
-- exercises CoerceToDomain while COPY exercises domain_in.

create domain domainvarchar varchar(5)

create domain domainnumeric numeric(8,2)

create domain domainint4 int4

create domain domaintext text


-- Test explicit coercions --- these should succeed (and truncate)
SELECT cast('123456' as domainvarchar)
RESULT: 
	[('12345',)]

SELECT cast('12345' as domainvarchar)
RESULT: 
	[('12345',)]


-- Test tables using domains
create table basictest
           ( testint4 domainint4
           , testtext domaintext
           , testvarchar domainvarchar
           , testnumeric domainnumeric
           )


INSERT INTO basictest values ('88', 'haha', 'short', '123.12')
      -- Good
INSERT INTO basictest values ('88', 'haha', 'short text', '123.12')
ERROR:       -- Good
INSERT INTO basictest values ('88', 'haha', 'short text', '123.12')

value too long for type character varying(5)

 -- Bad varchar
INSERT INTO basictest values ('88', 'haha', 'short', '123.1212')
    -- Truncate numeric

-- Test copy
COPY basictest (testvarchar) FROM stdin
ProgrammingError:     -- Truncate numeric

-- Test copy
COPY basictest (testvarchar) FROM stdin

can't execute COPY FROM: use the copy_from() method instead
 -- fail
notsoshorttext
\.

COPY basictest (testvarchar) FROM stdin
ProgrammingError:  -- fail
notsoshorttext
\.

COPY basictest (testvarchar) FROM stdin

syntax error at or near "notsoshorttext"
LINE 2: notsoshorttext
        ^


short
\.

select * from basictest
ProgrammingError: 
short
\.

select * from basictest

syntax error at or near "short"
LINE 2: short
        ^



-- check that domains inherit operations from base types
select testtext || testvarchar as concat, testnumeric + 42 as sum
from basictest
RESULT: 
	[('hahashort', Decimal('165.12')), ('hahashort', Decimal('165.12'))]


-- check that union/case/coalesce type resolution handles domains properly
select pg_typeof(coalesce(4::domainint4, 7))
RESULT: 
	[('integer',)]

select pg_typeof(coalesce(4::domainint4, 7::domainint4))
RESULT: 
	[('domainint4',)]


drop table basictest

drop domain domainvarchar restrict

drop domain domainnumeric restrict

drop domain domainint4 restrict

drop domain domaintext



-- Test non-error-throwing input

create domain positiveint int4 check(value > 0)

create domain weirdfloat float8 check((1 / value) < 10)


select pg_input_is_valid('1', 'positiveint')
RESULT: 
	[(True,)]

select pg_input_is_valid('junk', 'positiveint')
RESULT: 
	[(False,)]

select pg_input_is_valid('-1', 'positiveint')
RESULT: 
	[(False,)]

select * from pg_input_error_info('junk', 'positiveint')
RESULT: 
	[('invalid input syntax for type integer: "junk"', None, None, '22P02')]

select * from pg_input_error_info('-1', 'positiveint')
RESULT: 
	[('value for domain positiveint violates check constraint "positiveint_check"', None, None, '23514')]

select * from pg_input_error_info('junk', 'weirdfloat')
RESULT: 
	[('invalid input syntax for type double precision: "junk"', None, None, '22P02')]

select * from pg_input_error_info('0.01', 'weirdfloat')
RESULT: 
	[('value for domain weirdfloat violates check constraint "weirdfloat_check"', None, None, '23514')]

-- We currently can''t trap errors raised in the CHECK expression itself
select * from pg_input_error_info('0', 'weirdfloat')
ERROR: 
-- We currently can''t trap errors raised in the CHECK expression itself
select * from pg_input_error_info('0', 'weirdfloat')

division by zero



drop domain positiveint

drop domain weirdfloat



-- Test domains over array types

create domain domainint4arr int4[1]

create domain domainchar4arr varchar(4)[2][3]


create table domarrtest
           ( testint4arr domainint4arr
           , testchar4arr domainchar4arr
            )

INSERT INTO domarrtest values ('{2,2}', '{{"a","b"},{"c","d"}}')

INSERT INTO domarrtest values ('{{2,2},{2,2}}', '{{"a","b"}}')

INSERT INTO domarrtest values ('{2,2}', '{{"a","b"},{"c","d"},{"e","f"}}')

INSERT INTO domarrtest values ('{2,2}', '{{"a"},{"c"}}')

INSERT INTO domarrtest values (NULL, '{{"a","b","c"},{"d","e","f"}}')

INSERT INTO domarrtest values (NULL, '{{"toolong","b","c"},{"d","e","f"}}')
ERROR: 
INSERT INTO domarrtest values (NULL, '{{"toolong","b","c"},{"d","e","f"}}')

value too long for type character varying(4)


INSERT INTO domarrtest (testint4arr[1], testint4arr[3]) values (11,22)

select * from domarrtest
RESULT: 
	[([2, 2], [['a', 'b'], ['c', 'd']]), ([[2, 2], [2, 2]], [['a', 'b']]), ([2, 2], [['a', 'b'], ['c', 'd'], ['e', 'f']]), ([2, 2], [['a'], ['c']]), (None, [['a', 'b', 'c'], ['d', 'e', 'f']]), ([11, None, 22], None)]

select testint4arr[1], testchar4arr[2:2] from domarrtest
RESULT: 
	[(2, [['c', 'd']]), (None, []), (2, [['c', 'd']]), (2, [['c']]), (None, [['d', 'e', 'f']]), (11, None)]

select array_dims(testint4arr), array_dims(testchar4arr) from domarrtest
RESULT: 
	[('[1:2]', '[1:2][1:2]'), ('[1:2][1:2]', '[1:1][1:2]'), ('[1:2]', '[1:3][1:2]'), ('[1:2]', '[1:2][1:1]'), (None, '[1:2][1:3]'), ('[1:3]', None)]


COPY domarrtest FROM stdin
ProgrammingError: 

COPY domarrtest FROM stdin

can't execute COPY FROM: use the copy_from() method instead

{3,4}	{q,w,e}
\N	\N
\.

COPY domarrtest FROM stdin
ProgrammingError: 
{3,4}	{q,w,e}
\N	\N
\.

COPY domarrtest FROM stdin

syntax error at or near "{"
LINE 2: {3,4} {q,w,e}
        ^

	-- fail
{3,4}	{qwerty,w,e}
\.

select * from domarrtest
ProgrammingError: 	-- fail
{3,4}	{qwerty,w,e}
\.

select * from domarrtest

syntax error at or near "{"
LINE 2: {3,4} {qwerty,w,e}
        ^



update domarrtest set
  testint4arr[1] = testint4arr[1] + 1,
  testint4arr[3] = testint4arr[3] - 1
where testchar4arr is null


select * from domarrtest where testchar4arr is null
RESULT: 
	[([12, None, 21], None)]


drop table domarrtest

drop domain domainint4arr restrict

drop domain domainchar4arr restrict


create domain dia as int[]

select '{1,2,3}'::dia
RESULT: 
	[([1, 2, 3],)]

select array_dims('{1,2,3}'::dia)
RESULT: 
	[('[1:3]',)]

select pg_typeof('{1,2,3}'::dia)
RESULT: 
	[('dia',)]

select pg_typeof('{1,2,3}'::dia || 42)
RESULT: 
	[('integer[]',)]
 -- should be int[] not dia
drop domain dia



-- Test domains over composites

create type comptype as (r float8, i float8)

create domain dcomptype as comptype

create table dcomptable (d1 dcomptype unique)


insert into dcomptable values (row(1,2)::dcomptype)

insert into dcomptable values (row(3,4)::comptype)

insert into dcomptable values (row(1,2)::dcomptype)
ERROR: 
insert into dcomptable values (row(1,2)::dcomptype)

duplicate key value violates unique constraint "dcomptable_d1_key"
DETAIL:  Key (d1)=((1,2)) already exists.

  -- fail on uniqueness
insert into dcomptable (d1.r) values(11)


select * from dcomptable
RESULT: 
	[('(1,2)',), ('(3,4)',), ('(11,)',)]

select (d1).r, (d1).i, (d1).* from dcomptable
RESULT: 
	[(1.0, 2.0, 1.0, 2.0), (3.0, 4.0, 3.0, 4.0), (11.0, None, 11.0, None)]

update dcomptable set d1.r = (d1).r + 1 where (d1).i > 0

select * from dcomptable
RESULT: 
	[('(11,)',), ('(2,2)',), ('(4,4)',)]


alter domain dcomptype add constraint c1 check ((value).r <= (value).i)

alter domain dcomptype add constraint c2 check ((value).r > (value).i)
ERROR: 
alter domain dcomptype add constraint c2 check ((value).r > (value).i)

column "d1" of table "dcomptable" contains values that violate the new constraint

  -- fail

select row(2,1)::dcomptype
ERROR:   -- fail

select row(2,1)::dcomptype

value for domain dcomptype violates check constraint "c1"

  -- fail
insert into dcomptable values (row(1,2)::comptype)

insert into dcomptable values (row(2,1)::comptype)
ERROR: 
insert into dcomptable values (row(2,1)::comptype)

value for domain dcomptype violates check constraint "c1"

  -- fail
insert into dcomptable (d1.r) values(99)

insert into dcomptable (d1.r, d1.i) values(99, 100)

insert into dcomptable (d1.r, d1.i) values(100, 99)
ERROR: 
insert into dcomptable (d1.r, d1.i) values(100, 99)

value for domain dcomptype violates check constraint "c1"

  -- fail
update dcomptable set d1.r = (d1).r + 1 where (d1).i > 0
ERROR:   -- fail
update dcomptable set d1.r = (d1).r + 1 where (d1).i > 0

value for domain dcomptype violates check constraint "c1"

  -- fail
update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0

select * from dcomptable
RESULT: 
	[('(11,)',), ('(99,)',), ('(1,3)',), ('(3,5)',), ('(0,3)',), ('(98,101)',)]


explain (verbose, costs off)
  update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0
RESULT: 
	[('Update on public.dcomptable',), ('  ->  Seq Scan on public.dcomptable',), ("        Output: ROW(((d1).r - '1'::double precision), ((d1).i + '1'::double precision)), ctid",), ("        Filter: ((dcomptable.d1).i > '0'::double precision)",)]

create rule silly as on delete to dcomptable do instead
  update dcomptable set d1.r = (d1).r - 1, d1.i = (d1).i + 1 where (d1).i > 0

-- \d+ dcomptable

create function makedcomp(r float8, i float8) returns dcomptype
as 'select row(r, i)' language sql


select makedcomp(1,2)
RESULT: 
	[('(1,2)',)]

select makedcomp(2,1)
ERROR: 
select makedcomp(2,1)

value for domain dcomptype violates check constraint "c1"

  -- fail
select * from makedcomp(1,2) m
RESULT: 
	[(1.0, 2.0)]

select m, m is not null from makedcomp(1,2) m
RESULT: 
	[('(1,2)', True)]


drop function makedcomp(float8, float8)

drop table dcomptable

drop type comptype cascade



-- check altering and dropping columns used by domain constraints
create type comptype as (r float8, i float8)

create domain dcomptype as comptype

alter domain dcomptype add constraint c1 check ((value).r > 0)

comment on constraint c1 on domain dcomptype is 'random commentary'


select row(0,1)::dcomptype
ERROR: 

select row(0,1)::dcomptype

value for domain dcomptype violates check constraint "c1"

  -- fail

alter type comptype alter attribute r type varchar
ProgrammingError:   -- fail

alter type comptype alter attribute r type varchar

operator does not exist: character varying > double precision
HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.

  -- fail
alter type comptype alter attribute r type bigint


alter type comptype drop attribute r
ERROR: 

alter type comptype drop attribute r

cannot drop column r of composite type comptype because other objects depend on it
DETAIL:  constraint c1 depends on column r of composite type comptype
HINT:  Use DROP ... CASCADE to drop the dependent objects too.

  -- fail
alter type comptype drop attribute i


select conname, obj_description(oid, 'pg_constraint') from pg_constraint
  where contypid = 'dcomptype'::regtype
RESULT: 
	[('c1', 'random commentary')]
  -- check comment is still there

drop type comptype cascade



-- Test domains over arrays of composite

create type comptype as (r float8, i float8)

create domain dcomptypea as comptype[]

create table dcomptable (d1 dcomptypea unique)


insert into dcomptable values (array[row(1,2)]::dcomptypea)

insert into dcomptable values (array[row(3,4), row(5,6)]::comptype[])

insert into dcomptable values (array[row(7,8)::comptype, row(9,10)::comptype])

insert into dcomptable values (array[row(1,2)]::dcomptypea)
ERROR: 
insert into dcomptable values (array[row(1,2)]::dcomptypea)

duplicate key value violates unique constraint "dcomptable_d1_key"
DETAIL:  Key (d1)=({"(1,2)"}) already exists.

  -- fail on uniqueness
insert into dcomptable (d1[1]) values(row(9,10))

insert into dcomptable (d1[1].r) values(11)


select * from dcomptable
RESULT: 
	[('{"(1,2)"}',), ('{"(3,4)","(5,6)"}',), ('{"(7,8)","(9,10)"}',), ('{"(9,10)"}',), ('{"(11,)"}',)]

select d1[2], d1[1].r, d1[1].i from dcomptable
RESULT: 
	[(None, 1.0, 2.0), ('(5,6)', 3.0, 4.0), ('(9,10)', 7.0, 8.0), (None, 9.0, 10.0), (None, 11.0, None)]

update dcomptable set d1[2] = row(d1[2].i, d1[2].r)

select * from dcomptable
RESULT: 
	[('{"(1,2)","(,)"}',), ('{"(3,4)","(6,5)"}',), ('{"(7,8)","(10,9)"}',), ('{"(9,10)","(,)"}',), ('{"(11,)","(,)"}',)]

update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0

select * from dcomptable
RESULT: 
	[('{"(11,)","(,)"}',), ('{"(2,2)","(,)"}',), ('{"(4,4)","(6,5)"}',), ('{"(8,8)","(10,9)"}',), ('{"(10,10)","(,)"}',)]


alter domain dcomptypea add constraint c1 check (value[1].r <= value[1].i)

alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i)
ERROR: 
alter domain dcomptypea add constraint c2 check (value[1].r > value[1].i)

column "d1" of table "dcomptable" contains values that violate the new constraint

  -- fail

select array[row(2,1)]::dcomptypea
ERROR:   -- fail

select array[row(2,1)]::dcomptypea

value for domain dcomptypea violates check constraint "c1"

  -- fail
insert into dcomptable values (array[row(1,2)]::comptype[])

insert into dcomptable values (array[row(2,1)]::comptype[])
ERROR: 
insert into dcomptable values (array[row(2,1)]::comptype[])

value for domain dcomptypea violates check constraint "c1"

  -- fail
insert into dcomptable (d1[1].r) values(99)

insert into dcomptable (d1[1].r, d1[1].i) values(99, 100)

insert into dcomptable (d1[1].r, d1[1].i) values(100, 99)
ERROR: 
insert into dcomptable (d1[1].r, d1[1].i) values(100, 99)

value for domain dcomptypea violates check constraint "c1"

  -- fail
update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0
ERROR:   -- fail
update dcomptable set d1[1].r = d1[1].r + 1 where d1[1].i > 0

value for domain dcomptypea violates check constraint "c1"

  -- fail
update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
  where d1[1].i > 0

select * from dcomptable
RESULT: 
	[('{"(11,)","(,)"}',), ('{"(99,)"}',), ('{"(1,3)","(,)"}',), ('{"(3,5)","(6,5)"}',), ('{"(7,9)","(10,9)"}',), ('{"(9,11)","(,)"}',), ('{"(0,3)"}',), ('{"(98,101)"}',)]


explain (verbose, costs off)
  update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
    where d1[1].i > 0
RESULT: 
	[('Update on public.dcomptable',), ('  ->  Seq Scan on public.dcomptable',), ("        Output: (d1[1].r := (d1[1].r - '1'::double precision))[1].i := (d1[1].i + '1'::double precision), ctid",), ("        Filter: (dcomptable.d1[1].i > '0'::double precision)",)]

create rule silly as on delete to dcomptable do instead
  update dcomptable set d1[1].r = d1[1].r - 1, d1[1].i = d1[1].i + 1
    where d1[1].i > 0

-- \d+ dcomptable

drop table dcomptable

drop type comptype cascade



-- Test arrays over domains

create domain posint as int check (value > 0)


create table pitable (f1 posint[])

insert into pitable values(array[42])

insert into pitable values(array[-1])
ERROR: 
insert into pitable values(array[-1])

value for domain posint violates check constraint "posint_check"

  -- fail
insert into pitable values('{0}')
ERROR:   -- fail
insert into pitable values('{0}')

value for domain posint violates check constraint "posint_check"
LINE 2: insert into pitable values('{0}')
                                   ^

  -- fail
update pitable set f1[1] = f1[1] + 1

update pitable set f1[1] = 0
ERROR: 
update pitable set f1[1] = 0

value for domain posint violates check constraint "posint_check"

  -- fail
select * from pitable
RESULT: 
	[('{43}',)]

drop table pitable


create domain vc4 as varchar(4)

create table vc4table (f1 vc4[])

insert into vc4table values(array['too long'])
ERROR: 
insert into vc4table values(array['too long'])

value too long for type character varying(4)

  -- fail
insert into vc4table values(array['too long']::vc4[])
  -- cast truncates
select * from vc4table
RESULT: 
	[('{"too "}',)]

drop table vc4table

drop type vc4


-- You can sort of fake arrays-of-arrays by putting a domain in between
create domain dposinta as posint[]

create table dposintatable (f1 dposinta[])

insert into dposintatable values(array[array[42]])
ProgrammingError: 
insert into dposintatable values(array[array[42]])

column "f1" is of type dposinta[] but expression is of type integer[]
LINE 2: insert into dposintatable values(array[array[42]])
                                         ^
HINT:  You will need to rewrite or cast the expression.

  -- fail
insert into dposintatable values(array[array[42]::posint[]])
ProgrammingError:   -- fail
insert into dposintatable values(array[array[42]::posint[]])

column "f1" is of type dposinta[] but expression is of type posint[]
LINE 2: insert into dposintatable values(array[array[42]::posint[]])
                                         ^
HINT:  You will need to rewrite or cast the expression.

 -- still fail
insert into dposintatable values(array[array[42]::dposinta])
 -- but this works
select f1, f1[1], (f1[1])[1] from dposintatable
RESULT: 
	[('{"{42}"}', '{42}', 42)]

select pg_typeof(f1) from dposintatable
RESULT: 
	[('dposinta[]',)]

select pg_typeof(f1[1]) from dposintatable
RESULT: 
	[('dposinta',)]

select pg_typeof(f1[1][1]) from dposintatable
RESULT: 
	[('dposinta',)]

select pg_typeof((f1[1])[1]) from dposintatable
RESULT: 
	[('posint',)]

update dposintatable set f1[2] = array[99]

select f1, f1[1], (f1[2])[1] from dposintatable
RESULT: 
	[('{"{42}","{99}"}', '{42}', 99)]

-- it''d be nice if you could do something like this, but for now you can''t:
update dposintatable set f1[2][1] = array[97]
ERROR: 
-- it''d be nice if you could do something like this, but for now you can''t:
update dposintatable set f1[2][1] = array[97]

wrong number of array subscripts


-- maybe someday we can make this syntax work:
update dposintatable set (f1[2])[1] = array[98]
ProgrammingError: 
-- maybe someday we can make this syntax work:
update dposintatable set (f1[2])[1] = array[98]

syntax error at or near "["
LINE 3: update dposintatable set (f1[2])[1] = array[98]
                                        ^



drop table dposintatable

drop domain posint cascade



-- Test arrays over domains of composite

create type comptype as (cf1 int, cf2 int)

create domain dcomptype as comptype check ((value).cf1 > 0)


create table dcomptable (f1 dcomptype[])

insert into dcomptable values (null)

update dcomptable set f1[1].cf2 = 5

table dcomptable
RESULT: 
	[('{"(,5)"}',)]

update dcomptable set f1[1].cf1 = -1
ERROR: 
update dcomptable set f1[1].cf1 = -1

value for domain dcomptype violates check constraint "dcomptype_check"

  -- fail
update dcomptable set f1[1].cf1 = 1

table dcomptable
RESULT: 
	[('{"(1,5)"}',)]

-- if there''s no constraints, a different code path is taken:
alter domain dcomptype drop constraint dcomptype_check

update dcomptable set f1[1].cf1 = -1
  -- now ok
table dcomptable
RESULT: 
	[('{"(-1,5)"}',)]


drop table dcomptable

drop type comptype cascade



-- Test not-null restrictions

create domain dnotnull varchar(15) NOT NULL

create domain dnull    varchar(15)

create domain dcheck   varchar(15) NOT NULL CHECK (VALUE = 'a' OR VALUE = 'c' OR VALUE = 'd')


create table nulltest
           ( col1 dnotnull
           , col2 dnotnull NULL  -- NOT NULL in the domain cannot be overridden
           , col3 dnull    NOT NULL
           , col4 dnull
           , col5 dcheck CHECK (col5 IN ('c', 'd'))
           )

INSERT INTO nulltest DEFAULT VALUES
ERROR: 
INSERT INTO nulltest DEFAULT VALUES

domain dnotnull does not allow null values


INSERT INTO nulltest values ('a', 'b', 'c', 'd', 'c')
  -- Good
insert into nulltest values ('a', 'b', 'c', 'd', NULL)
ERROR:   -- Good
insert into nulltest values ('a', 'b', 'c', 'd', NULL)

domain dcheck does not allow null values


insert into nulltest values ('a', 'b', 'c', 'd', 'a')
ERROR: 
insert into nulltest values ('a', 'b', 'c', 'd', 'a')

new row for relation "nulltest" violates check constraint "nulltest_col5_check"
DETAIL:  Failing row contains (a, b, c, d, a).


INSERT INTO nulltest values (NULL, 'b', 'c', 'd', 'd')
ERROR: 
INSERT INTO nulltest values (NULL, 'b', 'c', 'd', 'd')

domain dnotnull does not allow null values


INSERT INTO nulltest values ('a', NULL, 'c', 'd', 'c')
ERROR: 
INSERT INTO nulltest values ('a', NULL, 'c', 'd', 'c')

domain dnotnull does not allow null values


INSERT INTO nulltest values ('a', 'b', NULL, 'd', 'c')
ERROR: 
INSERT INTO nulltest values ('a', 'b', NULL, 'd', 'c')

null value in column "col3" of relation "nulltest" violates not-null constraint
DETAIL:  Failing row contains (a, b, null, d, c).


INSERT INTO nulltest values ('a', 'b', 'c', NULL, 'd')
 -- Good

-- Test copy
COPY nulltest FROM stdin
ProgrammingError:  -- Good

-- Test copy
COPY nulltest FROM stdin

can't execute COPY FROM: use the copy_from() method instead
 --fail
a	b	\N	d	d
\.

COPY nulltest FROM stdin
ProgrammingError:  --fail
a	b	\N	d	d
\.

COPY nulltest FROM stdin

syntax error at or near "a"
LINE 2: a b \N d d
        ^

 --fail
a	b	c	d	\N
\.

-- Last row is bad
COPY nulltest FROM stdin
ProgrammingError:  --fail
a	b	c	d	\N
\.

-- Last row is bad
COPY nulltest FROM stdin

syntax error at or near "a"
LINE 2: a b c d \N
        ^


a	b	c	\N	c
a	b	c	\N	d
a	b	c	\N	a
\.

select * from nulltest
ProgrammingError: 
a	b	c	\N	c
a	b	c	\N	d
a	b	c	\N	a
\.

select * from nulltest

syntax error at or near "a"
LINE 2: a b c \N c
        ^



-- Test out coerced (casted) constraints
SELECT cast('1' as dnotnull)
RESULT: 
	[('1',)]

SELECT cast(NULL as dnotnull)
ERROR: 
SELECT cast(NULL as dnotnull)

domain dnotnull does not allow null values

 -- fail
SELECT cast(cast(NULL as dnull) as dnotnull)
ERROR:  -- fail
SELECT cast(cast(NULL as dnull) as dnotnull)

domain dnotnull does not allow null values

 -- fail
SELECT cast(col4 as dnotnull) from nulltest
ERROR:  -- fail
SELECT cast(col4 as dnotnull) from nulltest

domain dnotnull does not allow null values

 -- fail

-- cleanup
drop table nulltest

drop domain dnotnull restrict

drop domain dnull restrict

drop domain dcheck restrict



create domain ddef1 int4 DEFAULT 3

create domain ddef2 oid DEFAULT '12'

-- Type mixing, function returns int8
create domain ddef3 text DEFAULT 5

create sequence ddef4_seq

create domain ddef4 int4 DEFAULT nextval('ddef4_seq')

create domain ddef5 numeric(8,2) NOT NULL DEFAULT '12.12'


create table defaulttest
            ( col1 ddef1
            , col2 ddef2
            , col3 ddef3
            , col4 ddef4 PRIMARY KEY
            , col5 ddef1 NOT NULL DEFAULT NULL
            , col6 ddef2 DEFAULT '88'
            , col7 ddef4 DEFAULT 8000
            , col8 ddef5
            )

insert into defaulttest(col4) values(0)
ERROR: 
insert into defaulttest(col4) values(0)

null value in column "col5" of relation "defaulttest" violates not-null constraint
DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).

 -- fails, col5 defaults to null
alter table defaulttest alter column col5 drop default

insert into defaulttest default values
 -- succeeds, inserts domain default
-- We used to treat SET DEFAULT NULL as equivalent to DROP DEFAULT /* REPLACED */, wrong
alter table defaulttest alter column col5 set default null

insert into defaulttest(col4) values(0)
ERROR: 
insert into defaulttest(col4) values(0)

null value in column "col5" of relation "defaulttest" violates not-null constraint
DETAIL:  Failing row contains (3, 12, 5, 0, null, 88, 8000, 12.12).

 -- fails
alter table defaulttest alter column col5 drop default

insert into defaulttest default values

insert into defaulttest default values


-- Test defaults with copy
COPY defaulttest(col5) FROM stdin
ProgrammingError: 

-- Test defaults with copy
COPY defaulttest(col5) FROM stdin

can't execute COPY FROM: use the copy_from() method instead

42
\.

select * from defaulttest
ProgrammingError: 
42
\.

select * from defaulttest

syntax error at or near "42"
LINE 2: 42
        ^



drop table defaulttest cascade


-- Test ALTER DOMAIN .. NOT NULL
create domain dnotnulltest integer

create table domnotnull
( col1 dnotnulltest
, col2 dnotnulltest
)


insert into domnotnull default values

alter domain dnotnulltest set not null
ERROR: 
alter domain dnotnulltest set not null

column "col1" of table "domnotnull" contains null values

 -- fails

update domnotnull set col1 = 5

alter domain dnotnulltest set not null
ERROR: 
alter domain dnotnulltest set not null

column "col2" of table "domnotnull" contains null values

 -- fails

update domnotnull set col2 = 6


alter domain dnotnulltest set not null


update domnotnull set col1 = null
ERROR: 

update domnotnull set col1 = null

domain dnotnulltest does not allow null values

 -- fails

alter domain dnotnulltest drop not null


update domnotnull set col1 = null


drop domain dnotnulltest cascade


-- Test ALTER DOMAIN .. DEFAULT ..
create table domdeftest (col1 ddef1)


insert into domdeftest default values

select * from domdeftest
RESULT: 
	[(3,)]


alter domain ddef1 set default '42'

insert into domdeftest default values

select * from domdeftest
RESULT: 
	[(3,), (42,)]


alter domain ddef1 drop default

insert into domdeftest default values

select * from domdeftest
RESULT: 
	[(3,), (42,), (None,)]


drop table domdeftest


-- Test ALTER DOMAIN .. CONSTRAINT ..
create domain con as integer

create table domcontest (col1 con)


insert into domcontest values (1)

insert into domcontest values (2)

alter domain con add constraint t check (VALUE < 1)
ERROR: 
alter domain con add constraint t check (VALUE < 1)

column "col1" of table "domcontest" contains values that violate the new constraint

 -- fails

alter domain con add constraint t check (VALUE < 34)

alter domain con add check (VALUE > 0)


insert into domcontest values (-5)
ERROR: 

insert into domcontest values (-5)

value for domain con violates check constraint "con_check"

 -- fails
insert into domcontest values (42)
ERROR:  -- fails
insert into domcontest values (42)

value for domain con violates check constraint "t"

 -- fails
insert into domcontest values (5)


alter domain con drop constraint t

insert into domcontest values (-5)
ERROR: 
insert into domcontest values (-5)

value for domain con violates check constraint "con_check"

 --fails
insert into domcontest values (42)


alter domain con drop constraint nonexistent
ProgrammingError: 

alter domain con drop constraint nonexistent

constraint "nonexistent" of domain "con" does not exist


alter domain con drop constraint if exists nonexistent


-- not-null constraints
create domain connotnull integer

create table domconnotnulltest
( col1 connotnull
, col2 connotnull
)


insert into domconnotnulltest default values

alter domain connotnull add not null value
ERROR: 
alter domain connotnull add not null value

column "col1" of table "domconnotnulltest" contains null values

 -- fails

update domconnotnulltest set col1 = 5

alter domain connotnull add not null value
ERROR: 
alter domain connotnull add not null value

column "col2" of table "domconnotnulltest" contains null values

 -- fails

update domconnotnulltest set col2 = 6


alter domain connotnull add constraint constr1 not null value

select count(*) from pg_constraint where contypid = 'connotnull'::regtype and contype = 'n'
RESULT: 
	[(1,)]

alter domain connotnull add constraint constr1bis not null value
  -- redundant
select count(*) from pg_constraint where contypid = 'connotnull'::regtype and contype = 'n'
RESULT: 
	[(1,)]


update domconnotnulltest set col1 = null
ERROR: 

update domconnotnulltest set col1 = null

domain connotnull does not allow null values

 -- fails

alter domain connotnull drop constraint constr1


update domconnotnulltest set col1 = null


drop domain connotnull cascade

drop table domconnotnulltest


-- Test ALTER DOMAIN .. CONSTRAINT .. NOT VALID
create domain things AS INT

CREATE TABLE thethings (stuff things)

INSERT INTO thethings (stuff) VALUES (55)

ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11)
ERROR: 
ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11)

column "stuff" of table "thethings" contains values that violate the new constraint


ALTER DOMAIN things ADD CONSTRAINT meow CHECK (VALUE < 11) NOT VALID

ALTER DOMAIN things VALIDATE CONSTRAINT meow
ERROR: 
ALTER DOMAIN things VALIDATE CONSTRAINT meow

column "stuff" of table "thethings" contains values that violate the new constraint


UPDATE thethings SET stuff = 10

ALTER DOMAIN things VALIDATE CONSTRAINT meow


-- Confirm ALTER DOMAIN with RULES.
create table domtab (col1 integer)

create domain dom as integer

create view domview as select cast(col1 as dom) from domtab

insert into domtab (col1) values (null)

insert into domtab (col1) values (5)

select * from domview
RESULT: 
	[(None,), (5,)]


alter domain dom set not null

select * from domview
ERROR: 
select * from domview

domain dom does not allow null values

 -- fail

alter domain dom drop not null

select * from domview
RESULT: 
	[(None,), (5,)]


alter domain dom add constraint domchkgt6 check(value > 6)

select * from domview
ERROR: 
select * from domview

value for domain dom violates check constraint "domchkgt6"

 --fail

alter domain dom drop constraint domchkgt6 restrict

select * from domview
RESULT: 
	[(None,), (5,)]


-- cleanup
drop domain ddef1 restrict

drop domain ddef2 restrict

drop domain ddef3 restrict

drop domain ddef4 restrict

drop domain ddef5 restrict

drop sequence ddef4_seq


-- Test domains over domains
create domain vchar4 varchar(4)

create domain dinter vchar4 check (substring(VALUE, 1, 1) = 'x')

create domain dtop dinter check (substring(VALUE, 2, 1) = '1')


select 'x123'::dtop
RESULT: 
	[('x123',)]

select 'x1234'::dtop
RESULT: 
	[('x123',)]
 -- explicit coercion should truncate
select 'y1234'::dtop
ERROR:  -- explicit coercion should truncate
select 'y1234'::dtop

value for domain dtop violates check constraint "dinter_check"

 -- fail
select 'y123'::dtop
ERROR:  -- fail
select 'y123'::dtop

value for domain dtop violates check constraint "dinter_check"

 -- fail
select 'yz23'::dtop
ERROR:  -- fail
select 'yz23'::dtop

value for domain dtop violates check constraint "dinter_check"

 -- fail
select 'xz23'::dtop
ERROR:  -- fail
select 'xz23'::dtop

value for domain dtop violates check constraint "dtop_check"

 -- fail

create temp table dtest(f1 dtop)


insert into dtest values('x123')

insert into dtest values('x1234')
ERROR: 
insert into dtest values('x1234')

value too long for type character varying(4)

 -- fail, implicit coercion
insert into dtest values('y1234')
ERROR:  -- fail, implicit coercion
insert into dtest values('y1234')

value too long for type character varying(4)

 -- fail, implicit coercion
insert into dtest values('y123')
ERROR:  -- fail, implicit coercion
insert into dtest values('y123')

value for domain dtop violates check constraint "dinter_check"

 -- fail
insert into dtest values('yz23')
ERROR:  -- fail
insert into dtest values('yz23')

value for domain dtop violates check constraint "dinter_check"

 -- fail
insert into dtest values('xz23')
ERROR:  -- fail
insert into dtest values('xz23')

value for domain dtop violates check constraint "dtop_check"

 -- fail

drop table dtest

drop domain vchar4 cascade


-- Make sure that constraints of newly-added domain columns are
-- enforced correctly, even if there''s no default value for the new
-- column. Per bug #1433
create domain str_domain as text not null


create table domain_test (a int, b int)


insert into domain_test values (1, 2)

insert into domain_test values (1, 2)


-- should fail
alter table domain_test add column c str_domain
ERROR: 

-- should fail
alter table domain_test add column c str_domain

domain str_domain does not allow null values



create domain str_domain2 as text check (value <> 'foo') default 'foo'


-- should fail
alter table domain_test add column d str_domain2
ERROR: 

-- should fail
alter table domain_test add column d str_domain2

value for domain str_domain2 violates check constraint "str_domain2_check"



-- Check that domain constraints on prepared statement parameters of
-- unknown type are enforced correctly.
create domain pos_int as int4 check (value > 0) not null

prepare s1 as select $1::pos_int = 10 as "is_ten"


execute s1(10)
RESULT: 
	[(True,)]

execute s1(0)
ERROR: 
execute s1(0)

value for domain pos_int violates check constraint "pos_int_check"

 -- should fail
execute s1(NULL)
ERROR:  -- should fail
execute s1(NULL)

domain pos_int does not allow null values

 -- should fail

-- Check that domain constraints on plpgsql function parameters, results,
-- and local variables are enforced correctly.

create function doubledecrement(p1 pos_int) returns pos_int as $$
declare v pos_int;
begin
    return p1;
end$$ language plpgsql


select doubledecrement(3)
ERROR: 

select doubledecrement(3)

domain pos_int does not allow null values
CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 2 during statement block local variable initialization

 -- fail because of implicit null assignment

create or replace function doubledecrement(p1 pos_int) returns pos_int as $$
declare v pos_int := 0;
begin
    return p1;
end$$ language plpgsql


select doubledecrement(3)
ERROR: 

select doubledecrement(3)

value for domain pos_int violates check constraint "pos_int_check"
CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 2 during statement block local variable initialization

 -- fail at initialization assignment

create or replace function doubledecrement(p1 pos_int) returns pos_int as $$
declare v pos_int := 1;
begin
    v := p1 - 1;
    return v - 1;
end$$ language plpgsql


select doubledecrement(null)
ERROR: 

select doubledecrement(null)

domain pos_int does not allow null values

 -- fail before call
select doubledecrement(0)
ERROR:  -- fail before call
select doubledecrement(0)

value for domain pos_int violates check constraint "pos_int_check"

 -- fail before call
select doubledecrement(1)
ERROR:  -- fail before call
select doubledecrement(1)

value for domain pos_int violates check constraint "pos_int_check"
CONTEXT:  PL/pgSQL function doubledecrement(pos_int) line 4 at assignment

 -- fail at assignment to v
select doubledecrement(2)
ERROR:  -- fail at assignment to v
select doubledecrement(2)

value for domain pos_int violates check constraint "pos_int_check"
CONTEXT:  PL/pgSQL function doubledecrement(pos_int) while casting return value to function's return type

 -- fail at return
select doubledecrement(3)
RESULT: 
	[(1,)]
 -- good

-- Check that ALTER DOMAIN tests columns of derived types

create domain posint as int4


-- Currently, this doesn''t work for composite types, but verify it complains
create type ddtest1 as (f1 posint)

create table ddtest2(f1 ddtest1)

insert into ddtest2 values(row(-1))

alter domain posint add constraint c1 check(value >= 0)
ERROR: 
alter domain posint add constraint c1 check(value >= 0)

cannot alter type "posint" because column "ddtest2.f1" uses it


drop table ddtest2


-- Likewise for domains within arrays of composite
create table ddtest2(f1 ddtest1[])

insert into ddtest2 values('{(-1)}')

alter domain posint add constraint c1 check(value >= 0)
ERROR: 
alter domain posint add constraint c1 check(value >= 0)

cannot alter type "posint" because column "ddtest2.f1" uses it


drop table ddtest2


-- Likewise for domains within domains over composite
create domain ddtest1d as ddtest1

create table ddtest2(f1 ddtest1d)

insert into ddtest2 values('(-1)')

alter domain posint add constraint c1 check(value >= 0)
ERROR: 
alter domain posint add constraint c1 check(value >= 0)

cannot alter type "posint" because column "ddtest2.f1" uses it


drop table ddtest2

drop domain ddtest1d


-- Likewise for domains within domains over array of composite
create domain ddtest1d as ddtest1[]

create table ddtest2(f1 ddtest1d)

insert into ddtest2 values('{(-1)}')

alter domain posint add constraint c1 check(value >= 0)
ERROR: 
alter domain posint add constraint c1 check(value >= 0)

cannot alter type "posint" because column "ddtest2.f1" uses it


drop table ddtest2

drop domain ddtest1d


-- Doesn''t work for ranges, either
create type rposint as range (subtype = posint)

create table ddtest2(f1 rposint)

insert into ddtest2 values('(-1,3]')

alter domain posint add constraint c1 check(value >= 0)
ERROR: 
alter domain posint add constraint c1 check(value >= 0)

cannot alter type "posint" because column "ddtest2.f1" uses it


drop table ddtest2

drop type rposint


alter domain posint add constraint c1 check(value >= 0)


create domain posint2 as posint check (value % 2 = 0)

create table ddtest2(f1 posint2)

insert into ddtest2 values(11)
ERROR: 
insert into ddtest2 values(11)

value for domain posint2 violates check constraint "posint2_check"

 -- fail
insert into ddtest2 values(-2)
ERROR:  -- fail
insert into ddtest2 values(-2)

value for domain posint2 violates check constraint "c1"

 -- fail
insert into ddtest2 values(2)


alter domain posint add constraint c2 check(value >= 10)
ERROR: 

alter domain posint add constraint c2 check(value >= 10)

column "f1" of table "ddtest2" contains values that violate the new constraint

 -- fail
alter domain posint add constraint c2 check(value > 0)
 -- OK

drop table ddtest2

drop type ddtest1

drop domain posint cascade


--
-- Check enforcement of domain-related typmod in plpgsql (bug #5717)
--

create or replace function array_elem_check(numeric) returns numeric as $$
declare
  x numeric(4,2)[1];
begin
  x[1] := $1;
  return x[1];
end$$ language plpgsql


select array_elem_check(121.00)
ERROR: 

select array_elem_check(121.00)

numeric field overflow
DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment


select array_elem_check(1.23456)
RESULT: 
	[(Decimal('1.23'),)]


create domain mynums as numeric(4,2)[1]


create or replace function array_elem_check(numeric) returns numeric as $$
declare
  x mynums;
begin
  x[1] := $1;
  return x[1];
end$$ language plpgsql


select array_elem_check(121.00)
ERROR: 

select array_elem_check(121.00)

numeric field overflow
DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment


select array_elem_check(1.23456)
RESULT: 
	[(Decimal('1.23'),)]


create domain mynums2 as mynums


create or replace function array_elem_check(numeric) returns numeric as $$
declare
  x mynums2;
begin
  x[1] := $1;
  return x[1];
end$$ language plpgsql


select array_elem_check(121.00)
ERROR: 

select array_elem_check(121.00)

numeric field overflow
DETAIL:  A field with precision 4, scale 2 must round to an absolute value less than 10^2.
CONTEXT:  PL/pgSQL function array_elem_check(numeric) line 5 at assignment


select array_elem_check(1.23456)
RESULT: 
	[(Decimal('1.23'),)]


drop function array_elem_check(numeric)


--
-- Check enforcement of array-level domain constraints
--

create domain orderedpair as int[2] check (value[1] < value[2])


select array[1,2]::orderedpair
RESULT: 
	[([1, 2],)]

select array[2,1]::orderedpair
ERROR: 
select array[2,1]::orderedpair

value for domain orderedpair violates check constraint "orderedpair_check"

  -- fail

create temp table op (f1 orderedpair)

insert into op values (array[1,2])

insert into op values (array[2,1])
ERROR: 
insert into op values (array[2,1])

value for domain orderedpair violates check constraint "orderedpair_check"

  -- fail

update op set f1[2] = 3

update op set f1[2] = 0
ERROR: 
update op set f1[2] = 0

value for domain orderedpair violates check constraint "orderedpair_check"

  -- fail
select * from op
RESULT: 
	[([1, 3],)]


create or replace function array_elem_check(int) returns int as $$
declare
  x orderedpair := '{1,2}';
begin
  x[2] := $1;
  return x[2];
end$$ language plpgsql


select array_elem_check(3)
RESULT: 
	[(3,)]

select array_elem_check(-1)
ERROR: 
select array_elem_check(-1)

value for domain orderedpair violates check constraint "orderedpair_check"
CONTEXT:  PL/pgSQL function array_elem_check(integer) line 5 at assignment



drop function array_elem_check(int)


--
-- Check enforcement of changing constraints in plpgsql
--

create domain di as int


create function dom_check(int) returns di as $$
declare d di;
begin
  d := $1::di;
  return d;
end
$$ language plpgsql immutable


select dom_check(0)
RESULT: 
	[(0,)]


alter domain di add constraint pos check (value > 0)


select dom_check(0)
ERROR: 

select dom_check(0)

value for domain di violates check constraint "pos"
CONTEXT:  PL/pgSQL function dom_check(integer) line 4 at assignment

 -- fail

alter domain di drop constraint pos


select dom_check(0)
RESULT: 
	[(0,)]


-- implicit cast during assignment is a separate code path, test that too

create or replace function dom_check(int) returns di as $$
declare d di;
begin
  d := $1;
  return d;
end
$$ language plpgsql immutable


select dom_check(0)
RESULT: 
	[(0,)]


alter domain di add constraint pos check (value > 0)


select dom_check(0)
ERROR: 

select dom_check(0)

value for domain di violates check constraint "pos"
CONTEXT:  PL/pgSQL function dom_check(integer) line 4 at assignment

 -- fail

alter domain di drop constraint pos


select dom_check(0)
RESULT: 
	[(0,)]


drop function dom_check(int)


drop domain di


--
-- Check use of a (non-inline-able) SQL function in a domain constraint /* REPLACED */,
-- this has caused issues in the past
--

create function sql_is_distinct_from(anyelement, anyelement)
returns boolean language sql
as 'select $1 is distinct from $2 limit 1'


create domain inotnull int
  check (sql_is_distinct_from(value, null))


select 1::inotnull
RESULT: 
	[(1,)]

select null::inotnull
ERROR: 
select null::inotnull

value for domain inotnull violates check constraint "inotnull_check"



create table dom_table (x inotnull)

insert into dom_table values ('1')

insert into dom_table values (1)

insert into dom_table values (null)
ERROR: 
insert into dom_table values (null)

value for domain inotnull violates check constraint "inotnull_check"



drop table dom_table

drop domain inotnull

drop function sql_is_distinct_from(anyelement, anyelement)


--
-- Renaming
--

create domain testdomain1 as int

alter domain testdomain1 rename to testdomain2

alter type testdomain2 rename to testdomain3
  -- alter type also works
drop domain testdomain3



--
-- Renaming domain constraints
--

create domain testdomain1 as int constraint unsigned check (value > 0)

alter domain testdomain1 rename constraint unsigned to unsigned_foo

alter domain testdomain1 drop constraint unsigned_foo

drop domain testdomain1



--
-- Information schema
--

SELECT * FROM information_schema.column_domain_usage
  WHERE domain_name IN ('con', 'dom', 'pos_int', 'things')
  ORDER BY domain_name
RESULT: 
	[('regression', 'public', 'con', 'regression', 'public', 'domcontest', 'col1'), ('regression', 'public', 'dom', 'regression', 'public', 'domview', 'col1'), ('regression', 'public', 'things', 'regression', 'public', 'thethings', 'stuff')]


SELECT * FROM information_schema.domain_constraints
  WHERE domain_name IN ('con', 'dom', 'pos_int', 'things')
  ORDER BY constraint_name
RESULT: 
	[('regression', 'public', 'con_check', 'regression', 'public', 'con', 'NO', 'NO'), ('regression', 'public', 'meow', 'regression', 'public', 'things', 'NO', 'NO'), ('regression', 'public', 'pos_int_check', 'regression', 'public', 'pos_int', 'NO', 'NO'), ('regression', 'public', 'pos_int_not_null', 'regression', 'public', 'pos_int', 'NO', 'NO')]


SELECT * FROM information_schema.domains
  WHERE domain_name IN ('con', 'dom', 'pos_int', 'things')
  ORDER BY domain_name
RESULT: 
	[('regression', 'public', 'con', 'integer', None, None, None, None, None, None, None, None, 32, 2, 0, None, None, None, None, 'regression', 'pg_catalog', 'int4', None, None, None, None, '1'), ('regression', 'public', 'dom', 'integer', None, None, None, None, None, None, None, None, 32, 2, 0, None, None, None, None, 'regression', 'pg_catalog', 'int4', None, None, None, None, '1'), ('regression', 'public', 'pos_int', 'integer', None, None, None, None, None, None, None, None, 32, 2, 0, None, None, None, None, 'regression', 'pg_catalog', 'int4', None, None, None, None, '1'), ('regression', 'public', 'things', 'integer', None, None, None, None, None, None, None, None, 32, 2, 0, None, None, None, None, 'regression', 'pg_catalog', 'int4', None, None, None, None, '1')]


SELECT * FROM information_schema.check_constraints
  WHERE (constraint_schema, constraint_name)
        IN (SELECT constraint_schema, constraint_name
            FROM information_schema.domain_constraints
            WHERE domain_name IN ('con', 'dom', 'pos_int', 'things'))
  ORDER BY constraint_name
RESULT: 
	[('regression', 'public', 'con_check', '(VALUE > 0)'), ('regression', 'public', 'meow', '(VALUE < 11)'), ('regression', 'public', 'pos_int_check', '(VALUE > 0)'), ('regression', 'public', 'pos_int_not_null', 'VALUE IS NOT NULL')]


