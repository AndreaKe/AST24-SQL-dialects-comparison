-- pg_regress should ensure that this default value applies /* REPLACED */, however
-- we can''t rely on any specific default value of vacuum_cost_delay
SHOW datestyle
RESULT: 
	[('ISO, DMY',)]


-- SET to some nondefault value
SET vacuum_cost_delay TO 40

SET datestyle = 'ISO, YMD'

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]


-- SET LOCAL has no effect outside of a transaction
SET LOCAL vacuum_cost_delay TO 50

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SET LOCAL datestyle = 'SQL'

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]


-- SET LOCAL within a transaction that commits
BEGIN

SET LOCAL vacuum_cost_delay TO 50

SHOW vacuum_cost_delay
RESULT: 
	[('50ms',)]

SET LOCAL datestyle = 'SQL'

SHOW datestyle
RESULT: 
	[('SQL, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
ERROR: 
SELECT '2006-08-13 12:34:56'::timestamptz

year 791292006 is out of range

COMMIT

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]


-- SET should be reverted after ROLLBACK
BEGIN

SET vacuum_cost_delay TO 60

SHOW vacuum_cost_delay
RESULT: 
	[('60ms',)]

SET datestyle = 'German'

SHOW datestyle
RESULT: 
	[('German, DMY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
ERROR: 
SELECT '2006-08-13 12:34:56'::timestamptz

year 1280782006 is out of range

ROLLBACK

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]


-- Some tests with subtransactions
BEGIN

SET vacuum_cost_delay TO 70

SET datestyle = 'MDY'

SHOW datestyle
RESULT: 
	[('ISO, MDY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]

SAVEPOINT first_sp

SET vacuum_cost_delay TO 80.1

SHOW vacuum_cost_delay
RESULT: 
	[('80100us',)]

SET datestyle = 'German, DMY'

SHOW datestyle
RESULT: 
	[('German, DMY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
ERROR: 
SELECT '2006-08-13 12:34:56'::timestamptz

year 1280782006 is out of range

ROLLBACK TO first_sp

SHOW datestyle
RESULT: 
	[('ISO, MDY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]

SAVEPOINT second_sp

SET vacuum_cost_delay TO '900us'

SET datestyle = 'SQL, YMD'

SHOW datestyle
RESULT: 
	[('SQL, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
ERROR: 
SELECT '2006-08-13 12:34:56'::timestamptz

year 791292006 is out of range

SAVEPOINT third_sp

SET vacuum_cost_delay TO 100

SHOW vacuum_cost_delay
RESULT: 
	[('100ms',)]

SET datestyle = 'Postgres, MDY'

SHOW datestyle
RESULT: 
	[('Postgres, MDY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
ERROR: 
SELECT '2006-08-13 12:34:56'::timestamptz

month must be in 1..12

ROLLBACK TO third_sp

SHOW vacuum_cost_delay
RESULT: 
	[('900us',)]

SHOW datestyle
RESULT: 
	[('SQL, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
ERROR: 
SELECT '2006-08-13 12:34:56'::timestamptz

year 791292006 is out of range

ROLLBACK TO second_sp

SHOW vacuum_cost_delay
RESULT: 
	[('70ms',)]

SHOW datestyle
RESULT: 
	[('ISO, MDY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]

ROLLBACK

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]


-- SET LOCAL with Savepoints
BEGIN

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]

SAVEPOINT sp

SET LOCAL vacuum_cost_delay TO 30

SHOW vacuum_cost_delay
RESULT: 
	[('30ms',)]

SET LOCAL datestyle = 'Postgres, MDY'

SHOW datestyle
RESULT: 
	[('Postgres, MDY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
ERROR: 
SELECT '2006-08-13 12:34:56'::timestamptz

month must be in 1..12

ROLLBACK TO sp

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]

ROLLBACK

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]


-- SET LOCAL persists through RELEASE (which was not true in 8.0-8.2)
BEGIN

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]

SAVEPOINT sp

SET LOCAL vacuum_cost_delay TO 30

SHOW vacuum_cost_delay
RESULT: 
	[('30ms',)]

SET LOCAL datestyle = 'Postgres, MDY'

SHOW datestyle
RESULT: 
	[('Postgres, MDY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
ERROR: 
SELECT '2006-08-13 12:34:56'::timestamptz

month must be in 1..12

RELEASE SAVEPOINT sp

SHOW vacuum_cost_delay
RESULT: 
	[('30ms',)]

SHOW datestyle
RESULT: 
	[('Postgres, MDY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
ERROR: 
SELECT '2006-08-13 12:34:56'::timestamptz

month must be in 1..12

ROLLBACK

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]


-- SET followed by SET LOCAL
BEGIN

SET vacuum_cost_delay TO 40

SET LOCAL vacuum_cost_delay TO 50

SHOW vacuum_cost_delay
RESULT: 
	[('50ms',)]

SET datestyle = 'ISO, DMY'

SET LOCAL datestyle = 'Postgres, MDY'

SHOW datestyle
RESULT: 
	[('Postgres, MDY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
ERROR: 
SELECT '2006-08-13 12:34:56'::timestamptz

month must be in 1..12

COMMIT

SHOW vacuum_cost_delay
RESULT: 
	[('40ms',)]

SHOW datestyle
RESULT: 
	[('ISO, DMY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]


--
-- Test RESET.  We use datestyle because the reset value is forced by
-- pg_regress, so it doesn''t depend on the installation''s configuration.
--
SET datestyle = iso, ymd

SHOW datestyle
RESULT: 
	[('ISO, YMD',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]

RESET datestyle

SHOW datestyle
RESULT: 
	[('ISO, DMY',)]

SELECT '2006-08-13 12:34:56'::timestamptz
RESULT: 
	[(datetime.datetime(2006, 8, 13, 12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=7200))),)]


-- Test some simple error cases
SET seq_page_cost TO 'NaN'
ERROR: 

-- Test some simple error cases
SET seq_page_cost TO 'NaN'

invalid value for parameter "seq_page_cost": "NaN"


SET vacuum_cost_delay TO '10s'
ERROR: 
SET vacuum_cost_delay TO '10s'

10000 ms is outside the valid range for parameter "vacuum_cost_delay" (0 .. 100)


SET no_such_variable TO 42
ProgrammingError: 
SET no_such_variable TO 42

unrecognized configuration parameter "no_such_variable"



-- Test ''custom'' GUCs created on the fly (which aren''t really an
-- intended feature, but many people use them).
SHOW custom.my_guc
ProgrammingError: 

-- Test ''custom'' GUCs created on the fly (which aren''t really an
-- intended feature, but many people use them).
SHOW custom.my_guc

unrecognized configuration parameter "custom.my_guc"

  -- error, not known yet
SET custom.my_guc = 42

SHOW custom.my_guc
RESULT: 
	[('42',)]

RESET custom.my_guc
  -- this makes it go to empty, not become unknown again
SHOW custom.my_guc
RESULT: 
	[('',)]

SET custom.my.qualified.guc = 'foo'

SHOW custom.my.qualified.guc
RESULT: 
	[('foo',)]

SET custom."bad-guc" = 42
ProgrammingError: 
SET custom."bad-guc" = 42

invalid configuration parameter name "custom.bad-guc"
DETAIL:  Custom parameter names must be two or more simple identifiers separated by dots.

  -- disallowed because -c cannot set this name
SHOW custom."bad-guc"
ProgrammingError:   -- disallowed because -c cannot set this name
SHOW custom."bad-guc"

unrecognized configuration parameter "custom.bad-guc"


SET special."weird name" = 'foo'
ProgrammingError: 
SET special."weird name" = 'foo'

invalid configuration parameter name "special.weird name"
DETAIL:  Custom parameter names must be two or more simple identifiers separated by dots.

  -- could be allowed, but we choose not to
SHOW special."weird name"
ProgrammingError:   -- could be allowed, but we choose not to
SHOW special."weird name"

unrecognized configuration parameter "special.weird name"



-- Check what happens when you try to set a ''custom'' GUC within the
-- namespace of an extension.
SET plpgsql.extra_foo_warnings = true
ProgrammingError: 

-- Check what happens when you try to set a ''custom'' GUC within the
-- namespace of an extension.
SET plpgsql.extra_foo_warnings = true

invalid configuration parameter name "plpgsql.extra_foo_warnings"
DETAIL:  "plpgsql" is a reserved prefix.

  -- allowed if plpgsql is not loaded yet
LOAD 'plpgsql'
  -- this will throw a warning and delete the variable
SET plpgsql.extra_foo_warnings = true
ProgrammingError:   -- this will throw a warning and delete the variable
SET plpgsql.extra_foo_warnings = true

invalid configuration parameter name "plpgsql.extra_foo_warnings"
DETAIL:  "plpgsql" is a reserved prefix.

  -- now, it''s an error
SHOW plpgsql.extra_foo_warnings
ProgrammingError:   -- now, it''s an error
SHOW plpgsql.extra_foo_warnings

unrecognized configuration parameter "plpgsql.extra_foo_warnings"



--
-- Test DISCARD TEMP
--
CREATE TEMP TABLE reset_test ( data text ) ON COMMIT DELETE ROWS

SELECT relname FROM pg_class WHERE relname = 'reset_test'
RESULT: 
	[('reset_test',)]

DISCARD TEMP

SELECT relname FROM pg_class WHERE relname = 'reset_test'
RESULT: 
	[]


--
-- Test DISCARD ALL
--

-- do changes
DECLARE foo CURSOR WITH HOLD FOR SELECT 1

PREPARE foo AS SELECT 1

LISTEN foo_event

SET vacuum_cost_delay = 13

CREATE TEMP TABLE tmp_foo (data text) ON COMMIT DELETE ROWS

CREATE ROLE regress_guc_user

SET SESSION AUTHORIZATION regress_guc_user

-- look changes
SELECT pg_listening_channels()
RESULT: 
	[('foo_event',)]

SELECT name FROM pg_prepared_statements
RESULT: 
	[('foo',)]

SELECT name FROM pg_cursors
RESULT: 
	[('foo',)]

SHOW vacuum_cost_delay
RESULT: 
	[('13ms',)]

SELECT relname from pg_class where relname = 'tmp_foo'
RESULT: 
	[('tmp_foo',)]

SELECT current_user = 'regress_guc_user'
RESULT: 
	[(True,)]

-- discard everything
DISCARD ALL

-- look again
SELECT pg_listening_channels()
RESULT: 
	[]

SELECT name FROM pg_prepared_statements
RESULT: 
	[]

SELECT name FROM pg_cursors
RESULT: 
	[]

SHOW vacuum_cost_delay
RESULT: 
	[('0',)]

SELECT relname from pg_class where relname = 'tmp_foo'
RESULT: 
	[]

SELECT current_user = 'regress_guc_user'
RESULT: 
	[(False,)]

DROP ROLE regress_guc_user


--
-- search_path should react to changes in pg_namespace
--

set search_path = foo, public, not_there_initially

select current_schemas(false)
RESULT: 
	[(['public'],)]

create schema not_there_initially

select current_schemas(false)
RESULT: 
	[(['public', 'not_there_initially'],)]

drop schema not_there_initially

select current_schemas(false)
RESULT: 
	[(['public'],)]

reset search_path


--
-- Tests for function-local GUC settings
--

set work_mem = '3MB'


create function report_guc(text) returns text as
$$ select current_setting($1) $$ language sql
set work_mem = '1MB'


select report_guc('work_mem'), current_setting('work_mem')
RESULT: 
	[('1MB', '3MB')]


alter function report_guc(text) set work_mem = '2MB'


select report_guc('work_mem'), current_setting('work_mem')
RESULT: 
	[('2MB', '3MB')]


alter function report_guc(text) reset all


select report_guc('work_mem'), current_setting('work_mem')
RESULT: 
	[('3MB', '3MB')]


-- SET LOCAL is restricted by a function SET option
create or replace function myfunc(int) returns text as $$
begin
  set local work_mem = '2MB';
  return current_setting('work_mem');
end $$
language plpgsql
set work_mem = '1MB'


select myfunc(0), current_setting('work_mem')
RESULT: 
	[('2MB', '3MB')]


alter function myfunc(int) reset all


select myfunc(0), current_setting('work_mem')
RESULT: 
	[('2MB', '2MB')]


set work_mem = '3MB'


-- but SET isn''t
create or replace function myfunc(int) returns text as $$
begin
  set work_mem = '2MB';
  return current_setting('work_mem');
end $$
language plpgsql
set work_mem = '1MB'


select myfunc(0), current_setting('work_mem')
RESULT: 
	[('2MB', '2MB')]


set work_mem = '3MB'


-- it should roll back on error, though
create or replace function myfunc(int) returns text as $$
begin
  set work_mem = '2MB';
  perform 1/$1;
  return current_setting('work_mem');
end $$
language plpgsql
set work_mem = '1MB'


select myfunc(0)
ERROR: 

select myfunc(0)

division by zero
CONTEXT:  SQL statement "SELECT 1/$1"
PL/pgSQL function myfunc(integer) line 4 at PERFORM


select current_setting('work_mem')
RESULT: 
	[('3MB',)]

select myfunc(1), current_setting('work_mem')
RESULT: 
	[('2MB', '2MB')]


-- check current_setting()''s behavior with invalid setting name

select current_setting('nosuch.setting')
ProgrammingError: 

-- check current_setting()''s behavior with invalid setting name

select current_setting('nosuch.setting')

unrecognized configuration parameter "nosuch.setting"

  -- FAIL
select current_setting('nosuch.setting', false)
ProgrammingError:   -- FAIL
select current_setting('nosuch.setting', false)

unrecognized configuration parameter "nosuch.setting"

  -- FAIL
select current_setting('nosuch.setting', true) is null
RESULT: 
	[(True,)]


-- after this, all three cases should yield ''nada''
set nosuch.setting = 'nada'


select current_setting('nosuch.setting')
RESULT: 
	[('nada',)]

select current_setting('nosuch.setting', false)
RESULT: 
	[('nada',)]

select current_setting('nosuch.setting', true)
RESULT: 
	[('nada',)]


-- Normally, CREATE FUNCTION should complain about invalid values in
-- function SET options /* REPLACED */, but not if check_function_bodies is off,
-- because that creates ordering hazards for pg_dump

create function func_with_bad_set() returns int as $$ select 1 $$
language sql
set default_text_search_config = no_such_config
ERROR: 

-- Normally, CREATE FUNCTION should complain about invalid values in
-- function SET options /* REPLACED */, but not if check_function_bodies is off,
-- because that creates ordering hazards for pg_dump

create function func_with_bad_set() returns int as $$ select 1 $$
language sql
set default_text_search_config = no_such_config

invalid value for parameter "default_text_search_config": "no_such_config"



set check_function_bodies = off


create function func_with_bad_set() returns int as $$ select 1 $$
language sql
set default_text_search_config = no_such_config


select func_with_bad_set()
ERROR: 

select func_with_bad_set()

invalid value for parameter "default_text_search_config": "no_such_config"



reset check_function_bodies


set default_with_oids to f

-- Should not allow to set it to true.
set default_with_oids to t
ERROR: 
-- Should not allow to set it to true.
set default_with_oids to t

tables declared WITH OIDS are not supported



-- Test GUC categories and flag patterns
SELECT pg_settings_get_flags(NULL)
RESULT: 
	[(None,)]

SELECT pg_settings_get_flags('does_not_exist')
RESULT: 
	[(None,)]

CREATE TABLE tab_settings_flags AS SELECT name, category,
    'EXPLAIN'          = ANY(flags) AS explain,
    'NO_RESET'         = ANY(flags) AS no_reset,
    'NO_RESET_ALL'     = ANY(flags) AS no_reset_all,
    'NOT_IN_SAMPLE'    = ANY(flags) AS not_in_sample,
    'RUNTIME_COMPUTED' = ANY(flags) AS runtime_computed
  FROM pg_show_all_settings() AS psas,
    pg_settings_get_flags(psas.name) AS flags


-- Developer GUCs should be flagged with GUC_NOT_IN_SAMPLE:
SELECT name FROM tab_settings_flags
  WHERE category = 'Developer Options' AND NOT not_in_sample
  ORDER BY 1
RESULT: 
	[]

-- Most query-tuning GUCs are flagged as valid for EXPLAIN.
-- default_statistics_target is an exception.
SELECT name FROM tab_settings_flags
  WHERE category ~ '^Query Tuning' AND NOT explain
  ORDER BY 1
RESULT: 
	[('default_statistics_target',)]

-- Runtime-computed GUCs should be part of the preset category.
SELECT name FROM tab_settings_flags
  WHERE NOT category = 'Preset Options' AND runtime_computed
  ORDER BY 1
RESULT: 
	[]

-- Preset GUCs are flagged as NOT_IN_SAMPLE.
SELECT name FROM tab_settings_flags
  WHERE category = 'Preset Options' AND NOT not_in_sample
  ORDER BY 1
RESULT: 
	[]

-- NO_RESET implies NO_RESET_ALL.
SELECT name FROM tab_settings_flags
  WHERE no_reset AND NOT no_reset_all
  ORDER BY 1
RESULT: 
	[]

DROP TABLE tab_settings_flags


