-- START setup from test_setup 
--
-- TEST_SETUP --- prepare environment expected by regression test scripts
--
-- directory paths and dlsuffix are passed to us in environment variables
\getenv abs_srcdir PG_ABS_SRCDIR
\getenv libdir PG_LIBDIR
\getenv dlsuffix PG_DLSUFFIX
\set regresslib :libdir '/regress' :dlsuffix
--
-- synchronous_commit=off delays when hint bits may be set. Some plans change
-- depending on the number of all-visible pages, which in turn can be
-- influenced by the delayed hint bits. Force synchronous_commit=on to avoid
-- that source of variability.
--
SET synchronous_commit = on;
--
-- Postgres formerly made the public schema read/write by default,
-- and most of the core regression tests still expect that.
--
GRANT ALL ON SCHEMA public TO public;
-- Create a tablespace we can use in tests.
SET allow_in_place_tablespaces = true;
CREATE TABLESPACE regress_tblspace LOCATION '';
--
-- These tables have traditionally been referenced by many tests,
-- so create and populate them.  Insert only non-error values here.
-- (Some subsequent tests try to insert erroneous values.  That's okay
-- because the table won't actually change.  Do not change the contents
-- of these tables in later tests, as it may affect other tests.)
--
CREATE TABLE CHAR_TBL(f1 char(4));
INSERT INTO CHAR_TBL (f1) VALUES
  ('a'),
  ('ab'),
  ('abcd'),
  ('abcd    ');
VACUUM CHAR_TBL;
CREATE TABLE FLOAT8_TBL(f1 float8);
INSERT INTO FLOAT8_TBL(f1) VALUES
  ('0.0'),
  ('-34.84'),
  ('-1004.30'),
  ('-1.2345678901234e+200'),
  ('-1.2345678901234e-200');
VACUUM FLOAT8_TBL;
CREATE TABLE INT2_TBL(f1 int2);
INSERT INTO INT2_TBL(f1) VALUES
  ('0   '),
  ('  1234 '),
  ('    -1234'),
  ('32767'),  -- largest and smallest values
  ('-32767');
VACUUM INT2_TBL;
CREATE TABLE INT4_TBL(f1 int4);
INSERT INTO INT4_TBL(f1) VALUES
  ('   0  '),
  ('123456     '),
  ('    -123456'),
  ('2147483647'),  -- largest and smallest values
  ('-2147483647');
VACUUM INT4_TBL;
CREATE TABLE INT8_TBL(q1 int8, q2 int8);
INSERT INTO INT8_TBL VALUES
  ('  123   ','  456'),
  ('123   ','4567890123456789'),
  ('4567890123456789','123'),
  (+4567890123456789,'4567890123456789'),
  ('+4567890123456789','-4567890123456789');
VACUUM INT8_TBL;
CREATE TABLE POINT_TBL(f1 point);
INSERT INTO POINT_TBL(f1) VALUES
  ('(0.0,0.0)'),
  ('(-10.0,0.0)'),
  ('(-3.0,4.0)'),
  ('(5.1, 34.5)'),
  ('(-5.0,-12.0)'),
  ('(1e-300,-1e-300)'),  -- To underflow
  ('(1e+300,Inf)'),  -- To overflow
  ('(Inf,1e+300)'),  -- Transposed
  (' ( Nan , NaN ) '),
  ('10.0,10.0');
-- We intentionally don't vacuum point_tbl here; geometry depends on that
CREATE TABLE TEXT_TBL (f1 text);
INSERT INTO TEXT_TBL VALUES
  ('doh!'),
  ('hi de ho neighbor');
VACUUM TEXT_TBL;
CREATE TABLE VARCHAR_TBL(f1 varchar(4));
INSERT INTO VARCHAR_TBL (f1) VALUES
  ('a'),
  ('ab'),
  ('abcd'),
  ('abcd    ');
VACUUM VARCHAR_TBL;
CREATE TABLE onek (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
\set filename :abs_srcdir '/data/onek.data'
COPY onek FROM :'filename';
VACUUM ANALYZE onek;
CREATE TABLE onek2 AS SELECT * FROM onek;
VACUUM ANALYZE onek2;
CREATE TABLE tenk1 (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
\set filename :abs_srcdir '/data/tenk.data'
COPY tenk1 FROM :'filename';
VACUUM ANALYZE tenk1;
CREATE TABLE tenk2 AS SELECT * FROM tenk1;
VACUUM ANALYZE tenk2;
CREATE TABLE person (
	name 		text,
	age			int4,
	location 	point
);
\set filename :abs_srcdir '/data/person.data'
COPY person FROM :'filename';
VACUUM ANALYZE person;
CREATE TABLE emp (
	salary 		int4,
	manager 	name
) INHERITS (person);
\set filename :abs_srcdir '/data/emp.data'
COPY emp FROM :'filename';
VACUUM ANALYZE emp;
CREATE TABLE student (
	gpa 		float8
) INHERITS (person);
\set filename :abs_srcdir '/data/student.data'
COPY student FROM :'filename';
VACUUM ANALYZE student;
CREATE TABLE stud_emp (
	percent 	int4
) INHERITS (emp, student);
NOTICE:  merging multiple inherited definitions of column "name"
NOTICE:  merging multiple inherited definitions of column "age"
NOTICE:  merging multiple inherited definitions of column "location"
\set filename :abs_srcdir '/data/stud_emp.data'
COPY stud_emp FROM :'filename';
VACUUM ANALYZE stud_emp;
CREATE TABLE road (
	name		text,
	thepath 	path
);
\set filename :abs_srcdir '/data/streets.data'
COPY road FROM :'filename';
VACUUM ANALYZE road;
CREATE TABLE ihighway () INHERITS (road);
INSERT INTO ihighway
   SELECT *
   FROM ONLY road
   WHERE name ~ 'I- .*';
VACUUM ANALYZE ihighway;
CREATE TABLE shighway (
	surface		text
) INHERITS (road);
INSERT INTO shighway
   SELECT *, 'asphalt'
   FROM ONLY road
   WHERE name ~ 'State Hwy.*';
VACUUM ANALYZE shighway;
--
-- We must have some enum type in the database for opr_sanity and type_sanity.
--
create type stoplight as enum ('red', 'yellow', 'green');
--
-- Also create some non-built-in range types.
--
create type float8range as range (subtype = float8, subtype_diff = float8mi);
create type textrange as range (subtype = text, collation = "C");
--
-- Create some C functions that will be used by various tests.
--
CREATE FUNCTION binary_coercible(oid, oid)
    RETURNS bool
    AS :'regresslib', 'binary_coercible'
    LANGUAGE C STRICT STABLE PARALLEL SAFE;
CREATE FUNCTION ttdummy ()
    RETURNS trigger
    AS :'regresslib'
    LANGUAGE C;
-- Use hand-rolled hash functions and operator classes to get predictable
-- result on different machines.  The hash function for int4 simply returns
-- the sum of the values passed to it and the one for text returns the length
-- of the non-empty string value passed to it or 0.
create function part_hashint4_noop(value int4, seed int8)
    returns int8 as $$
    select value + seed;
    $$ language sql strict immutable parallel safe;
create operator class part_test_int4_ops for type int4 using hash as
    operator 1 =,
    function 2 part_hashint4_noop(int4, int8);
create function part_hashtext_length(value text, seed int8)
    returns int8 as $$
    select length(coalesce(value, ''))::int8
    $$ language sql strict immutable parallel safe;
create operator class part_test_text_ops for type text using hash as
    operator 1 =,
    function 2 part_hashtext_length(text, int8);
--
-- These functions are used in tests that used to use md5(), which we now
-- mostly avoid so that the tests will pass in FIPS mode.
--
create function fipshash(bytea)
    returns text
    strict immutable parallel safe leakproof
    return substr(encode(sha256($1), 'hex'), 1, 32);
create function fipshash(text)
    returns text
    strict immutable parallel safe leakproof
    return substr(encode(sha256($1::bytea), 'hex'), 1, 32);
-- END setup from test_setup 
-- START setup from create_index 
--
-- CREATE_INDEX
-- Create ancillary data structures (i.e. indices)
--
-- directory paths are passed to us in environment variables
\getenv abs_srcdir PG_ABS_SRCDIR
--
-- BTREE
--
CREATE INDEX onek_unique1 ON onek USING btree(unique1 int4_ops);
CREATE INDEX IF NOT EXISTS onek_unique1 ON onek USING btree(unique1 int4_ops);
NOTICE:  relation "onek_unique1" already exists, skipping
CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops);
ERROR:  syntax error at or near "ON"
LINE 1: CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_...
                                   ^
CREATE INDEX onek_unique2 ON onek USING btree(unique2 int4_ops);
CREATE INDEX onek_hundred ON onek USING btree(hundred int4_ops);
CREATE INDEX onek_stringu1 ON onek USING btree(stringu1 name_ops);
CREATE INDEX tenk1_unique1 ON tenk1 USING btree(unique1 int4_ops);
CREATE INDEX tenk1_unique2 ON tenk1 USING btree(unique2 int4_ops);
CREATE INDEX tenk1_hundred ON tenk1 USING btree(hundred int4_ops);
CREATE INDEX tenk1_thous_tenthous ON tenk1 (thousand, tenthous);
CREATE INDEX tenk2_unique1 ON tenk2 USING btree(unique1 int4_ops);
CREATE INDEX tenk2_unique2 ON tenk2 USING btree(unique2 int4_ops);
CREATE INDEX tenk2_hundred ON tenk2 USING btree(hundred int4_ops);
CREATE INDEX rix ON road USING btree (name text_ops);
CREATE INDEX iix ON ihighway USING btree (name text_ops);
CREATE INDEX six ON shighway USING btree (name text_ops);
-- test comments
COMMENT ON INDEX six_wrong IS 'bad index';
ERROR:  relation "six_wrong" does not exist
COMMENT ON INDEX six IS 'good index';
COMMENT ON INDEX six IS NULL;
--
-- BTREE partial indices
--
CREATE INDEX onek2_u1_prtl ON onek2 USING btree(unique1 int4_ops)
	where unique1 < 20 or unique1 > 980;
CREATE INDEX onek2_u2_prtl ON onek2 USING btree(unique2 int4_ops)
	where stringu1 < 'B';
CREATE INDEX onek2_stu1_prtl ON onek2 USING btree(stringu1 name_ops)
	where onek2.stringu1 >= 'J' and onek2.stringu1 < 'K';
--
-- GiST (rtree-equivalent opclasses only)
--
CREATE TABLE slow_emp4000 (
	home_base	 box
);
CREATE TABLE fast_emp4000 (
	home_base	 box
);
\set filename :abs_srcdir '/data/rect.data'
COPY slow_emp4000 FROM :'filename';
INSERT INTO fast_emp4000 SELECT * FROM slow_emp4000;
ANALYZE slow_emp4000;
ANALYZE fast_emp4000;
CREATE INDEX grect2ind ON fast_emp4000 USING gist (home_base);
-- we want to work with a point_tbl that includes a null
CREATE TEMP TABLE point_tbl AS SELECT * FROM public.point_tbl;
INSERT INTO POINT_TBL(f1) VALUES (NULL);
CREATE INDEX gpointind ON point_tbl USING gist (f1);
CREATE TEMP TABLE gpolygon_tbl AS
    SELECT polygon(home_base) AS f1 FROM slow_emp4000;
INSERT INTO gpolygon_tbl VALUES ( '(1000,0,0,1000)' );
INSERT INTO gpolygon_tbl VALUES ( '(0,1000,1000,1000)' );
CREATE TEMP TABLE gcircle_tbl AS
    SELECT circle(home_base) AS f1 FROM slow_emp4000;
CREATE INDEX ggpolygonind ON gpolygon_tbl USING gist (f1);
CREATE INDEX ggcircleind ON gcircle_tbl USING gist (f1);
--
-- Test GiST indexes
--
-- get non-indexed results for comparison purposes
SET enable_seqscan = ON;
SET enable_indexscan = OFF;
SET enable_bitmapscan = OFF;
SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
       home_base       
-----------------------
 (337,455),(240,359)
 (1444,403),(1346,344)
(2 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
 count 
-------
     2
(1 row)

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
 count 
-------
   278
(1 row)

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
 count 
-------
     2
(1 row)

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
 count 
-------
     2
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
 count 
-------
     5
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
 count 
-------
     1
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
 count 
-------
     4
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
 count 
-------
     1
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
 count 
-------
     5
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
 count 
-------
     1
(1 row)

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (Infinity,1e+300)
 (1e+300,Infinity)
 (NaN,NaN)
 
(11 rows)

SELECT * FROM point_tbl WHERE f1 IS NULL;
 f1 
----
 
(1 row)

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (1e+300,Infinity)
 (Infinity,1e+300)
 (NaN,NaN)
(10 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                       f1                        
-------------------------------------------------
 ((240,359),(240,455),(337,455),(337,359))
 ((662,163),(662,187),(759,187),(759,163))
 ((1000,0),(0,1000))
 ((0,1000),(1000,1000))
 ((1346,344),(1346,403),(1444,403),(1444,344))
 ((278,1409),(278,1457),(369,1457),(369,1409))
 ((907,1156),(907,1201),(948,1201),(948,1156))
 ((1517,971),(1517,1043),(1594,1043),(1594,971))
 ((175,1820),(175,1850),(259,1850),(259,1820))
 ((2424,81),(2424,160),(2424,160),(2424,81))
(10 rows)

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 circle_center  | radius 
----------------+--------
 (288.5,407)    |     68
 (710.5,175)    |     50
 (323.5,1433)   |     51
 (927.5,1178.5) |     30
 (1395,373.5)   |     57
 (1555.5,1007)  |     53
 (217,1835)     |     45
 (489,2421.5)   |     22
 (2424,120.5)   |     40
 (751.5,2655)   |     20
(10 rows)

-- Now check the results from plain indexscan
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
EXPLAIN (COSTS OFF)
SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
                           QUERY PLAN                            
-----------------------------------------------------------------
 Sort
   Sort Key: ((home_base[0])[0])
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base <@ '(2000,1000),(200,200)'::box)
(4 rows)

SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
       home_base       
-----------------------
 (337,455),(240,359)
 (1444,403),(1346,344)
(2 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base && '(1000,1000),(0,0)'::box)
(3 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base IS NULL)
(3 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
 count 
-------
   278
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Index Scan using ggpolygonind on gpolygon_tbl
         Index Cond: (f1 && '((1000,1000),(0,0))'::polygon)
(3 rows)

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Scan using ggcircleind on gcircle_tbl
         Index Cond: (f1 && '<(500,500),500>'::circle)
(3 rows)

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '(100,100),(0,0)'::box)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '(100,100),(0,0)'::box)
(3 rows)

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '((0,0),(0,100),(100,100),(50,50),(100,0),(0,0))'::polygon)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
 count 
-------
     4
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '<(50,50),50>'::circle)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 << '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 >> '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
 count 
-------
     4
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 <<| '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 |>> '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
 count 
-------
     5
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 ~= '(-5,-12)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Order By: (f1 <-> '(0,1)'::point)
(2 rows)

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (Infinity,1e+300)
 (1e+300,Infinity)
 (NaN,NaN)
 
(11 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NULL;
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 IS NULL)
(2 rows)

SELECT * FROM point_tbl WHERE f1 IS NULL;
 f1 
----
 
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 IS NOT NULL)
   Order By: (f1 <-> '(0,1)'::point)
(3 rows)

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (Infinity,1e+300)
 (1e+300,Infinity)
 (NaN,NaN)
(10 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
                   QUERY PLAN                   
------------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 <@ '(10,10),(-10,-10)'::box)
   Order By: (f1 <-> '(0,1)'::point)
(3 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                     QUERY PLAN                      
-----------------------------------------------------
 Limit
   ->  Index Scan using ggpolygonind on gpolygon_tbl
         Order By: (f1 <-> '(0,0)'::point)
(3 rows)

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                       f1                        
-------------------------------------------------
 ((240,359),(240,455),(337,455),(337,359))
 ((662,163),(662,187),(759,187),(759,163))
 ((1000,0),(0,1000))
 ((0,1000),(1000,1000))
 ((1346,344),(1346,403),(1444,403),(1444,344))
 ((278,1409),(278,1457),(369,1457),(369,1409))
 ((907,1156),(907,1201),(948,1201),(948,1156))
 ((1517,971),(1517,1043),(1594,1043),(1594,971))
 ((175,1820),(175,1850),(259,1850),(259,1820))
 ((2424,81),(2424,160),(2424,160),(2424,81))
(10 rows)

EXPLAIN (COSTS OFF)
SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
                    QUERY PLAN                     
---------------------------------------------------
 Limit
   ->  Index Scan using ggcircleind on gcircle_tbl
         Order By: (f1 <-> '(200,300)'::point)
(3 rows)

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 circle_center  | radius 
----------------+--------
 (288.5,407)    |     68
 (710.5,175)    |     50
 (323.5,1433)   |     51
 (927.5,1178.5) |     30
 (1395,373.5)   |     57
 (1555.5,1007)  |     53
 (217,1835)     |     45
 (489,2421.5)   |     22
 (2424,120.5)   |     40
 (751.5,2655)   |     20
(10 rows)

EXPLAIN (COSTS OFF)
SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Function Scan on generate_series x
   SubPlan 1
     ->  Limit
           ->  Index Scan using ggpolygonind on gpolygon_tbl
                 Order By: (f1 <-> point((x.x)::double precision, (x.x)::double precision))
(5 rows)

SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
  point  |                     c                     
---------+-------------------------------------------
 (0,0)   | ((240,359),(240,455),(337,455),(337,359))
 (1,1)   | ((240,359),(240,455),(337,455),(337,359))
 (2,2)   | ((240,359),(240,455),(337,455),(337,359))
 (3,3)   | ((240,359),(240,455),(337,455),(337,359))
 (4,4)   | ((240,359),(240,455),(337,455),(337,359))
 (5,5)   | ((240,359),(240,455),(337,455),(337,359))
 (6,6)   | ((240,359),(240,455),(337,455),(337,359))
 (7,7)   | ((240,359),(240,455),(337,455),(337,359))
 (8,8)   | ((240,359),(240,455),(337,455),(337,359))
 (9,9)   | ((240,359),(240,455),(337,455),(337,359))
 (10,10) | ((240,359),(240,455),(337,455),(337,359))
(11 rows)

-- Now check the results from bitmap indexscan
SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: ((f1 <-> '(0,1)'::point))
   ->  Bitmap Heap Scan on point_tbl
         Recheck Cond: (f1 <@ '(10,10),(-10,-10)'::box)
         ->  Bitmap Index Scan on gpointind
               Index Cond: (f1 <@ '(10,10),(-10,-10)'::box)
(6 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
--
-- GIN over int[] and text[]
--
-- Note: GIN currently supports only bitmap scans, not plain indexscans
--
CREATE TABLE array_index_op_test (
	seqno		int4,
	i			int4[],
	t			text[]
);
\set filename :abs_srcdir '/data/array.data'
COPY array_index_op_test FROM :'filename';
ANALYZE array_index_op_test;
SELECT * FROM array_index_op_test WHERE i = '{NULL}' ORDER BY seqno;
 seqno |   i    |   t    
-------+--------+--------
   102 | {NULL} | {NULL}
(1 row)

SELECT * FROM array_index_op_test WHERE i @> '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i && '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
explain (costs off)
SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: seqno
   ->  Bitmap Heap Scan on array_index_op_test
         Recheck Cond: (i @> '{32}'::integer[])
         ->  Bitmap Index Scan on intarrayidx
               Index Cond: (i @> '{32}'::integer[])
(6 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
(8 rows)

SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
(8 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
(3 rows)

SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(11 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
 seqno |       i       |                                                             t                                                              
-------+---------------+----------------------------------------------------------------------------------------------------------------------------
    40 | {34}          | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
    74 | {32}          | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    98 | {38,34,32,89} | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   101 | {}            | {}
(4 rows)

SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
 seqno |    i    |                                                        t                                                        
-------+---------+-----------------------------------------------------------------------------------------------------------------
    95 | {47,77} | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
(1 row)

SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
 seqno |                i                |                                                                                                       t                                                                                                        
-------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
     2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
     3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
     4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
     5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
     7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
     8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
     9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
    10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
    11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
    14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    16 | {14,63,85,11}                   | {AAAAAA66777}
    17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
    18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
    21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
    22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
    23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
    24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
    25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
    26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
    27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
    28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
    29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
    30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
    32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
    33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
    34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
    35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
    36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
    37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
    38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
    39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
    40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
    41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
    42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
    43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
    44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
    45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
    47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
    48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
    49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
    50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
    51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
    52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
    55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
    56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
    57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
    58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
    59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
    60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
    61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
    62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
    63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
    64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
    67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
    68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
    69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
    70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
    71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
    72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
    76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
    79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
    81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
    82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
    84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
    85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
    86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
    87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
    88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
    91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
    92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
    93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
    94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
    95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
    96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
    97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
    99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
   101 | {}                              | {}
   102 | {NULL}                          | {NULL}
(102 rows)

SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
explain (costs off)
SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: seqno
   ->  Bitmap Heap Scan on array_index_op_test
         Recheck Cond: (t @> '{AAAAAAAA72908}'::text[])
         ->  Bitmap Index Scan on textarrayidx
               Index Cond: (t @> '{AAAAAAAA72908}'::text[])
(6 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
 seqno |           i           |                                                                     t                                                                      
-------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
(4 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
 seqno |           i           |                                                                     t                                                                      
-------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
(4 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
 seqno |        i         |                                 t                                  
-------+------------------+--------------------------------------------------------------------
    15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
    79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
(3 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
 seqno |        i         |                                 t                                  
-------+------------------+--------------------------------------------------------------------
    15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
    79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
(3 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
 seqno |  i   |                                 t                                  
-------+------+--------------------------------------------------------------------
    79 | {45} | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
(1 row)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
 seqno |           i           |                                                                     t                                                                      
-------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
    15 | {17,14,16,63,67}      | {AA6416,AAAAAAAAAA646,AAAAA95309}
    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    96 | {23,97,43}            | {AAAAAAAAAA646,A87088}
(6 rows)

SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
 seqno |         i          |                                                     t                                                     
-------+--------------------+-----------------------------------------------------------------------------------------------------------
    22 | {11,6,56,62,53,30} | {AAAAAAAA72908}
    45 | {99,45}            | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
   101 | {}                 | {}
(3 rows)

SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
 seqno |     i      |           t            
-------+------------+------------------------
    96 | {23,97,43} | {AAAAAAAAAA646,A87088}
(1 row)

SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
 seqno |                i                |                                                                                                       t                                                                                                        
-------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
     2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
     3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
     4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
     5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
     7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
     8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
     9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
    10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
    11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
    14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    16 | {14,63,85,11}                   | {AAAAAA66777}
    17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
    18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
    21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
    22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
    23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
    24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
    25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
    26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
    27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
    28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
    29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
    30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
    32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
    33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
    34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
    35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
    36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
    37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
    38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
    39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
    40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
    41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
    42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
    43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
    44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
    45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
    47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
    48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
    49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
    50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
    51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
    52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
    55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
    56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
    57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
    58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
    59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
    60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
    61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
    62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
    63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
    64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
    67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
    68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
    69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
    70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
    71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
    72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
    76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
    79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
    81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
    82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
    84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
    85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
    86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
    87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
    88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
    91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
    92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
    93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
    94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
    95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
    96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
    97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
    99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
   101 | {}                              | {}
   102 | {NULL}                          | {NULL}
(102 rows)

SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

-- And try it with a multicolumn GIN index
DROP INDEX intarrayidx, textarrayidx;
CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
 seqno |               i                |                                                                              t                                                                              
-------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
    19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
   100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(7 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
 seqno |               i                |                                                                              t                                                                              
-------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
    19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
   100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(7 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
 seqno |              i              |                                      t                                       
-------+-----------------------------+------------------------------------------------------------------------------
   100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(1 row)

SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
 seqno |              i              |                                      t                                       
-------+-----------------------------+------------------------------------------------------------------------------
   100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(1 row)

SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
--
-- Try a GIN index with a lot of items with same key. (GIN creates a posting
-- tree when there are enough duplicates)
--
CREATE TABLE array_gin_test (a int[]);
INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
 count 
-------
  2000
(1 row)

DROP TABLE array_gin_test;
--
-- Test GIN index's reloptions
--
CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
  WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
\d+ gin_relopts_test
                Index "public.gin_relopts_test"
 Column |  Type   | Key? | Definition | Storage | Stats target 
--------+---------+------+------------+---------+--------------
 i      | integer | yes  | i          | plain   | 
gin, for table "public.array_index_op_test"
Options: fastupdate=on, gin_pending_list_limit=128

--
-- HASH
--
CREATE UNLOGGED TABLE unlogged_hash_table (id int4);
CREATE INDEX unlogged_hash_index ON unlogged_hash_table USING hash (id int4_ops);
DROP TABLE unlogged_hash_table;
-- CREATE INDEX hash_ovfl_index ON hash_ovfl_heap USING hash (x int4_ops);
-- Test hash index build tuplesorting.  Force hash tuplesort using low
-- maintenance_work_mem setting and fillfactor:
SET maintenance_work_mem = '1MB';
CREATE INDEX hash_tuplesort_idx ON tenk1 USING hash (stringu1 name_ops) WITH (fillfactor = 10);
EXPLAIN (COSTS OFF)
SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on tenk1
         Recheck Cond: (stringu1 = 'TVAAAA'::name)
         ->  Bitmap Index Scan on hash_tuplesort_idx
               Index Cond: (stringu1 = 'TVAAAA'::name)
(5 rows)

SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
 count 
-------
    14
(1 row)

DROP INDEX hash_tuplesort_idx;
RESET maintenance_work_mem;
--
-- Test unique null behavior
--
CREATE TABLE unique_tbl (i int, t text);
CREATE UNIQUE INDEX unique_idx1 ON unique_tbl (i) NULLS DISTINCT;
CREATE UNIQUE INDEX unique_idx2 ON unique_tbl (i) NULLS NOT DISTINCT;
INSERT INTO unique_tbl VALUES (1, 'one');
INSERT INTO unique_tbl VALUES (2, 'two');
INSERT INTO unique_tbl VALUES (3, 'three');
INSERT INTO unique_tbl VALUES (4, 'four');
INSERT INTO unique_tbl VALUES (5, 'one');
INSERT INTO unique_tbl (t) VALUES ('six');
INSERT INTO unique_tbl (t) VALUES ('seven');  -- error from unique_idx2
ERROR:  duplicate key value violates unique constraint "unique_idx2"
DETAIL:  Key (i)=(null) already exists.
DROP INDEX unique_idx1, unique_idx2;
INSERT INTO unique_tbl (t) VALUES ('seven');
-- build indexes on filled table
CREATE UNIQUE INDEX unique_idx3 ON unique_tbl (i) NULLS DISTINCT;  -- ok
CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;  -- error
ERROR:  could not create unique index "unique_idx4"
DETAIL:  Key (i)=(null) is duplicated.
DELETE FROM unique_tbl WHERE t = 'seven';
CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;  -- ok now
\d unique_tbl
             Table "public.unique_tbl"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 i      | integer |           |          | 
 t      | text    |           |          | 
Indexes:
    "unique_idx3" UNIQUE, btree (i)
    "unique_idx4" UNIQUE, btree (i) NULLS NOT DISTINCT

\d unique_idx3
      Index "public.unique_idx3"
 Column |  Type   | Key? | Definition 
--------+---------+------+------------
 i      | integer | yes  | i
unique, btree, for table "public.unique_tbl"

\d unique_idx4
      Index "public.unique_idx4"
 Column |  Type   | Key? | Definition 
--------+---------+------+------------
 i      | integer | yes  | i
unique nulls not distinct, btree, for table "public.unique_tbl"

SELECT pg_get_indexdef('unique_idx3'::regclass);
                           pg_get_indexdef                            
----------------------------------------------------------------------
 CREATE UNIQUE INDEX unique_idx3 ON public.unique_tbl USING btree (i)
(1 row)

SELECT pg_get_indexdef('unique_idx4'::regclass);
                                     pg_get_indexdef                                     
-----------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX unique_idx4 ON public.unique_tbl USING btree (i) NULLS NOT DISTINCT
(1 row)

DROP TABLE unique_tbl;
--
-- Test functional index
--
CREATE TABLE func_index_heap (f1 text, f2 text);
CREATE UNIQUE INDEX func_index_index on func_index_heap (textcat(f1,f2));
INSERT INTO func_index_heap VALUES('ABC','DEF');
INSERT INTO func_index_heap VALUES('AB','CDEFG');
INSERT INTO func_index_heap VALUES('QWE','RTY');
-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
ERROR:  duplicate key value violates unique constraint "func_index_index"
DETAIL:  Key (textcat(f1, f2))=(ABCDEF) already exists.
-- but this shouldn't:
INSERT INTO func_index_heap VALUES('QWERTY');
-- while we're here, see that the metadata looks sane
\d func_index_heap
         Table "public.func_index_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "func_index_index" UNIQUE, btree (textcat(f1, f2))

\d func_index_index
     Index "public.func_index_index"
 Column  | Type | Key? |   Definition    
---------+------+------+-----------------
 textcat | text | yes  | textcat(f1, f2)
unique, btree, for table "public.func_index_heap"

--
-- Same test, expressional index
--
DROP TABLE func_index_heap;
CREATE TABLE func_index_heap (f1 text, f2 text);
CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
INSERT INTO func_index_heap VALUES('ABC','DEF');
INSERT INTO func_index_heap VALUES('AB','CDEFG');
INSERT INTO func_index_heap VALUES('QWE','RTY');
-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
ERROR:  duplicate key value violates unique constraint "func_index_index"
DETAIL:  Key ((f1 || f2))=(ABCDEF) already exists.
-- but this shouldn't:
INSERT INTO func_index_heap VALUES('QWERTY');
-- while we're here, see that the metadata looks sane
\d func_index_heap
         Table "public.func_index_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "func_index_index" UNIQUE, btree ((f1 || f2))

\d func_index_index
  Index "public.func_index_index"
 Column | Type | Key? | Definition 
--------+------+------+------------
 expr   | text | yes  | (f1 || f2)
unique, btree, for table "public.func_index_heap"

-- this should fail because of unsafe column type (anonymous record)
create index on func_index_heap ((f1 || f2), (row(f1, f2)));
ERROR:  column "row" has pseudo-type record
--
-- Test unique index with included columns
--
CREATE TABLE covering_index_heap (f1 int, f2 int, f3 text);
CREATE UNIQUE INDEX covering_index_index on covering_index_heap (f1,f2) INCLUDE(f3);
INSERT INTO covering_index_heap VALUES(1,1,'AAA');
INSERT INTO covering_index_heap VALUES(1,2,'AAA');
-- this should fail because of unique index on f1,f2:
INSERT INTO covering_index_heap VALUES(1,2,'BBB');
ERROR:  duplicate key value violates unique constraint "covering_index_index"
DETAIL:  Key (f1, f2)=(1, 2) already exists.
-- and this shouldn't:
INSERT INTO covering_index_heap VALUES(1,4,'AAA');
-- Try to build index on table that already contains data
CREATE UNIQUE INDEX covering_pkey on covering_index_heap (f1,f2) INCLUDE(f3);
-- Try to use existing covering index as primary key
ALTER TABLE covering_index_heap ADD CONSTRAINT covering_pkey PRIMARY KEY USING INDEX
covering_pkey;
DROP TABLE covering_index_heap;
--
-- Try some concurrent index builds
--
-- Unfortunately this only tests about half the code paths because there are
-- no concurrent updates happening to the table at the same time.
CREATE TABLE concur_heap (f1 text, f2 text);
-- empty table
CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
NOTICE:  relation "concur_index1" already exists, skipping
INSERT INTO concur_heap VALUES  ('a','b');
INSERT INTO concur_heap VALUES  ('b','b');
-- unique index
CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
NOTICE:  relation "concur_index2" already exists, skipping
-- check if constraint is set up properly to be enforced
INSERT INTO concur_heap VALUES ('b','x');
ERROR:  duplicate key value violates unique constraint "concur_index2"
DETAIL:  Key (f1)=(b) already exists.
-- check if constraint is enforced properly at build time
CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
ERROR:  could not create unique index "concur_index3"
DETAIL:  Key (f2)=(b) is duplicated.
-- test that expression indexes and partial indexes work concurrently
CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
-- here we also check that you can default the index name
CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
-- You can't do a concurrent index build in a transaction
BEGIN;
CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- test where predicate is able to do a transactional update during
-- a concurrent build before switching pg_index state flags.
CREATE FUNCTION predicate_stable() RETURNS bool IMMUTABLE
LANGUAGE plpgsql AS $$
BEGIN
  EXECUTE 'SELECT txid_current()';
  RETURN true;
END; $$;
CREATE INDEX CONCURRENTLY concur_index8 ON concur_heap (f1)
  WHERE predicate_stable();
DROP INDEX concur_index8;
DROP FUNCTION predicate_stable();
-- But you can do a regular index build in a transaction
BEGIN;
CREATE INDEX std_index on concur_heap(f2);
COMMIT;
-- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
VACUUM FULL concur_heap;
REINDEX TABLE concur_heap;
ERROR:  could not create unique index "concur_index3"
DETAIL:  Key (f2)=(b) is duplicated.
DELETE FROM concur_heap WHERE f1 = 'b';
VACUUM FULL concur_heap;
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "concur_heap_expr_idx" btree ((f2 || f1))
    "concur_index1" btree (f2, f1)
    "concur_index2" UNIQUE, btree (f1)
    "concur_index3" UNIQUE, btree (f2) INVALID
    "concur_index4" btree (f2) WHERE f1 = 'a'::text
    "concur_index5" btree (f2) WHERE f1 = 'x'::text
    "std_index" btree (f2)

REINDEX TABLE concur_heap;
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "concur_heap_expr_idx" btree ((f2 || f1))
    "concur_index1" btree (f2, f1)
    "concur_index2" UNIQUE, btree (f1)
    "concur_index3" UNIQUE, btree (f2)
    "concur_index4" btree (f2) WHERE f1 = 'a'::text
    "concur_index5" btree (f2) WHERE f1 = 'x'::text
    "std_index" btree (f2)

-- Temporary tables with concurrent builds and on-commit actions
-- CONCURRENTLY used with CREATE INDEX and DROP INDEX is ignored.
-- PRESERVE ROWS, the default.
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
DROP INDEX CONCURRENTLY concur_temp_ind;
DROP TABLE concur_temp;
-- ON COMMIT DROP
BEGIN;
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT DROP;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
-- Fails when running in a transaction.
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- ON COMMIT DELETE ROWS
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT DELETE ROWS;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
DROP INDEX CONCURRENTLY concur_temp_ind;
DROP TABLE concur_temp;
--
-- Try some concurrent index drops
--
DROP INDEX CONCURRENTLY "concur_index2";				-- works
DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
NOTICE:  index "concur_index2" does not exist, skipping
-- failures
DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
BEGIN;
DROP INDEX CONCURRENTLY "concur_index5";
ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
ROLLBACK;
-- successes
DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
DROP INDEX CONCURRENTLY "concur_index4";
DROP INDEX CONCURRENTLY "concur_index5";
DROP INDEX CONCURRENTLY "concur_index1";
DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "std_index" btree (f2)

DROP TABLE concur_heap;
--
-- Test ADD CONSTRAINT USING INDEX
--
CREATE TABLE cwi_test( a int , b varchar(10), c char);
-- add some data so that all tests have something to work with.
INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
\d cwi_test
                     Table "public.cwi_test"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           | not null | 
 b      | character varying(10) |           | not null | 
 c      | character(1)          |           |          | 
Indexes:
    "cwi_uniq_idx" PRIMARY KEY, btree (a, b)

\d cwi_uniq_idx
            Index "public.cwi_uniq_idx"
 Column |         Type          | Key? | Definition 
--------+-----------------------+------+------------
 a      | integer               | yes  | a
 b      | character varying(10) | yes  | b
primary key, btree, for table "public.cwi_test"

CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
		USING INDEX cwi_uniq2_idx;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
\d cwi_test
                     Table "public.cwi_test"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           | not null | 
 b      | character varying(10) |           | not null | 
 c      | character(1)          |           |          | 
Indexes:
    "cwi_replaced_pkey" PRIMARY KEY, btree (b, a)

\d cwi_replaced_pkey
          Index "public.cwi_replaced_pkey"
 Column |         Type          | Key? | Definition 
--------+-----------------------+------+------------
 b      | character varying(10) | yes  | b
 a      | integer               | yes  | a
primary key, btree, for table "public.cwi_test"

DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
-- Check that non-default index options are rejected
CREATE UNIQUE INDEX cwi_uniq3_idx ON cwi_test(a desc);
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;  -- fail
ERROR:  index "cwi_uniq3_idx" column number 1 does not have default sorting behavior
LINE 1: ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;
                                 ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
CREATE UNIQUE INDEX cwi_uniq4_idx ON cwi_test(b collate "POSIX");
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;  -- fail
ERROR:  index "cwi_uniq4_idx" column number 1 does not have default sorting behavior
LINE 1: ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;
                                 ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
DROP TABLE cwi_test;
-- ADD CONSTRAINT USING INDEX is forbidden on partitioned tables
CREATE TABLE cwi_test(a int) PARTITION BY hash (a);
create unique index on cwi_test (a);
alter table cwi_test add primary key using index cwi_test_a_idx ;
ERROR:  ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables
DROP TABLE cwi_test;
-- PRIMARY KEY constraint cannot be backed by a NULLS NOT DISTINCT index
CREATE TABLE cwi_test(a int, b int);
CREATE UNIQUE INDEX cwi_a_nnd ON cwi_test (a) NULLS NOT DISTINCT;
ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_a_nnd;
ERROR:  primary keys cannot use NULLS NOT DISTINCT indexes
DROP TABLE cwi_test;
--
-- Check handling of indexes on system columns
--
CREATE TABLE syscol_table (a INT);
-- System columns cannot be indexed
CREATE INDEX ON syscolcol_table (ctid);
ERROR:  relation "syscolcol_table" does not exist
-- nor used in expressions
CREATE INDEX ON syscol_table ((ctid >= '(1000,0)'));
ERROR:  index creation on system columns is not supported
-- nor used in predicates
CREATE INDEX ON syscol_table (a) WHERE ctid >= '(1000,0)';
ERROR:  index creation on system columns is not supported
DROP TABLE syscol_table;
--
-- Tests for IS NULL/IS NOT NULL with b-tree indexes
--
CREATE TABLE onek_with_null AS SELECT unique1, unique2 FROM onek;
INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = ON;
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
-- Check initial-positioning logic too
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
     147 |       0
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
     147 |       0
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
     147 |       0
     931 |       1
(2 rows)

SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
         |        
     278 |     999
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
     278 |     999
       0 |     998
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
       0 |     998
     744 |     997
(2 rows)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
DROP TABLE onek_with_null;
--
-- Check bitmap index path planning
--
EXPLAIN (COSTS OFF)
SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1
   Recheck Cond: (((thousand = 42) AND (tenthous = 1)) OR ((thousand = 42) AND (tenthous = 3)) OR ((thousand = 42) AND (tenthous = 42)))
   ->  BitmapOr
         ->  Bitmap Index Scan on tenk1_thous_tenthous
               Index Cond: ((thousand = 42) AND (tenthous = 1))
         ->  Bitmap Index Scan on tenk1_thous_tenthous
               Index Cond: ((thousand = 42) AND (tenthous = 3))
         ->  Bitmap Index Scan on tenk1_thous_tenthous
               Index Cond: ((thousand = 42) AND (tenthous = 42))
(9 rows)

SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
      42 |    5530 |   0 |    2 |   2 |      2 |      42 |       42 |          42 |        42 |       42 |  84 |   85 | QBAAAA   | SEIAAA   | OOOOxx
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on tenk1
         Recheck Cond: ((hundred = 42) AND ((thousand = 42) OR (thousand = 99)))
         ->  BitmapAnd
               ->  Bitmap Index Scan on tenk1_hundred
                     Index Cond: (hundred = 42)
               ->  BitmapOr
                     ->  Bitmap Index Scan on tenk1_thous_tenthous
                           Index Cond: (thousand = 42)
                     ->  Bitmap Index Scan on tenk1_thous_tenthous
                           Index Cond: (thousand = 99)
(11 rows)

SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
 count 
-------
    10
(1 row)

--
-- Check behavior with duplicate index column contents
--
CREATE TABLE dupindexcols AS
  SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
ANALYZE dupindexcols;
EXPLAIN (COSTS OFF)
  SELECT count(*) FROM dupindexcols
    WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on dupindexcols
         Recheck Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
         ->  Bitmap Index Scan on dupindexcols_i
               Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
(5 rows)

SELECT count(*) FROM dupindexcols
  WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
 count 
-------
    97
(1 row)

--
-- Check ordering of =ANY indexqual results (bug in 9.2.0)
--
explain (costs off)
SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
                      QUERY PLAN                       
-------------------------------------------------------
 Index Only Scan using tenk1_unique1 on tenk1
   Index Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
(2 rows)

SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
 unique1 
---------
       1
       7
      42
(3 rows)

explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
                      QUERY PLAN                       
-------------------------------------------------------
 Index Only Scan using tenk1_thous_tenthous on tenk1
   Index Cond: (thousand < 2)
   Filter: (tenthous = ANY ('{1001,3000}'::integer[]))
(3 rows)

SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

SET enable_indexonlyscan = OFF;
explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort
   Sort Key: thousand
   ->  Index Scan using tenk1_thous_tenthous on tenk1
         Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
(4 rows)

SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

RESET enable_indexonlyscan;
--
-- Check elimination of constant-NULL subexpressions
--
explain (costs off)
  select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
                      QUERY PLAN                      
------------------------------------------------------
 Index Scan using tenk1_thous_tenthous on tenk1
   Index Cond: ((thousand = 1) AND (tenthous = 1001))
(2 rows)

--
-- Check matching of boolean index columns to WHERE conditions and sort keys
--
create temp table boolindex (b bool, i int, unique(b, i), junk float);
explain (costs off)
  select * from boolindex order by b, i limit 10;
                      QUERY PLAN                       
-------------------------------------------------------
 Limit
   ->  Index Scan using boolindex_b_i_key on boolindex
(2 rows)

explain (costs off)
  select * from boolindex where b order by i limit 10;
                      QUERY PLAN                       
-------------------------------------------------------
 Limit
   ->  Index Scan using boolindex_b_i_key on boolindex
         Index Cond: (b = true)
(3 rows)

explain (costs off)
  select * from boolindex where b = true order by i desc limit 10;
                           QUERY PLAN                           
----------------------------------------------------------------
 Limit
   ->  Index Scan Backward using boolindex_b_i_key on boolindex
         Index Cond: (b = true)
(3 rows)

explain (costs off)
  select * from boolindex where not b order by i limit 10;
                      QUERY PLAN                       
-------------------------------------------------------
 Limit
   ->  Index Scan using boolindex_b_i_key on boolindex
         Index Cond: (b = false)
(3 rows)

explain (costs off)
  select * from boolindex where b is true order by i desc limit 10;
                           QUERY PLAN                           
----------------------------------------------------------------
 Limit
   ->  Index Scan Backward using boolindex_b_i_key on boolindex
         Index Cond: (b = true)
(3 rows)

explain (costs off)
  select * from boolindex where b is false order by i desc limit 10;
                           QUERY PLAN                           
----------------------------------------------------------------
 Limit
   ->  Index Scan Backward using boolindex_b_i_key on boolindex
         Index Cond: (b = false)
(3 rows)

--
-- REINDEX (VERBOSE)
--
CREATE TABLE reindex_verbose(id integer primary key);
\set VERBOSITY terse \\ -- suppress machine-dependent details
REINDEX (VERBOSE) TABLE reindex_verbose;
INFO:  index "reindex_verbose_pkey" was reindexed
\set VERBOSITY default
DROP TABLE reindex_verbose;
--
-- REINDEX CONCURRENTLY
--
CREATE TABLE concur_reindex_tab (c1 int);
-- REINDEX
REINDEX TABLE concur_reindex_tab; -- notice
NOTICE:  table "concur_reindex_tab" has no indexes to reindex
REINDEX (CONCURRENTLY) TABLE concur_reindex_tab; -- notice
NOTICE:  table "concur_reindex_tab" has no indexes that can be reindexed concurrently
ALTER TABLE concur_reindex_tab ADD COLUMN c2 text; -- add toast index
-- Normal index with integer column
CREATE UNIQUE INDEX concur_reindex_ind1 ON concur_reindex_tab(c1);
-- Normal index with text column
CREATE INDEX concur_reindex_ind2 ON concur_reindex_tab(c2);
-- UNIQUE index with expression
CREATE UNIQUE INDEX concur_reindex_ind3 ON concur_reindex_tab(abs(c1));
-- Duplicate column names
CREATE INDEX concur_reindex_ind4 ON concur_reindex_tab(c1, c1, c2);
-- Create table for check on foreign key dependence switch with indexes swapped
ALTER TABLE concur_reindex_tab ADD PRIMARY KEY USING INDEX concur_reindex_ind1;
CREATE TABLE concur_reindex_tab2 (c1 int REFERENCES concur_reindex_tab);
INSERT INTO concur_reindex_tab VALUES  (1, 'a');
INSERT INTO concur_reindex_tab VALUES  (2, 'a');
-- Reindex concurrently of exclusion constraint currently not supported
CREATE TABLE concur_reindex_tab3 (c1 int, c2 int4range, EXCLUDE USING gist (c2 WITH &&));
INSERT INTO concur_reindex_tab3 VALUES  (3, '[1,2]');
REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl;  -- error
ERROR:  concurrent index creation for exclusion constraints is not supported
REINDEX TABLE CONCURRENTLY concur_reindex_tab3;  -- succeeds with warning
WARNING:  cannot reindex exclusion constraint index "public.concur_reindex_tab3_c2_excl" concurrently, skipping
INSERT INTO concur_reindex_tab3 VALUES  (4, '[2,4]');
ERROR:  conflicting key value violates exclusion constraint "concur_reindex_tab3_c2_excl"
DETAIL:  Key (c2)=([2,5)) conflicts with existing key (c2)=([1,3)).
-- Check materialized views
CREATE MATERIALIZED VIEW concur_reindex_matview AS SELECT * FROM concur_reindex_tab;
-- Dependency lookup before and after the follow-up REINDEX commands.
-- These should remain consistent.
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_tab'::regclass,
            'concur_reindex_ind1'::regclass,
	    'concur_reindex_ind2'::regclass,
	    'concur_reindex_ind3'::regclass,
	    'concur_reindex_ind4'::regclass,
	    'concur_reindex_matview'::regclass)
  ORDER BY 1, 2;
                   obj                    |                           objref                           | deptype 
------------------------------------------+------------------------------------------------------------+---------
 index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
 index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | table concur_reindex_tab                                   | a
 index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
 materialized view concur_reindex_matview | schema public                                              | n
 table concur_reindex_tab                 | schema public                                              | n
(8 rows)

REINDEX INDEX CONCURRENTLY concur_reindex_ind1;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
REINDEX TABLE CONCURRENTLY concur_reindex_matview;
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_tab'::regclass,
            'concur_reindex_ind1'::regclass,
	    'concur_reindex_ind2'::regclass,
	    'concur_reindex_ind3'::regclass,
	    'concur_reindex_ind4'::regclass,
	    'concur_reindex_matview'::regclass)
  ORDER BY 1, 2;
                   obj                    |                           objref                           | deptype 
------------------------------------------+------------------------------------------------------------+---------
 index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
 index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | table concur_reindex_tab                                   | a
 index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
 materialized view concur_reindex_matview | schema public                                              | n
 table concur_reindex_tab                 | schema public                                              | n
(8 rows)

-- Check that comments are preserved
CREATE TABLE testcomment (i int);
CREATE INDEX testcomment_idx1 ON testcomment (i);
COMMENT ON INDEX testcomment_idx1 IS 'test comment';
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

REINDEX TABLE testcomment;
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

REINDEX TABLE CONCURRENTLY testcomment ;
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

DROP TABLE testcomment;
-- Check that indisclustered updates are preserved
CREATE TABLE concur_clustered(i int);
CREATE INDEX concur_clustered_i_idx ON concur_clustered(i);
ALTER TABLE concur_clustered CLUSTER ON concur_clustered_i_idx;
REINDEX TABLE CONCURRENTLY concur_clustered;
SELECT indexrelid::regclass, indisclustered FROM pg_index
  WHERE indrelid = 'concur_clustered'::regclass;
       indexrelid       | indisclustered 
------------------------+----------------
 concur_clustered_i_idx | t
(1 row)

DROP TABLE concur_clustered;
-- Check that indisreplident updates are preserved.
CREATE TABLE concur_replident(i int NOT NULL);
CREATE UNIQUE INDEX concur_replident_i_idx ON concur_replident(i);
ALTER TABLE concur_replident REPLICA IDENTITY
  USING INDEX concur_replident_i_idx;
SELECT indexrelid::regclass, indisreplident FROM pg_index
  WHERE indrelid = 'concur_replident'::regclass;
       indexrelid       | indisreplident 
------------------------+----------------
 concur_replident_i_idx | t
(1 row)

REINDEX TABLE CONCURRENTLY concur_replident;
SELECT indexrelid::regclass, indisreplident FROM pg_index
  WHERE indrelid = 'concur_replident'::regclass;
       indexrelid       | indisreplident 
------------------------+----------------
 concur_replident_i_idx | t
(1 row)

DROP TABLE concur_replident;
-- Check that opclass parameters are preserved
CREATE TABLE concur_appclass_tab(i tsvector, j tsvector, k tsvector);
CREATE INDEX concur_appclass_ind on concur_appclass_tab
  USING gist (i tsvector_ops (siglen='1000'), j tsvector_ops (siglen='500'));
CREATE INDEX concur_appclass_ind_2 on concur_appclass_tab
  USING gist (k tsvector_ops (siglen='300'), j tsvector_ops);
REINDEX TABLE CONCURRENTLY concur_appclass_tab;
\d concur_appclass_tab
         Table "public.concur_appclass_tab"
 Column |   Type   | Collation | Nullable | Default 
--------+----------+-----------+----------+---------
 i      | tsvector |           |          | 
 j      | tsvector |           |          | 
 k      | tsvector |           |          | 
Indexes:
    "concur_appclass_ind" gist (i tsvector_ops (siglen='1000'), j tsvector_ops (siglen='500'))
    "concur_appclass_ind_2" gist (k tsvector_ops (siglen='300'), j)

DROP TABLE concur_appclass_tab;
-- Partitions
-- Create some partitioned tables
CREATE TABLE concur_reindex_part (c1 int, c2 int) PARTITION BY RANGE (c1);
CREATE TABLE concur_reindex_part_0 PARTITION OF concur_reindex_part
  FOR VALUES FROM (0) TO (10) PARTITION BY list (c2);
CREATE TABLE concur_reindex_part_0_1 PARTITION OF concur_reindex_part_0
  FOR VALUES IN (1);
CREATE TABLE concur_reindex_part_0_2 PARTITION OF concur_reindex_part_0
  FOR VALUES IN (2);
-- This partitioned table will have no partitions.
CREATE TABLE concur_reindex_part_10 PARTITION OF concur_reindex_part
  FOR VALUES FROM (10) TO (20) PARTITION BY list (c2);
-- Create some partitioned indexes
CREATE INDEX concur_reindex_part_index ON ONLY concur_reindex_part (c1);
CREATE INDEX concur_reindex_part_index_0 ON ONLY concur_reindex_part_0 (c1);
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_0;
-- This partitioned index will have no partitions.
CREATE INDEX concur_reindex_part_index_10 ON ONLY concur_reindex_part_10 (c1);
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_10;
CREATE INDEX concur_reindex_part_index_0_1 ON ONLY concur_reindex_part_0_1 (c1);
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_1;
CREATE INDEX concur_reindex_part_index_0_2 ON ONLY concur_reindex_part_0_2 (c1);
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

-- REINDEX should preserve dependencies of partition tree.
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_part'::regclass,
            'concur_reindex_part_0'::regclass,
            'concur_reindex_part_0_1'::regclass,
            'concur_reindex_part_0_2'::regclass,
            'concur_reindex_part_index'::regclass,
            'concur_reindex_part_index_0'::regclass,
            'concur_reindex_part_index_0_1'::regclass,
            'concur_reindex_part_index_0_2'::regclass)
  ORDER BY 1, 2;
                   obj                    |                   objref                   | deptype 
------------------------------------------+--------------------------------------------+---------
 column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
 column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
 index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
 index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
 index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
 index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
 index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
 index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
 index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
 index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
 table concur_reindex_part                | schema public                              | n
 table concur_reindex_part_0              | schema public                              | n
 table concur_reindex_part_0              | table concur_reindex_part                  | a
 table concur_reindex_part_0_1            | schema public                              | n
 table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
 table concur_reindex_part_0_2            | schema public                              | n
 table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
(19 rows)

REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1;
REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2;
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_part'::regclass,
            'concur_reindex_part_0'::regclass,
            'concur_reindex_part_0_1'::regclass,
            'concur_reindex_part_0_2'::regclass,
            'concur_reindex_part_index'::regclass,
            'concur_reindex_part_index_0'::regclass,
            'concur_reindex_part_index_0_1'::regclass,
            'concur_reindex_part_index_0_2'::regclass)
  ORDER BY 1, 2;
                   obj                    |                   objref                   | deptype 
------------------------------------------+--------------------------------------------+---------
 column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
 column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
 index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
 index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
 index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
 index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
 index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
 index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
 index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
 index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
 table concur_reindex_part                | schema public                              | n
 table concur_reindex_part_0              | schema public                              | n
 table concur_reindex_part_0              | table concur_reindex_part                  | a
 table concur_reindex_part_0_1            | schema public                              | n
 table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
 table concur_reindex_part_0_2            | schema public                              | n
 table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
(19 rows)

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

-- REINDEX for partitioned indexes
-- REINDEX TABLE fails for partitioned indexes
-- Top-most parent index
REINDEX TABLE concur_reindex_part_index; -- error
ERROR:  "concur_reindex_part_index" is not a table or materialized view
REINDEX TABLE CONCURRENTLY concur_reindex_part_index; -- error
ERROR:  "concur_reindex_part_index" is not a table or materialized view
-- Partitioned index with no leaves
REINDEX TABLE concur_reindex_part_index_10; -- error
ERROR:  "concur_reindex_part_index_10" is not a table or materialized view
REINDEX TABLE CONCURRENTLY concur_reindex_part_index_10; -- error
ERROR:  "concur_reindex_part_index_10" is not a table or materialized view
-- Cannot run in a transaction block
BEGIN;
REINDEX INDEX concur_reindex_part_index;
ERROR:  REINDEX INDEX cannot run inside a transaction block
CONTEXT:  while reindexing partitioned index "public.concur_reindex_part_index"
ROLLBACK;
-- Helper functions to track changes of relfilenodes in a partition tree.
-- Create a table tracking the relfilenode state.
CREATE OR REPLACE FUNCTION create_relfilenode_part(relname text, indname text)
  RETURNS VOID AS
  $func$
  BEGIN
  EXECUTE format('
    CREATE TABLE %I AS
      SELECT oid, relname, relfilenode, relkind, reltoastrelid
      FROM pg_class
      WHERE oid IN
         (SELECT relid FROM pg_partition_tree(''%I''));',
	 relname, indname);
  END
  $func$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION compare_relfilenode_part(tabname text)
  RETURNS TABLE (relname name, relkind "char", state text) AS
  $func$
  BEGIN
    RETURN QUERY EXECUTE
      format(
        'SELECT  b.relname,
                 b.relkind,
                 CASE WHEN a.relfilenode = b.relfilenode THEN ''relfilenode is unchanged''
                 ELSE ''relfilenode has changed'' END
           -- Do not join with OID here as CONCURRENTLY changes it.
           FROM %I b JOIN pg_class a ON b.relname = a.relname
           ORDER BY 1;', tabname);
  END
  $func$ LANGUAGE plpgsql;
--  Check that expected relfilenodes are changed, non-concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX INDEX concur_reindex_part_index;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
-- concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX INDEX CONCURRENTLY concur_reindex_part_index;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
-- REINDEX for partitioned tables
-- REINDEX INDEX fails for partitioned tables
-- Top-most parent
REINDEX INDEX concur_reindex_part; -- error
ERROR:  "concur_reindex_part" is not an index
REINDEX INDEX CONCURRENTLY concur_reindex_part; -- error
ERROR:  "concur_reindex_part" is not an index
-- Partitioned with no leaves
REINDEX INDEX concur_reindex_part_10; -- error
ERROR:  "concur_reindex_part_10" is not an index
REINDEX INDEX CONCURRENTLY concur_reindex_part_10; -- error
ERROR:  "concur_reindex_part_10" is not an index
-- Cannot run in a transaction block
BEGIN;
REINDEX TABLE concur_reindex_part;
ERROR:  REINDEX TABLE cannot run inside a transaction block
CONTEXT:  while reindexing partitioned table "public.concur_reindex_part"
ROLLBACK;
-- Check that expected relfilenodes are changed, non-concurrent case.
-- Note that the partition tree changes of the *indexes* need to be checked.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX TABLE concur_reindex_part;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
-- concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX TABLE CONCURRENTLY concur_reindex_part;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
DROP FUNCTION create_relfilenode_part;
DROP FUNCTION compare_relfilenode_part;
-- Cleanup of partition tree used for REINDEX test.
DROP TABLE concur_reindex_part;
-- Check errors
-- Cannot run inside a transaction block
BEGIN;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
REINDEX TABLE CONCURRENTLY pg_class; -- no catalog relation
ERROR:  cannot reindex system catalogs concurrently
REINDEX INDEX CONCURRENTLY pg_class_oid_index; -- no catalog index
ERROR:  cannot reindex system catalogs concurrently
-- These are the toast table and index of pg_authid.
REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260; -- no catalog toast table
ERROR:  cannot reindex system catalogs concurrently
REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index; -- no catalog toast index
ERROR:  cannot reindex system catalogs concurrently
REINDEX SYSTEM CONCURRENTLY postgres; -- not allowed for SYSTEM
ERROR:  cannot reindex system catalogs concurrently
REINDEX (CONCURRENTLY) SYSTEM postgres; -- ditto
ERROR:  cannot reindex system catalogs concurrently
REINDEX (CONCURRENTLY) SYSTEM;  -- ditto
ERROR:  cannot reindex system catalogs concurrently
-- Warns about catalog relations
REINDEX SCHEMA CONCURRENTLY pg_catalog;
WARNING:  cannot reindex system catalogs concurrently, skipping all
-- Not the current database
REINDEX DATABASE not_current_database;
ERROR:  can only reindex the currently open database
-- Check the relation status, there should not be invalid indexes
\d concur_reindex_tab
         Table "public.concur_reindex_tab"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           | not null | 
 c2     | text    |           |          | 
Indexes:
    "concur_reindex_ind1" PRIMARY KEY, btree (c1)
    "concur_reindex_ind2" btree (c2)
    "concur_reindex_ind3" UNIQUE, btree (abs(c1))
    "concur_reindex_ind4" btree (c1, c1, c2)
Referenced by:
    TABLE "concur_reindex_tab2" CONSTRAINT "concur_reindex_tab2_c1_fkey" FOREIGN KEY (c1) REFERENCES concur_reindex_tab(c1)

DROP MATERIALIZED VIEW concur_reindex_matview;
DROP TABLE concur_reindex_tab, concur_reindex_tab2, concur_reindex_tab3;
-- Check handling of invalid indexes
CREATE TABLE concur_reindex_tab4 (c1 int);
INSERT INTO concur_reindex_tab4 VALUES (1), (1), (2);
-- This trick creates an invalid index.
CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
ERROR:  could not create unique index "concur_reindex_ind5"
DETAIL:  Key (c1)=(1) is duplicated.
-- Reindexing concurrently this index fails with the same failure.
-- The extra index created is itself invalid, and can be dropped.
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
ERROR:  could not create unique index "concur_reindex_ind5_ccnew"
DETAIL:  Key (c1)=(1) is duplicated.
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 
Indexes:
    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
    "concur_reindex_ind5_ccnew" UNIQUE, btree (c1) INVALID

DROP INDEX concur_reindex_ind5_ccnew;
-- This makes the previous failure go away, so the index can become valid.
DELETE FROM concur_reindex_tab4 WHERE c1 = 1;
-- The invalid index is not processed when running REINDEX TABLE.
REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
WARNING:  skipping reindex of invalid index "public.concur_reindex_ind5"
HINT:  Use DROP INDEX or REINDEX INDEX.
NOTICE:  table "concur_reindex_tab4" has no indexes that can be reindexed concurrently
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 
Indexes:
    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID

-- But it is fixed with REINDEX INDEX.
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 
Indexes:
    "concur_reindex_ind5" UNIQUE, btree (c1)

DROP TABLE concur_reindex_tab4;
-- Check handling of indexes with expressions and predicates.  The
-- definitions of the rebuilt indexes should match the original
-- definitions.
CREATE TABLE concur_exprs_tab (c1 int , c2 boolean);
INSERT INTO concur_exprs_tab (c1, c2) VALUES (1369652450, FALSE),
  (414515746, TRUE),
  (897778963, FALSE);
CREATE UNIQUE INDEX concur_exprs_index_expr
  ON concur_exprs_tab ((c1::text COLLATE "C"));
CREATE UNIQUE INDEX concur_exprs_index_pred ON concur_exprs_tab (c1)
  WHERE (c1::text > 500000000::text COLLATE "C");
CREATE UNIQUE INDEX concur_exprs_index_pred_2
  ON concur_exprs_tab ((1 / c1))
  WHERE ('-H') >= (c2::TEXT) COLLATE "C";
ALTER INDEX concur_exprs_index_expr ALTER COLUMN 1 SET STATISTICS 100;
ANALYZE concur_exprs_tab;
SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
  'concur_exprs_index_expr'::regclass,
  'concur_exprs_index_pred'::regclass,
  'concur_exprs_index_pred_2'::regclass)
  GROUP BY starelid ORDER BY starelid::regclass::text;
        starelid         | count 
-------------------------+-------
 concur_exprs_index_expr |     1
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                                 pg_get_indexdef                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
(1 row)

REINDEX TABLE CONCURRENTLY concur_exprs_tab;
SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                                 pg_get_indexdef                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
(1 row)

-- ALTER TABLE recreates the indexes, which should keep their collations.
ALTER TABLE concur_exprs_tab ALTER c2 TYPE TEXT;
SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                             pg_get_indexdef                                                              
------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= (c2 COLLATE "C"))
(1 row)

-- Statistics should remain intact.
SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
  'concur_exprs_index_expr'::regclass,
  'concur_exprs_index_pred'::regclass,
  'concur_exprs_index_pred_2'::regclass)
  GROUP BY starelid ORDER BY starelid::regclass::text;
        starelid         | count 
-------------------------+-------
 concur_exprs_index_expr |     1
(1 row)

-- attstattarget should remain intact
SELECT attrelid::regclass, attnum, attstattarget
  FROM pg_attribute WHERE attrelid IN (
    'concur_exprs_index_expr'::regclass,
    'concur_exprs_index_pred'::regclass,
    'concur_exprs_index_pred_2'::regclass)
  ORDER BY attrelid::regclass::text, attnum;
         attrelid          | attnum | attstattarget 
---------------------------+--------+---------------
 concur_exprs_index_expr   |      1 |           100
 concur_exprs_index_pred   |      1 |              
 concur_exprs_index_pred_2 |      1 |              
(3 rows)

DROP TABLE concur_exprs_tab;
-- Temporary tables and on-commit actions, where CONCURRENTLY is ignored.
-- ON COMMIT PRESERVE ROWS, the default.
CREATE TEMP TABLE concur_temp_tab_1 (c1 int, c2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp_tab_1 VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX concur_temp_ind_1 ON concur_temp_tab_1(c2);
REINDEX TABLE CONCURRENTLY concur_temp_tab_1;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
-- Still fails in transaction blocks
BEGIN;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- ON COMMIT DELETE ROWS
CREATE TEMP TABLE concur_temp_tab_2 (c1 int, c2 text)
  ON COMMIT DELETE ROWS;
CREATE INDEX concur_temp_ind_2 ON concur_temp_tab_2(c2);
REINDEX TABLE CONCURRENTLY concur_temp_tab_2;
REINDEX INDEX CONCURRENTLY concur_temp_ind_2;
-- ON COMMIT DROP
BEGIN;
CREATE TEMP TABLE concur_temp_tab_3 (c1 int, c2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp_tab_3 VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX concur_temp_ind_3 ON concur_temp_tab_3(c2);
-- Fails when running in a transaction
REINDEX INDEX CONCURRENTLY concur_temp_ind_3;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- REINDEX SCHEMA processes all temporary relations
CREATE TABLE reindex_temp_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
  FROM pg_class
  WHERE relname IN ('concur_temp_ind_1', 'concur_temp_ind_2');
SELECT pg_my_temp_schema()::regnamespace as temp_schema_name \gset
REINDEX SCHEMA CONCURRENTLY :temp_schema_name;
SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_temp_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
      relname      | relkind |          case           
-------------------+---------+-------------------------
 concur_temp_ind_1 | i       | relfilenode has changed
 concur_temp_ind_2 | i       | relfilenode has changed
(2 rows)

DROP TABLE concur_temp_tab_1, concur_temp_tab_2, reindex_temp_before;
--
-- REINDEX SCHEMA
--
REINDEX SCHEMA schema_to_reindex; -- failure, schema does not exist
ERROR:  schema "schema_to_reindex" does not exist
CREATE SCHEMA schema_to_reindex;
SET search_path = 'schema_to_reindex';
CREATE TABLE table1(col1 SERIAL PRIMARY KEY);
INSERT INTO table1 SELECT generate_series(1,400);
CREATE TABLE table2(col1 SERIAL PRIMARY KEY, col2 TEXT NOT NULL);
INSERT INTO table2 SELECT generate_series(1,400), 'abc';
CREATE INDEX ON table2(col2);
CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
CREATE INDEX ON matview(col1);
CREATE VIEW view AS SELECT col2 FROM table2;
CREATE TABLE reindex_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelid
FROM pg_class WHERE oid IN
	(SELECT reltoastrelid FROM reindex_before WHERE reltoastrelid > 0);
INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE_index', relfilenode, relkind, reltoastrelid
FROM pg_class where oid in
	(select indexrelid from pg_index where indrelid in
		(select reltoastrelid from reindex_before where reltoastrelid > 0));
REINDEX SCHEMA schema_to_reindex;
CREATE TABLE reindex_after AS SELECT oid, relname, relfilenode, relkind
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
       relname        | relkind |           case           
----------------------+---------+--------------------------
 matview              | m       | relfilenode is unchanged
 matview_col1_idx     | i       | relfilenode has changed
 pg_toast_TABLE       | t       | relfilenode is unchanged
 pg_toast_TABLE_index | i       | relfilenode has changed
 table1               | r       | relfilenode is unchanged
 table1_col1_seq      | S       | relfilenode is unchanged
 table1_pkey          | i       | relfilenode has changed
 table2               | r       | relfilenode is unchanged
 table2_col1_seq      | S       | relfilenode is unchanged
 table2_col2_idx      | i       | relfilenode has changed
 table2_pkey          | i       | relfilenode has changed
 view                 | v       | relfilenode is unchanged
(12 rows)

REINDEX SCHEMA schema_to_reindex;
BEGIN;
REINDEX SCHEMA schema_to_reindex; -- failure, cannot run in a transaction
ERROR:  REINDEX SCHEMA cannot run inside a transaction block
END;
-- concurrently
REINDEX SCHEMA CONCURRENTLY schema_to_reindex;
-- Failure for unauthorized user
CREATE ROLE regress_reindexuser NOLOGIN;
SET SESSION ROLE regress_reindexuser;
REINDEX SCHEMA schema_to_reindex;
ERROR:  must be owner of schema schema_to_reindex
-- Permission failures with toast tables and indexes (pg_authid here)
RESET ROLE;
GRANT USAGE ON SCHEMA pg_toast TO regress_reindexuser;
SET SESSION ROLE regress_reindexuser;
REINDEX TABLE pg_toast.pg_toast_1260;
ERROR:  permission denied for table pg_toast_1260
REINDEX INDEX pg_toast.pg_toast_1260_index;
ERROR:  permission denied for index pg_toast_1260_index
-- Clean up
RESET ROLE;
REVOKE USAGE ON SCHEMA pg_toast FROM regress_reindexuser;
DROP ROLE regress_reindexuser;
DROP SCHEMA schema_to_reindex CASCADE;
NOTICE:  drop cascades to 6 other objects
DETAIL:  drop cascades to table table1
drop cascades to table table2
drop cascades to materialized view matview
drop cascades to view view
drop cascades to table reindex_before
drop cascades to table reindex_after
-- END setup from create_index 
-- START setup from  date 
--
-- DATE
--
CREATE TABLE DATE_TBL (f1 date);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE DATE_TBL (f1 date);
                     ^
INSERT INTO DATE_TBL VALUES ('1957-04-09');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('1957-04-09');
                    ^
INSERT INTO DATE_TBL VALUES ('1957-06-13');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('1957-06-13');
                    ^
INSERT INTO DATE_TBL VALUES ('1996-02-28');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('1996-02-28');
                    ^
INSERT INTO DATE_TBL VALUES ('1996-02-29');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('1996-02-29');
                    ^
INSERT INTO DATE_TBL VALUES ('1996-03-01');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('1996-03-01');
                    ^
INSERT INTO DATE_TBL VALUES ('1996-03-02');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('1996-03-02');
                    ^
INSERT INTO DATE_TBL VALUES ('1997-02-28');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('1997-02-28');
                    ^
INSERT INTO DATE_TBL VALUES ('1997-02-29');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('1997-02-29');
                    ^
INSERT INTO DATE_TBL VALUES ('1997-03-01');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('1997-03-01');
                    ^
INSERT INTO DATE_TBL VALUES ('1997-03-02');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('1997-03-02');
                    ^
INSERT INTO DATE_TBL VALUES ('2000-04-01');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('2000-04-01');
                    ^
INSERT INTO DATE_TBL VALUES ('2000-04-02');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('2000-04-02');
                    ^
INSERT INTO DATE_TBL VALUES ('2000-04-03');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('2000-04-03');
                    ^
INSERT INTO DATE_TBL VALUES ('2038-04-08');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('2038-04-08');
                    ^
INSERT INTO DATE_TBL VALUES ('2039-04-09');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('2039-04-09');
                    ^
INSERT INTO DATE_TBL VALUES ('2040-04-10');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('2040-04-10');
                    ^
INSERT INTO DATE_TBL VALUES ('2040-04-10 BC');
ERROR:  relation "date_tbl" does not exist
LINE 1: INSERT INTO DATE_TBL VALUES ('2040-04-10 BC');
                    ^
SELECT f1 FROM DATE_TBL;
ERROR:  relation "date_tbl" does not exist
LINE 1: SELECT f1 FROM DATE_TBL;
                       ^
SELECT f1 FROM DATE_TBL WHERE f1 < '2000-01-01';
ERROR:  relation "date_tbl" does not exist
LINE 1: SELECT f1 FROM DATE_TBL WHERE f1 < '2000-01-01';
                       ^
SELECT f1 FROM DATE_TBL
  WHERE f1 BETWEEN '2000-01-01' AND '2001-01-01';
ERROR:  relation "date_tbl" does not exist
LINE 1: SELECT f1 FROM DATE_TBL
                       ^
--
-- Check all the documented input formats
--
SET datestyle TO iso;  -- display results in ISO
SET datestyle TO ymd;
SELECT date 'January 8, 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999-01-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999-01-18';
    date    
------------
 1999-01-18
(1 row)

SELECT date '1/8/1999';
ERROR:  date/time field value out of range: "1/8/1999"
LINE 1: SELECT date '1/8/1999';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1/18/1999';
ERROR:  date/time field value out of range: "1/18/1999"
LINE 1: SELECT date '1/18/1999';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '18/1/1999';
ERROR:  date/time field value out of range: "18/1/1999"
LINE 1: SELECT date '18/1/1999';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '01/02/03';
    date    
------------
 2001-02-03
(1 row)

SELECT date '19990108';
    date    
------------
 1999-01-08
(1 row)

SELECT date '990108';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999.008';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'J2451187';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'January 8, 99 BC';
ERROR:  date/time field value out of range: "January 8, 99 BC"
LINE 1: SELECT date 'January 8, 99 BC';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '99-Jan-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999-Jan-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08-Jan-99';
ERROR:  date/time field value out of range: "08-Jan-99"
LINE 1: SELECT date '08-Jan-99';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '08-Jan-1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'Jan-08-99';
ERROR:  date/time field value out of range: "Jan-08-99"
LINE 1: SELECT date 'Jan-08-99';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date 'Jan-08-1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99-08-Jan';
ERROR:  invalid input syntax for type date: "99-08-Jan"
LINE 1: SELECT date '99-08-Jan';
                    ^
SELECT date '1999-08-Jan';
ERROR:  invalid input syntax for type date: "1999-08-Jan"
LINE 1: SELECT date '1999-08-Jan';
                    ^
SELECT date '99 Jan 08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999 Jan 08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08 Jan 99';
ERROR:  date/time field value out of range: "08 Jan 99"
LINE 1: SELECT date '08 Jan 99';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '08 Jan 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'Jan 08 99';
ERROR:  date/time field value out of range: "Jan 08 99"
LINE 1: SELECT date 'Jan 08 99';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date 'Jan 08 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99 08 Jan';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999 08 Jan';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99-01-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999-01-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08-01-99';
ERROR:  date/time field value out of range: "08-01-99"
LINE 1: SELECT date '08-01-99';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '08-01-1999';
ERROR:  date/time field value out of range: "08-01-1999"
LINE 1: SELECT date '08-01-1999';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '01-08-99';
ERROR:  date/time field value out of range: "01-08-99"
LINE 1: SELECT date '01-08-99';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '01-08-1999';
ERROR:  date/time field value out of range: "01-08-1999"
LINE 1: SELECT date '01-08-1999';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '99-08-01';
    date    
------------
 1999-08-01
(1 row)

SELECT date '1999-08-01';
    date    
------------
 1999-08-01
(1 row)

SELECT date '99 01 08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999 01 08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08 01 99';
ERROR:  date/time field value out of range: "08 01 99"
LINE 1: SELECT date '08 01 99';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '08 01 1999';
ERROR:  date/time field value out of range: "08 01 1999"
LINE 1: SELECT date '08 01 1999';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '01 08 99';
ERROR:  date/time field value out of range: "01 08 99"
LINE 1: SELECT date '01 08 99';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '01 08 1999';
ERROR:  date/time field value out of range: "01 08 1999"
LINE 1: SELECT date '01 08 1999';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '99 08 01';
    date    
------------
 1999-08-01
(1 row)

SELECT date '1999 08 01';
    date    
------------
 1999-08-01
(1 row)

SET datestyle TO dmy;
SELECT date 'January 8, 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999-01-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999-01-18';
    date    
------------
 1999-01-18
(1 row)

SELECT date '1/8/1999';
    date    
------------
 1999-08-01
(1 row)

SELECT date '1/18/1999';
ERROR:  date/time field value out of range: "1/18/1999"
LINE 1: SELECT date '1/18/1999';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '18/1/1999';
    date    
------------
 1999-01-18
(1 row)

SELECT date '01/02/03';
    date    
------------
 2003-02-01
(1 row)

SELECT date '19990108';
    date    
------------
 1999-01-08
(1 row)

SELECT date '990108';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999.008';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'J2451187';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'January 8, 99 BC';
     date      
---------------
 0099-01-08 BC
(1 row)

SELECT date '99-Jan-08';
ERROR:  date/time field value out of range: "99-Jan-08"
LINE 1: SELECT date '99-Jan-08';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999-Jan-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08-Jan-99';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08-Jan-1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'Jan-08-99';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'Jan-08-1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99-08-Jan';
ERROR:  invalid input syntax for type date: "99-08-Jan"
LINE 1: SELECT date '99-08-Jan';
                    ^
SELECT date '1999-08-Jan';
ERROR:  invalid input syntax for type date: "1999-08-Jan"
LINE 1: SELECT date '1999-08-Jan';
                    ^
SELECT date '99 Jan 08';
ERROR:  date/time field value out of range: "99 Jan 08"
LINE 1: SELECT date '99 Jan 08';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999 Jan 08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08 Jan 99';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08 Jan 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'Jan 08 99';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'Jan 08 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99 08 Jan';
ERROR:  invalid input syntax for type date: "99 08 Jan"
LINE 1: SELECT date '99 08 Jan';
                    ^
SELECT date '1999 08 Jan';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99-01-08';
ERROR:  date/time field value out of range: "99-01-08"
LINE 1: SELECT date '99-01-08';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999-01-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08-01-99';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08-01-1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '01-08-99';
    date    
------------
 1999-08-01
(1 row)

SELECT date '01-08-1999';
    date    
------------
 1999-08-01
(1 row)

SELECT date '99-08-01';
ERROR:  date/time field value out of range: "99-08-01"
LINE 1: SELECT date '99-08-01';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999-08-01';
    date    
------------
 1999-08-01
(1 row)

SELECT date '99 01 08';
ERROR:  date/time field value out of range: "99 01 08"
LINE 1: SELECT date '99 01 08';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999 01 08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08 01 99';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08 01 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '01 08 99';
    date    
------------
 1999-08-01
(1 row)

SELECT date '01 08 1999';
    date    
------------
 1999-08-01
(1 row)

SELECT date '99 08 01';
ERROR:  date/time field value out of range: "99 08 01"
LINE 1: SELECT date '99 08 01';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999 08 01';
    date    
------------
 1999-08-01
(1 row)

SET datestyle TO mdy;
SELECT date 'January 8, 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999-01-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999-01-18';
    date    
------------
 1999-01-18
(1 row)

SELECT date '1/8/1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1/18/1999';
    date    
------------
 1999-01-18
(1 row)

SELECT date '18/1/1999';
ERROR:  date/time field value out of range: "18/1/1999"
LINE 1: SELECT date '18/1/1999';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '01/02/03';
    date    
------------
 2003-01-02
(1 row)

SELECT date '19990108';
    date    
------------
 1999-01-08
(1 row)

SELECT date '990108';
    date    
------------
 1999-01-08
(1 row)

SELECT date '1999.008';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'J2451187';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'January 8, 99 BC';
     date      
---------------
 0099-01-08 BC
(1 row)

SELECT date '99-Jan-08';
ERROR:  date/time field value out of range: "99-Jan-08"
LINE 1: SELECT date '99-Jan-08';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999-Jan-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08-Jan-99';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08-Jan-1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'Jan-08-99';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'Jan-08-1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99-08-Jan';
ERROR:  invalid input syntax for type date: "99-08-Jan"
LINE 1: SELECT date '99-08-Jan';
                    ^
SELECT date '1999-08-Jan';
ERROR:  invalid input syntax for type date: "1999-08-Jan"
LINE 1: SELECT date '1999-08-Jan';
                    ^
SELECT date '99 Jan 08';
ERROR:  invalid input syntax for type date: "99 Jan 08"
LINE 1: SELECT date '99 Jan 08';
                    ^
SELECT date '1999 Jan 08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08 Jan 99';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08 Jan 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'Jan 08 99';
    date    
------------
 1999-01-08
(1 row)

SELECT date 'Jan 08 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99 08 Jan';
ERROR:  invalid input syntax for type date: "99 08 Jan"
LINE 1: SELECT date '99 08 Jan';
                    ^
SELECT date '1999 08 Jan';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99-01-08';
ERROR:  date/time field value out of range: "99-01-08"
LINE 1: SELECT date '99-01-08';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999-01-08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08-01-99';
    date    
------------
 1999-08-01
(1 row)

SELECT date '08-01-1999';
    date    
------------
 1999-08-01
(1 row)

SELECT date '01-08-99';
    date    
------------
 1999-01-08
(1 row)

SELECT date '01-08-1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99-08-01';
ERROR:  date/time field value out of range: "99-08-01"
LINE 1: SELECT date '99-08-01';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999-08-01';
    date    
------------
 1999-08-01
(1 row)

SELECT date '99 01 08';
ERROR:  date/time field value out of range: "99 01 08"
LINE 1: SELECT date '99 01 08';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999 01 08';
    date    
------------
 1999-01-08
(1 row)

SELECT date '08 01 99';
    date    
------------
 1999-08-01
(1 row)

SELECT date '08 01 1999';
    date    
------------
 1999-08-01
(1 row)

SELECT date '01 08 99';
    date    
------------
 1999-01-08
(1 row)

SELECT date '01 08 1999';
    date    
------------
 1999-01-08
(1 row)

SELECT date '99 08 01';
ERROR:  date/time field value out of range: "99 08 01"
LINE 1: SELECT date '99 08 01';
                    ^
HINT:  Perhaps you need a different "datestyle" setting.
SELECT date '1999 08 01';
    date    
------------
 1999-08-01
(1 row)

-- Check upper and lower limits of date range
SELECT date '4714-11-24 BC';
     date      
---------------
 4714-11-24 BC
(1 row)

SELECT date '4714-11-23 BC';  -- out of range
ERROR:  date out of range: "4714-11-23 BC"
LINE 1: SELECT date '4714-11-23 BC';
                    ^
SELECT date '5874897-12-31';
     date      
---------------
 5874897-12-31
(1 row)

SELECT date '5874898-01-01';  -- out of range
ERROR:  date out of range: "5874898-01-01"
LINE 1: SELECT date '5874898-01-01';
                    ^
-- Test non-error-throwing API
SELECT pg_input_is_valid('now', 'date');
 pg_input_is_valid 
-------------------
 t
(1 row)

SELECT pg_input_is_valid('garbage', 'date');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT pg_input_is_valid('6874898-01-01', 'date');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT * FROM pg_input_error_info('garbage', 'date');
                    message                    | detail | hint | sql_error_code 
-----------------------------------------------+--------+------+----------------
 invalid input syntax for type date: "garbage" |        |      | 22007
(1 row)

SELECT * FROM pg_input_error_info('6874898-01-01', 'date');
              message               | detail | hint | sql_error_code 
------------------------------------+--------+------+----------------
 date out of range: "6874898-01-01" |        |      | 22008
(1 row)

RESET datestyle;
--
-- Simple math
-- Leave most of it for the horology tests
--
SELECT f1 - date '2000-01-01' AS "Days From 2K" FROM DATE_TBL;
ERROR:  relation "date_tbl" does not exist
LINE 1: ...LECT f1 - date '2000-01-01' AS "Days From 2K" FROM DATE_TBL;
                                                              ^
SELECT f1 - date 'epoch' AS "Days From Epoch" FROM DATE_TBL;
ERROR:  relation "date_tbl" does not exist
LINE 1: SELECT f1 - date 'epoch' AS "Days From Epoch" FROM DATE_TBL;
                                                           ^
SELECT date 'yesterday' - date 'today' AS "One day";
 One day 
---------
      -1
(1 row)

SELECT date 'today' - date 'tomorrow' AS "One day";
 One day 
---------
      -1
(1 row)

SELECT date 'yesterday' - date 'tomorrow' AS "Two days";
 Two days 
----------
       -2
(1 row)

SELECT date 'tomorrow' - date 'today' AS "One day";
 One day 
---------
       1
(1 row)

SELECT date 'today' - date 'yesterday' AS "One day";
 One day 
---------
       1
(1 row)

SELECT date 'tomorrow' - date 'yesterday' AS "Two days";
 Two days 
----------
        2
(1 row)

--
-- test extract!
--
SELECT f1 as "date",
    date_part('year', f1) AS year,
    date_part('month', f1) AS month,
    date_part('day', f1) AS day,
    date_part('quarter', f1) AS quarter,
    date_part('decade', f1) AS decade,
    date_part('century', f1) AS century,
    date_part('millennium', f1) AS millennium,
    date_part('isoyear', f1) AS isoyear,
    date_part('week', f1) AS week,
    date_part('dow', f1) AS dow,
    date_part('isodow', f1) AS isodow,
    date_part('doy', f1) AS doy,
    date_part('julian', f1) AS julian,
    date_part('epoch', f1) AS epoch
    FROM date_tbl;
ERROR:  relation "date_tbl" does not exist
LINE 16:     FROM date_tbl;
                  ^
--
-- epoch
--
SELECT EXTRACT(EPOCH FROM DATE        '1970-01-01');     --  0
 extract 
---------
       0
(1 row)

--
-- century
--
SELECT EXTRACT(CENTURY FROM DATE '0101-12-31 BC'); -- -2
 extract 
---------
      -2
(1 row)

SELECT EXTRACT(CENTURY FROM DATE '0100-12-31 BC'); -- -1
 extract 
---------
      -1
(1 row)

SELECT EXTRACT(CENTURY FROM DATE '0001-12-31 BC'); -- -1
 extract 
---------
      -1
(1 row)

SELECT EXTRACT(CENTURY FROM DATE '0001-01-01');    --  1
 extract 
---------
       1
(1 row)

SELECT EXTRACT(CENTURY FROM DATE '0001-01-01 AD'); --  1
 extract 
---------
       1
(1 row)

SELECT EXTRACT(CENTURY FROM DATE '1900-12-31');    -- 19
 extract 
---------
      19
(1 row)

SELECT EXTRACT(CENTURY FROM DATE '1901-01-01');    -- 20
 extract 
---------
      20
(1 row)

SELECT EXTRACT(CENTURY FROM DATE '2000-12-31');    -- 20
 extract 
---------
      20
(1 row)

SELECT EXTRACT(CENTURY FROM DATE '2001-01-01');    -- 21
 extract 
---------
      21
(1 row)

SELECT EXTRACT(CENTURY FROM CURRENT_DATE)>=21 AS True;     -- true
 true 
------
 t
(1 row)

--
-- millennium
--
SELECT EXTRACT(MILLENNIUM FROM DATE '0001-12-31 BC'); -- -1
 extract 
---------
      -1
(1 row)

SELECT EXTRACT(MILLENNIUM FROM DATE '0001-01-01 AD'); --  1
 extract 
---------
       1
(1 row)

SELECT EXTRACT(MILLENNIUM FROM DATE '1000-12-31');    --  1
 extract 
---------
       1
(1 row)

SELECT EXTRACT(MILLENNIUM FROM DATE '1001-01-01');    --  2
 extract 
---------
       2
(1 row)

SELECT EXTRACT(MILLENNIUM FROM DATE '2000-12-31');    --  2
 extract 
---------
       2
(1 row)

SELECT EXTRACT(MILLENNIUM FROM DATE '2001-01-01');    --  3
 extract 
---------
       3
(1 row)

-- next test to be fixed on the turn of the next millennium;-)
SELECT EXTRACT(MILLENNIUM FROM CURRENT_DATE);         --  3
 extract 
---------
       3
(1 row)

--
-- decade
--
SELECT EXTRACT(DECADE FROM DATE '1994-12-25');    -- 199
 extract 
---------
     199
(1 row)

SELECT EXTRACT(DECADE FROM DATE '0010-01-01');    --   1
 extract 
---------
       1
(1 row)

SELECT EXTRACT(DECADE FROM DATE '0009-12-31');    --   0
 extract 
---------
       0
(1 row)

SELECT EXTRACT(DECADE FROM DATE '0001-01-01 BC'); --   0
 extract 
---------
       0
(1 row)

SELECT EXTRACT(DECADE FROM DATE '0002-12-31 BC'); --  -1
 extract 
---------
      -1
(1 row)

SELECT EXTRACT(DECADE FROM DATE '0011-01-01 BC'); --  -1
 extract 
---------
      -1
(1 row)

SELECT EXTRACT(DECADE FROM DATE '0012-12-31 BC'); --  -2
 extract 
---------
      -2
(1 row)

--
-- all possible fields
--
SELECT EXTRACT(MICROSECONDS  FROM DATE '2020-08-11');
ERROR:  unit "microseconds" not supported for type date
SELECT EXTRACT(MILLISECONDS  FROM DATE '2020-08-11');
ERROR:  unit "milliseconds" not supported for type date
SELECT EXTRACT(SECOND        FROM DATE '2020-08-11');
ERROR:  unit "second" not supported for type date
SELECT EXTRACT(MINUTE        FROM DATE '2020-08-11');
ERROR:  unit "minute" not supported for type date
SELECT EXTRACT(HOUR          FROM DATE '2020-08-11');
ERROR:  unit "hour" not supported for type date
SELECT EXTRACT(DAY           FROM DATE '2020-08-11');
 extract 
---------
      11
(1 row)

SELECT EXTRACT(MONTH         FROM DATE '2020-08-11');
 extract 
---------
       8
(1 row)

SELECT EXTRACT(YEAR          FROM DATE '2020-08-11');
 extract 
---------
    2020
(1 row)

SELECT EXTRACT(YEAR          FROM DATE '2020-08-11 BC');
 extract 
---------
   -2020
(1 row)

SELECT EXTRACT(DECADE        FROM DATE '2020-08-11');
 extract 
---------
     202
(1 row)

SELECT EXTRACT(CENTURY       FROM DATE '2020-08-11');
 extract 
---------
      21
(1 row)

SELECT EXTRACT(MILLENNIUM    FROM DATE '2020-08-11');
 extract 
---------
       3
(1 row)

SELECT EXTRACT(ISOYEAR       FROM DATE '2020-08-11');
 extract 
---------
    2020
(1 row)

SELECT EXTRACT(ISOYEAR       FROM DATE '2020-08-11 BC');
 extract 
---------
   -2020
(1 row)

SELECT EXTRACT(QUARTER       FROM DATE '2020-08-11');
 extract 
---------
       3
(1 row)

SELECT EXTRACT(WEEK          FROM DATE '2020-08-11');
 extract 
---------
      33
(1 row)

SELECT EXTRACT(DOW           FROM DATE '2020-08-11');
 extract 
---------
       2
(1 row)

SELECT EXTRACT(DOW           FROM DATE '2020-08-16');
 extract 
---------
       0
(1 row)

SELECT EXTRACT(ISODOW        FROM DATE '2020-08-11');
 extract 
---------
       2
(1 row)

SELECT EXTRACT(ISODOW        FROM DATE '2020-08-16');
 extract 
---------
       7
(1 row)

SELECT EXTRACT(DOY           FROM DATE '2020-08-11');
 extract 
---------
     224
(1 row)

SELECT EXTRACT(TIMEZONE      FROM DATE '2020-08-11');
ERROR:  unit "timezone" not supported for type date
SELECT EXTRACT(TIMEZONE_M    FROM DATE '2020-08-11');
ERROR:  unit "timezone_m" not supported for type date
SELECT EXTRACT(TIMEZONE_H    FROM DATE '2020-08-11');
ERROR:  unit "timezone_h" not supported for type date
SELECT EXTRACT(EPOCH         FROM DATE '2020-08-11');
  extract   
------------
 1597104000
(1 row)

SELECT EXTRACT(JULIAN        FROM DATE '2020-08-11');
 extract 
---------
 2459073
(1 row)

--
-- test trunc function!
--
SELECT DATE_TRUNC('MILLENNIUM', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1001
        date_trunc        
--------------------------
 Thu Jan 01 00:00:00 1001
(1 row)

SELECT DATE_TRUNC('MILLENNIUM', DATE '1970-03-20'); -- 1001-01-01
          date_trunc          
------------------------------
 Thu Jan 01 00:00:00 1001 PST
(1 row)

SELECT DATE_TRUNC('CENTURY', TIMESTAMP '1970-03-20 04:30:00.00000'); -- 1901
        date_trunc        
--------------------------
 Tue Jan 01 00:00:00 1901
(1 row)

SELECT DATE_TRUNC('CENTURY', DATE '1970-03-20'); -- 1901
          date_trunc          
------------------------------
 Tue Jan 01 00:00:00 1901 PST
(1 row)

SELECT DATE_TRUNC('CENTURY', DATE '2004-08-10'); -- 2001-01-01
          date_trunc          
------------------------------
 Mon Jan 01 00:00:00 2001 PST
(1 row)

SELECT DATE_TRUNC('CENTURY', DATE '0002-02-04'); -- 0001-01-01
          date_trunc          
------------------------------
 Mon Jan 01 00:00:00 0001 PST
(1 row)

SELECT DATE_TRUNC('CENTURY', DATE '0055-08-10 BC'); -- 0100-01-01 BC
           date_trunc            
---------------------------------
 Tue Jan 01 00:00:00 0100 PST BC
(1 row)

SELECT DATE_TRUNC('DECADE', DATE '1993-12-25'); -- 1990-01-01
          date_trunc          
------------------------------
 Mon Jan 01 00:00:00 1990 PST
(1 row)

SELECT DATE_TRUNC('DECADE', DATE '0004-12-25'); -- 0001-01-01 BC
           date_trunc            
---------------------------------
 Sat Jan 01 00:00:00 0001 PST BC
(1 row)

SELECT DATE_TRUNC('DECADE', DATE '0002-12-31 BC'); -- 0011-01-01 BC
           date_trunc            
---------------------------------
 Mon Jan 01 00:00:00 0011 PST BC
(1 row)

--
-- test infinity
--
select 'infinity'::date, '-infinity'::date;
   date   |   date    
----------+-----------
 infinity | -infinity
(1 row)

select 'infinity'::date > 'today'::date as t;
 t 
---
 t
(1 row)

select '-infinity'::date < 'today'::date as t;
 t 
---
 t
(1 row)

select isfinite('infinity'::date), isfinite('-infinity'::date), isfinite('today'::date);
 isfinite | isfinite | isfinite 
----------+----------+----------
 f        | f        | t
(1 row)

select 'infinity'::date = '+infinity'::date as t;
 t 
---
 t
(1 row)

--
-- oscillating fields from non-finite date:
--
SELECT EXTRACT(DAY FROM DATE 'infinity');      -- NULL
 extract 
---------
        
(1 row)

SELECT EXTRACT(DAY FROM DATE '-infinity');     -- NULL
 extract 
---------
        
(1 row)

-- all supported fields
SELECT EXTRACT(DAY           FROM DATE 'infinity');    -- NULL
 extract 
---------
        
(1 row)

SELECT EXTRACT(MONTH         FROM DATE 'infinity');    -- NULL
 extract 
---------
        
(1 row)

SELECT EXTRACT(QUARTER       FROM DATE 'infinity');    -- NULL
 extract 
---------
        
(1 row)

SELECT EXTRACT(WEEK          FROM DATE 'infinity');    -- NULL
 extract 
---------
        
(1 row)

SELECT EXTRACT(DOW           FROM DATE 'infinity');    -- NULL
 extract 
---------
        
(1 row)

SELECT EXTRACT(ISODOW        FROM DATE 'infinity');    -- NULL
 extract 
---------
        
(1 row)

SELECT EXTRACT(DOY           FROM DATE 'infinity');    -- NULL
 extract 
---------
        
(1 row)

--
-- monotonic fields from non-finite date:
--
SELECT EXTRACT(EPOCH FROM DATE 'infinity');         --  Infinity
 extract  
----------
 Infinity
(1 row)

SELECT EXTRACT(EPOCH FROM DATE '-infinity');        -- -Infinity
  extract  
-----------
 -Infinity
(1 row)

-- all supported fields
SELECT EXTRACT(YEAR       FROM DATE 'infinity');    --  Infinity
 extract  
----------
 Infinity
(1 row)

SELECT EXTRACT(DECADE     FROM DATE 'infinity');    --  Infinity
 extract  
----------
 Infinity
(1 row)

SELECT EXTRACT(CENTURY    FROM DATE 'infinity');    --  Infinity
 extract  
----------
 Infinity
(1 row)

SELECT EXTRACT(MILLENNIUM FROM DATE 'infinity');    --  Infinity
 extract  
----------
 Infinity
(1 row)

SELECT EXTRACT(JULIAN     FROM DATE 'infinity');    --  Infinity
 extract  
----------
 Infinity
(1 row)

SELECT EXTRACT(ISOYEAR    FROM DATE 'infinity');    --  Infinity
 extract  
----------
 Infinity
(1 row)

SELECT EXTRACT(EPOCH      FROM DATE 'infinity');    --  Infinity
 extract  
----------
 Infinity
(1 row)

--
-- wrong fields from non-finite date:
--
SELECT EXTRACT(MICROSEC  FROM DATE 'infinity');     -- error
ERROR:  unit "microsec" not recognized for type date
-- test constructors
select make_date(2013, 7, 15);
 make_date  
------------
 07-15-2013
(1 row)

select make_date(-44, 3, 15);
   make_date   
---------------
 03-15-0044 BC
(1 row)

select make_time(8, 20, 0.0);
 make_time 
-----------
 08:20:00
(1 row)

-- should fail
select make_date(0, 7, 15);
ERROR:  date field value out of range: 0-07-15
select make_date(2013, 2, 30);
ERROR:  date field value out of range: 2013-02-30
select make_date(2013, 13, 1);
ERROR:  date field value out of range: 2013-13-01
select make_date(2013, 11, -1);
ERROR:  date field value out of range: 2013-11--1
select make_time(10, 55, 100.1);
ERROR:  time field value out of range: 10:55:100.1
select make_time(24, 0, 2.1);
ERROR:  time field value out of range: 24:00:2.1
-- END setup from  date 
-- START setup from time 
--
-- TIME
--
CREATE TABLE TIME_TBL (f1 time(2));
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE TIME_TBL (f1 time(2));
                     ^
INSERT INTO TIME_TBL VALUES ('00:00');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('00:00');
                    ^
INSERT INTO TIME_TBL VALUES ('01:00');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('01:00');
                    ^
-- as of 7.4, timezone spec should be accepted and ignored
INSERT INTO TIME_TBL VALUES ('02:03 PST');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('02:03 PST');
                    ^
INSERT INTO TIME_TBL VALUES ('11:59 EDT');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('11:59 EDT');
                    ^
INSERT INTO TIME_TBL VALUES ('12:00');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('12:00');
                    ^
INSERT INTO TIME_TBL VALUES ('12:01');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('12:01');
                    ^
INSERT INTO TIME_TBL VALUES ('23:59');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('23:59');
                    ^
INSERT INTO TIME_TBL VALUES ('11:59:59.99 PM');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('11:59:59.99 PM');
                    ^
INSERT INTO TIME_TBL VALUES ('2003-03-07 15:36:39 America/New_York');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('2003-03-07 15:36:39 America/Ne...
                    ^
INSERT INTO TIME_TBL VALUES ('2003-07-07 15:36:39 America/New_York');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('2003-07-07 15:36:39 America/Ne...
                    ^
-- this should fail (the timezone offset is not known)
INSERT INTO TIME_TBL VALUES ('15:36:39 America/New_York');
ERROR:  relation "time_tbl" does not exist
LINE 1: INSERT INTO TIME_TBL VALUES ('15:36:39 America/New_York');
                    ^
SELECT f1 AS "Time" FROM TIME_TBL;
ERROR:  relation "time_tbl" does not exist
LINE 1: SELECT f1 AS "Time" FROM TIME_TBL;
                                 ^
SELECT f1 AS "Three" FROM TIME_TBL WHERE f1 < '05:06:07';
ERROR:  relation "time_tbl" does not exist
LINE 1: SELECT f1 AS "Three" FROM TIME_TBL WHERE f1 < '05:06:07';
                                  ^
SELECT f1 AS "Five" FROM TIME_TBL WHERE f1 > '05:06:07';
ERROR:  relation "time_tbl" does not exist
LINE 1: SELECT f1 AS "Five" FROM TIME_TBL WHERE f1 > '05:06:07';
                                 ^
SELECT f1 AS "None" FROM TIME_TBL WHERE f1 < '00:00';
ERROR:  relation "time_tbl" does not exist
LINE 1: SELECT f1 AS "None" FROM TIME_TBL WHERE f1 < '00:00';
                                 ^
SELECT f1 AS "Eight" FROM TIME_TBL WHERE f1 >= '00:00';
ERROR:  relation "time_tbl" does not exist
LINE 1: SELECT f1 AS "Eight" FROM TIME_TBL WHERE f1 >= '00:00';
                                  ^
-- Check edge cases
SELECT '23:59:59.999999'::time;
      time       
-----------------
 23:59:59.999999
(1 row)

SELECT '23:59:59.9999999'::time;  -- rounds up
   time   
----------
 24:00:00
(1 row)

SELECT '23:59:60'::time;  -- rounds up
   time   
----------
 24:00:00
(1 row)

SELECT '24:00:00'::time;  -- allowed
   time   
----------
 24:00:00
(1 row)

SELECT '24:00:00.01'::time;  -- not allowed
ERROR:  date/time field value out of range: "24:00:00.01"
LINE 1: SELECT '24:00:00.01'::time;
               ^
SELECT '23:59:60.01'::time;  -- not allowed
ERROR:  date/time field value out of range: "23:59:60.01"
LINE 1: SELECT '23:59:60.01'::time;
               ^
SELECT '24:01:00'::time;  -- not allowed
ERROR:  date/time field value out of range: "24:01:00"
LINE 1: SELECT '24:01:00'::time;
               ^
SELECT '25:00:00'::time;  -- not allowed
ERROR:  date/time field value out of range: "25:00:00"
LINE 1: SELECT '25:00:00'::time;
               ^
-- Test non-error-throwing API
SELECT pg_input_is_valid('12:00:00', 'time');
 pg_input_is_valid 
-------------------
 t
(1 row)

SELECT pg_input_is_valid('25:00:00', 'time');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT pg_input_is_valid('15:36:39 America/New_York', 'time');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT * FROM pg_input_error_info('25:00:00', 'time');
                    message                     | detail | hint | sql_error_code 
------------------------------------------------+--------+------+----------------
 date/time field value out of range: "25:00:00" |        |      | 22008
(1 row)

SELECT * FROM pg_input_error_info('15:36:39 America/New_York', 'time');
                             message                             | detail | hint | sql_error_code 
-----------------------------------------------------------------+--------+------+----------------
 invalid input syntax for type time: "15:36:39 America/New_York" |        |      | 22007
(1 row)

--
-- TIME simple math
--
-- We now make a distinction between time and intervals,
-- and adding two times together makes no sense at all.
-- Leave in one query to show that it is rejected,
-- and do the rest of the testing in horology.sql
-- where we do mixed-type arithmetic. - thomas 2000-12-02
SELECT f1 + time '00:01' AS "Illegal" FROM TIME_TBL;
ERROR:  relation "time_tbl" does not exist
LINE 1: SELECT f1 + time '00:01' AS "Illegal" FROM TIME_TBL;
                                                   ^
--
-- test EXTRACT
--
SELECT EXTRACT(MICROSECOND FROM TIME '2020-05-26 13:30:25.575401');
 extract  
----------
 25575401
(1 row)

SELECT EXTRACT(MILLISECOND FROM TIME '2020-05-26 13:30:25.575401');
  extract  
-----------
 25575.401
(1 row)

SELECT EXTRACT(SECOND      FROM TIME '2020-05-26 13:30:25.575401');
  extract  
-----------
 25.575401
(1 row)

SELECT EXTRACT(MINUTE      FROM TIME '2020-05-26 13:30:25.575401');
 extract 
---------
      30
(1 row)

SELECT EXTRACT(HOUR        FROM TIME '2020-05-26 13:30:25.575401');
 extract 
---------
      13
(1 row)

SELECT EXTRACT(DAY         FROM TIME '2020-05-26 13:30:25.575401');  -- error
ERROR:  unit "day" not supported for type time without time zone
SELECT EXTRACT(FORTNIGHT   FROM TIME '2020-05-26 13:30:25.575401');  -- error
ERROR:  unit "fortnight" not recognized for type time without time zone
SELECT EXTRACT(TIMEZONE    FROM TIME '2020-05-26 13:30:25.575401');  -- error
ERROR:  unit "timezone" not supported for type time without time zone
SELECT EXTRACT(EPOCH       FROM TIME '2020-05-26 13:30:25.575401');
   extract    
--------------
 48625.575401
(1 row)

-- date_part implementation is mostly the same as extract, so only
-- test a few cases for additional coverage.
SELECT date_part('microsecond', TIME '2020-05-26 13:30:25.575401');
 date_part 
-----------
  25575401
(1 row)

SELECT date_part('millisecond', TIME '2020-05-26 13:30:25.575401');
 date_part 
-----------
 25575.401
(1 row)

SELECT date_part('second',      TIME '2020-05-26 13:30:25.575401');
 date_part 
-----------
 25.575401
(1 row)

SELECT date_part('epoch',       TIME '2020-05-26 13:30:25.575401');
  date_part   
--------------
 48625.575401
(1 row)

-- END setup from time 
-- START setup from timetz 
--
-- TIMETZ
--
CREATE TABLE TIMETZ_TBL (f1 time(2) with time zone);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE TIMETZ_TBL (f1 time(2) with time zone);
                     ^
INSERT INTO TIMETZ_TBL VALUES ('00:01 PDT');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('00:01 PDT');
                    ^
INSERT INTO TIMETZ_TBL VALUES ('01:00 PDT');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('01:00 PDT');
                    ^
INSERT INTO TIMETZ_TBL VALUES ('02:03 PDT');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('02:03 PDT');
                    ^
INSERT INTO TIMETZ_TBL VALUES ('07:07 PST');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('07:07 PST');
                    ^
INSERT INTO TIMETZ_TBL VALUES ('08:08 EDT');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('08:08 EDT');
                    ^
INSERT INTO TIMETZ_TBL VALUES ('11:59 PDT');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('11:59 PDT');
                    ^
INSERT INTO TIMETZ_TBL VALUES ('12:00 PDT');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('12:00 PDT');
                    ^
INSERT INTO TIMETZ_TBL VALUES ('12:01 PDT');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('12:01 PDT');
                    ^
INSERT INTO TIMETZ_TBL VALUES ('23:59 PDT');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('23:59 PDT');
                    ^
INSERT INTO TIMETZ_TBL VALUES ('11:59:59.99 PM PDT');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('11:59:59.99 PM PDT');
                    ^
INSERT INTO TIMETZ_TBL VALUES ('2003-03-07 15:36:39 America/New_York');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('2003-03-07 15:36:39 America/...
                    ^
INSERT INTO TIMETZ_TBL VALUES ('2003-07-07 15:36:39 America/New_York');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('2003-07-07 15:36:39 America/...
                    ^
-- this should fail (the timezone offset is not known)
INSERT INTO TIMETZ_TBL VALUES ('15:36:39 America/New_York');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('15:36:39 America/New_York');
                    ^
-- this should fail (timezone not specified without a date)
INSERT INTO TIMETZ_TBL VALUES ('15:36:39 m2');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('15:36:39 m2');
                    ^
-- this should fail (dynamic timezone abbreviation without a date)
INSERT INTO TIMETZ_TBL VALUES ('15:36:39 MSK m2');
ERROR:  relation "timetz_tbl" does not exist
LINE 1: INSERT INTO TIMETZ_TBL VALUES ('15:36:39 MSK m2');
                    ^
SELECT f1 AS "Time TZ" FROM TIMETZ_TBL;
ERROR:  relation "timetz_tbl" does not exist
LINE 1: SELECT f1 AS "Time TZ" FROM TIMETZ_TBL;
                                    ^
SELECT f1 AS "Three" FROM TIMETZ_TBL WHERE f1 < '05:06:07-07';
ERROR:  relation "timetz_tbl" does not exist
LINE 1: SELECT f1 AS "Three" FROM TIMETZ_TBL WHERE f1 < '05:06:07-07...
                                  ^
SELECT f1 AS "Seven" FROM TIMETZ_TBL WHERE f1 > '05:06:07-07';
ERROR:  relation "timetz_tbl" does not exist
LINE 1: SELECT f1 AS "Seven" FROM TIMETZ_TBL WHERE f1 > '05:06:07-07...
                                  ^
SELECT f1 AS "None" FROM TIMETZ_TBL WHERE f1 < '00:00-07';
ERROR:  relation "timetz_tbl" does not exist
LINE 1: SELECT f1 AS "None" FROM TIMETZ_TBL WHERE f1 < '00:00-07';
                                 ^
SELECT f1 AS "Ten" FROM TIMETZ_TBL WHERE f1 >= '00:00-07';
ERROR:  relation "timetz_tbl" does not exist
LINE 1: SELECT f1 AS "Ten" FROM TIMETZ_TBL WHERE f1 >= '00:00-07';
                                ^
-- Check edge cases
SELECT '23:59:59.999999 PDT'::timetz;
       timetz       
--------------------
 23:59:59.999999-07
(1 row)

SELECT '23:59:59.9999999 PDT'::timetz;  -- rounds up
   timetz    
-------------
 24:00:00-07
(1 row)

SELECT '23:59:60 PDT'::timetz;  -- rounds up
   timetz    
-------------
 24:00:00-07
(1 row)

SELECT '24:00:00 PDT'::timetz;  -- allowed
   timetz    
-------------
 24:00:00-07
(1 row)

SELECT '24:00:00.01 PDT'::timetz;  -- not allowed
ERROR:  date/time field value out of range: "24:00:00.01 PDT"
LINE 1: SELECT '24:00:00.01 PDT'::timetz;
               ^
SELECT '23:59:60.01 PDT'::timetz;  -- not allowed
ERROR:  date/time field value out of range: "23:59:60.01 PDT"
LINE 1: SELECT '23:59:60.01 PDT'::timetz;
               ^
SELECT '24:01:00 PDT'::timetz;  -- not allowed
ERROR:  date/time field value out of range: "24:01:00 PDT"
LINE 1: SELECT '24:01:00 PDT'::timetz;
               ^
SELECT '25:00:00 PDT'::timetz;  -- not allowed
ERROR:  date/time field value out of range: "25:00:00 PDT"
LINE 1: SELECT '25:00:00 PDT'::timetz;
               ^
-- Test non-error-throwing API
SELECT pg_input_is_valid('12:00:00 PDT', 'timetz');
 pg_input_is_valid 
-------------------
 t
(1 row)

SELECT pg_input_is_valid('25:00:00 PDT', 'timetz');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT pg_input_is_valid('15:36:39 America/New_York', 'timetz');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT * FROM pg_input_error_info('25:00:00 PDT', 'timetz');
                      message                       | detail | hint | sql_error_code 
----------------------------------------------------+--------+------+----------------
 date/time field value out of range: "25:00:00 PDT" |        |      | 22008
(1 row)

SELECT * FROM pg_input_error_info('15:36:39 America/New_York', 'timetz');
                                    message                                     | detail | hint | sql_error_code 
--------------------------------------------------------------------------------+--------+------+----------------
 invalid input syntax for type time with time zone: "15:36:39 America/New_York" |        |      | 22007
(1 row)

--
-- TIME simple math
--
-- We now make a distinction between time and intervals,
-- and adding two times together makes no sense at all.
-- Leave in one query to show that it is rejected,
-- and do the rest of the testing in horology.sql
-- where we do mixed-type arithmetic. - thomas 2000-12-02
SELECT f1 + time with time zone '00:01' AS "Illegal" FROM TIMETZ_TBL;
ERROR:  relation "timetz_tbl" does not exist
LINE 1: ...1 + time with time zone '00:01' AS "Illegal" FROM TIMETZ_TBL...
                                                             ^
--
-- test EXTRACT
--
SELECT EXTRACT(MICROSECOND FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
 extract  
----------
 25575401
(1 row)

SELECT EXTRACT(MILLISECOND FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
  extract  
-----------
 25575.401
(1 row)

SELECT EXTRACT(SECOND      FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
  extract  
-----------
 25.575401
(1 row)

SELECT EXTRACT(MINUTE      FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
 extract 
---------
      30
(1 row)

SELECT EXTRACT(HOUR        FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
 extract 
---------
      13
(1 row)

SELECT EXTRACT(DAY         FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');  -- error
ERROR:  unit "day" not supported for type time with time zone
SELECT EXTRACT(FORTNIGHT   FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');  -- error
ERROR:  unit "fortnight" not recognized for type time with time zone
SELECT EXTRACT(TIMEZONE    FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04:30');
 extract 
---------
  -16200
(1 row)

SELECT EXTRACT(TIMEZONE_HOUR   FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04:30');
 extract 
---------
      -4
(1 row)

SELECT EXTRACT(TIMEZONE_MINUTE FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04:30');
 extract 
---------
     -30
(1 row)

SELECT EXTRACT(EPOCH       FROM TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
   extract    
--------------
 63025.575401
(1 row)

-- date_part implementation is mostly the same as extract, so only
-- test a few cases for additional coverage.
SELECT date_part('microsecond', TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
 date_part 
-----------
  25575401
(1 row)

SELECT date_part('millisecond', TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
 date_part 
-----------
 25575.401
(1 row)

SELECT date_part('second',      TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
 date_part 
-----------
 25.575401
(1 row)

SELECT date_part('epoch',       TIME WITH TIME ZONE '2020-05-26 13:30:25.575401-04');
  date_part   
--------------
 63025.575401
(1 row)

--
-- Test timetz_zone, timetz_izone, AT LOCAL
--
BEGIN;
SET LOCAL TimeZone TO 'UTC';
CREATE VIEW timetz_local_view AS
  SELECT f1 AS dat,
       timezone(f1) AS dat_func,
       f1 AT LOCAL AS dat_at_local,
       f1 AT TIME ZONE current_setting('TimeZone') AS dat_at_tz,
       f1 AT TIME ZONE INTERVAL '00:00' AS dat_at_int
  FROM TIMETZ_TBL
  ORDER BY f1;
ERROR:  relation "timetz_tbl" does not exist
LINE 7:   FROM TIMETZ_TBL
               ^
SELECT pg_get_viewdef('timetz_local_view', true);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
TABLE timetz_local_view;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT f1 AS dat,
       f1 AT TIME ZONE 'UTC+10' AS dat_at_tz,
       f1 AT TIME ZONE INTERVAL '-10:00' AS dat_at_int
  FROM TIMETZ_TBL
  ORDER BY f1;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
ROLLBACK;
-- END setup from timetz 
-- START setup from timestamp 
--
-- TIMESTAMP
--
CREATE TABLE TIMESTAMP_TBL (d1 timestamp(2) without time zone);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE TIMESTAMP_TBL (d1 timestamp(2) without time zon...
                     ^
-- Test shorthand input values
-- We can't just "select" the results since they aren't constants; test for
-- equality instead.  We can do that by running the test inside a transaction
-- block, within which the value of 'now' shouldn't change, and so these
-- related values shouldn't either.
BEGIN;
INSERT INTO TIMESTAMP_TBL VALUES ('today');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('today');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('yesterday');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO TIMESTAMP_TBL VALUES ('tomorrow');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
-- time zone should be ignored by this data type
INSERT INTO TIMESTAMP_TBL VALUES ('tomorrow EST');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO TIMESTAMP_TBL VALUES ('tomorrow zulu');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(*) AS One FROM TIMESTAMP_TBL WHERE d1 = timestamp without time zone 'today';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(*) AS Three FROM TIMESTAMP_TBL WHERE d1 = timestamp without time zone 'tomorrow';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(*) AS One FROM TIMESTAMP_TBL WHERE d1 = timestamp without time zone 'yesterday';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT;
DELETE FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: DELETE FROM TIMESTAMP_TBL;
                    ^
-- Verify that 'now' *does* change over a reasonable interval such as 100 msec,
-- and that it doesn't change over the same interval within a transaction block
INSERT INTO TIMESTAMP_TBL VALUES ('now');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('now');
                    ^
SELECT pg_sleep(0.1);
 pg_sleep 
----------
 
(1 row)

BEGIN;
INSERT INTO TIMESTAMP_TBL VALUES ('now');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('now');
                    ^
SELECT pg_sleep(0.1);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO TIMESTAMP_TBL VALUES ('now');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT pg_sleep(0.1);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(*) AS two FROM TIMESTAMP_TBL WHERE d1 = timestamp(2) without time zone 'now';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(d1) AS three, count(DISTINCT d1) AS two FROM TIMESTAMP_TBL;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT;
TRUNCATE TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
-- Special values
INSERT INTO TIMESTAMP_TBL VALUES ('-infinity');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('-infinity');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('infinity');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('infinity');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('epoch');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('epoch');
                    ^
SELECT timestamp 'infinity' = timestamp '+infinity' AS t;
 t 
---
 t
(1 row)

-- Postgres v6.0 standard output format
INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01 1997 PST');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01 1997 ...
                    ^
-- Variations on Postgres v6.1 standard output format
INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01.000001 1997 PST');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01.00000...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01.999999 1997 PST');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01.99999...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01.4 1997 PST');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01.4 199...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01.5 1997 PST');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01.5 199...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01.6 1997 PST');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Mon Feb 10 17:32:01.6 199...
                    ^
-- ISO 8601 format
INSERT INTO TIMESTAMP_TBL VALUES ('1997-01-02');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('1997-01-02');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('1997-01-02 03:04:05');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('1997-01-02 03:04:05');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('1997-02-10 17:32:01-08');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('1997-02-10 17:32:01-08');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('1997-02-10 17:32:01-0800');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('1997-02-10 17:32:01-0800'...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('1997-02-10 17:32:01 -08:00');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('1997-02-10 17:32:01 -08:0...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('19970210 173201 -0800');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('19970210 173201 -0800');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('1997-06-10 17:32:01 -07:00');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('1997-06-10 17:32:01 -07:0...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('2001-09-22T18:19:20');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('2001-09-22T18:19:20');
                    ^
-- POSIX format (note that the timezone abbrev is just decoration here)
INSERT INTO TIMESTAMP_TBL VALUES ('2000-03-15 08:14:01 GMT+8');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('2000-03-15 08:14:01 GMT+8...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('2000-03-15 13:14:02 GMT-1');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('2000-03-15 13:14:02 GMT-1...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('2000-03-15 12:14:03 GMT-2');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('2000-03-15 12:14:03 GMT-2...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('2000-03-15 03:14:04 PST+8');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('2000-03-15 03:14:04 PST+8...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('2000-03-15 02:14:05 MST+7:00');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('2000-03-15 02:14:05 MST+7...
                    ^
-- Variations for acceptable input formats
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 10 17:32:01 1997 -0800');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 10 17:32:01 1997 -080...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 10 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 10 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 10 5:32PM 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 10 5:32PM 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('1997/02/10 17:32:01-0800');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('1997/02/10 17:32:01-0800'...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('1997-02-10 17:32:01 PST');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('1997-02-10 17:32:01 PST')...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb-10-1997 17:32:01 PST');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb-10-1997 17:32:01 PST'...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('02-10-1997 17:32:01 PST');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('02-10-1997 17:32:01 PST')...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('19970210 173201 PST');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('19970210 173201 PST');
                    ^
set datestyle to ymd;
INSERT INTO TIMESTAMP_TBL VALUES ('97FEB10 5:32:01PM UTC');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('97FEB10 5:32:01PM UTC');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('97/02/10 17:32:01 UTC');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('97/02/10 17:32:01 UTC');
                    ^
reset datestyle;
INSERT INTO TIMESTAMP_TBL VALUES ('1997.041 17:32:01 UTC');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('1997.041 17:32:01 UTC');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('19970210 173201 America/New_York');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('19970210 173201 America/N...
                    ^
-- this fails (even though TZ is a no-op, we still look it up)
INSERT INTO TIMESTAMP_TBL VALUES ('19970710 173201 America/Does_not_exist');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('19970710 173201 America/D...
                    ^
-- Test non-error-throwing API
SELECT pg_input_is_valid('now', 'timestamp');
 pg_input_is_valid 
-------------------
 t
(1 row)

SELECT pg_input_is_valid('garbage', 'timestamp');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT pg_input_is_valid('2001-01-01 00:00 Nehwon/Lankhmar', 'timestamp');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT * FROM pg_input_error_info('garbage', 'timestamp');
                      message                       | detail | hint | sql_error_code 
----------------------------------------------------+--------+------+----------------
 invalid input syntax for type timestamp: "garbage" |        |      | 22007
(1 row)

SELECT * FROM pg_input_error_info('2001-01-01 00:00 Nehwon/Lankhmar', 'timestamp');
                  message                   | detail | hint | sql_error_code 
--------------------------------------------+--------+------+----------------
 time zone "nehwon/lankhmar" not recognized |        |      | 22023
(1 row)

-- Check date conversion and date arithmetic
INSERT INTO TIMESTAMP_TBL VALUES ('1997-06-10 18:32:01 PDT');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('1997-06-10 18:32:01 PDT')...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 10 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 10 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 11 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 11 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 12 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 12 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 13 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 13 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 14 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 14 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 15 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 15 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 0097 BC');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 0097 BC')...
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 0097');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 0097');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 0597');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 0597');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1097');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1097');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1697');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1697');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1797');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1797');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1897');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1897');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 2097');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 2097');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 28 17:32:01 1996');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 28 17:32:01 1996');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 29 17:32:01 1996');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 29 17:32:01 1996');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Mar 01 17:32:01 1996');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Mar 01 17:32:01 1996');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Dec 30 17:32:01 1996');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Dec 30 17:32:01 1996');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Dec 31 17:32:01 1996');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Dec 31 17:32:01 1996');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Jan 01 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Jan 01 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 28 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 28 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 29 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 29 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Mar 01 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Mar 01 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Dec 30 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Dec 30 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Dec 31 17:32:01 1997');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Dec 31 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Dec 31 17:32:01 1999');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Dec 31 17:32:01 1999');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Jan 01 17:32:01 2000');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Jan 01 17:32:01 2000');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Dec 31 17:32:01 2000');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Dec 31 17:32:01 2000');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Jan 01 17:32:01 2001');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Jan 01 17:32:01 2001');
                    ^
-- Currently unsupported syntax and ranges
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 -0097');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 -0097');
                    ^
INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 5097 BC');
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMP_TBL VALUES ('Feb 16 17:32:01 5097 BC')...
                    ^
SELECT d1 FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMP_TBL;
                       ^
-- Check behavior at the boundaries of the timestamp range
SELECT '4714-11-24 00:00:00 BC'::timestamp;
          timestamp          
-----------------------------
 Mon Nov 24 00:00:00 4714 BC
(1 row)

SELECT '4714-11-23 23:59:59 BC'::timestamp;  -- out of range
ERROR:  timestamp out of range: "4714-11-23 23:59:59 BC"
LINE 1: SELECT '4714-11-23 23:59:59 BC'::timestamp;
               ^
SELECT '294276-12-31 23:59:59'::timestamp;
         timestamp          
----------------------------
 Sun Dec 31 23:59:59 294276
(1 row)

SELECT '294277-01-01 00:00:00'::timestamp;  -- out of range
ERROR:  timestamp out of range: "294277-01-01 00:00:00"
LINE 1: SELECT '294277-01-01 00:00:00'::timestamp;
               ^
-- Demonstrate functions and operators
SELECT d1 FROM TIMESTAMP_TBL
   WHERE d1 > timestamp without time zone '1997-01-02';
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMP_TBL
                       ^
SELECT d1 FROM TIMESTAMP_TBL
   WHERE d1 < timestamp without time zone '1997-01-02';
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMP_TBL
                       ^
SELECT d1 FROM TIMESTAMP_TBL
   WHERE d1 = timestamp without time zone '1997-01-02';
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMP_TBL
                       ^
SELECT d1 FROM TIMESTAMP_TBL
   WHERE d1 != timestamp without time zone '1997-01-02';
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMP_TBL
                       ^
SELECT d1 FROM TIMESTAMP_TBL
   WHERE d1 <= timestamp without time zone '1997-01-02';
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMP_TBL
                       ^
SELECT d1 FROM TIMESTAMP_TBL
   WHERE d1 >= timestamp without time zone '1997-01-02';
ERROR:  relation "timestamp_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMP_TBL
                       ^
SELECT d1 - timestamp without time zone '1997-01-02' AS diff
   FROM TIMESTAMP_TBL WHERE d1 BETWEEN '1902-01-01' AND '2038-01-01';
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL WHERE d1 BETWEEN '1902-01-01' AND '203...
                ^
SELECT date_trunc( 'week', timestamp '2004-02-29 15:44:17.71393' ) AS week_trunc;
        week_trunc        
--------------------------
 Mon Feb 23 00:00:00 2004
(1 row)

-- verify date_bin behaves the same as date_trunc for relevant intervals
-- case 1: AD dates, origin < input
SELECT
  str,
  interval,
  date_trunc(str, ts) = date_bin(interval::interval, ts, timestamp '2001-01-01') AS equal
FROM (
  VALUES
  ('week', '7 d'),
  ('day', '1 d'),
  ('hour', '1 h'),
  ('minute', '1 m'),
  ('second', '1 s'),
  ('millisecond', '1 ms'),
  ('microsecond', '1 us')
) intervals (str, interval),
(VALUES (timestamp '2020-02-29 15:44:17.71393')) ts (ts);
     str     | interval | equal 
-------------+----------+-------
 week        | 7 d      | t
 day         | 1 d      | t
 hour        | 1 h      | t
 minute      | 1 m      | t
 second      | 1 s      | t
 millisecond | 1 ms     | t
 microsecond | 1 us     | t
(7 rows)

-- case 2: BC dates, origin < input
SELECT
  str,
  interval,
  date_trunc(str, ts) = date_bin(interval::interval, ts, timestamp '2000-01-01 BC') AS equal
FROM (
  VALUES
  ('week', '7 d'),
  ('day', '1 d'),
  ('hour', '1 h'),
  ('minute', '1 m'),
  ('second', '1 s'),
  ('millisecond', '1 ms'),
  ('microsecond', '1 us')
) intervals (str, interval),
(VALUES (timestamp '0055-6-10 15:44:17.71393 BC')) ts (ts);
     str     | interval | equal 
-------------+----------+-------
 week        | 7 d      | t
 day         | 1 d      | t
 hour        | 1 h      | t
 minute      | 1 m      | t
 second      | 1 s      | t
 millisecond | 1 ms     | t
 microsecond | 1 us     | t
(7 rows)

-- case 3: AD dates, origin > input
SELECT
  str,
  interval,
  date_trunc(str, ts) = date_bin(interval::interval, ts, timestamp '2020-03-02') AS equal
FROM (
  VALUES
  ('week', '7 d'),
  ('day', '1 d'),
  ('hour', '1 h'),
  ('minute', '1 m'),
  ('second', '1 s'),
  ('millisecond', '1 ms'),
  ('microsecond', '1 us')
) intervals (str, interval),
(VALUES (timestamp '2020-02-29 15:44:17.71393')) ts (ts);
     str     | interval | equal 
-------------+----------+-------
 week        | 7 d      | t
 day         | 1 d      | t
 hour        | 1 h      | t
 minute      | 1 m      | t
 second      | 1 s      | t
 millisecond | 1 ms     | t
 microsecond | 1 us     | t
(7 rows)

-- case 4: BC dates, origin > input
SELECT
  str,
  interval,
  date_trunc(str, ts) = date_bin(interval::interval, ts, timestamp '0055-06-17 BC') AS equal
FROM (
  VALUES
  ('week', '7 d'),
  ('day', '1 d'),
  ('hour', '1 h'),
  ('minute', '1 m'),
  ('second', '1 s'),
  ('millisecond', '1 ms'),
  ('microsecond', '1 us')
) intervals (str, interval),
(VALUES (timestamp '0055-6-10 15:44:17.71393 BC')) ts (ts);
     str     | interval | equal 
-------------+----------+-------
 week        | 7 d      | t
 day         | 1 d      | t
 hour        | 1 h      | t
 minute      | 1 m      | t
 second      | 1 s      | t
 millisecond | 1 ms     | t
 microsecond | 1 us     | t
(7 rows)

-- bin timestamps into arbitrary intervals
SELECT
  interval,
  ts,
  origin,
  date_bin(interval::interval, ts, origin)
FROM (
  VALUES
  ('15 days'),
  ('2 hours'),
  ('1 hour 30 minutes'),
  ('15 minutes'),
  ('10 seconds'),
  ('100 milliseconds'),
  ('250 microseconds')
) intervals (interval),
(VALUES (timestamp '2020-02-11 15:44:17.71393')) ts (ts),
(VALUES (timestamp '2001-01-01')) origin (origin);
     interval      |               ts               |          origin          |            date_bin            
-------------------+--------------------------------+--------------------------+--------------------------------
 15 days           | Tue Feb 11 15:44:17.71393 2020 | Mon Jan 01 00:00:00 2001 | Thu Feb 06 00:00:00 2020
 2 hours           | Tue Feb 11 15:44:17.71393 2020 | Mon Jan 01 00:00:00 2001 | Tue Feb 11 14:00:00 2020
 1 hour 30 minutes | Tue Feb 11 15:44:17.71393 2020 | Mon Jan 01 00:00:00 2001 | Tue Feb 11 15:00:00 2020
 15 minutes        | Tue Feb 11 15:44:17.71393 2020 | Mon Jan 01 00:00:00 2001 | Tue Feb 11 15:30:00 2020
 10 seconds        | Tue Feb 11 15:44:17.71393 2020 | Mon Jan 01 00:00:00 2001 | Tue Feb 11 15:44:10 2020
 100 milliseconds  | Tue Feb 11 15:44:17.71393 2020 | Mon Jan 01 00:00:00 2001 | Tue Feb 11 15:44:17.7 2020
 250 microseconds  | Tue Feb 11 15:44:17.71393 2020 | Mon Jan 01 00:00:00 2001 | Tue Feb 11 15:44:17.71375 2020
(7 rows)

-- shift bins using the origin parameter:
SELECT date_bin('5 min'::interval, timestamp '2020-02-01 01:01:01', timestamp '2020-02-01 00:02:30');
         date_bin         
--------------------------
 Sat Feb 01 00:57:30 2020
(1 row)

-- test roundoff edge case when source < origin
SELECT date_bin('30 minutes'::interval, timestamp '2024-02-01 15:00:00', timestamp '2024-02-01 17:00:00');
         date_bin         
--------------------------
 Thu Feb 01 15:00:00 2024
(1 row)

-- disallow intervals with months or years
SELECT date_bin('5 months'::interval, timestamp '2020-02-01 01:01:01', timestamp '2001-01-01');
ERROR:  timestamps cannot be binned into intervals containing months or years
SELECT date_bin('5 years'::interval,  timestamp '2020-02-01 01:01:01', timestamp '2001-01-01');
ERROR:  timestamps cannot be binned into intervals containing months or years
-- disallow zero intervals
SELECT date_bin('0 days'::interval, timestamp '1970-01-01 01:00:00' , timestamp '1970-01-01 00:00:00');
ERROR:  stride must be greater than zero
-- disallow negative intervals
SELECT date_bin('-2 days'::interval, timestamp '1970-01-01 01:00:00' , timestamp '1970-01-01 00:00:00');
ERROR:  stride must be greater than zero
-- test overflow cases
select date_bin('15 minutes'::interval, timestamp '294276-12-30', timestamp '4000-12-20 BC');
ERROR:  interval out of range
select date_bin('200000000 days'::interval, '2024-02-01'::timestamp, '2024-01-01'::timestamp);
ERROR:  interval out of range
select date_bin('365000 days'::interval, '4400-01-01 BC'::timestamp, '4000-01-01 BC'::timestamp);
ERROR:  timestamp out of range
-- Test casting within a BETWEEN qualifier
SELECT d1 - timestamp without time zone '1997-01-02' AS diff
  FROM TIMESTAMP_TBL
  WHERE d1 BETWEEN timestamp without time zone '1902-01-01'
   AND timestamp without time zone '2038-01-01';
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:   FROM TIMESTAMP_TBL
               ^
-- DATE_PART (timestamp_part)
SELECT d1 as "timestamp",
   date_part( 'year', d1) AS year, date_part( 'month', d1) AS month,
   date_part( 'day', d1) AS day, date_part( 'hour', d1) AS hour,
   date_part( 'minute', d1) AS minute, date_part( 'second', d1) AS second
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 5:    FROM TIMESTAMP_TBL;
                ^
SELECT d1 as "timestamp",
   date_part( 'quarter', d1) AS quarter, date_part( 'msec', d1) AS msec,
   date_part( 'usec', d1) AS usec
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 4:    FROM TIMESTAMP_TBL;
                ^
SELECT d1 as "timestamp",
   date_part( 'isoyear', d1) AS isoyear, date_part( 'week', d1) AS week,
   date_part( 'isodow', d1) AS isodow, date_part( 'dow', d1) AS dow,
   date_part( 'doy', d1) AS doy
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 5:    FROM TIMESTAMP_TBL;
                ^
SELECT d1 as "timestamp",
   date_part( 'decade', d1) AS decade,
   date_part( 'century', d1) AS century,
   date_part( 'millennium', d1) AS millennium,
   round(date_part( 'julian', d1)) AS julian,
   date_part( 'epoch', d1) AS epoch
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 7:    FROM TIMESTAMP_TBL;
                ^
-- extract implementation is mostly the same as date_part, so only
-- test a few cases for additional coverage.
SELECT d1 as "timestamp",
   extract(microseconds from d1) AS microseconds,
   extract(milliseconds from d1) AS milliseconds,
   extract(seconds from d1) AS seconds,
   round(extract(julian from d1)) AS julian,
   extract(epoch from d1) AS epoch
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 7:    FROM TIMESTAMP_TBL;
                ^
-- value near upper bound uses special case in code
SELECT date_part('epoch', '294270-01-01 00:00:00'::timestamp);
   date_part   
---------------
 9224097091200
(1 row)

SELECT extract(epoch from '294270-01-01 00:00:00'::timestamp);
       extract        
----------------------
 9224097091200.000000
(1 row)

-- another internal overflow test case
SELECT extract(epoch from '5000-01-01 00:00:00'::timestamp);
      extract       
--------------------
 95617584000.000000
(1 row)

-- test edge-case overflow in timestamp subtraction
SELECT timestamp '294276-12-31 23:59:59' - timestamp '1999-12-23 19:59:04.224193' AS ok;
                   ok                    
-----------------------------------------
 @ 106751991 days 4 hours 54.775807 secs
(1 row)

SELECT timestamp '294276-12-31 23:59:59' - timestamp '1999-12-23 19:59:04.224192' AS overflows;
ERROR:  interval out of range
-- TO_CHAR()
SELECT to_char(d1, 'DAY Day day DY Dy dy MONTH Month month RM MON Mon mon')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d1, 'FMDAY FMDay FMday FMMONTH FMMonth FMmonth FMRM')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d1, 'Y,YYY YYYY YYY YY Y CC Q MM WW DDD DD D J')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d1, 'FMY,YYY FMYYYY FMYYY FMYY FMY FMCC FMQ FMMM FMWW FMDDD FMDD FMD FMJ')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d1, 'HH HH12 HH24 MI SS SSSS')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d1, E'"HH:MI:SS is" HH:MI:SS "\\"text between quote marks\\""')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d1, 'HH24--text--MI--text--SS')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d1, 'YYYYTH YYYYth Jth')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d1, 'YYYY A.D. YYYY a.d. YYYY bc HH:MI:SS P.M. HH:MI:SS p.m. HH:MI:SS pm')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d1, 'IYYY IYY IY I IW IDDD ID')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d1, 'FMIYYY FMIYY FMIY FMI FMIW FMIDDD FMID')
   FROM TIMESTAMP_TBL;
ERROR:  relation "timestamp_tbl" does not exist
LINE 2:    FROM TIMESTAMP_TBL;
                ^
SELECT to_char(d, 'FF1 FF2 FF3 FF4 FF5 FF6  ff1 ff2 ff3 ff4 ff5 ff6  MS US')
   FROM (VALUES
       ('2018-11-02 12:34:56'::timestamp),
       ('2018-11-02 12:34:56.78'),
       ('2018-11-02 12:34:56.78901'),
       ('2018-11-02 12:34:56.78901234')
   ) d(d);
                              to_char                               
--------------------------------------------------------------------
 0 00 000 0000 00000 000000  0 00 000 0000 00000 000000  000 000000
 7 78 780 7800 78000 780000  7 78 780 7800 78000 780000  780 780000
 7 78 789 7890 78901 789010  7 78 789 7890 78901 789010  789 789010
 7 78 789 7890 78901 789012  7 78 789 7890 78901 789012  789 789012
(4 rows)

-- Roman months, with upper and lower case.
SELECT i,
       to_char(i * interval '1mon', 'rm'),
       to_char(i * interval '1mon', 'RM')
    FROM generate_series(-13, 13) i;
  i  | to_char | to_char 
-----+---------+---------
 -13 | xii     | XII 
 -12 | i       | I   
 -11 | ii      | II  
 -10 | iii     | III 
  -9 | iv      | IV  
  -8 | v       | V   
  -7 | vi      | VI  
  -6 | vii     | VII 
  -5 | viii    | VIII
  -4 | ix      | IX  
  -3 | x       | X   
  -2 | xi      | XI  
  -1 | xii     | XII 
   0 |         | 
   1 | i       | I   
   2 | ii      | II  
   3 | iii     | III 
   4 | iv      | IV  
   5 | v       | V   
   6 | vi      | VI  
   7 | vii     | VII 
   8 | viii    | VIII
   9 | ix      | IX  
  10 | x       | X   
  11 | xi      | XI  
  12 | xii     | XII 
  13 | i       | I   
(27 rows)

-- timestamp numeric fields constructor
SELECT make_timestamp(2014, 12, 28, 6, 30, 45.887);
        make_timestamp        
------------------------------
 Sun Dec 28 06:30:45.887 2014
(1 row)

SELECT make_timestamp(-44, 3, 15, 12, 30, 15);
       make_timestamp        
-----------------------------
 Fri Mar 15 12:30:15 0044 BC
(1 row)

-- should fail
select make_timestamp(0, 7, 15, 12, 30, 15);
ERROR:  date field value out of range: 0-07-15
-- generate_series for timestamp
select * from generate_series('2020-01-01 00:00'::timestamp,
                              '2020-01-02 03:00'::timestamp,
                              '1 hour'::interval);
     generate_series      
--------------------------
 Wed Jan 01 00:00:00 2020
 Wed Jan 01 01:00:00 2020
 Wed Jan 01 02:00:00 2020
 Wed Jan 01 03:00:00 2020
 Wed Jan 01 04:00:00 2020
 Wed Jan 01 05:00:00 2020
 Wed Jan 01 06:00:00 2020
 Wed Jan 01 07:00:00 2020
 Wed Jan 01 08:00:00 2020
 Wed Jan 01 09:00:00 2020
 Wed Jan 01 10:00:00 2020
 Wed Jan 01 11:00:00 2020
 Wed Jan 01 12:00:00 2020
 Wed Jan 01 13:00:00 2020
 Wed Jan 01 14:00:00 2020
 Wed Jan 01 15:00:00 2020
 Wed Jan 01 16:00:00 2020
 Wed Jan 01 17:00:00 2020
 Wed Jan 01 18:00:00 2020
 Wed Jan 01 19:00:00 2020
 Wed Jan 01 20:00:00 2020
 Wed Jan 01 21:00:00 2020
 Wed Jan 01 22:00:00 2020
 Wed Jan 01 23:00:00 2020
 Thu Jan 02 00:00:00 2020
 Thu Jan 02 01:00:00 2020
 Thu Jan 02 02:00:00 2020
 Thu Jan 02 03:00:00 2020
(28 rows)

-- the LIMIT should allow this to terminate in a reasonable amount of time
-- (but that unfortunately doesn't work yet for SELECT * FROM ...)
select generate_series('2022-01-01 00:00'::timestamp,
                       'infinity'::timestamp,
                       '1 month'::interval) limit 10;
     generate_series      
--------------------------
 Sat Jan 01 00:00:00 2022
 Tue Feb 01 00:00:00 2022
 Tue Mar 01 00:00:00 2022
 Fri Apr 01 00:00:00 2022
 Sun May 01 00:00:00 2022
 Wed Jun 01 00:00:00 2022
 Fri Jul 01 00:00:00 2022
 Mon Aug 01 00:00:00 2022
 Thu Sep 01 00:00:00 2022
 Sat Oct 01 00:00:00 2022
(10 rows)

-- errors
select * from generate_series('2020-01-01 00:00'::timestamp,
                              '2020-01-02 03:00'::timestamp,
                              '0 hour'::interval);
ERROR:  step size cannot equal zero
select generate_series(timestamp '1995-08-06 12:12:12', timestamp '1996-08-06 12:12:12', interval 'infinity');
ERROR:  step size cannot be infinite
select generate_series(timestamp '1995-08-06 12:12:12', timestamp '1996-08-06 12:12:12', interval '-infinity');
ERROR:  step size cannot be infinite
-- test arithmetic with infinite timestamps
select timestamp 'infinity' - timestamp 'infinity';
ERROR:  interval out of range
select timestamp 'infinity' - timestamp '-infinity';
 ?column? 
----------
 infinity
(1 row)

select timestamp '-infinity' - timestamp 'infinity';
 ?column?  
-----------
 -infinity
(1 row)

select timestamp '-infinity' - timestamp '-infinity';
ERROR:  interval out of range
select timestamp 'infinity' - timestamp '1995-08-06 12:12:12';
 ?column? 
----------
 infinity
(1 row)

select timestamp '-infinity' - timestamp '1995-08-06 12:12:12';
 ?column?  
-----------
 -infinity
(1 row)

-- test age() with infinite timestamps
select age(timestamp 'infinity');
    age    
-----------
 -infinity
(1 row)

select age(timestamp '-infinity');
   age    
----------
 infinity
(1 row)

select age(timestamp 'infinity', timestamp 'infinity');
ERROR:  interval out of range
select age(timestamp 'infinity', timestamp '-infinity');
   age    
----------
 infinity
(1 row)

select age(timestamp '-infinity', timestamp 'infinity');
    age    
-----------
 -infinity
(1 row)

select age(timestamp '-infinity', timestamp '-infinity');
ERROR:  interval out of range
-- END setup from timestamp 
-- START setup from timestamptz 
--
-- TIMESTAMPTZ
--
CREATE TABLE TIMESTAMPTZ_TBL (d1 timestamp(2) with time zone);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE TIMESTAMPTZ_TBL (d1 timestamp(2) with time zone...
                     ^
-- Test shorthand input values
-- We can't just "select" the results since they aren't constants; test for
-- equality instead.  We can do that by running the test inside a transaction
-- block, within which the value of 'now' shouldn't change, and so these
-- related values shouldn't either.
BEGIN;
INSERT INTO TIMESTAMPTZ_TBL VALUES ('today');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('today');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('yesterday');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO TIMESTAMPTZ_TBL VALUES ('tomorrow');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO TIMESTAMPTZ_TBL VALUES ('tomorrow EST');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO TIMESTAMPTZ_TBL VALUES ('tomorrow zulu');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'today';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'tomorrow';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'yesterday';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'tomorrow EST';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(*) AS One FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp with time zone 'tomorrow zulu';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT;
DELETE FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: DELETE FROM TIMESTAMPTZ_TBL;
                    ^
-- Verify that 'now' *does* change over a reasonable interval such as 100 msec,
-- and that it doesn't change over the same interval within a transaction block
INSERT INTO TIMESTAMPTZ_TBL VALUES ('now');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('now');
                    ^
SELECT pg_sleep(0.1);
 pg_sleep 
----------
 
(1 row)

BEGIN;
INSERT INTO TIMESTAMPTZ_TBL VALUES ('now');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('now');
                    ^
SELECT pg_sleep(0.1);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
INSERT INTO TIMESTAMPTZ_TBL VALUES ('now');
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT pg_sleep(0.1);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(*) AS two FROM TIMESTAMPTZ_TBL WHERE d1 = timestamp(2) with time zone 'now';
ERROR:  current transaction is aborted, commands ignored until end of transaction block
SELECT count(d1) AS three, count(DISTINCT d1) AS two FROM TIMESTAMPTZ_TBL;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT;
TRUNCATE TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
-- Special values
INSERT INTO TIMESTAMPTZ_TBL VALUES ('-infinity');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('-infinity');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('infinity');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('infinity');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('epoch');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('epoch');
                    ^
SELECT timestamptz 'infinity' = timestamptz '+infinity' AS t;
 t 
---
 t
(1 row)

-- Postgres v6.0 standard output format
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01 1997 PST');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01 199...
                    ^
-- Variations on Postgres v6.1 standard output format
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01.000001 1997 PST');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01.000...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01.999999 1997 PST');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01.999...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01.4 1997 PST');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01.4 1...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01.5 1997 PST');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01.5 1...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01.6 1997 PST');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mon Feb 10 17:32:01.6 1...
                    ^
-- ISO 8601 format
INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-01-02');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-01-02');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-01-02 03:04:05');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-01-02 03:04:05');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-02-10 17:32:01-08');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-02-10 17:32:01-08'...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-02-10 17:32:01-0800');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-02-10 17:32:01-080...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-02-10 17:32:01 -08:00');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-02-10 17:32:01 -08...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970210 173201 -0800');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970210 173201 -0800')...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-06-10 17:32:01 -07:00');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-06-10 17:32:01 -07...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('2001-09-22T18:19:20');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('2001-09-22T18:19:20');
                    ^
-- POSIX format (note that the timezone abbrev is just decoration here)
INSERT INTO TIMESTAMPTZ_TBL VALUES ('2000-03-15 08:14:01 GMT+8');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('2000-03-15 08:14:01 GMT...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('2000-03-15 13:14:02 GMT-1');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('2000-03-15 13:14:02 GMT...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('2000-03-15 12:14:03 GMT-2');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('2000-03-15 12:14:03 GMT...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('2000-03-15 03:14:04 PST+8');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('2000-03-15 03:14:04 PST...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('2000-03-15 02:14:05 MST+7:00');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('2000-03-15 02:14:05 MST...
                    ^
-- Variations for acceptable input formats
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 10 17:32:01 1997 -0800');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 10 17:32:01 1997 -0...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 10 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 10 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 10 5:32PM 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 10 5:32PM 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997/02/10 17:32:01-0800');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997/02/10 17:32:01-080...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-02-10 17:32:01 PST');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-02-10 17:32:01 PST...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb-10-1997 17:32:01 PST');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb-10-1997 17:32:01 PS...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('02-10-1997 17:32:01 PST');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('02-10-1997 17:32:01 PST...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970210 173201 PST');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970210 173201 PST');
                    ^
set datestyle to ymd;
INSERT INTO TIMESTAMPTZ_TBL VALUES ('97FEB10 5:32:01PM UTC');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('97FEB10 5:32:01PM UTC')...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('97/02/10 17:32:01 UTC');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('97/02/10 17:32:01 UTC')...
                    ^
reset datestyle;
INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997.041 17:32:01 UTC');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997.041 17:32:01 UTC')...
                    ^
-- timestamps at different timezones
INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970210 173201 America/New_York');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970210 173201 America...
                    ^
SELECT '19970210 173201' AT TIME ZONE 'America/New_York';
         timezone         
--------------------------
 Mon Feb 10 20:32:01 1997
(1 row)

INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970710 173201 America/New_York');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970710 173201 America...
                    ^
SELECT '19970710 173201' AT TIME ZONE 'America/New_York';
         timezone         
--------------------------
 Thu Jul 10 20:32:01 1997
(1 row)

INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970710 173201 America/Does_not_exist');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('19970710 173201 America...
                    ^
SELECT '19970710 173201' AT TIME ZONE 'America/Does_not_exist';
ERROR:  time zone "America/Does_not_exist" not recognized
-- Daylight saving time for timestamps beyond 32-bit time_t range.
SELECT '20500710 173201 Europe/Helsinki'::timestamptz; -- DST
         timestamptz          
------------------------------
 Sun Jul 10 07:32:01 2050 PDT
(1 row)

SELECT '20500110 173201 Europe/Helsinki'::timestamptz; -- non-DST
         timestamptz          
------------------------------
 Mon Jan 10 07:32:01 2050 PST
(1 row)

SELECT '205000-07-10 17:32:01 Europe/Helsinki'::timestamptz; -- DST
          timestamptz           
--------------------------------
 Thu Jul 10 07:32:01 205000 PDT
(1 row)

SELECT '205000-01-10 17:32:01 Europe/Helsinki'::timestamptz; -- non-DST
          timestamptz           
--------------------------------
 Fri Jan 10 07:32:01 205000 PST
(1 row)

-- Test non-error-throwing API
SELECT pg_input_is_valid('now', 'timestamptz');
 pg_input_is_valid 
-------------------
 t
(1 row)

SELECT pg_input_is_valid('garbage', 'timestamptz');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT pg_input_is_valid('2001-01-01 00:00 Nehwon/Lankhmar', 'timestamptz');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT * FROM pg_input_error_info('garbage', 'timestamptz');
                              message                              | detail | hint | sql_error_code 
-------------------------------------------------------------------+--------+------+----------------
 invalid input syntax for type timestamp with time zone: "garbage" |        |      | 22007
(1 row)

SELECT * FROM pg_input_error_info('2001-01-01 00:00 Nehwon/Lankhmar', 'timestamptz');
                  message                   | detail | hint | sql_error_code 
--------------------------------------------+--------+------+----------------
 time zone "nehwon/lankhmar" not recognized |        |      | 22023
(1 row)

-- Check date conversion and date arithmetic
INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-06-10 18:32:01 PDT');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('1997-06-10 18:32:01 PDT...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 10 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 10 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 11 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 11 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 12 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 12 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 13 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 13 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 14 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 14 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 15 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 15 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 0097 BC');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 0097 BC...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 0097');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 0097');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 0597');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 0597');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1097');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1097');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1697');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1697');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1797');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1797');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1897');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1897');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 2097');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 2097');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 28 17:32:01 1996');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 28 17:32:01 1996');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 29 17:32:01 1996');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 29 17:32:01 1996');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mar 01 17:32:01 1996');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mar 01 17:32:01 1996');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 30 17:32:01 1996');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 30 17:32:01 1996');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 31 17:32:01 1996');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 31 17:32:01 1996');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Jan 01 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Jan 01 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 28 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 28 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 29 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 29 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mar 01 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Mar 01 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 30 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 30 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 31 17:32:01 1997');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 31 17:32:01 1997');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 31 17:32:01 1999');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 31 17:32:01 1999');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Jan 01 17:32:01 2000');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Jan 01 17:32:01 2000');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 31 17:32:01 2000');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Dec 31 17:32:01 2000');
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Jan 01 17:32:01 2001');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Jan 01 17:32:01 2001');
                    ^
-- Currently unsupported syntax and ranges
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 -0097');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 -0097')...
                    ^
INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 5097 BC');
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TBL VALUES ('Feb 16 17:32:01 5097 BC...
                    ^
-- Alternative field order that we've historically supported (sort of)
-- with regular and POSIXy timezone specs
SELECT 'Wed Jul 11 10:51:14 America/New_York 2001'::timestamptz;
         timestamptz          
------------------------------
 Wed Jul 11 07:51:14 2001 PDT
(1 row)

SELECT 'Wed Jul 11 10:51:14 GMT-4 2001'::timestamptz;
         timestamptz          
------------------------------
 Tue Jul 10 23:51:14 2001 PDT
(1 row)

SELECT 'Wed Jul 11 10:51:14 GMT+4 2001'::timestamptz;
         timestamptz          
------------------------------
 Wed Jul 11 07:51:14 2001 PDT
(1 row)

SELECT 'Wed Jul 11 10:51:14 PST-03:00 2001'::timestamptz;
         timestamptz          
------------------------------
 Wed Jul 11 00:51:14 2001 PDT
(1 row)

SELECT 'Wed Jul 11 10:51:14 PST+03:00 2001'::timestamptz;
         timestamptz          
------------------------------
 Wed Jul 11 06:51:14 2001 PDT
(1 row)

SELECT d1 FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMPTZ_TBL;
                       ^
-- Check behavior at the boundaries of the timestamp range
SELECT '4714-11-24 00:00:00+00 BC'::timestamptz;
           timestamptz           
---------------------------------
 Sun Nov 23 16:00:00 4714 PST BC
(1 row)

SELECT '4714-11-23 16:00:00-08 BC'::timestamptz;
           timestamptz           
---------------------------------
 Sun Nov 23 16:00:00 4714 PST BC
(1 row)

SELECT 'Sun Nov 23 16:00:00 4714 PST BC'::timestamptz;
           timestamptz           
---------------------------------
 Sun Nov 23 16:00:00 4714 PST BC
(1 row)

SELECT '4714-11-23 23:59:59+00 BC'::timestamptz;  -- out of range
ERROR:  timestamp out of range: "4714-11-23 23:59:59+00 BC"
LINE 1: SELECT '4714-11-23 23:59:59+00 BC'::timestamptz;
               ^
SELECT '294276-12-31 23:59:59+00'::timestamptz;
          timestamptz           
--------------------------------
 Sun Dec 31 15:59:59 294276 PST
(1 row)

SELECT '294276-12-31 15:59:59-08'::timestamptz;
          timestamptz           
--------------------------------
 Sun Dec 31 15:59:59 294276 PST
(1 row)

SELECT '294277-01-01 00:00:00+00'::timestamptz;  -- out of range
ERROR:  timestamp out of range: "294277-01-01 00:00:00+00"
LINE 1: SELECT '294277-01-01 00:00:00+00'::timestamptz;
               ^
SELECT '294277-12-31 16:00:00-08'::timestamptz;  -- out of range
ERROR:  timestamp out of range: "294277-12-31 16:00:00-08"
LINE 1: SELECT '294277-12-31 16:00:00-08'::timestamptz;
               ^
-- Demonstrate functions and operators
SELECT d1 FROM TIMESTAMPTZ_TBL
   WHERE d1 > timestamp with time zone '1997-01-02';
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMPTZ_TBL
                       ^
SELECT d1 FROM TIMESTAMPTZ_TBL
   WHERE d1 < timestamp with time zone '1997-01-02';
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMPTZ_TBL
                       ^
SELECT d1 FROM TIMESTAMPTZ_TBL
   WHERE d1 = timestamp with time zone '1997-01-02';
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMPTZ_TBL
                       ^
SELECT d1 FROM TIMESTAMPTZ_TBL
   WHERE d1 != timestamp with time zone '1997-01-02';
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMPTZ_TBL
                       ^
SELECT d1 FROM TIMESTAMPTZ_TBL
   WHERE d1 <= timestamp with time zone '1997-01-02';
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMPTZ_TBL
                       ^
SELECT d1 FROM TIMESTAMPTZ_TBL
   WHERE d1 >= timestamp with time zone '1997-01-02';
ERROR:  relation "timestamptz_tbl" does not exist
LINE 1: SELECT d1 FROM TIMESTAMPTZ_TBL
                       ^
SELECT d1 - timestamp with time zone '1997-01-02' AS diff
   FROM TIMESTAMPTZ_TBL WHERE d1 BETWEEN '1902-01-01' AND '2038-01-01';
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL WHERE d1 BETWEEN '1902-01-01' AND '2...
                ^
SELECT date_trunc( 'week', timestamp with time zone '2004-02-29 15:44:17.71393' ) AS week_trunc;
          week_trunc          
------------------------------
 Mon Feb 23 00:00:00 2004 PST
(1 row)

SELECT date_trunc('day', timestamp with time zone '2001-02-16 20:38:40+00', 'Australia/Sydney') as sydney_trunc;  -- zone name
         sydney_trunc         
------------------------------
 Fri Feb 16 05:00:00 2001 PST
(1 row)

SELECT date_trunc('day', timestamp with time zone '2001-02-16 20:38:40+00', 'GMT') as gmt_trunc;  -- fixed-offset abbreviation
          gmt_trunc           
------------------------------
 Thu Feb 15 16:00:00 2001 PST
(1 row)

SELECT date_trunc('day', timestamp with time zone '2001-02-16 20:38:40+00', 'VET') as vet_trunc;  -- variable-offset abbreviation
          vet_trunc           
------------------------------
 Thu Feb 15 20:00:00 2001 PST
(1 row)

-- verify date_bin behaves the same as date_trunc for relevant intervals
SELECT
  str,
  interval,
  date_trunc(str, ts, 'Australia/Sydney') = date_bin(interval::interval, ts, timestamp with time zone '2001-01-01+11') AS equal
FROM (
  VALUES
  ('day', '1 d'),
  ('hour', '1 h'),
  ('minute', '1 m'),
  ('second', '1 s'),
  ('millisecond', '1 ms'),
  ('microsecond', '1 us')
) intervals (str, interval),
(VALUES (timestamptz '2020-02-29 15:44:17.71393+00')) ts (ts);
     str     | interval | equal 
-------------+----------+-------
 day         | 1 d      | t
 hour        | 1 h      | t
 minute      | 1 m      | t
 second      | 1 s      | t
 millisecond | 1 ms     | t
 microsecond | 1 us     | t
(6 rows)

-- bin timestamps into arbitrary intervals
SELECT
  interval,
  ts,
  origin,
  date_bin(interval::interval, ts, origin)
FROM (
  VALUES
  ('15 days'),
  ('2 hours'),
  ('1 hour 30 minutes'),
  ('15 minutes'),
  ('10 seconds'),
  ('100 milliseconds'),
  ('250 microseconds')
) intervals (interval),
(VALUES (timestamptz '2020-02-11 15:44:17.71393')) ts (ts),
(VALUES (timestamptz '2001-01-01')) origin (origin);
     interval      |                 ts                 |            origin            |              date_bin              
-------------------+------------------------------------+------------------------------+------------------------------------
 15 days           | Tue Feb 11 15:44:17.71393 2020 PST | Mon Jan 01 00:00:00 2001 PST | Thu Feb 06 00:00:00 2020 PST
 2 hours           | Tue Feb 11 15:44:17.71393 2020 PST | Mon Jan 01 00:00:00 2001 PST | Tue Feb 11 14:00:00 2020 PST
 1 hour 30 minutes | Tue Feb 11 15:44:17.71393 2020 PST | Mon Jan 01 00:00:00 2001 PST | Tue Feb 11 15:00:00 2020 PST
 15 minutes        | Tue Feb 11 15:44:17.71393 2020 PST | Mon Jan 01 00:00:00 2001 PST | Tue Feb 11 15:30:00 2020 PST
 10 seconds        | Tue Feb 11 15:44:17.71393 2020 PST | Mon Jan 01 00:00:00 2001 PST | Tue Feb 11 15:44:10 2020 PST
 100 milliseconds  | Tue Feb 11 15:44:17.71393 2020 PST | Mon Jan 01 00:00:00 2001 PST | Tue Feb 11 15:44:17.7 2020 PST
 250 microseconds  | Tue Feb 11 15:44:17.71393 2020 PST | Mon Jan 01 00:00:00 2001 PST | Tue Feb 11 15:44:17.71375 2020 PST
(7 rows)

-- shift bins using the origin parameter:
SELECT date_bin('5 min'::interval, timestamptz '2020-02-01 01:01:01+00', timestamptz '2020-02-01 00:02:30+00');
           date_bin           
------------------------------
 Fri Jan 31 16:57:30 2020 PST
(1 row)

-- test roundoff edge case when source < origin
SELECT date_bin('30 minutes'::interval, timestamptz '2024-02-01 15:00:00', timestamptz '2024-02-01 17:00:00');
           date_bin           
------------------------------
 Thu Feb 01 15:00:00 2024 PST
(1 row)

-- disallow intervals with months or years
SELECT date_bin('5 months'::interval, timestamp with time zone '2020-02-01 01:01:01+00', timestamp with time zone '2001-01-01+00');
ERROR:  timestamps cannot be binned into intervals containing months or years
SELECT date_bin('5 years'::interval,  timestamp with time zone '2020-02-01 01:01:01+00', timestamp with time zone '2001-01-01+00');
ERROR:  timestamps cannot be binned into intervals containing months or years
-- disallow zero intervals
SELECT date_bin('0 days'::interval, timestamp with time zone '1970-01-01 01:00:00+00' , timestamp with time zone '1970-01-01 00:00:00+00');
ERROR:  stride must be greater than zero
-- disallow negative intervals
SELECT date_bin('-2 days'::interval, timestamp with time zone '1970-01-01 01:00:00+00' , timestamp with time zone '1970-01-01 00:00:00+00');
ERROR:  stride must be greater than zero
-- test overflow cases
select date_bin('15 minutes'::interval, timestamptz '294276-12-30', timestamptz '4000-12-20 BC');
ERROR:  interval out of range
select date_bin('200000000 days'::interval, '2024-02-01'::timestamptz, '2024-01-01'::timestamptz);
ERROR:  interval out of range
select date_bin('365000 days'::interval, '4400-01-01 BC'::timestamptz, '4000-01-01 BC'::timestamptz);
ERROR:  timestamp out of range
-- Test casting within a BETWEEN qualifier
SELECT d1 - timestamp with time zone '1997-01-02' AS diff
  FROM TIMESTAMPTZ_TBL
  WHERE d1 BETWEEN timestamp with time zone '1902-01-01' AND timestamp with time zone '2038-01-01';
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:   FROM TIMESTAMPTZ_TBL
               ^
-- DATE_PART (timestamptz_part)
SELECT d1 as timestamptz,
   date_part( 'year', d1) AS year, date_part( 'month', d1) AS month,
   date_part( 'day', d1) AS day, date_part( 'hour', d1) AS hour,
   date_part( 'minute', d1) AS minute, date_part( 'second', d1) AS second
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 5:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT d1 as timestamptz,
   date_part( 'quarter', d1) AS quarter, date_part( 'msec', d1) AS msec,
   date_part( 'usec', d1) AS usec
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 4:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT d1 as timestamptz,
   date_part( 'isoyear', d1) AS isoyear, date_part( 'week', d1) AS week,
   date_part( 'isodow', d1) AS isodow, date_part( 'dow', d1) AS dow,
   date_part( 'doy', d1) AS doy
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 5:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT d1 as timestamptz,
   date_part( 'decade', d1) AS decade,
   date_part( 'century', d1) AS century,
   date_part( 'millennium', d1) AS millennium,
   round(date_part( 'julian', d1)) AS julian,
   date_part( 'epoch', d1) AS epoch
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 7:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT d1 as timestamptz,
   date_part( 'timezone', d1) AS timezone,
   date_part( 'timezone_hour', d1) AS timezone_hour,
   date_part( 'timezone_minute', d1) AS timezone_minute
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 5:    FROM TIMESTAMPTZ_TBL;
                ^
-- extract implementation is mostly the same as date_part, so only
-- test a few cases for additional coverage.
SELECT d1 as "timestamp",
   extract(microseconds from d1) AS microseconds,
   extract(milliseconds from d1) AS milliseconds,
   extract(seconds from d1) AS seconds,
   round(extract(julian from d1)) AS julian,
   extract(epoch from d1) AS epoch
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 7:    FROM TIMESTAMPTZ_TBL;
                ^
-- value near upper bound uses special case in code
SELECT date_part('epoch', '294270-01-01 00:00:00+00'::timestamptz);
   date_part   
---------------
 9224097091200
(1 row)

SELECT extract(epoch from '294270-01-01 00:00:00+00'::timestamptz);
       extract        
----------------------
 9224097091200.000000
(1 row)

-- another internal overflow test case
SELECT extract(epoch from '5000-01-01 00:00:00+00'::timestamptz);
      extract       
--------------------
 95617584000.000000
(1 row)

-- test edge-case overflow in timestamp subtraction
SELECT timestamptz '294276-12-31 23:59:59 UTC' - timestamptz '1999-12-23 19:59:04.224193 UTC' AS ok;
                   ok                    
-----------------------------------------
 @ 106751991 days 4 hours 54.775807 secs
(1 row)

SELECT timestamptz '294276-12-31 23:59:59 UTC' - timestamptz '1999-12-23 19:59:04.224192 UTC' AS overflows;
ERROR:  interval out of range
-- TO_CHAR()
SELECT to_char(d1, 'DAY Day day DY Dy dy MONTH Month month RM MON Mon mon')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d1, 'FMDAY FMDay FMday FMMONTH FMMonth FMmonth FMRM')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d1, 'Y,YYY YYYY YYY YY Y CC Q MM WW DDD DD D J')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d1, 'FMY,YYY FMYYYY FMYYY FMYY FMY FMCC FMQ FMMM FMWW FMDDD FMDD FMD FMJ')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d1, 'HH HH12 HH24 MI SS SSSS')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d1, E'"HH:MI:SS is" HH:MI:SS "\\"text between quote marks\\""')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d1, 'HH24--text--MI--text--SS')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d1, 'YYYYTH YYYYth Jth')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d1, 'YYYY A.D. YYYY a.d. YYYY bc HH:MI:SS P.M. HH:MI:SS p.m. HH:MI:SS pm')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d1, 'IYYY IYY IY I IW IDDD ID')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d1, 'FMIYYY FMIYY FMIY FMI FMIW FMIDDD FMID')
   FROM TIMESTAMPTZ_TBL;
ERROR:  relation "timestamptz_tbl" does not exist
LINE 2:    FROM TIMESTAMPTZ_TBL;
                ^
SELECT to_char(d, 'FF1 FF2 FF3 FF4 FF5 FF6  ff1 ff2 ff3 ff4 ff5 ff6  MS US')
   FROM (VALUES
       ('2018-11-02 12:34:56'::timestamptz),
       ('2018-11-02 12:34:56.78'),
       ('2018-11-02 12:34:56.78901'),
       ('2018-11-02 12:34:56.78901234')
   ) d(d);
                              to_char                               
--------------------------------------------------------------------
 0 00 000 0000 00000 000000  0 00 000 0000 00000 000000  000 000000
 7 78 780 7800 78000 780000  7 78 780 7800 78000 780000  780 780000
 7 78 789 7890 78901 789010  7 78 789 7890 78901 789010  789 789010
 7 78 789 7890 78901 789012  7 78 789 7890 78901 789012  789 789012
(4 rows)

-- Check OF, TZH, TZM with various zone offsets, particularly fractional hours
SET timezone = '00:00';
SELECT to_char(now(), 'OF') as "OF", to_char(now(), 'TZH:TZM') as "TZH:TZM";
 OF  | TZH:TZM 
-----+---------
 +00 | +00:00
(1 row)

SET timezone = '+02:00';
SELECT to_char(now(), 'OF') as "OF", to_char(now(), 'TZH:TZM') as "TZH:TZM";
 OF  | TZH:TZM 
-----+---------
 -02 | -02:00
(1 row)

SET timezone = '-13:00';
SELECT to_char(now(), 'OF') as "OF", to_char(now(), 'TZH:TZM') as "TZH:TZM";
 OF  | TZH:TZM 
-----+---------
 +13 | +13:00
(1 row)

SET timezone = '-00:30';
SELECT to_char(now(), 'OF') as "OF", to_char(now(), 'TZH:TZM') as "TZH:TZM";
   OF   | TZH:TZM 
--------+---------
 +00:30 | +00:30
(1 row)

SET timezone = '00:30';
SELECT to_char(now(), 'OF') as "OF", to_char(now(), 'TZH:TZM') as "TZH:TZM";
   OF   | TZH:TZM 
--------+---------
 -00:30 | -00:30
(1 row)

SET timezone = '-04:30';
SELECT to_char(now(), 'OF') as "OF", to_char(now(), 'TZH:TZM') as "TZH:TZM";
   OF   | TZH:TZM 
--------+---------
 +04:30 | +04:30
(1 row)

SET timezone = '04:30';
SELECT to_char(now(), 'OF') as "OF", to_char(now(), 'TZH:TZM') as "TZH:TZM";
   OF   | TZH:TZM 
--------+---------
 -04:30 | -04:30
(1 row)

SET timezone = '-04:15';
SELECT to_char(now(), 'OF') as "OF", to_char(now(), 'TZH:TZM') as "TZH:TZM";
   OF   | TZH:TZM 
--------+---------
 +04:15 | +04:15
(1 row)

SET timezone = '04:15';
SELECT to_char(now(), 'OF') as "OF", to_char(now(), 'TZH:TZM') as "TZH:TZM";
   OF   | TZH:TZM 
--------+---------
 -04:15 | -04:15
(1 row)

RESET timezone;
-- Check of, tzh, tzm with various zone offsets.
SET timezone = '00:00';
SELECT to_char(now(), 'of') as "Of", to_char(now(), 'tzh:tzm') as "tzh:tzm";
 Of  | tzh:tzm 
-----+---------
 +00 | +00:00
(1 row)

SET timezone = '+02:00';
SELECT to_char(now(), 'of') as "of", to_char(now(), 'tzh:tzm') as "tzh:tzm";
 of  | tzh:tzm 
-----+---------
 -02 | -02:00
(1 row)

SET timezone = '-13:00';
SELECT to_char(now(), 'of') as "of", to_char(now(), 'tzh:tzm') as "tzh:tzm";
 of  | tzh:tzm 
-----+---------
 +13 | +13:00
(1 row)

SET timezone = '-00:30';
SELECT to_char(now(), 'of') as "of", to_char(now(), 'tzh:tzm') as "tzh:tzm";
   of   | tzh:tzm 
--------+---------
 +00:30 | +00:30
(1 row)

SET timezone = '00:30';
SELECT to_char(now(), 'of') as "of", to_char(now(), 'tzh:tzm') as "tzh:tzm";
   of   | tzh:tzm 
--------+---------
 -00:30 | -00:30
(1 row)

SET timezone = '-04:30';
SELECT to_char(now(), 'of') as "of", to_char(now(), 'tzh:tzm') as "tzh:tzm";
   of   | tzh:tzm 
--------+---------
 +04:30 | +04:30
(1 row)

SET timezone = '04:30';
SELECT to_char(now(), 'of') as "of", to_char(now(), 'tzh:tzm') as "tzh:tzm";
   of   | tzh:tzm 
--------+---------
 -04:30 | -04:30
(1 row)

SET timezone = '-04:15';
SELECT to_char(now(), 'of') as "of", to_char(now(), 'tzh:tzm') as "tzh:tzm";
   of   | tzh:tzm 
--------+---------
 +04:15 | +04:15
(1 row)

SET timezone = '04:15';
SELECT to_char(now(), 'of') as "of", to_char(now(), 'tzh:tzm') as "tzh:tzm";
   of   | tzh:tzm 
--------+---------
 -04:15 | -04:15
(1 row)

RESET timezone;
CREATE TABLE TIMESTAMPTZ_TST (a int , b timestamptz);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE TIMESTAMPTZ_TST (a int , b timestamptz);
                     ^
-- Test year field value with len > 4
INSERT INTO TIMESTAMPTZ_TST VALUES(1, 'Sat Mar 12 23:58:48 1000 IST');
ERROR:  relation "timestamptz_tst" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TST VALUES(1, 'Sat Mar 12 23:58:48 1...
                    ^
INSERT INTO TIMESTAMPTZ_TST VALUES(2, 'Sat Mar 12 23:58:48 10000 IST');
ERROR:  relation "timestamptz_tst" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TST VALUES(2, 'Sat Mar 12 23:58:48 1...
                    ^
INSERT INTO TIMESTAMPTZ_TST VALUES(3, 'Sat Mar 12 23:58:48 100000 IST');
ERROR:  relation "timestamptz_tst" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TST VALUES(3, 'Sat Mar 12 23:58:48 1...
                    ^
INSERT INTO TIMESTAMPTZ_TST VALUES(3, '10000 Mar 12 23:58:48 IST');
ERROR:  relation "timestamptz_tst" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TST VALUES(3, '10000 Mar 12 23:58:48...
                    ^
INSERT INTO TIMESTAMPTZ_TST VALUES(4, '100000312 23:58:48 IST');
ERROR:  relation "timestamptz_tst" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TST VALUES(4, '100000312 23:58:48 IS...
                    ^
INSERT INTO TIMESTAMPTZ_TST VALUES(4, '1000000312 23:58:48 IST');
ERROR:  relation "timestamptz_tst" does not exist
LINE 1: INSERT INTO TIMESTAMPTZ_TST VALUES(4, '1000000312 23:58:48 I...
                    ^
--Verify data
SELECT * FROM TIMESTAMPTZ_TST ORDER BY a;
ERROR:  relation "timestamptz_tst" does not exist
LINE 1: SELECT * FROM TIMESTAMPTZ_TST ORDER BY a;
                      ^
--Cleanup
DROP TABLE TIMESTAMPTZ_TST;
ERROR:  table "timestamptz_tst" does not exist
-- test timestamptz constructors
set TimeZone to 'America/New_York';
-- numeric timezone
SELECT make_timestamptz(1973, 07, 15, 08, 15, 55.33);
        make_timestamptz         
---------------------------------
 Sun Jul 15 08:15:55.33 1973 EDT
(1 row)

SELECT make_timestamptz(1973, 07, 15, 08, 15, 55.33, '+2');
        make_timestamptz         
---------------------------------
 Sun Jul 15 02:15:55.33 1973 EDT
(1 row)

SELECT make_timestamptz(1973, 07, 15, 08, 15, 55.33, '-2');
        make_timestamptz         
---------------------------------
 Sun Jul 15 06:15:55.33 1973 EDT
(1 row)

WITH tzs (tz) AS (VALUES
    ('+1'), ('+1:'), ('+1:0'), ('+100'), ('+1:00'), ('+01:00'),
    ('+10'), ('+1000'), ('+10:'), ('+10:0'), ('+10:00'), ('+10:00:'),
    ('+10:00:1'), ('+10:00:01'),
    ('+10:00:10'))
     SELECT make_timestamptz(2010, 2, 27, 3, 45, 00, tz), tz FROM tzs;
       make_timestamptz       |    tz     
------------------------------+-----------
 Fri Feb 26 21:45:00 2010 EST | +1
 Fri Feb 26 21:45:00 2010 EST | +1:
 Fri Feb 26 21:45:00 2010 EST | +1:0
 Fri Feb 26 21:45:00 2010 EST | +100
 Fri Feb 26 21:45:00 2010 EST | +1:00
 Fri Feb 26 21:45:00 2010 EST | +01:00
 Fri Feb 26 12:45:00 2010 EST | +10
 Fri Feb 26 12:45:00 2010 EST | +1000
 Fri Feb 26 12:45:00 2010 EST | +10:
 Fri Feb 26 12:45:00 2010 EST | +10:0
 Fri Feb 26 12:45:00 2010 EST | +10:00
 Fri Feb 26 12:45:00 2010 EST | +10:00:
 Fri Feb 26 12:44:59 2010 EST | +10:00:1
 Fri Feb 26 12:44:59 2010 EST | +10:00:01
 Fri Feb 26 12:44:50 2010 EST | +10:00:10
(15 rows)

-- these should fail
SELECT make_timestamptz(1973, 07, 15, 08, 15, 55.33, '2');
ERROR:  invalid input syntax for type numeric time zone: "2"
HINT:  Numeric time zones must have "-" or "+" as first character.
SELECT make_timestamptz(2014, 12, 10, 10, 10, 10, '+16');
ERROR:  numeric time zone "+16" out of range
SELECT make_timestamptz(2014, 12, 10, 10, 10, 10, '-16');
ERROR:  numeric time zone "-16" out of range
-- should be true
SELECT make_timestamptz(1973, 07, 15, 08, 15, 55.33, '+2') = '1973-07-15 08:15:55.33+02'::timestamptz;
 ?column? 
----------
 t
(1 row)

-- full timezone names
SELECT make_timestamptz(2014, 12, 10, 0, 0, 0, 'Europe/Prague') = timestamptz '2014-12-10 00:00:00 Europe/Prague';
 ?column? 
----------
 t
(1 row)

SELECT make_timestamptz(2014, 12, 10, 0, 0, 0, 'Europe/Prague') AT TIME ZONE 'UTC';
         timezone         
--------------------------
 Tue Dec 09 23:00:00 2014
(1 row)

SELECT make_timestamptz(1846, 12, 10, 0, 0, 0, 'Asia/Manila') AT TIME ZONE 'UTC';
         timezone         
--------------------------
 Wed Dec 09 15:56:00 1846
(1 row)

SELECT make_timestamptz(1881, 12, 10, 0, 0, 0, 'Europe/Paris') AT TIME ZONE 'UTC';
         timezone         
--------------------------
 Fri Dec 09 23:50:39 1881
(1 row)

SELECT make_timestamptz(1910, 12, 24, 0, 0, 0, 'Nehwon/Lankhmar');
ERROR:  time zone "Nehwon/Lankhmar" not recognized
-- abbreviations
SELECT make_timestamptz(2008, 12, 10, 10, 10, 10, 'EST');
       make_timestamptz       
------------------------------
 Wed Dec 10 10:10:10 2008 EST
(1 row)

SELECT make_timestamptz(2008, 12, 10, 10, 10, 10, 'EDT');
       make_timestamptz       
------------------------------
 Wed Dec 10 09:10:10 2008 EST
(1 row)

SELECT make_timestamptz(2014, 12, 10, 10, 10, 10, 'PST8PDT');
       make_timestamptz       
------------------------------
 Wed Dec 10 13:10:10 2014 EST
(1 row)

RESET TimeZone;
-- generate_series for timestamptz
select * from generate_series('2020-01-01 00:00'::timestamptz,
                              '2020-01-02 03:00'::timestamptz,
                              '1 hour'::interval);
       generate_series        
------------------------------
 Wed Jan 01 00:00:00 2020 PST
 Wed Jan 01 01:00:00 2020 PST
 Wed Jan 01 02:00:00 2020 PST
 Wed Jan 01 03:00:00 2020 PST
 Wed Jan 01 04:00:00 2020 PST
 Wed Jan 01 05:00:00 2020 PST
 Wed Jan 01 06:00:00 2020 PST
 Wed Jan 01 07:00:00 2020 PST
 Wed Jan 01 08:00:00 2020 PST
 Wed Jan 01 09:00:00 2020 PST
 Wed Jan 01 10:00:00 2020 PST
 Wed Jan 01 11:00:00 2020 PST
 Wed Jan 01 12:00:00 2020 PST
 Wed Jan 01 13:00:00 2020 PST
 Wed Jan 01 14:00:00 2020 PST
 Wed Jan 01 15:00:00 2020 PST
 Wed Jan 01 16:00:00 2020 PST
 Wed Jan 01 17:00:00 2020 PST
 Wed Jan 01 18:00:00 2020 PST
 Wed Jan 01 19:00:00 2020 PST
 Wed Jan 01 20:00:00 2020 PST
 Wed Jan 01 21:00:00 2020 PST
 Wed Jan 01 22:00:00 2020 PST
 Wed Jan 01 23:00:00 2020 PST
 Thu Jan 02 00:00:00 2020 PST
 Thu Jan 02 01:00:00 2020 PST
 Thu Jan 02 02:00:00 2020 PST
 Thu Jan 02 03:00:00 2020 PST
(28 rows)

-- the LIMIT should allow this to terminate in a reasonable amount of time
-- (but that unfortunately doesn't work yet for SELECT * FROM ...)
select generate_series('2022-01-01 00:00'::timestamptz,
                       'infinity'::timestamptz,
                       '1 month'::interval) limit 10;
       generate_series        
------------------------------
 Sat Jan 01 00:00:00 2022 PST
 Tue Feb 01 00:00:00 2022 PST
 Tue Mar 01 00:00:00 2022 PST
 Fri Apr 01 00:00:00 2022 PDT
 Sun May 01 00:00:00 2022 PDT
 Wed Jun 01 00:00:00 2022 PDT
 Fri Jul 01 00:00:00 2022 PDT
 Mon Aug 01 00:00:00 2022 PDT
 Thu Sep 01 00:00:00 2022 PDT
 Sat Oct 01 00:00:00 2022 PDT
(10 rows)

-- errors
select * from generate_series('2020-01-01 00:00'::timestamptz,
                              '2020-01-02 03:00'::timestamptz,
                              '0 hour'::interval);
ERROR:  step size cannot equal zero
select generate_series(timestamptz '1995-08-06 12:12:12', timestamptz '1996-08-06 12:12:12', interval 'infinity');
ERROR:  step size cannot be infinite
select generate_series(timestamptz '1995-08-06 12:12:12', timestamptz '1996-08-06 12:12:12', interval '-infinity');
ERROR:  step size cannot be infinite
-- Interval crossing time shift for Europe/Warsaw timezone (with DST)
SET TimeZone to 'UTC';
SELECT date_add('2022-10-30 00:00:00+01'::timestamptz,
                '1 day'::interval);
           date_add           
------------------------------
 Sun Oct 30 23:00:00 2022 UTC
(1 row)

SELECT date_add('2021-10-31 00:00:00+02'::timestamptz,
                '1 day'::interval,
                'Europe/Warsaw');
           date_add           
------------------------------
 Sun Oct 31 23:00:00 2021 UTC
(1 row)

SELECT date_subtract('2022-10-30 00:00:00+01'::timestamptz,
                     '1 day'::interval);
        date_subtract         
------------------------------
 Fri Oct 28 23:00:00 2022 UTC
(1 row)

SELECT date_subtract('2021-10-31 00:00:00+02'::timestamptz,
                     '1 day'::interval,
                     'Europe/Warsaw');
        date_subtract         
------------------------------
 Fri Oct 29 22:00:00 2021 UTC
(1 row)

SELECT * FROM generate_series('2021-12-31 23:00:00+00'::timestamptz,
                              '2020-12-31 23:00:00+00'::timestamptz,
                              '-1 month'::interval,
                              'Europe/Warsaw');
       generate_series        
------------------------------
 Fri Dec 31 23:00:00 2021 UTC
 Tue Nov 30 23:00:00 2021 UTC
 Sun Oct 31 23:00:00 2021 UTC
 Thu Sep 30 22:00:00 2021 UTC
 Tue Aug 31 22:00:00 2021 UTC
 Sat Jul 31 22:00:00 2021 UTC
 Wed Jun 30 22:00:00 2021 UTC
 Mon May 31 22:00:00 2021 UTC
 Fri Apr 30 22:00:00 2021 UTC
 Wed Mar 31 22:00:00 2021 UTC
 Sun Feb 28 23:00:00 2021 UTC
 Sun Jan 31 23:00:00 2021 UTC
 Thu Dec 31 23:00:00 2020 UTC
(13 rows)

RESET TimeZone;
--
-- Test behavior with a dynamic (time-varying) timezone abbreviation.
-- These tests rely on the knowledge that MSK (Europe/Moscow standard time)
-- moved forwards in Mar 2011 and backwards again in Oct 2014.
--
SET TimeZone to 'UTC';
SELECT '2011-03-27 00:00:00 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 21:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 01:00:00 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 22:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 01:59:59 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 22:59:59 2011 UTC
(1 row)

SELECT '2011-03-27 02:00:00 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 23:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 02:00:01 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 23:00:01 2011 UTC
(1 row)

SELECT '2011-03-27 02:59:59 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 23:59:59 2011 UTC
(1 row)

SELECT '2011-03-27 03:00:00 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 23:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 03:00:01 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 23:00:01 2011 UTC
(1 row)

SELECT '2011-03-27 04:00:00 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sun Mar 27 00:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 00:00:00 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 21:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 01:00:00 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 22:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 01:59:59 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 22:59:59 2011 UTC
(1 row)

SELECT '2011-03-27 02:00:00 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 22:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 02:00:01 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 22:00:01 2011 UTC
(1 row)

SELECT '2011-03-27 02:59:59 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 22:59:59 2011 UTC
(1 row)

SELECT '2011-03-27 03:00:00 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 23:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 03:00:01 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Mar 26 23:00:01 2011 UTC
(1 row)

SELECT '2011-03-27 04:00:00 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sun Mar 27 00:00:00 2011 UTC
(1 row)

SELECT '2014-10-26 00:00:00 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Oct 25 20:00:00 2014 UTC
(1 row)

SELECT '2014-10-26 00:59:59 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Oct 25 20:59:59 2014 UTC
(1 row)

SELECT '2014-10-26 01:00:00 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Oct 25 22:00:00 2014 UTC
(1 row)

SELECT '2014-10-26 01:00:01 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Oct 25 22:00:01 2014 UTC
(1 row)

SELECT '2014-10-26 02:00:00 Europe/Moscow'::timestamptz;
         timestamptz          
------------------------------
 Sat Oct 25 23:00:00 2014 UTC
(1 row)

SELECT '2014-10-26 00:00:00 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Oct 25 20:00:00 2014 UTC
(1 row)

SELECT '2014-10-26 00:59:59 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Oct 25 20:59:59 2014 UTC
(1 row)

SELECT '2014-10-26 01:00:00 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Oct 25 22:00:00 2014 UTC
(1 row)

SELECT '2014-10-26 01:00:01 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Oct 25 22:00:01 2014 UTC
(1 row)

SELECT '2014-10-26 02:00:00 MSK'::timestamptz;
         timestamptz          
------------------------------
 Sat Oct 25 23:00:00 2014 UTC
(1 row)

SELECT '2011-03-27 00:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Mar 26 21:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 01:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Mar 26 22:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 01:59:59'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Mar 26 22:59:59 2011 UTC
(1 row)

SELECT '2011-03-27 02:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Mar 26 23:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 02:00:01'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Mar 26 23:00:01 2011 UTC
(1 row)

SELECT '2011-03-27 02:59:59'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Mar 26 23:59:59 2011 UTC
(1 row)

SELECT '2011-03-27 03:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Mar 26 23:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 03:00:01'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Mar 26 23:00:01 2011 UTC
(1 row)

SELECT '2011-03-27 04:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sun Mar 27 00:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 00:00:00'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Mar 26 21:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 01:00:00'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Mar 26 22:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 01:59:59'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Mar 26 22:59:59 2011 UTC
(1 row)

SELECT '2011-03-27 02:00:00'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Mar 26 22:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 02:00:01'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Mar 26 22:00:01 2011 UTC
(1 row)

SELECT '2011-03-27 02:59:59'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Mar 26 22:59:59 2011 UTC
(1 row)

SELECT '2011-03-27 03:00:00'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Mar 26 23:00:00 2011 UTC
(1 row)

SELECT '2011-03-27 03:00:01'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Mar 26 23:00:01 2011 UTC
(1 row)

SELECT '2011-03-27 04:00:00'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sun Mar 27 00:00:00 2011 UTC
(1 row)

SELECT '2014-10-26 00:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Oct 25 20:00:00 2014 UTC
(1 row)

SELECT '2014-10-26 00:59:59'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Oct 25 20:59:59 2014 UTC
(1 row)

SELECT '2014-10-26 01:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Oct 25 22:00:00 2014 UTC
(1 row)

SELECT '2014-10-26 01:00:01'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Oct 25 22:00:01 2014 UTC
(1 row)

SELECT '2014-10-26 02:00:00'::timestamp AT TIME ZONE 'Europe/Moscow';
           timezone           
------------------------------
 Sat Oct 25 23:00:00 2014 UTC
(1 row)

SELECT '2014-10-26 00:00:00'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Oct 25 20:00:00 2014 UTC
(1 row)

SELECT '2014-10-26 00:59:59'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Oct 25 20:59:59 2014 UTC
(1 row)

SELECT '2014-10-26 01:00:00'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Oct 25 22:00:00 2014 UTC
(1 row)

SELECT '2014-10-26 01:00:01'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Oct 25 22:00:01 2014 UTC
(1 row)

SELECT '2014-10-26 02:00:00'::timestamp AT TIME ZONE 'MSK';
           timezone           
------------------------------
 Sat Oct 25 23:00:00 2014 UTC
(1 row)

SELECT make_timestamptz(2014, 10, 26, 0, 0, 0, 'MSK');
       make_timestamptz       
------------------------------
 Sat Oct 25 20:00:00 2014 UTC
(1 row)

SELECT make_timestamptz(2014, 10, 26, 1, 0, 0, 'MSK');
       make_timestamptz       
------------------------------
 Sat Oct 25 22:00:00 2014 UTC
(1 row)

SELECT to_timestamp(         0);          -- 1970-01-01 00:00:00+00
         to_timestamp         
------------------------------
 Thu Jan 01 00:00:00 1970 UTC
(1 row)

SELECT to_timestamp( 946684800);          -- 2000-01-01 00:00:00+00
         to_timestamp         
------------------------------
 Sat Jan 01 00:00:00 2000 UTC
(1 row)

SELECT to_timestamp(1262349296.7890123);  -- 2010-01-01 12:34:56.789012+00
            to_timestamp             
-------------------------------------
 Fri Jan 01 12:34:56.789012 2010 UTC
(1 row)

-- edge cases
SELECT to_timestamp(-210866803200);       --   4714-11-24 00:00:00+00 BC
          to_timestamp           
---------------------------------
 Mon Nov 24 00:00:00 4714 UTC BC
(1 row)

-- upper limit varies between integer and float timestamps, so hard to test
-- nonfinite values
SELECT to_timestamp(' Infinity'::float);
 to_timestamp 
--------------
 infinity
(1 row)

SELECT to_timestamp('-Infinity'::float);
 to_timestamp 
--------------
 -infinity
(1 row)

SELECT to_timestamp('NaN'::float);
ERROR:  timestamp cannot be NaN
SET TimeZone to 'Europe/Moscow';
SELECT '2011-03-26 21:00:00 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Mar 27 00:00:00 2011 MSK
(1 row)

SELECT '2011-03-26 22:00:00 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Mar 27 01:00:00 2011 MSK
(1 row)

SELECT '2011-03-26 22:59:59 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Mar 27 01:59:59 2011 MSK
(1 row)

SELECT '2011-03-26 23:00:00 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Mar 27 03:00:00 2011 MSK
(1 row)

SELECT '2011-03-26 23:00:01 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Mar 27 03:00:01 2011 MSK
(1 row)

SELECT '2011-03-26 23:59:59 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Mar 27 03:59:59 2011 MSK
(1 row)

SELECT '2011-03-27 00:00:00 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Mar 27 04:00:00 2011 MSK
(1 row)

SELECT '2014-10-25 21:00:00 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Oct 26 01:00:00 2014 MSK
(1 row)

SELECT '2014-10-25 21:59:59 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Oct 26 01:59:59 2014 MSK
(1 row)

SELECT '2014-10-25 22:00:00 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Oct 26 01:00:00 2014 MSK
(1 row)

SELECT '2014-10-25 22:00:01 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Oct 26 01:00:01 2014 MSK
(1 row)

SELECT '2014-10-25 23:00:00 UTC'::timestamptz;
         timestamptz          
------------------------------
 Sun Oct 26 02:00:00 2014 MSK
(1 row)

RESET TimeZone;
SELECT '2011-03-26 21:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Mar 27 00:00:00 2011
(1 row)

SELECT '2011-03-26 22:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Mar 27 01:00:00 2011
(1 row)

SELECT '2011-03-26 22:59:59 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Mar 27 01:59:59 2011
(1 row)

SELECT '2011-03-26 23:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Mar 27 03:00:00 2011
(1 row)

SELECT '2011-03-26 23:00:01 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Mar 27 03:00:01 2011
(1 row)

SELECT '2011-03-26 23:59:59 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Mar 27 03:59:59 2011
(1 row)

SELECT '2011-03-27 00:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Mar 27 04:00:00 2011
(1 row)

SELECT '2014-10-25 21:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Oct 26 01:00:00 2014
(1 row)

SELECT '2014-10-25 21:59:59 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Oct 26 01:59:59 2014
(1 row)

SELECT '2014-10-25 22:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Oct 26 01:00:00 2014
(1 row)

SELECT '2014-10-25 22:00:01 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Oct 26 01:00:01 2014
(1 row)

SELECT '2014-10-25 23:00:00 UTC'::timestamptz AT TIME ZONE 'Europe/Moscow';
         timezone         
--------------------------
 Sun Oct 26 02:00:00 2014
(1 row)

SELECT '2011-03-26 21:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Mar 27 00:00:00 2011
(1 row)

SELECT '2011-03-26 22:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Mar 27 01:00:00 2011
(1 row)

SELECT '2011-03-26 22:59:59 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Mar 27 01:59:59 2011
(1 row)

SELECT '2011-03-26 23:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Mar 27 03:00:00 2011
(1 row)

SELECT '2011-03-26 23:00:01 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Mar 27 03:00:01 2011
(1 row)

SELECT '2011-03-26 23:59:59 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Mar 27 03:59:59 2011
(1 row)

SELECT '2011-03-27 00:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Mar 27 04:00:00 2011
(1 row)

SELECT '2014-10-25 21:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Oct 26 01:00:00 2014
(1 row)

SELECT '2014-10-25 21:59:59 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Oct 26 01:59:59 2014
(1 row)

SELECT '2014-10-25 22:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Oct 26 01:00:00 2014
(1 row)

SELECT '2014-10-25 22:00:01 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Oct 26 01:00:01 2014
(1 row)

SELECT '2014-10-25 23:00:00 UTC'::timestamptz AT TIME ZONE 'MSK';
         timezone         
--------------------------
 Sun Oct 26 02:00:00 2014
(1 row)

--
-- Test LOCAL time zone
--
BEGIN;
SET LOCAL TIME ZONE 'Europe/Paris';
VALUES (CAST('1978-07-07 19:38 America/New_York' AS TIMESTAMP WITH TIME ZONE) AT LOCAL);
         column1          
--------------------------
 Sat Jul 08 01:38:00 1978
(1 row)

VALUES (TIMESTAMP '1978-07-07 19:38' AT LOCAL);
            column1            
-------------------------------
 Fri Jul 07 19:38:00 1978 CEST
(1 row)

SET LOCAL TIME ZONE 'Australia/Sydney';
VALUES (CAST('1978-07-07 19:38 America/New_York' AS TIMESTAMP WITH TIME ZONE) AT LOCAL);
         column1          
--------------------------
 Sat Jul 08 09:38:00 1978
(1 row)

VALUES (TIMESTAMP '1978-07-07 19:38' AT LOCAL);
            column1            
-------------------------------
 Fri Jul 07 19:38:00 1978 AEST
(1 row)

SET LOCAL TimeZone TO 'UTC';
CREATE VIEW timestamp_local_view AS
  SELECT CAST('1978-07-07 19:38 America/New_York' AS TIMESTAMP WITH TIME ZONE) AT LOCAL AS ttz_at_local,
         timezone(CAST('1978-07-07 19:38 America/New_York' AS TIMESTAMP WITH TIME ZONE)) AS ttz_func,
         TIMESTAMP '1978-07-07 19:38' AT LOCAL AS t_at_local,
         timezone(TIMESTAMP '1978-07-07 19:38') AS t_func;
ERROR:  no schema has been selected to create in
SELECT pg_get_viewdef('timestamp_local_view', true);
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\x
TABLE timestamp_local_view;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
\x
DROP VIEW timestamp_local_view;
ERROR:  current transaction is aborted, commands ignored until end of transaction block
COMMIT;
--
-- Test that AT TIME ZONE isn't misoptimized when using an index (bug #14504)
--
create temp table tmptz (f1 timestamptz primary key);
insert into tmptz values ('2017-01-18 00:00+00');
explain (costs off)
select * from tmptz where f1 at time zone 'utc' = '2017-01-18 00:00';
                                             QUERY PLAN                                              
-----------------------------------------------------------------------------------------------------
 Seq Scan on tmptz
   Filter: ((f1 AT TIME ZONE 'utc'::text) = 'Wed Jan 18 00:00:00 2017'::timestamp without time zone)
(2 rows)

select * from tmptz where f1 at time zone 'utc' = '2017-01-18 00:00';
              f1              
------------------------------
 Tue Jan 17 16:00:00 2017 PST
(1 row)

-- test arithmetic with infinite timestamps
SELECT timestamptz 'infinity' - timestamptz 'infinity';
ERROR:  interval out of range
SELECT timestamptz 'infinity' - timestamptz '-infinity';
 ?column? 
----------
 infinity
(1 row)

SELECT timestamptz '-infinity' - timestamptz 'infinity';
 ?column?  
-----------
 -infinity
(1 row)

SELECT timestamptz '-infinity' - timestamptz '-infinity';
ERROR:  interval out of range
SELECT timestamptz 'infinity' - timestamptz '1995-08-06 12:12:12';
 ?column? 
----------
 infinity
(1 row)

SELECT timestamptz '-infinity' - timestamptz '1995-08-06 12:12:12';
 ?column?  
-----------
 -infinity
(1 row)

-- test age() with infinite timestamps
SELECT age(timestamptz 'infinity');
    age    
-----------
 -infinity
(1 row)

SELECT age(timestamptz '-infinity');
   age    
----------
 infinity
(1 row)

SELECT age(timestamptz 'infinity', timestamptz 'infinity');
ERROR:  interval out of range
SELECT age(timestamptz 'infinity', timestamptz '-infinity');
   age    
----------
 infinity
(1 row)

SELECT age(timestamptz '-infinity', timestamptz 'infinity');
    age    
-----------
 -infinity
(1 row)

SELECT age(timestamptz '-infinity', timestamptz '-infinity');
ERROR:  interval out of range
-- END setup from timestamptz 
-- START setup from interval
 
--
-- INTERVAL
--
SET DATESTYLE = 'ISO';
SET IntervalStyle to postgres;
-- check acceptance of "time zone style"
SELECT INTERVAL '01:00' AS "One hour";
 One hour 
----------
 01:00:00
(1 row)

SELECT INTERVAL '+02:00' AS "Two hours";
 Two hours 
-----------
 02:00:00
(1 row)

SELECT INTERVAL '-08:00' AS "Eight hours";
 Eight hours 
-------------
 -08:00:00
(1 row)

SELECT INTERVAL '-1 +02:03' AS "22 hours ago...";
  22 hours ago...  
-------------------
 -1 days +02:03:00
(1 row)

SELECT INTERVAL '-1 days +02:03' AS "22 hours ago...";
  22 hours ago...  
-------------------
 -1 days +02:03:00
(1 row)

SELECT INTERVAL '1.5 weeks' AS "Ten days twelve hours";
 Ten days twelve hours 
-----------------------
 10 days 12:00:00
(1 row)

SELECT INTERVAL '1.5 months' AS "One month 15 days";
 One month 15 days 
-------------------
 1 mon 15 days
(1 row)

SELECT INTERVAL '10 years -11 month -12 days +13:14' AS "9 years...";
            9 years...            
----------------------------------
 9 years 1 mon -12 days +13:14:00
(1 row)

SELECT INTERVAL 'infinity' AS "eternity";
 eternity 
----------
 infinity
(1 row)

SELECT INTERVAL '-infinity' AS "beginning of time";
 beginning of time 
-------------------
 -infinity
(1 row)

CREATE TABLE INTERVAL_TBL (f1 interval);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE INTERVAL_TBL (f1 interval);
                     ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 1 minute');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 1 minute');
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 5 hour');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 5 hour');
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 10 day');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 10 day');
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 34 year');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 34 year');
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 3 months');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 3 months');
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 14 seconds ago');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 14 seconds ago');
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('1 day 2 hours 3 minutes 4 seconds');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('1 day 2 hours 3 minut...
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('6 years');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('6 years');
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('5 months');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('5 months');
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('5 months 12 hours');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('5 months 12 hours');
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('infinity');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('infinity');
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('-infinity');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('-infinity');
                    ^
-- badly formatted interval
INSERT INTO INTERVAL_TBL (f1) VALUES ('badly formatted interval');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('badly formatted inter...
                    ^
INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 30 eons ago');
ERROR:  relation "interval_tbl" does not exist
LINE 1: INSERT INTO INTERVAL_TBL (f1) VALUES ('@ 30 eons ago');
                    ^
-- Test non-error-throwing API
SELECT pg_input_is_valid('1.5 weeks', 'interval');
 pg_input_is_valid 
-------------------
 t
(1 row)

SELECT pg_input_is_valid('garbage', 'interval');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT pg_input_is_valid('@ 30 eons ago', 'interval');
 pg_input_is_valid 
-------------------
 f
(1 row)

SELECT * FROM pg_input_error_info('garbage', 'interval');
                      message                      | detail | hint | sql_error_code 
---------------------------------------------------+--------+------+----------------
 invalid input syntax for type interval: "garbage" |        |      | 22007
(1 row)

SELECT * FROM pg_input_error_info('@ 30 eons ago', 'interval');
                         message                         | detail | hint | sql_error_code 
---------------------------------------------------------+--------+------+----------------
 invalid input syntax for type interval: "@ 30 eons ago" |        |      | 22007
(1 row)

-- test interval operators
SELECT * FROM INTERVAL_TBL;
ERROR:  relation "interval_tbl" does not exist
LINE 1: SELECT * FROM INTERVAL_TBL;
                      ^
SELECT * FROM INTERVAL_TBL
   WHERE INTERVAL_TBL.f1 <> interval '@ 10 days';
ERROR:  relation "interval_tbl" does not exist
LINE 1: SELECT * FROM INTERVAL_TBL
                      ^
SELECT * FROM INTERVAL_TBL
   WHERE INTERVAL_TBL.f1 <= interval '@ 5 hours';
ERROR:  relation "interval_tbl" does not exist
LINE 1: SELECT * FROM INTERVAL_TBL
                      ^
SELECT * FROM INTERVAL_TBL
   WHERE INTERVAL_TBL.f1 < interval '@ 1 day';
ERROR:  relation "interval_tbl" does not exist
LINE 1: SELECT * FROM INTERVAL_TBL
                      ^
SELECT * FROM INTERVAL_TBL
   WHERE INTERVAL_TBL.f1 = interval '@ 34 years';
ERROR:  relation "interval_tbl" does not exist
LINE 1: SELECT * FROM INTERVAL_TBL
                      ^
SELECT * FROM INTERVAL_TBL
   WHERE INTERVAL_TBL.f1 >= interval '@ 1 month';
ERROR:  relation "interval_tbl" does not exist
LINE 1: SELECT * FROM INTERVAL_TBL
                      ^
SELECT * FROM INTERVAL_TBL
   WHERE INTERVAL_TBL.f1 > interval '@ 3 seconds ago';
ERROR:  relation "interval_tbl" does not exist
LINE 1: SELECT * FROM INTERVAL_TBL
                      ^
SELECT r1.*, r2.*
   FROM INTERVAL_TBL r1, INTERVAL_TBL r2
   WHERE r1.f1 > r2.f1
   ORDER BY r1.f1, r2.f1;
ERROR:  relation "interval_tbl" does not exist
LINE 2:    FROM INTERVAL_TBL r1, INTERVAL_TBL r2
                ^
-- test unary minus
SELECT f1, -f1 FROM INTERVAL_TBL;
ERROR:  relation "interval_tbl" does not exist
LINE 1: SELECT f1, -f1 FROM INTERVAL_TBL;
                            ^
SELECT -('-2147483648 months'::interval); -- should fail
ERROR:  interval out of range
SELECT -('-2147483647 months'::interval); -- ok
        ?column?        
------------------------
 178956970 years 7 mons
(1 row)

SELECT -('-2147483648 days'::interval); -- should fail
ERROR:  interval out of range
SELECT -('-2147483647 days'::interval); -- ok
    ?column?     
-----------------
 2147483647 days
(1 row)

SELECT -('-9223372036854775808 us'::interval); -- should fail
ERROR:  interval out of range
SELECT -('-9223372036854775807 us'::interval); -- ok
        ?column?         
-------------------------
 2562047788:00:54.775807
(1 row)

SELECT -('-2147483647 months -2147483647 days -9223372036854775807 us'::interval); -- should fail
ERROR:  interval out of range
-- Test intervals that are large enough to overflow 64 bits in comparisons
CREATE TEMP TABLE INTERVAL_TBL_OF (f1 interval);
INSERT INTO INTERVAL_TBL_OF (f1) VALUES
  ('2147483647 days 2147483647 months'),
  ('2147483647 days -2147483648 months'),
  ('1 year'),
  ('-2147483648 days 2147483647 months'),
  ('-2147483648 days -2147483648 months');
-- these should fail as out-of-range
INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('2147483648 days');
ERROR:  interval field value out of range: "2147483648 days"
LINE 1: INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('2147483648 days');
                                                 ^
INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('-2147483649 days');
ERROR:  interval field value out of range: "-2147483649 days"
LINE 1: INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('-2147483649 days')...
                                                 ^
INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('2147483647 years');
ERROR:  interval out of range
LINE 1: INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('2147483647 years')...
                                                 ^
INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('-2147483648 years');
ERROR:  interval out of range
LINE 1: INSERT INTO INTERVAL_TBL_OF (f1) VALUES ('-2147483648 years'...
                                                 ^
-- Test edge-case overflow detection in interval multiplication
select extract(epoch from '256 microseconds'::interval * (2^55)::float8);
ERROR:  interval out of range
SELECT r1.*, r2.*
   FROM INTERVAL_TBL_OF r1, INTERVAL_TBL_OF r2
   WHERE r1.f1 > r2.f1
   ORDER BY r1.f1, r2.f1;
                    f1                     |                    f1                     
-------------------------------------------+-------------------------------------------
 -178956970 years -8 mons +2147483647 days | -178956970 years -8 mons -2147483648 days
 1 year                                    | -178956970 years -8 mons -2147483648 days
 1 year                                    | -178956970 years -8 mons +2147483647 days
 178956970 years 7 mons -2147483648 days   | -178956970 years -8 mons -2147483648 days
 178956970 years 7 mons -2147483648 days   | -178956970 years -8 mons +2147483647 days
 178956970 years 7 mons -2147483648 days   | 1 year
 178956970 years 7 mons 2147483647 days    | -178956970 years -8 mons -2147483648 days
 178956970 years 7 mons 2147483647 days    | -178956970 years -8 mons +2147483647 days
 178956970 years 7 mons 2147483647 days    | 1 year
 178956970 years 7 mons 2147483647 days    | 178956970 years 7 mons -2147483648 days
(10 rows)

CREATE INDEX ON INTERVAL_TBL_OF USING btree (f1);
SET enable_seqscan TO false;
EXPLAIN (COSTS OFF)
SELECT f1 FROM INTERVAL_TBL_OF r1 ORDER BY f1;
                             QUERY PLAN                             
--------------------------------------------------------------------
 Index Only Scan using interval_tbl_of_f1_idx on interval_tbl_of r1
(1 row)

SELECT f1 FROM INTERVAL_TBL_OF r1 ORDER BY f1;
                    f1                     
-------------------------------------------
 -178956970 years -8 mons -2147483648 days
 -178956970 years -8 mons +2147483647 days
 1 year
 178956970 years 7 mons -2147483648 days
 178956970 years 7 mons 2147483647 days
(5 rows)

RESET enable_seqscan;
-- subtracting about-to-overflow values should result in 0
SELECT f1 - f1 FROM INTERVAL_TBL_OF;
 ?column? 
----------
 00:00:00
 00:00:00
 00:00:00
 00:00:00
 00:00:00
(5 rows)

DROP TABLE INTERVAL_TBL_OF;
-- Test multiplication and division with intervals.
-- Floating point arithmetic rounding errors can lead to unexpected results,
-- though the code attempts to do the right thing and round up to days and
-- minutes to avoid results such as '3 days 24:00 hours' or '14:20:60'.
-- Note that it is expected for some day components to be greater than 29 and
-- some time components be greater than 23:59:59 due to how intervals are
-- stored internally.
CREATE TABLE INTERVAL_MULDIV_TBL (span interval);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE INTERVAL_MULDIV_TBL (span interval);
                     ^
COPY INTERVAL_MULDIV_TBL FROM STDIN;
ERROR:  relation "interval_muldiv_tbl" does not exist
41 mon 12 days 360:00
-41 mon -12 days +360:00
-12 days
9 mon -27 days 12:34:56
-3 years 482 days 76:54:32.189
4 mon
14 mon
999 mon 999 days
\.
invalid command \.
SELECT span * 0.3 AS product
FROM INTERVAL_MULDIV_TBL;
ERROR:  syntax error at or near "41"
LINE 1: 41 mon 12 days 360:00
        ^
SELECT span * 8.2 AS product
FROM INTERVAL_MULDIV_TBL;
ERROR:  relation "interval_muldiv_tbl" does not exist
LINE 2: FROM INTERVAL_MULDIV_TBL;
             ^
SELECT span / 10 AS quotient
FROM INTERVAL_MULDIV_TBL;
ERROR:  relation "interval_muldiv_tbl" does not exist
LINE 2: FROM INTERVAL_MULDIV_TBL;
             ^
SELECT span / 100 AS quotient
FROM INTERVAL_MULDIV_TBL;
ERROR:  relation "interval_muldiv_tbl" does not exist
LINE 2: FROM INTERVAL_MULDIV_TBL;
             ^
DROP TABLE INTERVAL_MULDIV_TBL;
ERROR:  table "interval_muldiv_tbl" does not exist
SET DATESTYLE = 'postgres';
SET IntervalStyle to postgres_verbose;
SELECT * FROM INTERVAL_TBL;
ERROR:  relation "interval_tbl" does not exist
LINE 1: SELECT * FROM INTERVAL_TBL;
                      ^
-- multiplication and division overflow test cases
SELECT '3000000 months'::interval * 1000;
ERROR:  interval out of range
SELECT '3000000 months'::interval / 0.001;
ERROR:  interval out of range
SELECT '3000000 days'::interval * 1000;
ERROR:  interval out of range
SELECT '3000000 days'::interval / 0.001;
ERROR:  interval out of range
SELECT '1 month 2146410 days'::interval * 1000.5002;
ERROR:  interval out of range
SELECT '4611686018427387904 usec'::interval / 0.1;
ERROR:  interval out of range
-- test avg(interval), which is somewhat fragile since people have been
-- known to change the allowed input syntax for type interval without
-- updating pg_aggregate.agginitval
select avg(f1) from interval_tbl where isfinite(f1);
ERROR:  relation "interval_tbl" does not exist
LINE 1: select avg(f1) from interval_tbl where isfinite(f1);
                            ^
-- test long interval input
select '4 millenniums 5 centuries 4 decades 1 year 4 months 4 days 17 minutes 31 seconds'::interval;
                  interval                  
--------------------------------------------
 @ 4541 years 4 mons 4 days 17 mins 31 secs
(1 row)

-- test long interval output
-- Note: the actual maximum length of the interval output is longer,
-- but we need the test to work for both integer and floating-point
-- timestamps.
select '100000000y 10mon -1000000000d -100000h -10min -10.000001s ago'::interval;
                                       interval                                        
---------------------------------------------------------------------------------------
 @ 100000000 years 10 mons -1000000000 days -100000 hours -10 mins -10.000001 secs ago
(1 row)

-- test justify_hours() and justify_days()
SELECT justify_hours(interval '6 months 3 days 52 hours 3 minutes 2 seconds') as "6 mons 5 days 4 hours 3 mins 2 seconds";
 6 mons 5 days 4 hours 3 mins 2 seconds 
----------------------------------------
 @ 6 mons 5 days 4 hours 3 mins 2 secs
(1 row)

SELECT justify_days(interval '6 months 36 days 5 hours 4 minutes 3 seconds') as "7 mons 6 days 5 hours 4 mins 3 seconds";
 7 mons 6 days 5 hours 4 mins 3 seconds 
----------------------------------------
 @ 7 mons 6 days 5 hours 4 mins 3 secs
(1 row)

SELECT justify_hours(interval '2147483647 days 24 hrs');
ERROR:  interval out of range
SELECT justify_days(interval '2147483647 months 30 days');
ERROR:  interval out of range
-- test justify_interval()
SELECT justify_interval(interval '1 month -1 hour') as "1 month -1 hour";
  1 month -1 hour   
--------------------
 @ 29 days 23 hours
(1 row)

SELECT justify_interval(interval '2147483647 days 24 hrs');
       justify_interval        
-------------------------------
 @ 5965232 years 4 mons 8 days
(1 row)

SELECT justify_interval(interval '-2147483648 days -24 hrs');
         justify_interval          
-----------------------------------
 @ 5965232 years 4 mons 9 days ago
(1 row)

SELECT justify_interval(interval '2147483647 months 30 days');
ERROR:  interval out of range
SELECT justify_interval(interval '-2147483648 months -30 days');
ERROR:  interval out of range
SELECT justify_interval(interval '2147483647 months 30 days -24 hrs');
         justify_interval         
----------------------------------
 @ 178956970 years 7 mons 29 days
(1 row)

SELECT justify_interval(interval '-2147483648 months -30 days 24 hrs');
           justify_interval           
--------------------------------------
 @ 178956970 years 8 mons 29 days ago
(1 row)

SELECT justify_interval(interval '2147483647 months -30 days 1440 hrs');
ERROR:  interval out of range
SELECT justify_interval(interval '-2147483648 months 30 days -1440 hrs');
ERROR:  interval out of range
-- test fractional second input, and detection of duplicate units
SET DATESTYLE = 'ISO';
SET IntervalStyle TO postgres;
SELECT '1 millisecond'::interval, '1 microsecond'::interval,
       '500 seconds 99 milliseconds 51 microseconds'::interval;
   interval   |    interval     |    interval     
--------------+-----------------+-----------------
 00:00:00.001 | 00:00:00.000001 | 00:08:20.099051
(1 row)

SELECT '3 days 5 milliseconds'::interval;
      interval       
---------------------
 3 days 00:00:00.005
(1 row)

SELECT '1 second 2 seconds'::interval;              -- error
ERROR:  invalid input syntax for type interval: "1 second 2 seconds"
LINE 1: SELECT '1 second 2 seconds'::interval;
               ^
SELECT '10 milliseconds 20 milliseconds'::interval; -- error
ERROR:  invalid input syntax for type interval: "10 milliseconds 20 milliseconds"
LINE 1: SELECT '10 milliseconds 20 milliseconds'::interval;
               ^
SELECT '5.5 seconds 3 milliseconds'::interval;      -- error
ERROR:  invalid input syntax for type interval: "5.5 seconds 3 milliseconds"
LINE 1: SELECT '5.5 seconds 3 milliseconds'::interval;
               ^
SELECT '1:20:05 5 microseconds'::interval;          -- error
ERROR:  invalid input syntax for type interval: "1:20:05 5 microseconds"
LINE 1: SELECT '1:20:05 5 microseconds'::interval;
               ^
SELECT '1 day 1 day'::interval;                     -- error
ERROR:  invalid input syntax for type interval: "1 day 1 day"
LINE 1: SELECT '1 day 1 day'::interval;
               ^
SELECT interval '1-2';  -- SQL year-month literal
   interval    
---------------
 1 year 2 mons
(1 row)

SELECT interval '999' second;  -- oversize leading field is ok
 interval 
----------
 00:16:39
(1 row)

SELECT interval '999' minute;
 interval 
----------
 16:39:00
(1 row)

SELECT interval '999' hour;
 interval  
-----------
 999:00:00
(1 row)

SELECT interval '999' day;
 interval 
----------
 999 days
(1 row)

SELECT interval '999' month;
    interval     
-----------------
 83 years 3 mons
(1 row)

-- test SQL-spec syntaxes for restricted field sets
SELECT interval '1' year;
 interval 
----------
 1 year
(1 row)

SELECT interval '2' month;
 interval 
----------
 2 mons
(1 row)

SELECT interval '3' day;
 interval 
----------
 3 days
(1 row)

SELECT interval '4' hour;
 interval 
----------
 04:00:00
(1 row)

SELECT interval '5' minute;
 interval 
----------
 00:05:00
(1 row)

SELECT interval '6' second;
 interval 
----------
 00:00:06
(1 row)

SELECT interval '1' year to month;
 interval 
----------
 1 mon
(1 row)

SELECT interval '1-2' year to month;
   interval    
---------------
 1 year 2 mons
(1 row)

SELECT interval '1 2' day to hour;
    interval    
----------------
 1 day 02:00:00
(1 row)

SELECT interval '1 2:03' day to hour;
    interval    
----------------
 1 day 02:00:00
(1 row)

SELECT interval '1 2:03:04' day to hour;
    interval    
----------------
 1 day 02:00:00
(1 row)

SELECT interval '1 2' day to minute;
ERROR:  invalid input syntax for type interval: "1 2"
LINE 1: SELECT interval '1 2' day to minute;
                        ^
SELECT interval '1 2:03' day to minute;
    interval    
----------------
 1 day 02:03:00
(1 row)

SELECT interval '1 2:03:04' day to minute;
    interval    
----------------
 1 day 02:03:00
(1 row)

SELECT interval '1 2' day to second;
ERROR:  invalid input syntax for type interval: "1 2"
LINE 1: SELECT interval '1 2' day to second;
                        ^
SELECT interval '1 2:03' day to second;
    interval    
----------------
 1 day 02:03:00
(1 row)

SELECT interval '1 2:03:04' day to second;
    interval    
----------------
 1 day 02:03:04
(1 row)

SELECT interval '1 2' hour to minute;
ERROR:  invalid input syntax for type interval: "1 2"
LINE 1: SELECT interval '1 2' hour to minute;
                        ^
SELECT interval '1 2:03' hour to minute;
    interval    
----------------
 1 day 02:03:00
(1 row)

SELECT interval '1 2:03:04' hour to minute;
    interval    
----------------
 1 day 02:03:00
(1 row)

SELECT interval '1 2' hour to second;
ERROR:  invalid input syntax for type interval: "1 2"
LINE 1: SELECT interval '1 2' hour to second;
                        ^
SELECT interval '1 2:03' hour to second;
    interval    
----------------
 1 day 02:03:00
(1 row)

SELECT interval '1 2:03:04' hour to second;
    interval    
----------------
 1 day 02:03:04
(1 row)

SELECT interval '1 2' minute to second;
ERROR:  invalid input syntax for type interval: "1 2"
LINE 1: SELECT interval '1 2' minute to second;
                        ^
SELECT interval '1 2:03' minute to second;
    interval    
----------------
 1 day 00:02:03
(1 row)

SELECT interval '1 2:03:04' minute to second;
    interval    
----------------
 1 day 02:03:04
(1 row)

SELECT interval '1 +2:03' minute to second;
    interval    
----------------
 1 day 00:02:03
(1 row)

SELECT interval '1 +2:03:04' minute to second;
    interval    
----------------
 1 day 02:03:04
(1 row)

SELECT interval '1 -2:03' minute to second;
    interval     
-----------------
 1 day -00:02:03
(1 row)

SELECT interval '1 -2:03:04' minute to second;
    interval     
-----------------
 1 day -02:03:04
(1 row)

SELECT interval '123 11' day to hour; -- ok
     interval      
-------------------
 123 days 11:00:00
(1 row)

SELECT interval '123 11' day; -- not ok
ERROR:  invalid input syntax for type interval: "123 11"
LINE 1: SELECT interval '123 11' day;
                        ^
SELECT interval '123 11'; -- not ok, too ambiguous
ERROR:  invalid input syntax for type interval: "123 11"
LINE 1: SELECT interval '123 11';
                        ^
SELECT interval '123 2:03 -2:04'; -- not ok, redundant hh:mm fields
ERROR:  invalid input syntax for type interval: "123 2:03 -2:04"
LINE 1: SELECT interval '123 2:03 -2:04';
                        ^
-- test syntaxes for restricted precision
SELECT interval(0) '1 day 01:23:45.6789';
    interval    
----------------
 1 day 01:23:46
(1 row)

SELECT interval(2) '1 day 01:23:45.6789';
     interval      
-------------------
 1 day 01:23:45.68
(1 row)

SELECT interval '12:34.5678' minute to second(2);  -- per SQL spec
  interval   
-------------
 00:12:34.57
(1 row)

SELECT interval '1.234' second;
   interval   
--------------
 00:00:01.234
(1 row)

SELECT interval '1.234' second(2);
  interval   
-------------
 00:00:01.23
(1 row)

SELECT interval '1 2.345' day to second(2);
ERROR:  invalid input syntax for type interval: "1 2.345"
LINE 1: SELECT interval '1 2.345' day to second(2);
                        ^
SELECT interval '1 2:03' day to second(2);
    interval    
----------------
 1 day 02:03:00
(1 row)

SELECT interval '1 2:03.4567' day to second(2);
     interval      
-------------------
 1 day 00:02:03.46
(1 row)

SELECT interval '1 2:03:04.5678' day to second(2);
     interval      
-------------------
 1 day 02:03:04.57
(1 row)

SELECT interval '1 2.345' hour to second(2);
ERROR:  invalid input syntax for type interval: "1 2.345"
LINE 1: SELECT interval '1 2.345' hour to second(2);
                        ^
SELECT interval '1 2:03.45678' hour to second(2);
     interval      
-------------------
 1 day 00:02:03.46
(1 row)

SELECT interval '1 2:03:04.5678' hour to second(2);
     interval      
-------------------
 1 day 02:03:04.57
(1 row)

SELECT interval '1 2.3456' minute to second(2);
ERROR:  invalid input syntax for type interval: "1 2.3456"
LINE 1: SELECT interval '1 2.3456' minute to second(2);
                        ^
SELECT interval '1 2:03.5678' minute to second(2);
     interval      
-------------------
 1 day 00:02:03.57
(1 row)

SELECT interval '1 2:03:04.5678' minute to second(2);
     interval      
-------------------
 1 day 02:03:04.57
(1 row)

SELECT interval '2562047788:00:54.775807' second(2);  -- out of range
ERROR:  interval out of range
LINE 1: SELECT interval '2562047788:00:54.775807' second(2);
                        ^
SELECT interval '-2562047788:00:54.775807' second(2);  -- out of range
ERROR:  interval out of range
LINE 1: SELECT interval '-2562047788:00:54.775807' second(2);
                        ^
-- test casting to restricted precision (bug #14479)
SELECT f1, f1::INTERVAL DAY TO MINUTE AS "minutes",
  (f1 + INTERVAL '1 month')::INTERVAL MONTH::INTERVAL YEAR AS "years"
  FROM interval_tbl;
ERROR:  relation "interval_tbl" does not exist
LINE 3:   FROM interval_tbl;
               ^
-- test inputting and outputting SQL standard interval literals
SET IntervalStyle TO sql_standard;
SELECT  interval '0'                       AS "zero",
        interval '1-2' year to month       AS "year-month",
        interval '1 2:03:04' day to second AS "day-time",
        - interval '1-2'                   AS "negative year-month",
        - interval '1 2:03:04'             AS "negative day-time";
 zero | year-month | day-time  | negative year-month | negative day-time 
------+------------+-----------+---------------------+-------------------
 0    | 1-2        | 1 2:03:04 | -1-2                | -1 2:03:04
(1 row)

-- test input of some not-quite-standard interval values in the sql style
SET IntervalStyle TO postgres;
SELECT  interval '+1 -1:00:00',
        interval '-1 +1:00:00',
        interval '+1-2 -3 +4:05:06.789',
        interval '-1-2 +3 -4:05:06.789';
    interval     |     interval      |              interval               |                interval                
-----------------+-------------------+-------------------------------------+----------------------------------------
 1 day -01:00:00 | -1 days +01:00:00 | 1 year 2 mons -3 days +04:05:06.789 | -1 years -2 mons +3 days -04:05:06.789
(1 row)

-- cases that trigger sign-matching rules in the sql style
SELECT  interval '-23 hours 45 min 12.34 sec',
        interval '-1 day 23 hours 45 min 12.34 sec',
        interval '-1 year 2 months 1 day 23 hours 45 min 12.34 sec',
        interval '-1 year 2 months 1 day 23 hours 45 min +12.34 sec';
   interval   |       interval       |          interval           |          interval           
--------------+----------------------+-----------------------------+-----------------------------
 -22:14:47.66 | -1 days +23:45:12.34 | -10 mons +1 day 23:45:12.34 | -10 mons +1 day 23:45:12.34
(1 row)

-- test output of couple non-standard interval values in the sql style
SET IntervalStyle TO sql_standard;
SELECT  interval '1 day -1 hours',
        interval '-1 days +1 hours',
        interval '1 years 2 months -3 days 4 hours 5 minutes 6.789 seconds',
        - interval '1 years 2 months -3 days 4 hours 5 minutes 6.789 seconds';
     interval     |     interval     |       interval       |       ?column?       
------------------+------------------+----------------------+----------------------
 +0-0 +1 -1:00:00 | +0-0 -1 +1:00:00 | +1-2 -3 +4:05:06.789 | -1-2 +3 -4:05:06.789
(1 row)

-- cases that trigger sign-matching rules in the sql style
SELECT  interval '-23 hours 45 min 12.34 sec',
        interval '-1 day 23 hours 45 min 12.34 sec',
        interval '-1 year 2 months 1 day 23 hours 45 min 12.34 sec',
        interval '-1 year 2 months 1 day 23 hours 45 min +12.34 sec';
   interval   |    interval    |       interval       |       interval        
--------------+----------------+----------------------+-----------------------
 -23:45:12.34 | -1 23:45:12.34 | -1-2 -1 -23:45:12.34 | -0-10 +1 +23:45:12.34
(1 row)

-- edge case for sign-matching rules
SELECT  interval '';  -- error
ERROR:  invalid input syntax for type interval: ""
LINE 1: SELECT  interval '';
                         ^
-- test outputting iso8601 intervals
SET IntervalStyle to iso_8601;
select  interval '0'                                AS "zero",
        interval '1-2'                              AS "a year 2 months",
        interval '1 2:03:04'                        AS "a bit over a day",
        interval '2:03:04.45679'                    AS "a bit over 2 hours",
        (interval '1-2' + interval '3 4:05:06.7')   AS "all fields",
        (interval '1-2' - interval '3 4:05:06.7')   AS "mixed sign",
        (- interval '1-2' + interval '3 4:05:06.7') AS "negative";
 zero | a year 2 months | a bit over a day | a bit over 2 hours |    all fields    |      mixed sign      |      negative      
------+-----------------+------------------+--------------------+------------------+----------------------+--------------------
 PT0S | P1Y2M           | P1DT2H3M4S       | PT2H3M4.45679S     | P1Y2M3DT4H5M6.7S | P1Y2M-3DT-4H-5M-6.7S | P-1Y-2M3DT4H5M6.7S
(1 row)

-- test inputting ISO 8601 4.4.2.1 "Format With Time Unit Designators"
SET IntervalStyle to sql_standard;
select  interval 'P0Y'                    AS "zero",
        interval 'P1Y2M'                  AS "a year 2 months",
        interval 'P1W'                    AS "a week",
        interval 'P1DT2H3M4S'             AS "a bit over a day",
        interval 'P1Y2M3DT4H5M6.7S'       AS "all fields",
        interval 'P-1Y-2M-3DT-4H-5M-6.7S' AS "negative",
        interval 'PT-0.1S'                AS "fractional second";
 zero | a year 2 months |  a week   | a bit over a day |     all fields     |      negative      | fractional second 
------+-----------------+-----------+------------------+--------------------+--------------------+-------------------
 0    | 1-2             | 7 0:00:00 | 1 2:03:04        | +1-2 +3 +4:05:06.7 | -1-2 -3 -4:05:06.7 | -0:00:00.1
(1 row)

-- test inputting ISO 8601 4.4.2.2 "Alternative Format"
SET IntervalStyle to postgres;
select  interval 'P00021015T103020'       AS "ISO8601 Basic Format",
        interval 'P0002-10-15T10:30:20'   AS "ISO8601 Extended Format";
       ISO8601 Basic Format       |     ISO8601 Extended Format      
----------------------------------+----------------------------------
 2 years 10 mons 15 days 10:30:20 | 2 years 10 mons 15 days 10:30:20
(1 row)

-- Make sure optional ISO8601 alternative format fields are optional.
select  interval 'P0002'                  AS "year only",
        interval 'P0002-10'               AS "year month",
        interval 'P0002-10-15'            AS "year month day",
        interval 'P0002T1S'               AS "year only plus time",
        interval 'P0002-10T1S'            AS "year month plus time",
        interval 'P0002-10-15T1S'         AS "year month day plus time",
        interval 'PT10'                   AS "hour only",
        interval 'PT10:30'                AS "hour minute";
 year only |   year month    |     year month day      | year only plus time |   year month plus time   |     year month day plus time     | hour only | hour minute 
-----------+-----------------+-------------------------+---------------------+--------------------------+----------------------------------+-----------+-------------
 2 years   | 2 years 10 mons | 2 years 10 mons 15 days | 2 years 00:00:01    | 2 years 10 mons 00:00:01 | 2 years 10 mons 15 days 00:00:01 | 10:00:00  | 10:30:00
(1 row)

-- Check handling of fractional fields in ISO8601 format.
select interval 'P1Y0M3DT4H5M6S';
        interval        
------------------------
 1 year 3 days 04:05:06
(1 row)

select interval 'P1.0Y0M3DT4H5M6S';
        interval        
------------------------
 1 year 3 days 04:05:06
(1 row)

select interval 'P1.1Y0M3DT4H5M6S';
           interval           
------------------------------
 1 year 1 mon 3 days 04:05:06
(1 row)

select interval 'P1.Y0M3DT4H5M6S';
        interval        
------------------------
 1 year 3 days 04:05:06
(1 row)

select interval 'P.1Y0M3DT4H5M6S';
       interval        
-----------------------
 1 mon 3 days 04:05:06
(1 row)

select interval 'P10.5e4Y';  -- not per spec, but we've historically taken it
   interval   
--------------
 105000 years
(1 row)

select interval 'P.Y0M3DT4H5M6S';  -- error
ERROR:  invalid input syntax for type interval: "P.Y0M3DT4H5M6S"
LINE 1: select interval 'P.Y0M3DT4H5M6S';
                        ^
-- test a couple rounding cases that changed since 8.3 w/ HAVE_INT64_TIMESTAMP.
SET IntervalStyle to postgres_verbose;
select interval '-10 mons -3 days +03:55:06.70';
                     interval                     
--------------------------------------------------
 @ 10 mons 3 days -3 hours -55 mins -6.7 secs ago
(1 row)

select interval '1 year 2 mons 3 days 04:05:06.699999';
                      interval                       
-----------------------------------------------------
 @ 1 year 2 mons 3 days 4 hours 5 mins 6.699999 secs
(1 row)

select interval '0:0:0.7', interval '@ 0.70 secs', interval '0.7 seconds';
  interval  |  interval  |  interval  
------------+------------+------------
 @ 0.7 secs | @ 0.7 secs | @ 0.7 secs
(1 row)

-- test time fields using entire 64 bit microseconds range
select interval '2562047788.01521550194 hours';
             interval              
-----------------------------------
 @ 2562047788 hours 54.775807 secs
(1 row)

select interval '-2562047788.01521550222 hours';
               interval                
---------------------------------------
 @ 2562047788 hours 54.775808 secs ago
(1 row)

select interval '153722867280.912930117 minutes';
             interval              
-----------------------------------
 @ 2562047788 hours 54.775807 secs
(1 row)

select interval '-153722867280.912930133 minutes';
               interval                
---------------------------------------
 @ 2562047788 hours 54.775808 secs ago
(1 row)

select interval '9223372036854.775807 seconds';
             interval              
-----------------------------------
 @ 2562047788 hours 54.775807 secs
(1 row)

select interval '-9223372036854.775808 seconds';
               interval                
---------------------------------------
 @ 2562047788 hours 54.775808 secs ago
(1 row)

select interval '9223372036854775.807 milliseconds';
             interval              
-----------------------------------
 @ 2562047788 hours 54.775807 secs
(1 row)

select interval '-9223372036854775.808 milliseconds';
               interval                
---------------------------------------
 @ 2562047788 hours 54.775808 secs ago
(1 row)

select interval '9223372036854775807 microseconds';
             interval              
-----------------------------------
 @ 2562047788 hours 54.775807 secs
(1 row)

select interval '-9223372036854775808 microseconds';
               interval                
---------------------------------------
 @ 2562047788 hours 54.775808 secs ago
(1 row)

select interval 'PT2562047788H54.775807S';
             interval              
-----------------------------------
 @ 2562047788 hours 54.775807 secs
(1 row)

select interval 'PT-2562047788H-54.775808S';
               interval                
---------------------------------------
 @ 2562047788 hours 54.775808 secs ago
(1 row)

select interval 'PT2562047788:00:54.775807';
             interval              
-----------------------------------
 @ 2562047788 hours 54.775807 secs
(1 row)

select interval 'PT2562047788.0152155019444';
             interval              
-----------------------------------
 @ 2562047788 hours 54.775429 secs
(1 row)

select interval 'PT-2562047788.0152155022222';
               interval                
---------------------------------------
 @ 2562047788 hours 54.775429 secs ago
(1 row)

-- overflow each date/time field
select interval '2147483648 years';
ERROR:  interval field value out of range: "2147483648 years"
LINE 1: select interval '2147483648 years';
                        ^
select interval '-2147483649 years';
ERROR:  interval field value out of range: "-2147483649 years"
LINE 1: select interval '-2147483649 years';
                        ^
select interval '2147483648 months';
ERROR:  interval field value out of range: "2147483648 months"
LINE 1: select interval '2147483648 months';
                        ^
select interval '-2147483649 months';
ERROR:  interval field value out of range: "-2147483649 months"
LINE 1: select interval '-2147483649 months';
                        ^
select interval '2147483648 days';
ERROR:  interval field value out of range: "2147483648 days"
LINE 1: select interval '2147483648 days';
                        ^
select interval '-2147483649 days';
ERROR:  interval field value out of range: "-2147483649 days"
LINE 1: select interval '-2147483649 days';
                        ^
select interval '2562047789 hours';
ERROR:  interval field value out of range: "2562047789 hours"
LINE 1: select interval '2562047789 hours';
                        ^
select interval '-2562047789 hours';
ERROR:  interval field value out of range: "-2562047789 hours"
LINE 1: select interval '-2562047789 hours';
                        ^
select interval '153722867281 minutes';
ERROR:  interval field value out of range: "153722867281 minutes"
LINE 1: select interval '153722867281 minutes';
                        ^
select interval '-153722867281 minutes';
ERROR:  interval field value out of range: "-153722867281 minutes"
LINE 1: select interval '-153722867281 minutes';
                        ^
select interval '9223372036855 seconds';
ERROR:  interval field value out of range: "9223372036855 seconds"
LINE 1: select interval '9223372036855 seconds';
                        ^
select interval '-9223372036855 seconds';
ERROR:  interval field value out of range: "-9223372036855 seconds"
LINE 1: select interval '-9223372036855 seconds';
                        ^
select interval '9223372036854777 millisecond';
ERROR:  interval field value out of range: "9223372036854777 millisecond"
LINE 1: select interval '9223372036854777 millisecond';
                        ^
select interval '-9223372036854777 millisecond';
ERROR:  interval field value out of range: "-9223372036854777 millisecond"
LINE 1: select interval '-9223372036854777 millisecond';
                        ^
select interval '9223372036854775808 microsecond';
ERROR:  interval field value out of range: "9223372036854775808 microsecond"
LINE 1: select interval '9223372036854775808 microsecond';
                        ^
select interval '-9223372036854775809 microsecond';
ERROR:  interval field value out of range: "-9223372036854775809 microsecond"
LINE 1: select interval '-9223372036854775809 microsecond';
                        ^
select interval 'P2147483648';
ERROR:  interval field value out of range: "P2147483648"
LINE 1: select interval 'P2147483648';
                        ^
select interval 'P-2147483649';
ERROR:  interval field value out of range: "P-2147483649"
LINE 1: select interval 'P-2147483649';
                        ^
select interval 'P1-2147483647-2147483647';
ERROR:  interval out of range
LINE 1: select interval 'P1-2147483647-2147483647';
                        ^
select interval 'PT2562047789';
ERROR:  interval field value out of range: "PT2562047789"
LINE 1: select interval 'PT2562047789';
                        ^
select interval 'PT-2562047789';
ERROR:  interval field value out of range: "PT-2562047789"
LINE 1: select interval 'PT-2562047789';
                        ^
-- overflow with date/time unit aliases
select interval '2147483647 weeks';
ERROR:  interval field value out of range: "2147483647 weeks"
LINE 1: select interval '2147483647 weeks';
                        ^
select interval '-2147483648 weeks';
ERROR:  interval field value out of range: "-2147483648 weeks"
LINE 1: select interval '-2147483648 weeks';
                        ^
select interval '2147483647 decades';
ERROR:  interval field value out of range: "2147483647 decades"
LINE 1: select interval '2147483647 decades';
                        ^
select interval '-2147483648 decades';
ERROR:  interval field value out of range: "-2147483648 decades"
LINE 1: select interval '-2147483648 decades';
                        ^
select interval '2147483647 centuries';
ERROR:  interval field value out of range: "2147483647 centuries"
LINE 1: select interval '2147483647 centuries';
                        ^
select interval '-2147483648 centuries';
ERROR:  interval field value out of range: "-2147483648 centuries"
LINE 1: select interval '-2147483648 centuries';
                        ^
select interval '2147483647 millennium';
ERROR:  interval field value out of range: "2147483647 millennium"
LINE 1: select interval '2147483647 millennium';
                        ^
select interval '-2147483648 millennium';
ERROR:  interval field value out of range: "-2147483648 millennium"
LINE 1: select interval '-2147483648 millennium';
                        ^
select interval '1 week 2147483647 days';
ERROR:  interval field value out of range: "1 week 2147483647 days"
LINE 1: select interval '1 week 2147483647 days';
                        ^
select interval '-1 week -2147483648 days';
ERROR:  interval field value out of range: "-1 week -2147483648 days"
LINE 1: select interval '-1 week -2147483648 days';
                        ^
select interval '2147483647 days 1 week';
ERROR:  interval field value out of range: "2147483647 days 1 week"
LINE 1: select interval '2147483647 days 1 week';
                        ^
select interval '-2147483648 days -1 week';
ERROR:  interval field value out of range: "-2147483648 days -1 week"
LINE 1: select interval '-2147483648 days -1 week';
                        ^
select interval 'P1W2147483647D';
ERROR:  interval field value out of range: "P1W2147483647D"
LINE 1: select interval 'P1W2147483647D';
                        ^
select interval 'P-1W-2147483648D';
ERROR:  interval field value out of range: "P-1W-2147483648D"
LINE 1: select interval 'P-1W-2147483648D';
                        ^
select interval 'P2147483647D1W';
ERROR:  interval field value out of range: "P2147483647D1W"
LINE 1: select interval 'P2147483647D1W';
                        ^
select interval 'P-2147483648D-1W';
ERROR:  interval field value out of range: "P-2147483648D-1W"
LINE 1: select interval 'P-2147483648D-1W';
                        ^
select interval '1 decade 2147483647 years';
ERROR:  interval field value out of range: "1 decade 2147483647 years"
LINE 1: select interval '1 decade 2147483647 years';
                        ^
select interval '1 century 2147483647 years';
ERROR:  interval field value out of range: "1 century 2147483647 years"
LINE 1: select interval '1 century 2147483647 years';
                        ^
select interval '1 millennium 2147483647 years';
ERROR:  interval field value out of range: "1 millennium 2147483647 years"
LINE 1: select interval '1 millennium 2147483647 years';
                        ^
select interval '-1 decade -2147483648 years';
ERROR:  interval field value out of range: "-1 decade -2147483648 years"
LINE 1: select interval '-1 decade -2147483648 years';
                        ^
select interval '-1 century -2147483648 years';
ERROR:  interval field value out of range: "-1 century -2147483648 years"
LINE 1: select interval '-1 century -2147483648 years';
                        ^
select interval '-1 millennium -2147483648 years';
ERROR:  interval field value out of range: "-1 millennium -2147483648 years"
LINE 1: select interval '-1 millennium -2147483648 years';
                        ^
select interval '2147483647 years 1 decade';
ERROR:  interval field value out of range: "2147483647 years 1 decade"
LINE 1: select interval '2147483647 years 1 decade';
                        ^
select interval '2147483647 years 1 century';
ERROR:  interval field value out of range: "2147483647 years 1 century"
LINE 1: select interval '2147483647 years 1 century';
                        ^
select interval '2147483647 years 1 millennium';
ERROR:  interval field value out of range: "2147483647 years 1 millennium"
LINE 1: select interval '2147483647 years 1 millennium';
                        ^
select interval '-2147483648 years -1 decade';
ERROR:  interval field value out of range: "-2147483648 years -1 decade"
LINE 1: select interval '-2147483648 years -1 decade';
                        ^
select interval '-2147483648 years -1 century';
ERROR:  interval field value out of range: "-2147483648 years -1 century"
LINE 1: select interval '-2147483648 years -1 century';
                        ^
select interval '-2147483648 years -1 millennium';
ERROR:  interval field value out of range: "-2147483648 years -1 millennium"
LINE 1: select interval '-2147483648 years -1 millennium';
                        ^
-- overflowing with fractional fields - postgres format
select interval '0.1 millennium 2147483647 months';
ERROR:  interval field value out of range: "0.1 millennium 2147483647 months"
LINE 1: select interval '0.1 millennium 2147483647 months';
                        ^
select interval '0.1 centuries 2147483647 months';
ERROR:  interval field value out of range: "0.1 centuries 2147483647 months"
LINE 1: select interval '0.1 centuries 2147483647 months';
                        ^
select interval '0.1 decades 2147483647 months';
ERROR:  interval field value out of range: "0.1 decades 2147483647 months"
LINE 1: select interval '0.1 decades 2147483647 months';
                        ^
select interval '0.1 yrs 2147483647 months';
ERROR:  interval field value out of range: "0.1 yrs 2147483647 months"
LINE 1: select interval '0.1 yrs 2147483647 months';
                        ^
select interval '-0.1 millennium -2147483648 months';
ERROR:  interval field value out of range: "-0.1 millennium -2147483648 months"
LINE 1: select interval '-0.1 millennium -2147483648 months';
                        ^
select interval '-0.1 centuries -2147483648 months';
ERROR:  interval field value out of range: "-0.1 centuries -2147483648 months"
LINE 1: select interval '-0.1 centuries -2147483648 months';
                        ^
select interval '-0.1 decades -2147483648 months';
ERROR:  interval field value out of range: "-0.1 decades -2147483648 months"
LINE 1: select interval '-0.1 decades -2147483648 months';
                        ^
select interval '-0.1 yrs -2147483648 months';
ERROR:  interval field value out of range: "-0.1 yrs -2147483648 months"
LINE 1: select interval '-0.1 yrs -2147483648 months';
                        ^
select interval '2147483647 months 0.1 millennium';
ERROR:  interval field value out of range: "2147483647 months 0.1 millennium"
LINE 1: select interval '2147483647 months 0.1 millennium';
                        ^
select interval '2147483647 months 0.1 centuries';
ERROR:  interval field value out of range: "2147483647 months 0.1 centuries"
LINE 1: select interval '2147483647 months 0.1 centuries';
                        ^
select interval '2147483647 months 0.1 decades';
ERROR:  interval field value out of range: "2147483647 months 0.1 decades"
LINE 1: select interval '2147483647 months 0.1 decades';
                        ^
select interval '2147483647 months 0.1 yrs';
ERROR:  interval field value out of range: "2147483647 months 0.1 yrs"
LINE 1: select interval '2147483647 months 0.1 yrs';
                        ^
select interval '-2147483648 months -0.1 millennium';
ERROR:  interval field value out of range: "-2147483648 months -0.1 millennium"
LINE 1: select interval '-2147483648 months -0.1 millennium';
                        ^
select interval '-2147483648 months -0.1 centuries';
ERROR:  interval field value out of range: "-2147483648 months -0.1 centuries"
LINE 1: select interval '-2147483648 months -0.1 centuries';
                        ^
select interval '-2147483648 months -0.1 decades';
ERROR:  interval field value out of range: "-2147483648 months -0.1 decades"
LINE 1: select interval '-2147483648 months -0.1 decades';
                        ^
select interval '-2147483648 months -0.1 yrs';
ERROR:  interval field value out of range: "-2147483648 months -0.1 yrs"
LINE 1: select interval '-2147483648 months -0.1 yrs';
                        ^
select interval '0.1 months 2147483647 days';
ERROR:  interval field value out of range: "0.1 months 2147483647 days"
LINE 1: select interval '0.1 months 2147483647 days';
                        ^
select interval '-0.1 months -2147483648 days';
ERROR:  interval field value out of range: "-0.1 months -2147483648 days"
LINE 1: select interval '-0.1 months -2147483648 days';
                        ^
select interval '2147483647 days 0.1 months';
ERROR:  interval field value out of range: "2147483647 days 0.1 months"
LINE 1: select interval '2147483647 days 0.1 months';
                        ^
select interval '-2147483648 days -0.1 months';
ERROR:  interval field value out of range: "-2147483648 days -0.1 months"
LINE 1: select interval '-2147483648 days -0.1 months';
                        ^
select interval '0.5 weeks 2147483647 days';
ERROR:  interval field value out of range: "0.5 weeks 2147483647 days"
LINE 1: select interval '0.5 weeks 2147483647 days';
                        ^
select interval '-0.5 weeks -2147483648 days';
ERROR:  interval field value out of range: "-0.5 weeks -2147483648 days"
LINE 1: select interval '-0.5 weeks -2147483648 days';
                        ^
select interval '2147483647 days 0.5 weeks';
ERROR:  interval field value out of range: "2147483647 days 0.5 weeks"
LINE 1: select interval '2147483647 days 0.5 weeks';
                        ^
select interval '-2147483648 days -0.5 weeks';
ERROR:  interval field value out of range: "-2147483648 days -0.5 weeks"
LINE 1: select interval '-2147483648 days -0.5 weeks';
                        ^
select interval '0.01 months 9223372036854775807 microseconds';
ERROR:  interval field value out of range: "0.01 months 9223372036854775807 microseconds"
LINE 1: select interval '0.01 months 9223372036854775807 microsecond...
                        ^
select interval '-0.01 months -9223372036854775808 microseconds';
ERROR:  interval field value out of range: "-0.01 months -9223372036854775808 microseconds"
LINE 1: select interval '-0.01 months -9223372036854775808 microseco...
                        ^
select interval '9223372036854775807 microseconds 0.01 months';
ERROR:  interval field value out of range: "9223372036854775807 microseconds 0.01 months"
LINE 1: select interval '9223372036854775807 microseconds 0.01 month...
                        ^
select interval '-9223372036854775808 microseconds -0.01 months';
ERROR:  interval field value out of range: "-9223372036854775808 microseconds -0.01 months"
LINE 1: select interval '-9223372036854775808 microseconds -0.01 mon...
                        ^
select interval '0.1 weeks 9223372036854775807 microseconds';
ERROR:  interval field value out of range: "0.1 weeks 9223372036854775807 microseconds"
LINE 1: select interval '0.1 weeks 9223372036854775807 microseconds'...
                        ^
select interval '-0.1 weeks -9223372036854775808 microseconds';
ERROR:  interval field value out of range: "-0.1 weeks -9223372036854775808 microseconds"
LINE 1: select interval '-0.1 weeks -9223372036854775808 microsecond...
                        ^
select interval '9223372036854775807 microseconds 0.1 weeks';
ERROR:  interval field value out of range: "9223372036854775807 microseconds 0.1 weeks"
LINE 1: select interval '9223372036854775807 microseconds 0.1 weeks'...
                        ^
select interval '-9223372036854775808 microseconds -0.1 weeks';
ERROR:  interval field value out of range: "-9223372036854775808 microseconds -0.1 weeks"
LINE 1: select interval '-9223372036854775808 microseconds -0.1 week...
                        ^
select interval '0.1 days 9223372036854775807 microseconds';
ERROR:  interval field value out of range: "0.1 days 9223372036854775807 microseconds"
LINE 1: select interval '0.1 days 9223372036854775807 microseconds';
                        ^
select interval '-0.1 days -9223372036854775808 microseconds';
ERROR:  interval field value out of range: "-0.1 days -9223372036854775808 microseconds"
LINE 1: select interval '-0.1 days -9223372036854775808 microseconds...
                        ^
select interval '9223372036854775807 microseconds 0.1 days';
ERROR:  interval field value out of range: "9223372036854775807 microseconds 0.1 days"
LINE 1: select interval '9223372036854775807 microseconds 0.1 days';
                        ^
select interval '-9223372036854775808 microseconds -0.1 days';
ERROR:  interval field value out of range: "-9223372036854775808 microseconds -0.1 days"
LINE 1: select interval '-9223372036854775808 microseconds -0.1 days...
                        ^
-- overflowing with fractional fields - ISO8601 format
select interval 'P0.1Y2147483647M';
ERROR:  interval field value out of range: "P0.1Y2147483647M"
LINE 1: select interval 'P0.1Y2147483647M';
                        ^
select interval 'P-0.1Y-2147483648M';
ERROR:  interval field value out of range: "P-0.1Y-2147483648M"
LINE 1: select interval 'P-0.1Y-2147483648M';
                        ^
select interval 'P2147483647M0.1Y';
ERROR:  interval field value out of range: "P2147483647M0.1Y"
LINE 1: select interval 'P2147483647M0.1Y';
                        ^
select interval 'P-2147483648M-0.1Y';
ERROR:  interval field value out of range: "P-2147483648M-0.1Y"
LINE 1: select interval 'P-2147483648M-0.1Y';
                        ^
select interval 'P0.1M2147483647D';
ERROR:  interval field value out of range: "P0.1M2147483647D"
LINE 1: select interval 'P0.1M2147483647D';
                        ^
select interval 'P-0.1M-2147483648D';
ERROR:  interval field value out of range: "P-0.1M-2147483648D"
LINE 1: select interval 'P-0.1M-2147483648D';
                        ^
select interval 'P2147483647D0.1M';
ERROR:  interval field value out of range: "P2147483647D0.1M"
LINE 1: select interval 'P2147483647D0.1M';
                        ^
select interval 'P-2147483648D-0.1M';
ERROR:  interval field value out of range: "P-2147483648D-0.1M"
LINE 1: select interval 'P-2147483648D-0.1M';
                        ^
select interval 'P0.5W2147483647D';
ERROR:  interval field value out of range: "P0.5W2147483647D"
LINE 1: select interval 'P0.5W2147483647D';
                        ^
select interval 'P-0.5W-2147483648D';
ERROR:  interval field value out of range: "P-0.5W-2147483648D"
LINE 1: select interval 'P-0.5W-2147483648D';
                        ^
select interval 'P2147483647D0.5W';
ERROR:  interval field value out of range: "P2147483647D0.5W"
LINE 1: select interval 'P2147483647D0.5W';
                        ^
select interval 'P-2147483648D-0.5W';
ERROR:  interval field value out of range: "P-2147483648D-0.5W"
LINE 1: select interval 'P-2147483648D-0.5W';
                        ^
select interval 'P0.01MT2562047788H54.775807S';
ERROR:  interval field value out of range: "P0.01MT2562047788H54.775807S"
LINE 1: select interval 'P0.01MT2562047788H54.775807S';
                        ^
select interval 'P-0.01MT-2562047788H-54.775808S';
ERROR:  interval field value out of range: "P-0.01MT-2562047788H-54.775808S"
LINE 1: select interval 'P-0.01MT-2562047788H-54.775808S';
                        ^
select interval 'P0.1DT2562047788H54.775807S';
ERROR:  interval field value out of range: "P0.1DT2562047788H54.775807S"
LINE 1: select interval 'P0.1DT2562047788H54.775807S';
                        ^
select interval 'P-0.1DT-2562047788H-54.775808S';
ERROR:  interval field value out of range: "P-0.1DT-2562047788H-54.775808S"
LINE 1: select interval 'P-0.1DT-2562047788H-54.775808S';
                        ^
select interval 'PT2562047788.1H54.775807S';
ERROR:  interval field value out of range: "PT2562047788.1H54.775807S"
LINE 1: select interval 'PT2562047788.1H54.775807S';
                        ^
select interval 'PT-2562047788.1H-54.775808S';
ERROR:  interval field value out of range: "PT-2562047788.1H-54.775808S"
LINE 1: select interval 'PT-2562047788.1H-54.775808S';
                        ^
select interval 'PT2562047788H0.1M54.775807S';
ERROR:  interval field value out of range: "PT2562047788H0.1M54.775807S"
LINE 1: select interval 'PT2562047788H0.1M54.775807S';
                        ^
select interval 'PT-2562047788H-0.1M-54.775808S';
ERROR:  interval field value out of range: "PT-2562047788H-0.1M-54.775808S"
LINE 1: select interval 'PT-2562047788H-0.1M-54.775808S';
                        ^
-- overflowing with fractional fields - ISO8601 alternative format
select interval 'P0.1-2147483647-00';
ERROR:  interval field value out of range: "P0.1-2147483647-00"
LINE 1: select interval 'P0.1-2147483647-00';
                        ^
select interval 'P00-0.1-2147483647';
ERROR:  interval field value out of range: "P00-0.1-2147483647"
LINE 1: select interval 'P00-0.1-2147483647';
                        ^
select interval 'P00-0.01-00T2562047788:00:54.775807';
ERROR:  interval field value out of range: "P00-0.01-00T2562047788:00:54.775807"
LINE 1: select interval 'P00-0.01-00T2562047788:00:54.775807';
                        ^
select interval 'P00-00-0.1T2562047788:00:54.775807';
ERROR:  interval field value out of range: "P00-00-0.1T2562047788:00:54.775807"
LINE 1: select interval 'P00-00-0.1T2562047788:00:54.775807';
                        ^
select interval 'PT2562047788.1:00:54.775807';
ERROR:  interval field value out of range: "PT2562047788.1:00:54.775807"
LINE 1: select interval 'PT2562047788.1:00:54.775807';
                        ^
select interval 'PT2562047788:01.:54.775807';
ERROR:  interval field value out of range: "PT2562047788:01.:54.775807"
LINE 1: select interval 'PT2562047788:01.:54.775807';
                        ^
-- overflowing with fractional fields - SQL standard format
select interval '0.1 2562047788:0:54.775807';
ERROR:  interval field value out of range: "0.1 2562047788:0:54.775807"
LINE 1: select interval '0.1 2562047788:0:54.775807';
                        ^
select interval '0.1 2562047788:0:54.775808 ago';
ERROR:  interval field value out of range: "0.1 2562047788:0:54.775808 ago"
LINE 1: select interval '0.1 2562047788:0:54.775808 ago';
                        ^
select interval '2562047788.1:0:54.775807';
ERROR:  interval field value out of range: "2562047788.1:0:54.775807"
LINE 1: select interval '2562047788.1:0:54.775807';
                        ^
select interval '2562047788.1:0:54.775808 ago';
ERROR:  interval field value out of range: "2562047788.1:0:54.775808 ago"
LINE 1: select interval '2562047788.1:0:54.775808 ago';
                        ^
select interval '2562047788:0.1:54.775807';
ERROR:  invalid input syntax for type interval: "2562047788:0.1:54.775807"
LINE 1: select interval '2562047788:0.1:54.775807';
                        ^
select interval '2562047788:0.1:54.775808 ago';
ERROR:  invalid input syntax for type interval: "2562047788:0.1:54.775808 ago"
LINE 1: select interval '2562047788:0.1:54.775808 ago';
                        ^
-- overflowing using AGO with INT_MIN
select interval '-2147483648 months ago';
ERROR:  interval field value out of range: "-2147483648 months ago"
LINE 1: select interval '-2147483648 months ago';
                        ^
select interval '-2147483648 days ago';
ERROR:  interval field value out of range: "-2147483648 days ago"
LINE 1: select interval '-2147483648 days ago';
                        ^
select interval '-9223372036854775808 microseconds ago';
ERROR:  interval field value out of range: "-9223372036854775808 microseconds ago"
LINE 1: select interval '-9223372036854775808 microseconds ago';
                        ^
select interval '-2147483648 months -2147483648 days -9223372036854775808 microseconds ago';
ERROR:  interval field value out of range: "-2147483648 months -2147483648 days -9223372036854775808 microseconds ago"
LINE 1: select interval '-2147483648 months -2147483648 days -922337...
                        ^
-- overflowing using make_interval
select make_interval(years := 178956971);
ERROR:  interval out of range
select make_interval(years := -178956971);
ERROR:  interval out of range
select make_interval(years := 1, months := 2147483647);
ERROR:  interval out of range
select make_interval(years := -1, months := -2147483648);
ERROR:  interval out of range
select make_interval(weeks := 306783379);
ERROR:  interval out of range
select make_interval(weeks := -306783379);
ERROR:  interval out of range
select make_interval(weeks := 1, days := 2147483647);
ERROR:  interval out of range
select make_interval(weeks := -1, days := -2147483648);
ERROR:  interval out of range
select make_interval(secs := 1e308);
ERROR:  value out of range: overflow
select make_interval(secs := 1e18);
ERROR:  interval out of range
select make_interval(secs := -1e18);
ERROR:  interval out of range
select make_interval(mins := 1, secs := 9223372036800.0);
ERROR:  interval out of range
select make_interval(mins := -1, secs := -9223372036800.0);
ERROR:  interval out of range
-- test that INT_MIN number is formatted properly
SET IntervalStyle to postgres;
select interval '-2147483647 months -2147483648 days -9223372036854775808 us';
                              interval                              
--------------------------------------------------------------------
 -178956970 years -7 mons -2147483648 days -2562047788:00:54.775808
(1 row)

SET IntervalStyle to sql_standard;
select interval '-2147483647 months -2147483648 days -9223372036854775808 us';
                     interval                      
---------------------------------------------------
 -178956970-7 -2147483648 -2562047788:00:54.775808
(1 row)

SET IntervalStyle to iso_8601;
select interval '-2147483647 months -2147483648 days -9223372036854775808 us';
                      interval                       
-----------------------------------------------------
 P-178956970Y-7M-2147483648DT-2562047788H-54.775808S
(1 row)

SET IntervalStyle to postgres_verbose;
select interval '-2147483647 months -2147483648 days -9223372036854775808 us';
                                   interval                                   
------------------------------------------------------------------------------
 @ 178956970 years 7 mons 2147483648 days 2562047788 hours 54.775808 secs ago
(1 row)

-- check that '30 days' equals '1 month' according to the hash function
select '30 days'::interval = '1 month'::interval as t;
 t 
---
 t
(1 row)

select interval_hash('30 days'::interval) = interval_hash('1 month'::interval) as t;
 t 
---
 t
(1 row)

-- numeric constructor
select make_interval(years := 2);
 make_interval 
---------------
 @ 2 years
(1 row)

select make_interval(years := 1, months := 6);
  make_interval  
-----------------
 @ 1 year 6 mons
(1 row)

select make_interval(years := 1, months := -1, weeks := 5, days := -7, hours := 25, mins := -180);
       make_interval        
----------------------------
 @ 11 mons 28 days 22 hours
(1 row)

select make_interval() = make_interval(years := 0, months := 0, weeks := 0, days := 0, mins := 0, secs := 0.0);
 ?column? 
----------
 t
(1 row)

select make_interval(hours := -2, mins := -10, secs := -25.3);
          make_interval          
---------------------------------
 @ 2 hours 10 mins 25.3 secs ago
(1 row)

select make_interval(years := 'inf'::float::int);
ERROR:  integer out of range
select make_interval(months := 'NaN'::float::int);
ERROR:  integer out of range
select make_interval(secs := 'inf');
ERROR:  interval out of range
select make_interval(secs := 'NaN');
ERROR:  interval out of range
select make_interval(secs := 7e12);
           make_interval            
------------------------------------
 @ 1944444444 hours 26 mins 40 secs
(1 row)

--
-- test EXTRACT
--
SELECT f1,
    EXTRACT(MICROSECOND FROM f1) AS MICROSECOND,
    EXTRACT(MILLISECOND FROM f1) AS MILLISECOND,
    EXTRACT(SECOND FROM f1) AS SECOND,
    EXTRACT(MINUTE FROM f1) AS MINUTE,
    EXTRACT(HOUR FROM f1) AS HOUR,
    EXTRACT(DAY FROM f1) AS DAY,
    EXTRACT(MONTH FROM f1) AS MONTH,
    EXTRACT(QUARTER FROM f1) AS QUARTER,
    EXTRACT(YEAR FROM f1) AS YEAR,
    EXTRACT(DECADE FROM f1) AS DECADE,
    EXTRACT(CENTURY FROM f1) AS CENTURY,
    EXTRACT(MILLENNIUM FROM f1) AS MILLENNIUM,
    EXTRACT(EPOCH FROM f1) AS EPOCH
    FROM INTERVAL_TBL;
ERROR:  relation "interval_tbl" does not exist
LINE 15:     FROM INTERVAL_TBL;
                  ^
SELECT EXTRACT(FORTNIGHT FROM INTERVAL '2 days');  -- error
ERROR:  unit "fortnight" not recognized for type interval
SELECT EXTRACT(TIMEZONE FROM INTERVAL '2 days');  -- error
ERROR:  unit "timezone" not supported for type interval
SELECT EXTRACT(DECADE FROM INTERVAL '100 y');
 extract 
---------
      10
(1 row)

SELECT EXTRACT(DECADE FROM INTERVAL '99 y');
 extract 
---------
       9
(1 row)

SELECT EXTRACT(DECADE FROM INTERVAL '-99 y');
 extract 
---------
      -9
(1 row)

SELECT EXTRACT(DECADE FROM INTERVAL '-100 y');
 extract 
---------
     -10
(1 row)

SELECT EXTRACT(CENTURY FROM INTERVAL '100 y');
 extract 
---------
       1
(1 row)

SELECT EXTRACT(CENTURY FROM INTERVAL '99 y');
 extract 
---------
       0
(1 row)

SELECT EXTRACT(CENTURY FROM INTERVAL '-99 y');
 extract 
---------
       0
(1 row)

SELECT EXTRACT(CENTURY FROM INTERVAL '-100 y');
 extract 
---------
      -1
(1 row)

-- date_part implementation is mostly the same as extract, so only
-- test a few cases for additional coverage.
SELECT f1,
    date_part('microsecond', f1) AS microsecond,
    date_part('millisecond', f1) AS millisecond,
    date_part('second', f1) AS second,
    date_part('epoch', f1) AS epoch
    FROM INTERVAL_TBL;
ERROR:  relation "interval_tbl" does not exist
LINE 6:     FROM INTERVAL_TBL;
                 ^
-- internal overflow test case
SELECT extract(epoch from interval '1000000000 days');
        extract        
-----------------------
 86400000000000.000000
(1 row)

--
-- test infinite intervals
--
-- largest finite intervals
SELECT interval '-2147483648 months -2147483648 days -9223372036854775807 us';
                                   interval                                   
------------------------------------------------------------------------------
 @ 178956970 years 8 mons 2147483648 days 2562047788 hours 54.775807 secs ago
(1 row)

SELECT interval '2147483647 months 2147483647 days 9223372036854775806 us';
                                 interval                                 
--------------------------------------------------------------------------
 @ 178956970 years 7 mons 2147483647 days 2562047788 hours 54.775806 secs
(1 row)

-- infinite intervals
SELECT interval '-2147483648 months -2147483648 days -9223372036854775808 us';
 interval  
-----------
 -infinity
(1 row)

SELECT interval '2147483647 months 2147483647 days 9223372036854775807 us';
 interval 
----------
 infinity
(1 row)

CREATE TABLE INFINITE_INTERVAL_TBL (i interval);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE INFINITE_INTERVAL_TBL (i interval);
                     ^
INSERT INTO INFINITE_INTERVAL_TBL VALUES ('infinity'), ('-infinity'), ('1 year 2 days 3 hours');
ERROR:  relation "infinite_interval_tbl" does not exist
LINE 1: INSERT INTO INFINITE_INTERVAL_TBL VALUES ('infinity'), ('-in...
                    ^
SELECT i, isfinite(i) FROM INFINITE_INTERVAL_TBL;
ERROR:  relation "infinite_interval_tbl" does not exist
LINE 1: SELECT i, isfinite(i) FROM INFINITE_INTERVAL_TBL;
                                   ^
-- test basic arithmetic
CREATE FUNCTION eval(expr text)
RETURNS text AS
$$
DECLARE
  result text;
BEGIN
  EXECUTE 'select '||expr INTO result;
  RETURN result;
EXCEPTION WHEN OTHERS THEN
  RETURN SQLERRM;
END
$$
LANGUAGE plpgsql;
ERROR:  no schema has been selected to create in
SELECT d AS date, i AS interval,
       eval(format('date %L + interval %L', d, i)) AS plus,
       eval(format('date %L - interval %L', d, i)) AS minus
FROM (VALUES (date '-infinity'),
             (date '1995-08-06'),
             (date 'infinity')) AS t1(d),
     (VALUES (interval '-infinity'),
             (interval 'infinity')) AS t2(i);
ERROR:  function eval(text) does not exist
LINE 2:        eval(format('date %L + interval %L', d, i)) AS plus,
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
SELECT i1 AS interval1, i2 AS interval2,
       eval(format('interval %L + interval %L', i1, i2)) AS plus,
       eval(format('interval %L - interval %L', i1, i2)) AS minus
FROM (VALUES (interval '-infinity'),
             (interval '2 months'),
             (interval 'infinity')) AS t1(i1),
     (VALUES (interval '-infinity'),
             (interval '10 days'),
             (interval 'infinity')) AS t2(i2);
ERROR:  function eval(text) does not exist
LINE 2:        eval(format('interval %L + interval %L', i1, i2)) AS ...
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
SELECT interval '2147483646 months 2147483646 days 9223372036854775806 us' + interval '1 month 1 day 1 us';
ERROR:  interval out of range
SELECT interval '-2147483647 months -2147483647 days -9223372036854775807 us' + interval '-1 month -1 day -1 us';
ERROR:  interval out of range
SELECT interval '2147483646 months 2147483646 days 9223372036854775806 us' - interval '-1 month -1 day -1 us';
ERROR:  interval out of range
SELECT interval '-2147483647 months -2147483647 days -9223372036854775807 us' - interval '1 month 1 day 1 us';
ERROR:  interval out of range
SELECT t AS timestamp, i AS interval,
       eval(format('timestamp %L + interval %L', t, i)) AS plus,
       eval(format('timestamp %L - interval %L', t, i)) AS minus
FROM (VALUES (timestamp '-infinity'),
             (timestamp '1995-08-06 12:30:15'),
             (timestamp 'infinity')) AS t1(t),
     (VALUES (interval '-infinity'),
             (interval 'infinity')) AS t2(i);
ERROR:  function eval(text) does not exist
LINE 2:        eval(format('timestamp %L + interval %L', t, i)) AS p...
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
SELECT t AT TIME ZONE 'GMT' AS timestamptz, i AS interval,
       eval(format('timestamptz %L + interval %L', t, i)) AS plus,
       eval(format('timestamptz %L - interval %L', t, i)) AS minus
FROM (VALUES (timestamptz '-infinity'),
             (timestamptz '1995-08-06 12:30:15 GMT'),
             (timestamptz 'infinity')) AS t1(t),
     (VALUES (interval '-infinity'),
             (interval 'infinity')) AS t2(i);
ERROR:  function eval(text) does not exist
LINE 2:        eval(format('timestamptz %L + interval %L', t, i)) AS...
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.
-- time +/- infinite interval not supported
SELECT time '11:27:42' + interval 'infinity';
ERROR:  cannot add infinite interval to time
SELECT time '11:27:42' + interval '-infinity';
ERROR:  cannot add infinite interval to time
SELECT time '11:27:42' - interval 'infinity';
ERROR:  cannot subtract infinite interval from time
SELECT time '11:27:42' - interval '-infinity';
ERROR:  cannot subtract infinite interval from time
SELECT timetz '11:27:42' + interval 'infinity';
ERROR:  cannot add infinite interval to time
SELECT timetz '11:27:42' + interval '-infinity';
ERROR:  cannot add infinite interval to time
SELECT timetz '11:27:42' - interval 'infinity';
ERROR:  cannot subtract infinite interval from time
SELECT timetz '11:27:42' - interval '-infinity';
ERROR:  cannot subtract infinite interval from time
SELECT lhst.i lhs,
    rhst.i rhs,
    lhst.i < rhst.i AS lt,
    lhst.i <= rhst.i AS le,
    lhst.i = rhst.i AS eq,
    lhst.i > rhst.i AS gt,
    lhst.i >= rhst.i AS ge,
    lhst.i <> rhst.i AS ne
    FROM INFINITE_INTERVAL_TBL lhst CROSS JOIN INFINITE_INTERVAL_TBL rhst
    WHERE NOT isfinite(lhst.i);
ERROR:  relation "infinite_interval_tbl" does not exist
LINE 9:     FROM INFINITE_INTERVAL_TBL lhst CROSS JOIN INFINITE_INTE...
                 ^
SELECT i AS interval,
    -i AS um,
    i * 2.0 AS mul,
    i * -2.0 AS mul_neg,
    i * 'infinity' AS mul_inf,
    i * '-infinity' AS mul_inf_neg,
    i / 3.0 AS div,
    i / -3.0 AS div_neg
    FROM INFINITE_INTERVAL_TBL
    WHERE NOT isfinite(i);
ERROR:  relation "infinite_interval_tbl" does not exist
LINE 9:     FROM INFINITE_INTERVAL_TBL
                 ^
SELECT -interval '-2147483647 months -2147483647 days -9223372036854775807 us';
ERROR:  interval out of range
SELECT interval 'infinity' * 'nan';
ERROR:  interval out of range
SELECT interval '-infinity' * 'nan';
ERROR:  interval out of range
SELECT interval '-1073741824 months -1073741824 days -4611686018427387904 us' * 2;
ERROR:  interval out of range
SELECT interval 'infinity' * 0;
ERROR:  interval out of range
SELECT interval '-infinity' * 0;
ERROR:  interval out of range
SELECT interval '0 days' * 'infinity'::float;
ERROR:  interval out of range
SELECT interval '0 days' * '-infinity'::float;
ERROR:  interval out of range
SELECT interval '5 days' * 'infinity'::float;
 ?column? 
----------
 infinity
(1 row)

SELECT interval '5 days' * '-infinity'::float;
 ?column?  
-----------
 -infinity
(1 row)

SELECT interval 'infinity' / 'infinity';
ERROR:  interval out of range
SELECT interval 'infinity' / '-infinity';
ERROR:  interval out of range
SELECT interval 'infinity' / 'nan';
ERROR:  interval out of range
SELECT interval '-infinity' / 'infinity';
ERROR:  interval out of range
SELECT interval '-infinity' / '-infinity';
ERROR:  interval out of range
SELECT interval '-infinity' / 'nan';
ERROR:  interval out of range
SELECT interval '-1073741824 months -1073741824 days -4611686018427387904 us' / 0.5;
ERROR:  interval out of range
SELECT date_bin('infinity', timestamp '2001-02-16 20:38:40', timestamp '2001-02-16 20:05:00');
ERROR:  timestamps cannot be binned into infinite intervals
SELECT date_bin('-infinity', timestamp '2001-02-16 20:38:40', timestamp '2001-02-16 20:05:00');
ERROR:  timestamps cannot be binned into infinite intervals
SELECT i AS interval, date_trunc('hour', i)
    FROM INFINITE_INTERVAL_TBL
    WHERE NOT isfinite(i);
ERROR:  relation "infinite_interval_tbl" does not exist
LINE 2:     FROM INFINITE_INTERVAL_TBL
                 ^
SELECT i AS interval, justify_days(i), justify_hours(i), justify_interval(i)
    FROM INFINITE_INTERVAL_TBL
    WHERE NOT isfinite(i);
ERROR:  relation "infinite_interval_tbl" does not exist
LINE 2:     FROM INFINITE_INTERVAL_TBL
                 ^
SELECT timezone('infinity'::interval, '1995-08-06 12:12:12'::timestamp);
ERROR:  interval time zone "infinity" must be finite
SELECT timezone('-infinity'::interval, '1995-08-06 12:12:12'::timestamp);
ERROR:  interval time zone "-infinity" must be finite
SELECT timezone('infinity'::interval, '1995-08-06 12:12:12'::timestamptz);
ERROR:  interval time zone "infinity" must be finite
SELECT timezone('-infinity'::interval, '1995-08-06 12:12:12'::timestamptz);
ERROR:  interval time zone "-infinity" must be finite
SELECT timezone('infinity'::interval, '12:12:12'::time);
ERROR:  interval time zone "infinity" must be finite
SELECT timezone('-infinity'::interval, '12:12:12'::time);
ERROR:  interval time zone "-infinity" must be finite
SELECT timezone('infinity'::interval, '12:12:12'::timetz);
ERROR:  interval time zone "infinity" must be finite
SELECT timezone('-infinity'::interval, '12:12:12'::timetz);
ERROR:  interval time zone "-infinity" must be finite
SELECT 'infinity'::interval::time;
ERROR:  cannot convert infinite interval to time
SELECT '-infinity'::interval::time;
ERROR:  cannot convert infinite interval to time
SELECT to_char('infinity'::interval, 'YYYY');
 to_char 
---------
 
(1 row)

SELECT to_char('-infinity'::interval, 'YYYY');
 to_char 
---------
 
(1 row)

-- "ago" can only appear once at the end of an interval.
SELECT INTERVAL '42 days 2 seconds ago ago';
ERROR:  invalid input syntax for type interval: "42 days 2 seconds ago ago"
LINE 1: SELECT INTERVAL '42 days 2 seconds ago ago';
                        ^
SELECT INTERVAL '2 minutes ago 5 days';
ERROR:  invalid input syntax for type interval: "2 minutes ago 5 days"
LINE 1: SELECT INTERVAL '2 minutes ago 5 days';
                        ^
-- consecutive and dangling units are not allowed.
SELECT INTERVAL 'hour 5 months';
ERROR:  invalid input syntax for type interval: "hour 5 months"
LINE 1: SELECT INTERVAL 'hour 5 months';
                        ^
SELECT INTERVAL '1 year months days 5 hours';
ERROR:  invalid input syntax for type interval: "1 year months days 5 hours"
LINE 1: SELECT INTERVAL '1 year months days 5 hours';
                        ^
-- unacceptable reserved words in interval. Only "infinity", "+infinity" and
-- "-infinity" are allowed.
SELECT INTERVAL 'now';
ERROR:  invalid input syntax for type interval: "now"
LINE 1: SELECT INTERVAL 'now';
                        ^
SELECT INTERVAL 'today';
ERROR:  invalid input syntax for type interval: "today"
LINE 1: SELECT INTERVAL 'today';
                        ^
SELECT INTERVAL 'tomorrow';
ERROR:  invalid input syntax for type interval: "tomorrow"
LINE 1: SELECT INTERVAL 'tomorrow';
                        ^
SELECT INTERVAL 'allballs';
ERROR:  invalid input syntax for type interval: "allballs"
LINE 1: SELECT INTERVAL 'allballs';
                        ^
SELECT INTERVAL 'epoch';
ERROR:  invalid input syntax for type interval: "epoch"
LINE 1: SELECT INTERVAL 'epoch';
                        ^
SELECT INTERVAL 'yesterday';
ERROR:  invalid input syntax for type interval: "yesterday"
LINE 1: SELECT INTERVAL 'yesterday';
                        ^
-- infinity specification should be the only thing
SELECT INTERVAL 'infinity years';
ERROR:  invalid input syntax for type interval: "infinity years"
LINE 1: SELECT INTERVAL 'infinity years';
                        ^
SELECT INTERVAL 'infinity ago';
ERROR:  invalid input syntax for type interval: "infinity ago"
LINE 1: SELECT INTERVAL 'infinity ago';
                        ^
SELECT INTERVAL '+infinity -infinity';
ERROR:  invalid input syntax for type interval: "+infinity -infinity"
LINE 1: SELECT INTERVAL '+infinity -infinity';
                        ^
-- END setup from interval
 
