-- sanity check of system catalog
SELECT attrelid, attname, attidentity FROM pg_attribute WHERE attidentity NOT IN ('', 'a', 'd')
RESULT: 
	[]



CREATE TABLE itest1 (a int generated by default as identity, b text)

CREATE TABLE itest2 (a bigint generated always as identity, b text)

CREATE TABLE itest3 (a smallint generated by default as identity (start with 7 increment by 5), b text)

ALTER TABLE itest3 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY
ERROR: 
ALTER TABLE itest3 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY

column "a" of relation "itest3" is already an identity column

  -- error

SELECT table_name, column_name, column_default, is_nullable, is_identity, identity_generation, identity_start, identity_increment, identity_maximum, identity_minimum, identity_cycle FROM information_schema.columns WHERE table_name LIKE 'itest_' ORDER BY 1, 2
RESULT: 
	[('itest1', 'a', None, 'NO', 'YES', 'BY DEFAULT', '1', '1', '2147483647', '1', 'NO'), ('itest1', 'b', None, 'YES', 'NO', None, None, None, None, None, 'NO'), ('itest2', 'a', None, 'NO', 'YES', 'ALWAYS', '1', '1', '9223372036854775807', '1', 'NO'), ('itest2', 'b', None, 'YES', 'NO', None, None, None, None, None, 'NO'), ('itest3', 'a', None, 'NO', 'YES', 'BY DEFAULT', '7', '5', '32767', '1', 'NO'), ('itest3', 'b', None, 'YES', 'NO', None, None, None, None, None, 'NO')]


-- internal sequences should not be shown here
SELECT sequence_name FROM information_schema.sequences WHERE sequence_name LIKE 'itest%'
RESULT: 
	[]


SELECT pg_get_serial_sequence('itest1', 'a')
RESULT: 
	[('public.itest1_a_seq',)]


-- \d itest1_a_seq

CREATE TABLE itest4 (a int, b text)

ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY
ERROR: 
ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY

column "a" of relation "itest4" must be declared NOT NULL before identity can be added

  -- error, requires NOT NULL
ALTER TABLE itest4 ALTER COLUMN a SET NOT NULL

ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY
  -- ok
ALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL
ProgrammingError:   -- ok
ALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL

column "a" of relation "itest4" is an identity column

  -- error, disallowed
ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY
ERROR:   -- error, disallowed
ALTER TABLE itest4 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY

column "a" of relation "itest4" is already an identity column

  -- error, already set
ALTER TABLE itest4 ALTER COLUMN b ADD GENERATED ALWAYS AS IDENTITY
ERROR:   -- error, already set
ALTER TABLE itest4 ALTER COLUMN b ADD GENERATED ALWAYS AS IDENTITY

identity column type must be smallint, integer, or bigint

  -- error, wrong data type

-- for later
ALTER TABLE itest4 ALTER COLUMN b SET DEFAULT ''


-- invalid column type
CREATE TABLE itest_err_1 (a text generated by default as identity)
ERROR: 

-- invalid column type
CREATE TABLE itest_err_1 (a text generated by default as identity)

identity column type must be smallint, integer, or bigint



-- duplicate identity
CREATE TABLE itest_err_2 (a int generated always as identity generated by default as identity)
ProgrammingError: 

-- duplicate identity
CREATE TABLE itest_err_2 (a int generated always as identity generated by default as identity)

multiple identity specifications for column "a" of table "itest_err_2"
LINE 4: ...E itest_err_2 (a int generated always as identity generated ...
                                                             ^



-- cannot have default and identity
CREATE TABLE itest_err_3 (a int default 5 generated by default as identity)
ProgrammingError: 

-- cannot have default and identity
CREATE TABLE itest_err_3 (a int default 5 generated by default as identity)

both default and identity specified for column "a" of table "itest_err_3"
LINE 4: CREATE TABLE itest_err_3 (a int default 5 generated by defau...
                                                  ^



-- cannot combine serial and identity
CREATE TABLE itest_err_4 (a serial generated by default as identity)
ProgrammingError: 

-- cannot combine serial and identity
CREATE TABLE itest_err_4 (a serial generated by default as identity)

both default and identity specified for column "a" of table "itest_err_4"



INSERT INTO itest1 DEFAULT VALUES

INSERT INTO itest1 DEFAULT VALUES

INSERT INTO itest2 DEFAULT VALUES

INSERT INTO itest2 DEFAULT VALUES

INSERT INTO itest3 DEFAULT VALUES

INSERT INTO itest3 DEFAULT VALUES

INSERT INTO itest4 DEFAULT VALUES

INSERT INTO itest4 DEFAULT VALUES


SELECT * FROM itest1
RESULT: 
	[(1, None), (2, None)]

SELECT * FROM itest2
RESULT: 
	[(1, None), (2, None)]

SELECT * FROM itest3
RESULT: 
	[(7, None), (12, None)]

SELECT * FROM itest4
RESULT: 
	[(1, ''), (2, '')]



-- VALUES RTEs

CREATE TABLE itest5 (a int generated always as identity, b text)

INSERT INTO itest5 VALUES (1, 'a')
ProgrammingError: 
INSERT INTO itest5 VALUES (1, 'a')

cannot insert a non-DEFAULT value into column "a"
DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
HINT:  Use OVERRIDING SYSTEM VALUE to override.

  -- error
INSERT INTO itest5 VALUES (DEFAULT, 'a')
  -- ok
INSERT INTO itest5 VALUES (2, 'b'), (3, 'c')
ProgrammingError:   -- ok
INSERT INTO itest5 VALUES (2, 'b'), (3, 'c')

cannot insert a non-DEFAULT value into column "a"
DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
HINT:  Use OVERRIDING SYSTEM VALUE to override.

  -- error
INSERT INTO itest5 VALUES (DEFAULT, 'b'), (3, 'c')
ProgrammingError:   -- error
INSERT INTO itest5 VALUES (DEFAULT, 'b'), (3, 'c')

cannot insert a non-DEFAULT value into column "a"
DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
HINT:  Use OVERRIDING SYSTEM VALUE to override.

  -- error
INSERT INTO itest5 VALUES (2, 'b'), (DEFAULT, 'c')
ProgrammingError:   -- error
INSERT INTO itest5 VALUES (2, 'b'), (DEFAULT, 'c')

cannot insert a non-DEFAULT value into column "a"
DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
HINT:  Use OVERRIDING SYSTEM VALUE to override.

  -- error
INSERT INTO itest5 VALUES (DEFAULT, 'b'), (DEFAULT, 'c')
  -- ok

INSERT INTO itest5 OVERRIDING SYSTEM VALUE VALUES (-1, 'aa')

INSERT INTO itest5 OVERRIDING SYSTEM VALUE VALUES (-2, 'bb'), (-3, 'cc')

INSERT INTO itest5 OVERRIDING SYSTEM VALUE VALUES (DEFAULT, 'dd'), (-4, 'ee')

INSERT INTO itest5 OVERRIDING SYSTEM VALUE VALUES (-5, 'ff'), (DEFAULT, 'gg')

INSERT INTO itest5 OVERRIDING SYSTEM VALUE VALUES (DEFAULT, 'hh'), (DEFAULT, 'ii')


INSERT INTO itest5 OVERRIDING USER VALUE VALUES (-1, 'aaa')

INSERT INTO itest5 OVERRIDING USER VALUE VALUES (-2, 'bbb'), (-3, 'ccc')

INSERT INTO itest5 OVERRIDING USER VALUE VALUES (DEFAULT, 'ddd'), (-4, 'eee')

INSERT INTO itest5 OVERRIDING USER VALUE VALUES (-5, 'fff'), (DEFAULT, 'ggg')

INSERT INTO itest5 OVERRIDING USER VALUE VALUES (DEFAULT, 'hhh'), (DEFAULT, 'iii')


SELECT * FROM itest5
RESULT: 
	[(1, 'a'), (2, 'b'), (3, 'c'), (-1, 'aa'), (-2, 'bb'), (-3, 'cc'), (4, 'dd'), (-4, 'ee'), (-5, 'ff'), (5, 'gg'), (6, 'hh'), (7, 'ii'), (8, 'aaa'), (9, 'bbb'), (10, 'ccc'), (11, 'ddd'), (12, 'eee'), (13, 'fff'), (14, 'ggg'), (15, 'hhh'), (16, 'iii')]

DROP TABLE itest5


INSERT INTO itest3 VALUES (DEFAULT, 'a')

INSERT INTO itest3 VALUES (DEFAULT, 'b'), (DEFAULT, 'c')


SELECT * FROM itest3
RESULT: 
	[(7, None), (12, None), (17, 'a'), (22, 'b'), (27, 'c')]



-- OVERRIDING tests

-- GENERATED BY DEFAULT

-- This inserts the row as presented:
INSERT INTO itest1 VALUES (10, 'xyz')

-- With GENERATED BY DEFAULT, OVERRIDING SYSTEM VALUE is not allowed
-- by the standard, but we allow it as a no-op, since it is of use if
-- there are multiple identity columns in a table, which is also an
-- extension.
INSERT INTO itest1 OVERRIDING SYSTEM VALUE VALUES (20, 'xyz')

-- This ignores the 30 and uses the sequence value instead:
INSERT INTO itest1 OVERRIDING USER VALUE VALUES (30, 'xyz')


SELECT * FROM itest1
RESULT: 
	[(1, None), (2, None), (10, 'xyz'), (20, 'xyz'), (3, 'xyz')]


-- GENERATED ALWAYS

-- This is an error:
INSERT INTO itest2 VALUES (10, 'xyz')
ProgrammingError: 

-- GENERATED ALWAYS

-- This is an error:
INSERT INTO itest2 VALUES (10, 'xyz')

cannot insert a non-DEFAULT value into column "a"
DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
HINT:  Use OVERRIDING SYSTEM VALUE to override.


-- This inserts the row as presented:
INSERT INTO itest2 OVERRIDING SYSTEM VALUE VALUES (20, 'xyz')

-- This ignores the 30 and uses the sequence value instead:
INSERT INTO itest2 OVERRIDING USER VALUE VALUES (30, 'xyz')


SELECT * FROM itest2
RESULT: 
	[(1, None), (2, None), (20, 'xyz'), (3, 'xyz')]



-- UPDATE tests

-- GENERATED BY DEFAULT is not restricted.
UPDATE itest1 SET a = 101 WHERE a = 1

UPDATE itest1 SET a = DEFAULT WHERE a = 2

SELECT * FROM itest1
RESULT: 
	[(10, 'xyz'), (20, 'xyz'), (3, 'xyz'), (101, None), (4, None)]


-- GENERATED ALWAYS allows only DEFAULT.
UPDATE itest2 SET a = 101 WHERE a = 1
ProgrammingError: 

-- GENERATED ALWAYS allows only DEFAULT.
UPDATE itest2 SET a = 101 WHERE a = 1

column "a" can only be updated to DEFAULT
DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.

  -- error
UPDATE itest2 SET a = DEFAULT WHERE a = 2
  -- ok
SELECT * FROM itest2
RESULT: 
	[(1, None), (20, 'xyz'), (3, 'xyz'), (4, None)]



-- COPY tests

CREATE TABLE itest9 (a int GENERATED ALWAYS AS IDENTITY, b text, c bigint)


COPY itest9 FROM stdin
ProgrammingError: 

COPY itest9 FROM stdin

can't execute COPY FROM: use the copy_from() method instead

100	foo	200
101	bar	201
\.

COPY itest9 (b, c) FROM stdin
ProgrammingError: 
100	foo	200
101	bar	201
\.

COPY itest9 (b, c) FROM stdin

syntax error at or near "100"
LINE 2: 100 foo 200
        ^


foo2	202
bar2	203
\.

SELECT * FROM itest9 ORDER BY c
ProgrammingError: 
foo2	202
bar2	203
\.

SELECT * FROM itest9 ORDER BY c

syntax error at or near "foo2"
LINE 2: foo2 202
        ^




-- DROP IDENTITY tests

ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY

ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY
ERROR: 
ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY

column "a" of relation "itest4" is not an identity column

  -- error
ALTER TABLE itest4 ALTER COLUMN a DROP IDENTITY IF EXISTS
  -- noop

INSERT INTO itest4 DEFAULT VALUES
ERROR:   -- noop

INSERT INTO itest4 DEFAULT VALUES

null value in column "a" of relation "itest4" violates not-null constraint
DETAIL:  Failing row contains (null, ).

  -- fails because NOT NULL is not dropped
ALTER TABLE itest4 ALTER COLUMN a DROP NOT NULL

INSERT INTO itest4 DEFAULT VALUES

SELECT * FROM itest4
RESULT: 
	[(1, ''), (2, ''), (None, '')]


-- check that sequence is removed
SELECT sequence_name FROM itest4_a_seq
ProgrammingError: 

-- check that sequence is removed
SELECT sequence_name FROM itest4_a_seq

relation "itest4_a_seq" does not exist
LINE 4: SELECT sequence_name FROM itest4_a_seq
                                  ^




-- test views

CREATE TABLE itest10 (a int generated by default as identity, b text)

CREATE TABLE itest11 (a int generated always as identity, b text)


CREATE VIEW itestv10 AS SELECT * FROM itest10

CREATE VIEW itestv11 AS SELECT * FROM itest11


INSERT INTO itestv10 DEFAULT VALUES

INSERT INTO itestv10 DEFAULT VALUES


INSERT INTO itestv11 DEFAULT VALUES

INSERT INTO itestv11 DEFAULT VALUES


SELECT * FROM itestv10
RESULT: 
	[(1, None), (2, None)]

SELECT * FROM itestv11
RESULT: 
	[(1, None), (2, None)]


INSERT INTO itestv10 VALUES (10, 'xyz')

INSERT INTO itestv10 OVERRIDING USER VALUE VALUES (11, 'xyz')


SELECT * FROM itestv10
RESULT: 
	[(1, None), (2, None), (10, 'xyz'), (3, 'xyz')]


INSERT INTO itestv11 VALUES (10, 'xyz')
ProgrammingError: 

INSERT INTO itestv11 VALUES (10, 'xyz')

cannot insert a non-DEFAULT value into column "a"
DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
HINT:  Use OVERRIDING SYSTEM VALUE to override.


INSERT INTO itestv11 OVERRIDING SYSTEM VALUE VALUES (11, 'xyz')


SELECT * FROM itestv11
RESULT: 
	[(1, None), (2, None), (11, 'xyz')]


DROP VIEW itestv10, itestv11



-- ADD COLUMN

CREATE TABLE itest13 (a int)

-- add column to empty table
ALTER TABLE itest13 ADD COLUMN b int GENERATED BY DEFAULT AS IDENTITY

INSERT INTO itest13 VALUES (1), (2), (3)

-- add column to populated table
ALTER TABLE itest13 ADD COLUMN c int GENERATED BY DEFAULT AS IDENTITY

SELECT * FROM itest13
RESULT: 
	[(1, 1, 1), (2, 2, 2), (3, 3, 3)]



-- various ALTER COLUMN tests

-- fail, not allowed for identity columns
ALTER TABLE itest1 ALTER COLUMN a SET DEFAULT 1
ProgrammingError: 


-- various ALTER COLUMN tests

-- fail, not allowed for identity columns
ALTER TABLE itest1 ALTER COLUMN a SET DEFAULT 1

column "a" of relation "itest1" is an identity column



-- fail, not allowed, already has a default
CREATE TABLE itest5 (a serial, b text)

ALTER TABLE itest5 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY
ERROR: 
ALTER TABLE itest5 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY

column "a" of relation "itest5" already has a default value



ALTER TABLE itest3 ALTER COLUMN a TYPE int

SELECT seqtypid::regtype FROM pg_sequence WHERE seqrelid = 'itest3_a_seq'::regclass
RESULT: 
	[('integer',)]

-- \d itest3

ALTER TABLE itest3 ALTER COLUMN a TYPE text
ERROR: 
-- \d itest3

ALTER TABLE itest3 ALTER COLUMN a TYPE text

identity column type must be smallint, integer, or bigint

  -- error

-- check that unlogged propagates to sequence
CREATE UNLOGGED TABLE itest17 (a int NOT NULL, b text)

ALTER TABLE itest17 ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY

ALTER TABLE itest17 ADD COLUMN c int GENERATED ALWAYS AS IDENTITY

-- \d itest17
-- \d itest17_a_seq
-- \d itest17_c_seq
CREATE TABLE itest18 (a int NOT NULL, b text)

ALTER TABLE itest18 SET UNLOGGED, ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY

-- \d itest18
-- \d itest18_a_seq
ALTER TABLE itest18 SET LOGGED

-- \d itest18
-- \d itest18_a_seq
ALTER TABLE itest18 SET UNLOGGED

-- \d itest18
-- \d itest18_a_seq

-- kinda silly to change property in the same command, but it should work
ALTER TABLE itest3
  ADD COLUMN c int GENERATED BY DEFAULT AS IDENTITY,
  ALTER COLUMN c SET GENERATED ALWAYS

-- \d itest3


-- ALTER COLUMN ... SET

CREATE TABLE itest6 (a int GENERATED ALWAYS AS IDENTITY, b text)

INSERT INTO itest6 DEFAULT VALUES


ALTER TABLE itest6 ALTER COLUMN a SET GENERATED BY DEFAULT SET INCREMENT BY 2 SET START WITH 100 RESTART

INSERT INTO itest6 DEFAULT VALUES

INSERT INTO itest6 DEFAULT VALUES

SELECT * FROM itest6
RESULT: 
	[(1, None), (100, None), (102, None)]


SELECT table_name, column_name, is_identity, identity_generation FROM information_schema.columns WHERE table_name = 'itest6' ORDER BY 1, 2
RESULT: 
	[('itest6', 'a', 'YES', 'BY DEFAULT'), ('itest6', 'b', 'NO', None)]


ALTER TABLE itest6 ALTER COLUMN b SET INCREMENT BY 2
ERROR: 

ALTER TABLE itest6 ALTER COLUMN b SET INCREMENT BY 2

column "b" of relation "itest6" is not an identity column

  -- fail, not identity


-- prohibited direct modification of sequence

ALTER SEQUENCE itest6_a_seq OWNED BY NONE
ERROR:   -- fail, not identity


-- prohibited direct modification of sequence

ALTER SEQUENCE itest6_a_seq OWNED BY NONE

cannot change ownership of identity sequence
DETAIL:  Sequence "itest6_a_seq" is linked to table "itest6".




-- inheritance

CREATE TABLE itest7 (a int GENERATED ALWAYS AS IDENTITY)

INSERT INTO itest7 DEFAULT VALUES

SELECT * FROM itest7
RESULT: 
	[(1,)]


-- identity property is not inherited
CREATE TABLE itest7a (b text) INHERITS (itest7)


-- make column identity in child table
CREATE TABLE itest7b (a int)

CREATE TABLE itest7c (a int GENERATED ALWAYS AS IDENTITY) INHERITS (itest7b)

INSERT INTO itest7c DEFAULT VALUES

SELECT * FROM itest7c
RESULT: 
	[(1,)]


CREATE TABLE itest7d (a int not null)

CREATE TABLE itest7e () INHERITS (itest7d)

ALTER TABLE itest7d ALTER COLUMN a ADD GENERATED ALWAYS AS IDENTITY

ALTER TABLE itest7d ADD COLUMN b int GENERATED ALWAYS AS IDENTITY
ProgrammingError: 
ALTER TABLE itest7d ADD COLUMN b int GENERATED ALWAYS AS IDENTITY

cannot recursively add identity column to table that has child tables

  -- error

SELECT table_name, column_name, is_nullable, is_identity, identity_generation FROM information_schema.columns WHERE table_name LIKE 'itest7%' ORDER BY 1, 2
RESULT: 
	[('itest7', 'a', 'NO', 'YES', 'ALWAYS'), ('itest7a', 'a', 'NO', 'NO', None), ('itest7a', 'b', 'YES', 'NO', None), ('itest7b', 'a', 'YES', 'NO', None), ('itest7c', 'a', 'NO', 'YES', 'ALWAYS'), ('itest7d', 'a', 'NO', 'YES', 'ALWAYS'), ('itest7e', 'a', 'NO', 'NO', None)]


-- These ALTER TABLE variants will not recurse.
ALTER TABLE itest7 ALTER COLUMN a SET GENERATED BY DEFAULT

ALTER TABLE itest7 ALTER COLUMN a RESTART

ALTER TABLE itest7 ALTER COLUMN a DROP IDENTITY


-- privileges
CREATE USER regress_identity_user1

CREATE TABLE itest8 (a int GENERATED ALWAYS AS IDENTITY, b text)

GRANT SELECT, INSERT ON itest8 TO regress_identity_user1

SET ROLE regress_identity_user1

INSERT INTO itest8 DEFAULT VALUES

SELECT * FROM itest8
RESULT: 
	[(1, None)]

RESET ROLE

DROP TABLE itest8

DROP USER regress_identity_user1


-- multiple steps in ALTER TABLE
CREATE TABLE itest8 (f1 int)


ALTER TABLE itest8
  ADD COLUMN f2 int NOT NULL,
  ALTER COLUMN f2 ADD GENERATED ALWAYS AS IDENTITY


ALTER TABLE itest8
  ADD COLUMN f3 int NOT NULL,
  ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY,
  ALTER COLUMN f3 SET GENERATED BY DEFAULT SET INCREMENT 10


ALTER TABLE itest8
  ADD COLUMN f4 int


ALTER TABLE itest8
  ALTER COLUMN f4 SET NOT NULL,
  ALTER COLUMN f4 ADD GENERATED ALWAYS AS IDENTITY,
  ALTER COLUMN f4 SET DATA TYPE bigint


ALTER TABLE itest8
  ADD COLUMN f5 int GENERATED ALWAYS AS IDENTITY


ALTER TABLE itest8
  ALTER COLUMN f5 DROP IDENTITY,
  ALTER COLUMN f5 DROP NOT NULL,
  ALTER COLUMN f5 SET DATA TYPE bigint


INSERT INTO itest8 VALUES(0), (1)


-- This does not work when the table isn''t empty.  That''s intentional,
-- since ADD GENERATED should only affect later insertions:
ALTER TABLE itest8
  ADD COLUMN f22 int NOT NULL,
  ALTER COLUMN f22 ADD GENERATED ALWAYS AS IDENTITY
ERROR: 

-- This does not work when the table isn''t empty.  That''s intentional,
-- since ADD GENERATED should only affect later insertions:
ALTER TABLE itest8
  ADD COLUMN f22 int NOT NULL,
  ALTER COLUMN f22 ADD GENERATED ALWAYS AS IDENTITY

column "f22" of relation "itest8" contains null values



TABLE itest8
RESULT: 
	[(0, 1, 1, 1, None), (1, 2, 11, 2, None)]

-- \d+ itest8
-- \d itest8_f2_seq
-- \d itest8_f3_seq
-- \d itest8_f4_seq
-- \d itest8_f5_seq
DROP TABLE itest8



-- typed tables (currently not supported)

CREATE TYPE itest_type AS (f1 integer, f2 text, f3 bigint)

CREATE TABLE itest12 OF itest_type (f1 WITH OPTIONS GENERATED ALWAYS AS IDENTITY)
ERROR: 
CREATE TABLE itest12 OF itest_type (f1 WITH OPTIONS GENERATED ALWAYS AS IDENTITY)

identity columns are not supported on typed tables

 -- error
DROP TYPE itest_type CASCADE



-- table partitions

-- partitions inherit identity column and share sequence
CREATE TABLE pitest1 (f1 date NOT NULL, f2 text, f3 bigint generated always as identity) PARTITION BY RANGE (f1)

-- new partition
CREATE TABLE pitest1_p1 PARTITION OF pitest1 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01')

INSERT into pitest1(f1, f2) VALUES ('2016-07-2', 'from pitest1')

INSERT into pitest1_p1 (f1, f2) VALUES ('2016-07-3', 'from pitest1_p1')

-- attached partition
CREATE TABLE pitest1_p2 (f1 date NOT NULL, f2 text, f3 bigint)

INSERT INTO pitest1_p2 VALUES ('2016-08-2', 'before attaching', 100)

ALTER TABLE pitest1 ATTACH PARTITION pitest1_p2 FOR VALUES FROM ('2016-08-01') TO ('2016-09-01')
ProgrammingError: 
ALTER TABLE pitest1 ATTACH PARTITION pitest1_p2 FOR VALUES FROM ('2016-08-01') TO ('2016-09-01')

column "f3" in child table must be marked NOT NULL

 -- requires NOT NULL constraint
ALTER TABLE pitest1_p2 ALTER COLUMN f3 SET NOT NULL

ALTER TABLE pitest1 ATTACH PARTITION pitest1_p2 FOR VALUES FROM ('2016-08-01') TO ('2016-09-01')

INSERT INTO pitest1_p2 (f1, f2) VALUES ('2016-08-3', 'from pitest1_p2')

INSERT INTO pitest1 (f1, f2) VALUES ('2016-08-4', 'from pitest1')

SELECT tableoid::regclass, f1, f2, f3 FROM pitest1
RESULT: 
	[('pitest1_p1', datetime.date(2016, 7, 2), 'from pitest1', 1), ('pitest1_p1', datetime.date(2016, 7, 3), 'from pitest1_p1', 2), ('pitest1_p2', datetime.date(2016, 8, 2), 'before attaching', 100), ('pitest1_p2', datetime.date(2016, 8, 3), 'from pitest1_p2', 3), ('pitest1_p2', datetime.date(2016, 8, 4), 'from pitest1', 4)]


-- add identity column
CREATE TABLE pitest2 (f1 date NOT NULL, f2 text) PARTITION BY RANGE (f1)

CREATE TABLE pitest2_p1 PARTITION OF pitest2 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01')

CREATE TABLE pitest2_p2 PARTITION OF pitest2 FOR VALUES FROM ('2016-08-01') TO ('2016-09-01')

INSERT into pitest2(f1, f2) VALUES ('2016-07-2', 'from pitest2')

INSERT INTO pitest2 (f1, f2) VALUES ('2016-08-2', 'from pitest2')

ALTER TABLE pitest2 ADD COLUMN f3 int GENERATED ALWAYS AS IDENTITY

INSERT into pitest2_p1 (f1, f2) VALUES ('2016-07-3', 'from pitest2_p1')

INSERT INTO pitest2_p2 (f1, f2) VALUES ('2016-08-3', 'from pitest2_p2')

INSERT into pitest2(f1, f2) VALUES ('2016-07-4', 'from pitest2')

INSERT INTO pitest2 (f1, f2) VALUES ('2016-08-4', 'from pitest2')

SELECT tableoid::regclass, f1, f2, f3 FROM pitest2
RESULT: 
	[('pitest2_p1', datetime.date(2016, 7, 2), 'from pitest2', 1), ('pitest2_p1', datetime.date(2016, 7, 3), 'from pitest2_p1', 3), ('pitest2_p1', datetime.date(2016, 7, 4), 'from pitest2', 5), ('pitest2_p2', datetime.date(2016, 8, 2), 'from pitest2', 2), ('pitest2_p2', datetime.date(2016, 8, 3), 'from pitest2_p2', 4), ('pitest2_p2', datetime.date(2016, 8, 4), 'from pitest2', 6)]


-- SET identity column
ALTER TABLE pitest2_p1 ALTER COLUMN f3 SET GENERATED BY DEFAULT
ProgrammingError: 

-- SET identity column
ALTER TABLE pitest2_p1 ALTER COLUMN f3 SET GENERATED BY DEFAULT

cannot change identity column of a partition

 -- fails
ALTER TABLE pitest2_p1 ALTER COLUMN f3 SET INCREMENT BY 2
ProgrammingError:  -- fails
ALTER TABLE pitest2_p1 ALTER COLUMN f3 SET INCREMENT BY 2

cannot change identity column of a partition

 -- fails
ALTER TABLE ONLY pitest2 ALTER COLUMN f3 SET GENERATED BY DEFAULT SET INCREMENT BY 2 SET START WITH 1000 RESTART
ProgrammingError:  -- fails
ALTER TABLE ONLY pitest2 ALTER COLUMN f3 SET GENERATED BY DEFAULT SET INCREMENT BY 2 SET START WITH 1000 RESTART

cannot change identity column of only the partitioned table
HINT:  Do not specify the ONLY keyword.

 -- fails
ALTER TABLE pitest2 ALTER COLUMN f3 SET GENERATED BY DEFAULT SET INCREMENT BY 2 SET START WITH 1000 RESTART

INSERT into pitest2(f1, f2, f3) VALUES ('2016-07-5', 'from pitest2', 200)

INSERT INTO pitest2(f1, f2) VALUES ('2016-08-5', 'from pitest2')

INSERT into pitest2_p1 (f1, f2) VALUES ('2016-07-6', 'from pitest2_p1')

INSERT INTO pitest2_p2 (f1, f2, f3) VALUES ('2016-08-6', 'from pitest2_p2', 300)

SELECT tableoid::regclass, f1, f2, f3 FROM pitest2
RESULT: 
	[('pitest2_p1', datetime.date(2016, 7, 2), 'from pitest2', 1), ('pitest2_p1', datetime.date(2016, 7, 3), 'from pitest2_p1', 3), ('pitest2_p1', datetime.date(2016, 7, 4), 'from pitest2', 5), ('pitest2_p1', datetime.date(2016, 7, 5), 'from pitest2', 200), ('pitest2_p1', datetime.date(2016, 7, 6), 'from pitest2_p1', 1002), ('pitest2_p2', datetime.date(2016, 8, 2), 'from pitest2', 2), ('pitest2_p2', datetime.date(2016, 8, 3), 'from pitest2_p2', 4), ('pitest2_p2', datetime.date(2016, 8, 4), 'from pitest2', 6), ('pitest2_p2', datetime.date(2016, 8, 5), 'from pitest2', 1000), ('pitest2_p2', datetime.date(2016, 8, 6), 'from pitest2_p2', 300)]


-- detaching a partition removes identity property
ALTER TABLE pitest2 DETACH PARTITION pitest2_p1

INSERT into pitest2(f1, f2) VALUES ('2016-08-7', 'from pitest2')

INSERT into pitest2_p1 (f1, f2) VALUES ('2016-07-7', 'from pitest2_p1')
ERROR: 
INSERT into pitest2_p1 (f1, f2) VALUES ('2016-07-7', 'from pitest2_p1')

null value in column "f3" of relation "pitest2_p1" violates not-null constraint
DETAIL:  Failing row contains (2016-07-07, from pitest2_p1, null).

 -- error
INSERT into pitest2_p1 (f1, f2, f3) VALUES ('2016-07-7', 'from pitest2_p1', 2000)

SELECT tableoid::regclass, f1, f2, f3 FROM pitest2
RESULT: 
	[('pitest2_p2', datetime.date(2016, 8, 2), 'from pitest2', 2), ('pitest2_p2', datetime.date(2016, 8, 3), 'from pitest2_p2', 4), ('pitest2_p2', datetime.date(2016, 8, 4), 'from pitest2', 6), ('pitest2_p2', datetime.date(2016, 8, 5), 'from pitest2', 1000), ('pitest2_p2', datetime.date(2016, 8, 6), 'from pitest2_p2', 300), ('pitest2_p2', datetime.date(2016, 8, 7), 'from pitest2', 1004)]

SELECT tableoid::regclass, f1, f2, f3 FROM pitest2_p1
RESULT: 
	[('pitest2_p1', datetime.date(2016, 7, 2), 'from pitest2', 1), ('pitest2_p1', datetime.date(2016, 7, 3), 'from pitest2_p1', 3), ('pitest2_p1', datetime.date(2016, 7, 4), 'from pitest2', 5), ('pitest2_p1', datetime.date(2016, 7, 5), 'from pitest2', 200), ('pitest2_p1', datetime.date(2016, 7, 6), 'from pitest2_p1', 1002), ('pitest2_p1', datetime.date(2016, 7, 7), 'from pitest2_p1', 2000)]


DROP TABLE pitest2_p1


-- changing a regular column to identity column in a partitioned table
CREATE TABLE pitest3 (f1 date NOT NULL, f2 text, f3 int) PARTITION BY RANGE (f1)

CREATE TABLE pitest3_p1 PARTITION OF pitest3 FOR VALUES FROM ('2016-07-01') TO ('2016-08-01')

INSERT into pitest3 VALUES ('2016-07-2', 'from pitest3', 1)

INSERT into pitest3_p1 VALUES ('2016-07-3', 'from pitest3_p1', 2)

-- fails, changing only a partition not allowed
ALTER TABLE pitest3_p1
            ALTER COLUMN f3 SET NOT NULL,
            ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY (START WITH 3)
ProgrammingError: 
-- fails, changing only a partition not allowed
ALTER TABLE pitest3_p1
            ALTER COLUMN f3 SET NOT NULL,
            ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY (START WITH 3)

cannot add identity to a column of a partition


-- fails, changing only the partitioned table not allowed
ALTER TABLE ONLY pitest3
            ALTER COLUMN f3 SET NOT NULL,
            ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY (START WITH 3)
ProgrammingError: 
-- fails, changing only the partitioned table not allowed
ALTER TABLE ONLY pitest3
            ALTER COLUMN f3 SET NOT NULL,
            ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY (START WITH 3)

constraint must be added to child tables too
HINT:  Do not specify the ONLY keyword.


ALTER TABLE pitest3
            ALTER COLUMN f3 SET NOT NULL,
            ALTER COLUMN f3 ADD GENERATED ALWAYS AS IDENTITY (START WITH 3)

INSERT into pitest3(f1, f2) VALUES ('2016-07-4', 'from pitest3')

INSERT into pitest3_p1 (f1, f2) VALUES ('2016-07-5', 'from pitest3_p1')

SELECT tableoid::regclass, f1, f2, f3 FROM pitest3
RESULT: 
	[('pitest3_p1', datetime.date(2016, 7, 2), 'from pitest3', 1), ('pitest3_p1', datetime.date(2016, 7, 3), 'from pitest3_p1', 2), ('pitest3_p1', datetime.date(2016, 7, 4), 'from pitest3', 3), ('pitest3_p1', datetime.date(2016, 7, 5), 'from pitest3_p1', 4)]


-- changing an identity column to a non-identity column in a partitioned table
ALTER TABLE pitest3_p1 ALTER COLUMN f3 DROP IDENTITY
ProgrammingError: 

-- changing an identity column to a non-identity column in a partitioned table
ALTER TABLE pitest3_p1 ALTER COLUMN f3 DROP IDENTITY

cannot drop identity from a column of a partition

 -- fails
ALTER TABLE ONLY pitest3 ALTER COLUMN f3 DROP IDENTITY
ProgrammingError:  -- fails
ALTER TABLE ONLY pitest3 ALTER COLUMN f3 DROP IDENTITY

cannot drop identity from a column of only the partitioned table
HINT:  Do not specify the ONLY keyword.

 -- fails
ALTER TABLE pitest3 ALTER COLUMN f3 DROP IDENTITY

INSERT into pitest3(f1, f2) VALUES ('2016-07-4', 'from pitest3')
ERROR: 
INSERT into pitest3(f1, f2) VALUES ('2016-07-4', 'from pitest3')

null value in column "f3" of relation "pitest3_p1" violates not-null constraint
DETAIL:  Failing row contains (2016-07-04, from pitest3, null).

 -- fails
INSERT into pitest3_p1 (f1, f2) VALUES ('2016-07-5', 'from pitest3_p1')
ERROR:  -- fails
INSERT into pitest3_p1 (f1, f2) VALUES ('2016-07-5', 'from pitest3_p1')

null value in column "f3" of relation "pitest3_p1" violates not-null constraint
DETAIL:  Failing row contains (2016-07-05, from pitest3_p1, null).

 -- fails
INSERT into pitest3(f1, f2, f3) VALUES ('2016-07-6', 'from pitest3', 5)

INSERT into pitest3_p1 (f1, f2, f3) VALUES ('2016-07-7', 'from pitest3_p1', 6)

SELECT tableoid::regclass, f1, f2, f3 FROM pitest3
RESULT: 
	[('pitest3_p1', datetime.date(2016, 7, 2), 'from pitest3', 1), ('pitest3_p1', datetime.date(2016, 7, 3), 'from pitest3_p1', 2), ('pitest3_p1', datetime.date(2016, 7, 4), 'from pitest3', 3), ('pitest3_p1', datetime.date(2016, 7, 5), 'from pitest3_p1', 4), ('pitest3_p1', datetime.date(2016, 7, 6), 'from pitest3', 5), ('pitest3_p1', datetime.date(2016, 7, 7), 'from pitest3_p1', 6)]


-- Changing NOT NULL constraint of identity columns is not allowed
ALTER TABLE pitest1_p1 ALTER COLUMN f3 DROP NOT NULL
ProgrammingError: 

-- Changing NOT NULL constraint of identity columns is not allowed
ALTER TABLE pitest1_p1 ALTER COLUMN f3 DROP NOT NULL

column "f3" of relation "pitest1_p1" is an identity column


ALTER TABLE pitest1 ALTER COLUMN f3 DROP NOT NULL
ProgrammingError: 
ALTER TABLE pitest1 ALTER COLUMN f3 DROP NOT NULL

column "f3" of relation "pitest1" is an identity column


-- Identity columns have their own default
ALTER TABLE pitest1_p2 ALTER COLUMN f3 SET DEFAULT 10000
ProgrammingError: 
-- Identity columns have their own default
ALTER TABLE pitest1_p2 ALTER COLUMN f3 SET DEFAULT 10000

column "f3" of relation "pitest1_p2" is an identity column


ALTER TABLE pitest1 ALTER COLUMN f3 SET DEFAULT 10000
ProgrammingError: 
ALTER TABLE pitest1 ALTER COLUMN f3 SET DEFAULT 10000

column "f3" of relation "pitest1" is an identity column


-- Adding identity to an identity column is not allowed
ALTER TABLE pitest1_p2 ALTER COLUMN f3 ADD GENERATED BY DEFAULT AS IDENTITY
ProgrammingError: 
-- Adding identity to an identity column is not allowed
ALTER TABLE pitest1_p2 ALTER COLUMN f3 ADD GENERATED BY DEFAULT AS IDENTITY

cannot add identity to a column of a partition


ALTER TABLE pitest1 ALTER COLUMN f3 ADD GENERATED BY DEFAULT AS IDENTITY
ERROR: 
ALTER TABLE pitest1 ALTER COLUMN f3 ADD GENERATED BY DEFAULT AS IDENTITY

column "f3" of relation "pitest1" is already an identity column



-- partitions with their own identity columns are not allowed, even if the
-- partitioned table does not have an identity column.
CREATE TABLE pitest1_pfail PARTITION OF pitest1 (
    f3 WITH OPTIONS GENERATED ALWAYS AS IDENTITY
) FOR VALUES FROM ('2016-11-01') TO ('2016-12-01')
ERROR: 

-- partitions with their own identity columns are not allowed, even if the
-- partitioned table does not have an identity column.
CREATE TABLE pitest1_pfail PARTITION OF pitest1 (
    f3 WITH OPTIONS GENERATED ALWAYS AS IDENTITY
) FOR VALUES FROM ('2016-11-01') TO ('2016-12-01')

identity columns are not supported on partitions



CREATE TABLE pitest_pfail PARTITION OF pitest3 (
    f3 WITH OPTIONS GENERATED ALWAYS AS IDENTITY
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01')
ERROR: 

CREATE TABLE pitest_pfail PARTITION OF pitest3 (
    f3 WITH OPTIONS GENERATED ALWAYS AS IDENTITY
) FOR VALUES FROM ('2016-07-01') TO ('2016-08-01')

identity columns are not supported on partitions



CREATE TABLE pitest1_pfail (f1 date NOT NULL, f2 text, f3 bigint GENERATED ALWAYS AS IDENTITY)

ALTER TABLE pitest1 ATTACH PARTITION pitest1_pfail FOR VALUES FROM ('2016-11-01') TO ('2016-12-01')
ERROR: 
ALTER TABLE pitest1 ATTACH PARTITION pitest1_pfail FOR VALUES FROM ('2016-11-01') TO ('2016-12-01')

table "pitest1_pfail" being attached contains an identity column "f3"
DETAIL:  The new partition may not contain an identity column.


ALTER TABLE pitest3 ATTACH PARTITION pitest1_pfail FOR VALUES FROM ('2016-11-01') TO ('2016-12-01')
ERROR: 
ALTER TABLE pitest3 ATTACH PARTITION pitest1_pfail FOR VALUES FROM ('2016-11-01') TO ('2016-12-01')

table "pitest1_pfail" being attached contains an identity column "f3"
DETAIL:  The new partition may not contain an identity column.



DROP TABLE pitest1_pfail

DROP TABLE pitest3


-- test that sequence of half-dropped serial column is properly ignored

CREATE TABLE itest14 (id serial)

ALTER TABLE itest14 ALTER id DROP DEFAULT

ALTER TABLE itest14 ALTER id ADD GENERATED BY DEFAULT AS IDENTITY

INSERT INTO itest14 (id) VALUES (DEFAULT)


-- Identity columns must be NOT NULL (cf bug #16913)

CREATE TABLE itest15 (id integer GENERATED ALWAYS AS IDENTITY NULL)
ProgrammingError: 

-- Identity columns must be NOT NULL (cf bug #16913)

CREATE TABLE itest15 (id integer GENERATED ALWAYS AS IDENTITY NULL)

conflicting NULL/NOT NULL declarations for column "id" of table "itest15"
LINE 5: ...TABLE itest15 (id integer GENERATED ALWAYS AS IDENTITY NULL)
                                                                  ^

 -- fail
CREATE TABLE itest15 (id integer NULL GENERATED ALWAYS AS IDENTITY)
ProgrammingError:  -- fail
CREATE TABLE itest15 (id integer NULL GENERATED ALWAYS AS IDENTITY)

conflicting NULL/NOT NULL declarations for column "id" of table "itest15"
LINE 2: CREATE TABLE itest15 (id integer NULL GENERATED ALWAYS AS ID...
                                              ^

 -- fail
CREATE TABLE itest15 (id integer GENERATED ALWAYS AS IDENTITY NOT NULL)

DROP TABLE itest15

CREATE TABLE itest15 (id integer NOT NULL GENERATED ALWAYS AS IDENTITY)

DROP TABLE itest15


-- MERGE tests
CREATE TABLE itest15 (a int GENERATED ALWAYS AS IDENTITY, b text)

CREATE TABLE itest16 (a int GENERATED BY DEFAULT AS IDENTITY, b text)


MERGE INTO itest15 t
USING (SELECT 10 AS s_a, 'inserted by merge' AS s_b) s
ON t.a = s.s_a
WHEN NOT MATCHED THEN
	INSERT (a, b) VALUES (s.s_a, s.s_b)
ProgrammingError: 

MERGE INTO itest15 t
USING (SELECT 10 AS s_a, 'inserted by merge' AS s_b) s
ON t.a = s.s_a
WHEN NOT MATCHED THEN
	INSERT (a, b) VALUES (s.s_a, s.s_b)

cannot insert a non-DEFAULT value into column "a"
DETAIL:  Column "a" is an identity column defined as GENERATED ALWAYS.
HINT:  Use OVERRIDING SYSTEM VALUE to override.



-- Used to fail, but now it works and ignores the user supplied value
MERGE INTO itest15 t
USING (SELECT 20 AS s_a, 'inserted by merge' AS s_b) s
ON t.a = s.s_a
WHEN NOT MATCHED THEN
	INSERT (a, b) OVERRIDING USER VALUE VALUES (s.s_a, s.s_b)


MERGE INTO itest15 t
USING (SELECT 30 AS s_a, 'inserted by merge' AS s_b) s
ON t.a = s.s_a
WHEN NOT MATCHED THEN
	INSERT (a, b) OVERRIDING SYSTEM VALUE VALUES (s.s_a, s.s_b)


MERGE INTO itest16 t
USING (SELECT 10 AS s_a, 'inserted by merge' AS s_b) s
ON t.a = s.s_a
WHEN NOT MATCHED THEN
	INSERT (a, b) VALUES (s.s_a, s.s_b)


MERGE INTO itest16 t
USING (SELECT 20 AS s_a, 'inserted by merge' AS s_b) s
ON t.a = s.s_a
WHEN NOT MATCHED THEN
	INSERT (a, b) OVERRIDING USER VALUE VALUES (s.s_a, s.s_b)


MERGE INTO itest16 t
USING (SELECT 30 AS s_a, 'inserted by merge' AS s_b) s
ON t.a = s.s_a
WHEN NOT MATCHED THEN
	INSERT (a, b) OVERRIDING SYSTEM VALUE VALUES (s.s_a, s.s_b)


SELECT * FROM itest15
RESULT: 
	[(1, 'inserted by merge'), (30, 'inserted by merge')]

SELECT * FROM itest16
RESULT: 
	[(10, 'inserted by merge'), (1, 'inserted by merge'), (30, 'inserted by merge')]

DROP TABLE itest15

DROP TABLE itest16


