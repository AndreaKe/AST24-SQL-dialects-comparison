
-----------
QUERY:
--
-- Test inheritance features
--
CREATE TABLE a (aa TEXT);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE b (bb TEXT) INHERITS (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE c (cc TEXT) INHERITS (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE d (dd TEXT) INHERITS (b,c,a);
RESULT:
	[]

-----------
QUERY:


INSERT INTO a(aa) VALUES('aaa');
RESULT:
	[]

-----------
QUERY:

INSERT INTO a(aa) VALUES('aaaa');
RESULT:
	[]

-----------
QUERY:

INSERT INTO a(aa) VALUES('aaaaa');
RESULT:
	[]

-----------
QUERY:

INSERT INTO a(aa) VALUES('aaaaaa');
RESULT:
	[]

-----------
QUERY:

INSERT INTO a(aa) VALUES('aaaaaaa');
RESULT:
	[]

-----------
QUERY:

INSERT INTO a(aa) VALUES('aaaaaaaa');
RESULT:
	[]

-----------
QUERY:


INSERT INTO b(aa) VALUES('bbb');
RESULT:
	[]

-----------
QUERY:

INSERT INTO b(aa) VALUES('bbbb');
RESULT:
	[]

-----------
QUERY:

INSERT INTO b(aa) VALUES('bbbbb');
RESULT:
	[]

-----------
QUERY:

INSERT INTO b(aa) VALUES('bbbbbb');
RESULT:
	[]

-----------
QUERY:

INSERT INTO b(aa) VALUES('bbbbbbb');
RESULT:
	[]

-----------
QUERY:

INSERT INTO b(aa) VALUES('bbbbbbbb');
RESULT:
	[]

-----------
QUERY:


INSERT INTO c(aa) VALUES('ccc');
RESULT:
	[]

-----------
QUERY:

INSERT INTO c(aa) VALUES('cccc');
RESULT:
	[]

-----------
QUERY:

INSERT INTO c(aa) VALUES('ccccc');
RESULT:
	[]

-----------
QUERY:

INSERT INTO c(aa) VALUES('cccccc');
RESULT:
	[]

-----------
QUERY:

INSERT INTO c(aa) VALUES('ccccccc');
RESULT:
	[]

-----------
QUERY:

INSERT INTO c(aa) VALUES('cccccccc');
RESULT:
	[]

-----------
QUERY:


INSERT INTO d(aa) VALUES('ddd');
RESULT:
	[]

-----------
QUERY:

INSERT INTO d(aa) VALUES('dddd');
RESULT:
	[]

-----------
QUERY:

INSERT INTO d(aa) VALUES('ddddd');
RESULT:
	[]

-----------
QUERY:

INSERT INTO d(aa) VALUES('dddddd');
RESULT:
	[]

-----------
QUERY:

INSERT INTO d(aa) VALUES('ddddddd');
RESULT:
	[]

-----------
QUERY:

INSERT INTO d(aa) VALUES('dddddddd');
RESULT:
	[]

-----------
QUERY:


SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
RESULT:
	[('a', 'aaa'), ('a', 'aaaa'), ('a', 'aaaaa'), ('a', 'aaaaaa'), ('a', 'aaaaaaa'), ('a', 'aaaaaaaa'), ('b', 'bbb'), ('b', 'bbbb'), ('b', 'bbbbb'), ('b', 'bbbbbb'), ('b', 'bbbbbbb'), ('b', 'bbbbbbbb'), ('c', 'ccc'), ('c', 'cccc'), ('c', 'ccccc'), ('c', 'cccccc'), ('c', 'ccccccc'), ('c', 'cccccccc'), ('d', 'ddd'), ('d', 'dddd'), ('d', 'ddddd'), ('d', 'dddddd'), ('d', 'ddddddd'), ('d', 'dddddddd')]

-----------
QUERY:

SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
RESULT:
	[('b', 'bbb', None), ('b', 'bbbb', None), ('b', 'bbbbb', None), ('b', 'bbbbbb', None), ('b', 'bbbbbbb', None), ('b', 'bbbbbbbb', None), ('d', 'ddd', None), ('d', 'dddd', None), ('d', 'ddddd', None), ('d', 'dddddd', None), ('d', 'ddddddd', None), ('d', 'dddddddd', None)]

-----------
QUERY:

SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
RESULT:
	[('c', 'ccc', None), ('c', 'cccc', None), ('c', 'ccccc', None), ('c', 'cccccc', None), ('c', 'ccccccc', None), ('c', 'cccccccc', None), ('d', 'ddd', None), ('d', 'dddd', None), ('d', 'ddddd', None), ('d', 'dddddd', None), ('d', 'ddddddd', None), ('d', 'dddddddd', None)]

-----------
QUERY:

SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
RESULT:
	[('d', 'ddd', None, None, None), ('d', 'dddd', None, None, None), ('d', 'ddddd', None, None, None), ('d', 'dddddd', None, None, None), ('d', 'ddddddd', None, None, None), ('d', 'dddddddd', None, None, None)]

-----------
QUERY:

SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
RESULT:
	[('a', 'aaa'), ('a', 'aaaa'), ('a', 'aaaaa'), ('a', 'aaaaaa'), ('a', 'aaaaaaa'), ('a', 'aaaaaaaa')]

-----------
QUERY:

SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
RESULT:
	[('b', 'bbb', None), ('b', 'bbbb', None), ('b', 'bbbbb', None), ('b', 'bbbbbb', None), ('b', 'bbbbbbb', None), ('b', 'bbbbbbbb', None)]

-----------
QUERY:

SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
RESULT:
	[('c', 'ccc', None), ('c', 'cccc', None), ('c', 'ccccc', None), ('c', 'cccccc', None), ('c', 'ccccccc', None), ('c', 'cccccccc', None)]

-----------
QUERY:

SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
RESULT:
	[('d', 'ddd', None, None, None), ('d', 'dddd', None, None, None), ('d', 'ddddd', None, None, None), ('d', 'dddddd', None, None, None), ('d', 'ddddddd', None, None, None), ('d', 'dddddddd', None, None, None)]

-----------
QUERY:


UPDATE a SET aa='zzzz' WHERE aa='aaaa';
RESULT:
	[]

-----------
QUERY:

UPDATE ONLY a SET aa='zzzzz' WHERE aa='aaaaa';
RESULT:
	[]

-----------
QUERY:

UPDATE b SET aa='zzz' WHERE aa='aaa';
RESULT:
	[]

-----------
QUERY:

UPDATE ONLY b SET aa='zzz' WHERE aa='aaa';
RESULT:
	[]

-----------
QUERY:

UPDATE a SET aa='zzzzzz' WHERE aa LIKE 'aaa%';
RESULT:
	[]

-----------
QUERY:


SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
RESULT:
	[('a', 'zzzz'), ('a', 'zzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz'), ('b', 'bbb'), ('b', 'bbbb'), ('b', 'bbbbb'), ('b', 'bbbbbb'), ('b', 'bbbbbbb'), ('b', 'bbbbbbbb'), ('c', 'ccc'), ('c', 'cccc'), ('c', 'ccccc'), ('c', 'cccccc'), ('c', 'ccccccc'), ('c', 'cccccccc'), ('d', 'ddd'), ('d', 'dddd'), ('d', 'ddddd'), ('d', 'dddddd'), ('d', 'ddddddd'), ('d', 'dddddddd')]

-----------
QUERY:

SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
RESULT:
	[('b', 'bbb', None), ('b', 'bbbb', None), ('b', 'bbbbb', None), ('b', 'bbbbbb', None), ('b', 'bbbbbbb', None), ('b', 'bbbbbbbb', None), ('d', 'ddd', None), ('d', 'dddd', None), ('d', 'ddddd', None), ('d', 'dddddd', None), ('d', 'ddddddd', None), ('d', 'dddddddd', None)]

-----------
QUERY:

SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
RESULT:
	[('c', 'ccc', None), ('c', 'cccc', None), ('c', 'ccccc', None), ('c', 'cccccc', None), ('c', 'ccccccc', None), ('c', 'cccccccc', None), ('d', 'ddd', None), ('d', 'dddd', None), ('d', 'ddddd', None), ('d', 'dddddd', None), ('d', 'ddddddd', None), ('d', 'dddddddd', None)]

-----------
QUERY:

SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
RESULT:
	[('d', 'ddd', None, None, None), ('d', 'dddd', None, None, None), ('d', 'ddddd', None, None, None), ('d', 'dddddd', None, None, None), ('d', 'ddddddd', None, None, None), ('d', 'dddddddd', None, None, None)]

-----------
QUERY:

SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
RESULT:
	[('a', 'zzzz'), ('a', 'zzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz')]

-----------
QUERY:

SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
RESULT:
	[('b', 'bbb', None), ('b', 'bbbb', None), ('b', 'bbbbb', None), ('b', 'bbbbbb', None), ('b', 'bbbbbbb', None), ('b', 'bbbbbbbb', None)]

-----------
QUERY:

SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
RESULT:
	[('c', 'ccc', None), ('c', 'cccc', None), ('c', 'ccccc', None), ('c', 'cccccc', None), ('c', 'ccccccc', None), ('c', 'cccccccc', None)]

-----------
QUERY:

SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
RESULT:
	[('d', 'ddd', None, None, None), ('d', 'dddd', None, None, None), ('d', 'ddddd', None, None, None), ('d', 'dddddd', None, None, None), ('d', 'ddddddd', None, None, None), ('d', 'dddddddd', None, None, None)]

-----------
QUERY:


UPDATE b SET aa='new';
RESULT:
	[]

-----------
QUERY:


SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
RESULT:
	[('a', 'zzzz'), ('a', 'zzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz'), ('b', 'new'), ('b', 'new'), ('b', 'new'), ('b', 'new'), ('b', 'new'), ('b', 'new'), ('c', 'ccc'), ('c', 'cccc'), ('c', 'ccccc'), ('c', 'cccccc'), ('c', 'ccccccc'), ('c', 'cccccccc'), ('d', 'new'), ('d', 'new'), ('d', 'new'), ('d', 'new'), ('d', 'new'), ('d', 'new')]

-----------
QUERY:

SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
RESULT:
	[('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None)]

-----------
QUERY:

SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
RESULT:
	[('c', 'ccc', None), ('c', 'cccc', None), ('c', 'ccccc', None), ('c', 'cccccc', None), ('c', 'ccccccc', None), ('c', 'cccccccc', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None)]

-----------
QUERY:

SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
RESULT:
	[('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None)]

-----------
QUERY:

SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
RESULT:
	[('a', 'zzzz'), ('a', 'zzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz'), ('a', 'zzzzzz')]

-----------
QUERY:

SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
RESULT:
	[('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None)]

-----------
QUERY:

SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
RESULT:
	[('c', 'ccc', None), ('c', 'cccc', None), ('c', 'ccccc', None), ('c', 'cccccc', None), ('c', 'ccccccc', None), ('c', 'cccccccc', None)]

-----------
QUERY:

SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
RESULT:
	[('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None)]

-----------
QUERY:


UPDATE a SET aa='new';
RESULT:
	[]

-----------
QUERY:


DELETE FROM ONLY c WHERE aa='new';
RESULT:
	[]

-----------
QUERY:


SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
RESULT:
	[('a', 'new'), ('a', 'new'), ('a', 'new'), ('a', 'new'), ('a', 'new'), ('a', 'new'), ('b', 'new'), ('b', 'new'), ('b', 'new'), ('b', 'new'), ('b', 'new'), ('b', 'new'), ('d', 'new'), ('d', 'new'), ('d', 'new'), ('d', 'new'), ('d', 'new'), ('d', 'new')]

-----------
QUERY:

SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
RESULT:
	[('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None)]

-----------
QUERY:

SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
RESULT:
	[('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None), ('d', 'new', None)]

-----------
QUERY:

SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
RESULT:
	[('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None)]

-----------
QUERY:

SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
RESULT:
	[('a', 'new'), ('a', 'new'), ('a', 'new'), ('a', 'new'), ('a', 'new'), ('a', 'new')]

-----------
QUERY:

SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
RESULT:
	[('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None), ('b', 'new', None)]

-----------
QUERY:

SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
RESULT:
	[]

-----------
QUERY:

SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
RESULT:
	[('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None), ('d', 'new', None, None, None)]

-----------
QUERY:


DELETE FROM a;
RESULT:
	[]

-----------
QUERY:


SELECT relname, a.* FROM a, pg_class where a.tableoid = pg_class.oid;
RESULT:
	[]

-----------
QUERY:

SELECT relname, b.* FROM b, pg_class where b.tableoid = pg_class.oid;
RESULT:
	[]

-----------
QUERY:

SELECT relname, c.* FROM c, pg_class where c.tableoid = pg_class.oid;
RESULT:
	[]

-----------
QUERY:

SELECT relname, d.* FROM d, pg_class where d.tableoid = pg_class.oid;
RESULT:
	[]

-----------
QUERY:

SELECT relname, a.* FROM ONLY a, pg_class where a.tableoid = pg_class.oid;
RESULT:
	[]

-----------
QUERY:

SELECT relname, b.* FROM ONLY b, pg_class where b.tableoid = pg_class.oid;
RESULT:
	[]

-----------
QUERY:

SELECT relname, c.* FROM ONLY c, pg_class where c.tableoid = pg_class.oid;
RESULT:
	[]

-----------
QUERY:

SELECT relname, d.* FROM ONLY d, pg_class where d.tableoid = pg_class.oid;
RESULT:
	[]

-----------
QUERY:


-- Confirm PRIMARY KEY adds NOT NULL constraint to child table
CREATE TEMP TABLE z (b TEXT, PRIMARY KEY(aa, b)) inherits (a);
RESULT:
	[]

-----------
QUERY:

INSERT INTO z VALUES (NULL, 'text');
RESULT:
	ERROR - null value in column "aa" of relation "z" violates not-null constraint
DETAIL:  Failing row contains (null, text).


-----------
QUERY:
 -- should fail

-- Check inherited UPDATE with first child excluded
create table some_tab (f1 int, f2 int, f3 int, check (f1 < 10) no inherit);
RESULT:
	[]

-----------
QUERY:

create table some_tab_child () inherits(some_tab);
RESULT:
	[]

-----------
QUERY:

insert into some_tab_child select i, i+1, 0 from generate_series(1,1000) i;
RESULT:
	[]

-----------
QUERY:

create index on some_tab_child(f1, f2);
RESULT:
	[]

-----------
QUERY:

-- while at it, also check that statement-level triggers fire
create function some_tab_stmt_trig_func() returns trigger as
$$begin raise notice 'updating some_tab'; return NULL; end;$$
language plpgsql;
RESULT:
	[]

-----------
QUERY:

create trigger some_tab_stmt_trig
  before update on some_tab execute function some_tab_stmt_trig_func();
RESULT:
	[]

-----------
QUERY:


explain (costs off)
update some_tab set f3 = 11 where f1 = 12 and f2 = 13;
RESULT:
	[('Update on some_tab',), ('  Update on some_tab_child some_tab_1',), ('  ->  Result',), ('        ->  Index Scan using some_tab_child_f1_f2_idx on some_tab_child some_tab_1',), ('              Index Cond: ((f1 = 12) AND (f2 = 13))',)]

-----------
QUERY:

update some_tab set f3 = 11 where f1 = 12 and f2 = 13;
RESULT:
	[]

-----------
QUERY:


drop table some_tab cascade;
RESULT:
	[]

-----------
QUERY:

drop function some_tab_stmt_trig_func();
RESULT:
	[]

-----------
QUERY:


-- Check inherited UPDATE with all children excluded
create table some_tab (a int, b int);
RESULT:
	[]

-----------
QUERY:

create table some_tab_child () inherits (some_tab);
RESULT:
	[]

-----------
QUERY:

insert into some_tab_child values(1,2);
RESULT:
	[]

-----------
QUERY:


explain (verbose, costs off)
update some_tab set a = a + 1 where false;
RESULT:
	[('Update on public.some_tab',), ('  ->  Result',), ('        Output: (some_tab.a + 1), NULL::oid, NULL::tid',), ('        One-Time Filter: false',)]

-----------
QUERY:

update some_tab set a = a + 1 where false;
RESULT:
	[]

-----------
QUERY:

explain (verbose, costs off)
update some_tab set a = a + 1 where false returning b, a;
RESULT:
	[('Update on public.some_tab',), ('  Output: some_tab.b, some_tab.a',), ('  ->  Result',), ('        Output: (some_tab.a + 1), NULL::oid, NULL::tid',), ('        One-Time Filter: false',)]

-----------
QUERY:

update some_tab set a = a + 1 where false returning b, a;
RESULT:
	[]

-----------
QUERY:

table some_tab;
RESULT:
	[(1, 2)]

-----------
QUERY:


drop table some_tab cascade;
RESULT:
	[]

-----------
QUERY:


-- Check UPDATE with inherited target and an inherited source table
create temp table foo(f1 int, f2 int);
RESULT:
	[]

-----------
QUERY:

create temp table foo2(f3 int) inherits (foo);
RESULT:
	[]

-----------
QUERY:

create temp table bar(f1 int, f2 int);
RESULT:
	[]

-----------
QUERY:

create temp table bar2(f3 int) inherits (bar);
RESULT:
	[]

-----------
QUERY:


insert into foo values(1,1);
RESULT:
	[]

-----------
QUERY:

insert into foo values(3,3);
RESULT:
	[]

-----------
QUERY:

insert into foo2 values(2,2,2);
RESULT:
	[]

-----------
QUERY:

insert into foo2 values(3,3,3);
RESULT:
	[]

-----------
QUERY:

insert into bar values(1,1);
RESULT:
	[]

-----------
QUERY:

insert into bar values(2,2);
RESULT:
	[]

-----------
QUERY:

insert into bar values(3,3);
RESULT:
	[]

-----------
QUERY:

insert into bar values(4,4);
RESULT:
	[]

-----------
QUERY:

insert into bar2 values(1,1,1);
RESULT:
	[]

-----------
QUERY:

insert into bar2 values(2,2,2);
RESULT:
	[]

-----------
QUERY:

insert into bar2 values(3,3,3);
RESULT:
	[]

-----------
QUERY:

insert into bar2 values(4,4,4);
RESULT:
	[]

-----------
QUERY:


update bar set f2 = f2 + 100 where f1 in (select f1 from foo);
RESULT:
	[]

-----------
QUERY:


select tableoid::regclass::text as relname, bar.* from bar order by 1,2;
RESULT:
	[('bar', 1, 101), ('bar', 2, 102), ('bar', 3, 103), ('bar', 4, 4), ('bar2', 1, 101), ('bar2', 2, 102), ('bar2', 3, 103), ('bar2', 4, 4)]

-----------
QUERY:


-- Check UPDATE with inherited target and an appendrel subquery
update bar set f2 = f2 + 100
from
  ( select f1 from foo union all select f1+3 from foo ) ss
where bar.f1 = ss.f1;
RESULT:
	[]

-----------
QUERY:


select tableoid::regclass::text as relname, bar.* from bar order by 1,2;
RESULT:
	[('bar', 1, 201), ('bar', 2, 202), ('bar', 3, 203), ('bar', 4, 104), ('bar2', 1, 201), ('bar2', 2, 202), ('bar2', 3, 203), ('bar2', 4, 104)]

-----------
QUERY:


-- Check UPDATE with *partitioned* inherited target and an appendrel subquery
create table some_tab (a int);
RESULT:
	[]

-----------
QUERY:

insert into some_tab values (0);
RESULT:
	[]

-----------
QUERY:

create table some_tab_child () inherits (some_tab);
RESULT:
	[]

-----------
QUERY:

insert into some_tab_child values (1);
RESULT:
	[]

-----------
QUERY:

create table parted_tab (a int, b char) partition by list (a);
RESULT:
	[]

-----------
QUERY:

create table parted_tab_part1 partition of parted_tab for values in (1);
RESULT:
	[]

-----------
QUERY:

create table parted_tab_part2 partition of parted_tab for values in (2);
RESULT:
	[]

-----------
QUERY:

create table parted_tab_part3 partition of parted_tab for values in (3);
RESULT:
	[]

-----------
QUERY:

insert into parted_tab values (1, 'a'), (2, 'a'), (3, 'a');
RESULT:
	[]

-----------
QUERY:


update parted_tab set b = 'b'
from
  (select a from some_tab union all select a+1 from some_tab) ss (a)
where parted_tab.a = ss.a;
RESULT:
	[]

-----------
QUERY:

select tableoid::regclass::text as relname, parted_tab.* from parted_tab order by 1,2;
RESULT:
	[('parted_tab_part1', 1, 'b'), ('parted_tab_part2', 2, 'b'), ('parted_tab_part3', 3, 'a')]

-----------
QUERY:


truncate parted_tab;
RESULT:
	[]

-----------
QUERY:

insert into parted_tab values (1, 'a'), (2, 'a'), (3, 'a');
RESULT:
	[]

-----------
QUERY:

update parted_tab set b = 'b'
from
  (select 0 from parted_tab union all select 1 from parted_tab) ss (a)
where parted_tab.a = ss.a;
RESULT:
	[]

-----------
QUERY:

select tableoid::regclass::text as relname, parted_tab.* from parted_tab order by 1,2;
RESULT:
	[('parted_tab_part1', 1, 'b'), ('parted_tab_part2', 2, 'a'), ('parted_tab_part3', 3, 'a')]

-----------
QUERY:


-- modifies partition key, but no rows will actually be updated
explain update parted_tab set a = 2 where false;
RESULT:
	[('Update on parted_tab  (cost=0.00..0.00 rows=0 width=0)',), ('  ->  Result  (cost=0.00..0.00 rows=0 width=10)',), ('        One-Time Filter: false',)]

-----------
QUERY:


drop table parted_tab;
RESULT:
	[]

-----------
QUERY:


-- Check UPDATE with multi-level partitioned inherited target
create table mlparted_tab (a int, b char, c text) partition by list (a);
RESULT:
	[]

-----------
QUERY:

create table mlparted_tab_part1 partition of mlparted_tab for values in (1);
RESULT:
	[]

-----------
QUERY:

create table mlparted_tab_part2 partition of mlparted_tab for values in (2) partition by list (b);
RESULT:
	[]

-----------
QUERY:

create table mlparted_tab_part3 partition of mlparted_tab for values in (3);
RESULT:
	[]

-----------
QUERY:

create table mlparted_tab_part2a partition of mlparted_tab_part2 for values in ('a');
RESULT:
	[]

-----------
QUERY:

create table mlparted_tab_part2b partition of mlparted_tab_part2 for values in ('b');
RESULT:
	[]

-----------
QUERY:

insert into mlparted_tab values (1, 'a'), (2, 'a'), (2, 'b'), (3, 'a');
RESULT:
	[]

-----------
QUERY:


update mlparted_tab mlp set c = 'xxx'
from
  (select a from some_tab union all select a+1 from some_tab) ss (a)
where (mlp.a = ss.a and mlp.b = 'b') or mlp.a = 3;
RESULT:
	[]

-----------
QUERY:

select tableoid::regclass::text as relname, mlparted_tab.* from mlparted_tab order by 1,2;
RESULT:
	[('mlparted_tab_part1', 1, 'a', None), ('mlparted_tab_part2a', 2, 'a', None), ('mlparted_tab_part2b', 2, 'b', 'xxx'), ('mlparted_tab_part3', 3, 'a', 'xxx')]

-----------
QUERY:


drop table mlparted_tab;
RESULT:
	[]

-----------
QUERY:

drop table some_tab cascade;
RESULT:
	[]

-----------
QUERY:


/* Test multiple inheritance of column defaults */

CREATE TABLE firstparent (tomorrow date default now()::date + 1);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE secondparent (tomorrow date default  now() :: date  +  1);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE jointchild () INHERITS (firstparent, secondparent);
RESULT:
	[]

-----------
QUERY:
  -- ok
CREATE TABLE thirdparent (tomorrow date default now()::date - 1);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE otherchild () INHERITS (firstparent, thirdparent);
RESULT:
	ERROR - column "tomorrow" inherits conflicting default values
HINT:  To resolve the conflict, specify a default explicitly.


-----------
QUERY:
  -- not ok
CREATE TABLE otherchild (tomorrow date default now())
  INHERITS (firstparent, thirdparent);
RESULT:
	[]

-----------
QUERY:
  -- ok, child resolves ambiguous default

DROP TABLE firstparent, secondparent, jointchild, thirdparent, otherchild;
RESULT:
	[]

-----------
QUERY:


-- Test changing the type of inherited columns
insert into d values('test','one','two','three');
RESULT:
	[]

-----------
QUERY:

alter table a alter column aa type integer using bit_length(aa);
RESULT:
	[]

-----------
QUERY:

select * from d;
RESULT:
	[(32, 'one', 'two', 'three')]

-----------
QUERY:


-- The above verified that we can change the type of a multiply-inherited
-- column /* REPLACED */, but we should reject that if any definition was inherited from
-- an unrelated parent.
create temp table parent1(f1 int, f2 int);
RESULT:
	[]

-----------
QUERY:

create temp table parent2(f1 int, f3 bigint);
RESULT:
	[]

-----------
QUERY:

create temp table childtab(f4 int) inherits(parent1, parent2);
RESULT:
	[]

-----------
QUERY:

alter table parent1 alter column f1 type bigint;
RESULT:
	ERROR - cannot alter inherited column "f1" of relation "childtab"


-----------
QUERY:
  -- fail, conflict w/parent2
alter table parent1 alter column f2 type bigint;
RESULT:
	[]

-----------
QUERY:
  -- ok

-- Test non-inheritable parent constraints
create table p1(ff1 int);
RESULT:
	[]

-----------
QUERY:

alter table p1 add constraint p1chk check (ff1 > 0) no inherit;
RESULT:
	[]

-----------
QUERY:

alter table p1 add constraint p2chk check (ff1 > 10);
RESULT:
	[]

-----------
QUERY:

-- connoinherit should be true for NO INHERIT constraint
select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pgc.connoinherit from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname = 'p1' order by 1,2;
RESULT:
	[('p1', 'p1chk', 'c', True, 0, True), ('p1', 'p2chk', 'c', True, 0, False)]

-----------
QUERY:


-- Test that child does not inherit NO INHERIT constraints
create table c1 () inherits (p1);
RESULT:
	[]

-----------
QUERY:

-- \d p1
-- \d c1

-- Test that child does not override inheritable constraints of the parent
create table c2 (constraint p2chk check (ff1 > 10) no inherit) inherits (p1);
RESULT:
	ERROR - constraint "p2chk" conflicts with inherited constraint on relation "c2"


-----------
QUERY:
	--fails

drop table p1 cascade;
RESULT:
	[]

-----------
QUERY:


-- Tests for casting between the rowtypes of parent and child
-- tables. See the pgsql-hackers thread beginning Dec. 4/04
create table base (i integer);
RESULT:
	[]

-----------
QUERY:

create table derived () inherits (base);
RESULT:
	[]

-----------
QUERY:

create table more_derived (like derived, b int) inherits (derived);
RESULT:
	[]

-----------
QUERY:

insert into derived (i) values (0);
RESULT:
	[]

-----------
QUERY:

select derived::base from derived;
RESULT:
	[('(0)',)]

-----------
QUERY:

select NULL::derived::base;
RESULT:
	[(None,)]

-----------
QUERY:

-- remove redundant conversions.
explain (verbose on, costs off) select row(i, b)::more_derived::derived::base from more_derived;
RESULT:
	[('Seq Scan on public.more_derived',), ('  Output: (ROW(i, b)::more_derived)::base',)]

-----------
QUERY:

explain (verbose on, costs off) select (1, 2)::more_derived::derived::base;
RESULT:
	[('Result',), ("  Output: '(1)'::base",)]

-----------
QUERY:

drop table more_derived;
RESULT:
	[]

-----------
QUERY:

drop table derived;
RESULT:
	[]

-----------
QUERY:

drop table base;
RESULT:
	[]

-----------
QUERY:


create table p1(ff1 int);
RESULT:
	[]

-----------
QUERY:

create table p2(f1 text);
RESULT:
	[]

-----------
QUERY:

create function p2text(p2) returns text as 'select $1.f1' language sql;
RESULT:
	[]

-----------
QUERY:

create table c1(f3 int) inherits(p1,p2);
RESULT:
	[]

-----------
QUERY:

insert into c1 values(123456789, 'hi', 42);
RESULT:
	[]

-----------
QUERY:

select p2text(c1.*) from c1;
RESULT:
	[('hi',)]

-----------
QUERY:

drop function p2text(p2);
RESULT:
	[]

-----------
QUERY:

drop table c1;
RESULT:
	[]

-----------
QUERY:

drop table p2;
RESULT:
	[]

-----------
QUERY:

drop table p1;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE ac (aa TEXT);
RESULT:
	[]

-----------
QUERY:

alter table ac add constraint ac_check check (aa is not null);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE bc (bb TEXT) INHERITS (ac);
RESULT:
	[]

-----------
QUERY:

select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
RESULT:
	[('ac', 'ac_check', 'c', True, 0, '(aa IS NOT NULL)'), ('bc', 'ac_check', 'c', False, 1, '(aa IS NOT NULL)')]

-----------
QUERY:


insert into ac (aa) values (NULL);
RESULT:
	ERROR - new row for relation "ac" violates check constraint "ac_check"
DETAIL:  Failing row contains (null).


-----------
QUERY:

insert into bc (aa) values (NULL);
RESULT:
	ERROR - new row for relation "bc" violates check constraint "ac_check"
DETAIL:  Failing row contains (null, null).


-----------
QUERY:


alter table bc drop constraint ac_check;
RESULT:
	ERROR - cannot drop inherited constraint "ac_check" of relation "bc"


-----------
QUERY:
  -- fail, disallowed
alter table ac drop constraint ac_check;
RESULT:
	[]

-----------
QUERY:

select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
RESULT:
	[]

-----------
QUERY:


-- try the unnamed-constraint case
alter table ac add check (aa is not null);
RESULT:
	[]

-----------
QUERY:

select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
RESULT:
	[('ac', 'ac_aa_check', 'c', True, 0, '(aa IS NOT NULL)'), ('bc', 'ac_aa_check', 'c', False, 1, '(aa IS NOT NULL)')]

-----------
QUERY:


insert into ac (aa) values (NULL);
RESULT:
	ERROR - new row for relation "ac" violates check constraint "ac_aa_check"
DETAIL:  Failing row contains (null).


-----------
QUERY:

insert into bc (aa) values (NULL);
RESULT:
	ERROR - new row for relation "bc" violates check constraint "ac_aa_check"
DETAIL:  Failing row contains (null, null).


-----------
QUERY:


alter table bc drop constraint ac_aa_check;
RESULT:
	ERROR - cannot drop inherited constraint "ac_aa_check" of relation "bc"


-----------
QUERY:
  -- fail, disallowed
alter table ac drop constraint ac_aa_check;
RESULT:
	[]

-----------
QUERY:

select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
RESULT:
	[]

-----------
QUERY:


alter table ac add constraint ac_check check (aa is not null);
RESULT:
	[]

-----------
QUERY:

alter table bc no inherit ac;
RESULT:
	[]

-----------
QUERY:

select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
RESULT:
	[('ac', 'ac_check', 'c', True, 0, '(aa IS NOT NULL)'), ('bc', 'ac_check', 'c', True, 0, '(aa IS NOT NULL)')]

-----------
QUERY:

alter table bc drop constraint ac_check;
RESULT:
	[]

-----------
QUERY:

select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
RESULT:
	[('ac', 'ac_check', 'c', True, 0, '(aa IS NOT NULL)')]

-----------
QUERY:

alter table ac drop constraint ac_check;
RESULT:
	[]

-----------
QUERY:

select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
RESULT:
	[]

-----------
QUERY:


drop table bc;
RESULT:
	[]

-----------
QUERY:

drop table ac;
RESULT:
	[]

-----------
QUERY:


create table ac (a int constraint check_a check (a <> 0));
RESULT:
	[]

-----------
QUERY:

create table bc (a int constraint check_a check (a <> 0), b int constraint check_b check (b <> 0)) inherits (ac);
RESULT:
	[]

-----------
QUERY:

select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc') order by 1,2;
RESULT:
	[('ac', 'check_a', 'c', True, 0, '(a <> 0)'), ('bc', 'check_a', 'c', True, 1, '(a <> 0)'), ('bc', 'check_b', 'c', True, 0, '(b <> 0)')]

-----------
QUERY:


drop table bc;
RESULT:
	[]

-----------
QUERY:

drop table ac;
RESULT:
	[]

-----------
QUERY:


create table ac (a int constraint check_a check (a <> 0));
RESULT:
	[]

-----------
QUERY:

create table bc (b int constraint check_b check (b <> 0));
RESULT:
	[]

-----------
QUERY:

create table cc (c int constraint check_c check (c <> 0)) inherits (ac, bc);
RESULT:
	[]

-----------
QUERY:

select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
RESULT:
	[('ac', 'check_a', 'c', True, 0, '(a <> 0)'), ('bc', 'check_b', 'c', True, 0, '(b <> 0)'), ('cc', 'check_a', 'c', False, 1, '(a <> 0)'), ('cc', 'check_b', 'c', False, 1, '(b <> 0)'), ('cc', 'check_c', 'c', True, 0, '(c <> 0)')]

-----------
QUERY:


alter table cc no inherit bc;
RESULT:
	[]

-----------
QUERY:

select pc.relname, pgc.conname, pgc.contype, pgc.conislocal, pgc.coninhcount, pg_get_expr(pgc.conbin, pc.oid) as consrc from pg_class as pc inner join pg_constraint as pgc on (pgc.conrelid = pc.oid) where pc.relname in ('ac', 'bc', 'cc') order by 1,2;
RESULT:
	[('ac', 'check_a', 'c', True, 0, '(a <> 0)'), ('bc', 'check_b', 'c', True, 0, '(b <> 0)'), ('cc', 'check_a', 'c', False, 1, '(a <> 0)'), ('cc', 'check_b', 'c', True, 0, '(b <> 0)'), ('cc', 'check_c', 'c', True, 0, '(c <> 0)')]

-----------
QUERY:


drop table cc;
RESULT:
	[]

-----------
QUERY:

drop table bc;
RESULT:
	[]

-----------
QUERY:

drop table ac;
RESULT:
	[]

-----------
QUERY:


create table p1(f1 int);
RESULT:
	[]

-----------
QUERY:

create table p2(f2 int);
RESULT:
	[]

-----------
QUERY:

create table c1(f3 int) inherits(p1,p2);
RESULT:
	[]

-----------
QUERY:

insert into c1 values(1,-1,2);
RESULT:
	[]

-----------
QUERY:

alter table p2 add constraint cc check (f2>0);
RESULT:
	ERROR - check constraint "cc" of relation "c1" is violated by some row


-----------
QUERY:
  -- fail
alter table p2 add check (f2>0);
RESULT:
	ERROR - check constraint "p2_f2_check" of relation "c1" is violated by some row


-----------
QUERY:
  -- check it without a name, too
delete from c1;
RESULT:
	[]

-----------
QUERY:

insert into c1 values(1,1,2);
RESULT:
	[]

-----------
QUERY:

alter table p2 add check (f2>0);
RESULT:
	[]

-----------
QUERY:

insert into c1 values(1,-1,2);
RESULT:
	ERROR - new row for relation "c1" violates check constraint "p2_f2_check"
DETAIL:  Failing row contains (1, -1, 2).


-----------
QUERY:
  -- fail
create table c2(f3 int) inherits(p1,p2);
RESULT:
	[]

-----------
QUERY:

-- \d c2
create table c3 (f4 int) inherits(c1,c2);
RESULT:
	[]

-----------
QUERY:

-- \d c3
drop table p1 cascade;
RESULT:
	[]

-----------
QUERY:

drop table p2 cascade;
RESULT:
	[]

-----------
QUERY:


create table pp1 (f1 int);
RESULT:
	[]

-----------
QUERY:

create table cc1 (f2 text, f3 int) inherits (pp1);
RESULT:
	[]

-----------
QUERY:

alter table pp1 add column a1 int check (a1 > 0);
RESULT:
	[]

-----------
QUERY:

-- \d cc1
create table cc2(f4 float) inherits(pp1,cc1);
RESULT:
	[]

-----------
QUERY:

-- \d cc2
alter table pp1 add column a2 int check (a2 > 0);
RESULT:
	[]

-----------
QUERY:

-- \d cc2
drop table pp1 cascade;
RESULT:
	[]

-----------
QUERY:


-- Test for renaming in simple multiple inheritance
CREATE TABLE inht1 (a int, b int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE inhs1 (b int, c int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE inhts (d int) INHERITS (inht1, inhs1);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE inht1 RENAME a TO aa;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE inht1 RENAME b TO bb;
RESULT:
	ERROR - cannot rename inherited column "b"


-----------
QUERY:
                -- to be failed
ALTER TABLE inhts RENAME aa TO aaa;
RESULT:
	ERROR - cannot rename inherited column "aa"


-----------
QUERY:
      -- to be failed
ALTER TABLE inhts RENAME d TO dd;
RESULT:
	[]

-----------
QUERY:

-- \d+ inhts

DROP TABLE inhts;
RESULT:
	[]

-----------
QUERY:


-- Test for adding a column to a parent table with complex inheritance
CREATE TABLE inhta ();
RESULT:
	[]

-----------
QUERY:

CREATE TABLE inhtb () INHERITS (inhta);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE inhtc () INHERITS (inhtb);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE inhtd () INHERITS (inhta, inhtb, inhtc);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE inhta ADD COLUMN i int;
RESULT:
	[]

-----------
QUERY:

-- \d+ inhta
DROP TABLE inhta, inhtb, inhtc, inhtd;
RESULT:
	[]

-----------
QUERY:


-- Test for renaming in diamond inheritance
CREATE TABLE inht2 (x int) INHERITS (inht1);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE inht3 (y int) INHERITS (inht1);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE inht4 (z int) INHERITS (inht2, inht3);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE inht1 RENAME aa TO aaa;
RESULT:
	[]

-----------
QUERY:

-- \d+ inht4

CREATE TABLE inhts (d int) INHERITS (inht2, inhs1);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE inht1 RENAME aaa TO aaaa;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE inht1 RENAME b TO bb;
RESULT:
	ERROR - cannot rename inherited column "b"


-----------
QUERY:
                -- to be failed
-- \d+ inhts

WITH RECURSIVE r AS (
  SELECT 'inht1'::regclass AS inhrelid
UNION ALL
  SELECT c.inhrelid FROM pg_inherits c, r WHERE r.inhrelid = c.inhparent
)
SELECT a.attrelid::regclass, a.attname, a.attinhcount, e.expected
  FROM (SELECT inhrelid, count(*) AS expected FROM pg_inherits
        WHERE inhparent IN (SELECT inhrelid FROM r) GROUP BY inhrelid) e
  JOIN pg_attribute a ON e.inhrelid = a.attrelid WHERE NOT attislocal
  ORDER BY a.attrelid::regclass::name, a.attnum;
RESULT:
	[('inht2', 'aaaa', 1, 1), ('inht2', 'b', 1, 1), ('inht3', 'aaaa', 1, 1), ('inht3', 'b', 1, 1), ('inht4', 'aaaa', 2, 2), ('inht4', 'b', 2, 2), ('inht4', 'x', 1, 2), ('inht4', 'y', 1, 2), ('inhts', 'aaaa', 1, 1), ('inhts', 'b', 2, 1), ('inhts', 'x', 1, 1), ('inhts', 'c', 1, 1)]

-----------
QUERY:


DROP TABLE inht1, inhs1 CASCADE;
RESULT:
	[]

-----------
QUERY:



-- Test non-inheritable indices [UNIQUE, EXCLUDE] constraints
CREATE TABLE test_constraints (id int, val1 varchar, val2 int, UNIQUE(val1, val2));
RESULT:
	[]

-----------
QUERY:

CREATE TABLE test_constraints_inh () INHERITS (test_constraints);
RESULT:
	[]

-----------
QUERY:

-- \d+ test_constraints
ALTER TABLE ONLY test_constraints DROP CONSTRAINT test_constraints_val1_val2_key;
RESULT:
	[]

-----------
QUERY:

-- \d+ test_constraints
-- \d+ test_constraints_inh
DROP TABLE test_constraints_inh;
RESULT:
	[]

-----------
QUERY:

DROP TABLE test_constraints;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE test_ex_constraints (
    c circle,
    EXCLUDE USING gist (c WITH &&)
);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE test_ex_constraints_inh () INHERITS (test_ex_constraints);
RESULT:
	[]

-----------
QUERY:

-- \d+ test_ex_constraints
ALTER TABLE test_ex_constraints DROP CONSTRAINT test_ex_constraints_c_excl;
RESULT:
	[]

-----------
QUERY:

-- \d+ test_ex_constraints
-- \d+ test_ex_constraints_inh
DROP TABLE test_ex_constraints_inh;
RESULT:
	[]

-----------
QUERY:

DROP TABLE test_ex_constraints;
RESULT:
	[]

-----------
QUERY:


-- Test non-inheritable foreign key constraints
CREATE TABLE test_primary_constraints(id int PRIMARY KEY);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE test_foreign_constraints(id1 int REFERENCES test_primary_constraints(id));
RESULT:
	[]

-----------
QUERY:

CREATE TABLE test_foreign_constraints_inh () INHERITS (test_foreign_constraints);
RESULT:
	[]

-----------
QUERY:

-- \d+ test_primary_constraints
-- \d+ test_foreign_constraints
ALTER TABLE test_foreign_constraints DROP CONSTRAINT test_foreign_constraints_id1_fkey;
RESULT:
	[]

-----------
QUERY:

-- \d+ test_foreign_constraints
-- \d+ test_foreign_constraints_inh
DROP TABLE test_foreign_constraints_inh;
RESULT:
	[]

-----------
QUERY:

DROP TABLE test_foreign_constraints;
RESULT:
	[]

-----------
QUERY:

DROP TABLE test_primary_constraints;
RESULT:
	[]

-----------
QUERY:


-- Test foreign key behavior
create table inh_fk_1 (a int primary key);
RESULT:
	[]

-----------
QUERY:

insert into inh_fk_1 values (1), (2), (3);
RESULT:
	[]

-----------
QUERY:

create table inh_fk_2 (x int primary key, y int references inh_fk_1 on delete cascade);
RESULT:
	[]

-----------
QUERY:

insert into inh_fk_2 values (11, 1), (22, 2), (33, 3);
RESULT:
	[]

-----------
QUERY:

create table inh_fk_2_child () inherits (inh_fk_2);
RESULT:
	[]

-----------
QUERY:

insert into inh_fk_2_child values (111, 1), (222, 2);
RESULT:
	[]

-----------
QUERY:

delete from inh_fk_1 where a = 1;
RESULT:
	[]

-----------
QUERY:

select * from inh_fk_1 order by 1;
RESULT:
	[(2,), (3,)]

-----------
QUERY:

select * from inh_fk_2 order by 1, 2;
RESULT:
	[(22, 2), (33, 3), (111, 1), (222, 2)]

-----------
QUERY:

drop table inh_fk_1, inh_fk_2, inh_fk_2_child;
RESULT:
	[]

-----------
QUERY:


-- Test that parent and child CHECK constraints can be created in either order
create table p1(f1 int);
RESULT:
	[]

-----------
QUERY:

create table p1_c1() inherits(p1);
RESULT:
	[]

-----------
QUERY:


alter table p1 add constraint inh_check_constraint1 check (f1 > 0);
RESULT:
	[]

-----------
QUERY:

alter table p1_c1 add constraint inh_check_constraint1 check (f1 > 0);
RESULT:
	[]

-----------
QUERY:


alter table p1_c1 add constraint inh_check_constraint2 check (f1 < 10);
RESULT:
	[]

-----------
QUERY:

alter table p1 add constraint inh_check_constraint2 check (f1 < 10);
RESULT:
	[]

-----------
QUERY:


select conrelid::regclass::text as relname, conname, conislocal, coninhcount
from pg_constraint where conname like 'inh\_check\_constraint%'
order by 1, 2;
RESULT:
	[('p1', 'inh_check_constraint1', True, 0), ('p1', 'inh_check_constraint2', True, 0), ('p1_c1', 'inh_check_constraint1', True, 1), ('p1_c1', 'inh_check_constraint2', True, 1)]

-----------
QUERY:


drop table p1 cascade;
RESULT:
	[]

-----------
QUERY:


--
-- Test DROP behavior of multiply-defined CHECK constraints
--
create table p1(f1 int constraint f1_pos CHECK (f1 > 0));
RESULT:
	[]

-----------
QUERY:

create table p1_c1 (f1 int constraint f1_pos CHECK (f1 > 0)) inherits (p1);
RESULT:
	[]

-----------
QUERY:

alter table p1_c1 drop constraint f1_pos;
RESULT:
	ERROR - cannot drop inherited constraint "f1_pos" of relation "p1_c1"


-----------
QUERY:

alter table p1 drop constraint f1_pos;
RESULT:
	[]

-----------
QUERY:

-- \d p1_c1
drop table p1 cascade;
RESULT:
	[]

-----------
QUERY:


create table p1(f1 int constraint f1_pos CHECK (f1 > 0));
RESULT:
	[]

-----------
QUERY:

create table p2(f1 int constraint f1_pos CHECK (f1 > 0));
RESULT:
	[]

-----------
QUERY:

create table p1p2_c1 (f1 int) inherits (p1, p2);
RESULT:
	[]

-----------
QUERY:

create table p1p2_c2 (f1 int constraint f1_pos CHECK (f1 > 0)) inherits (p1, p2);
RESULT:
	[]

-----------
QUERY:

alter table p2 drop constraint f1_pos;
RESULT:
	[]

-----------
QUERY:

alter table p1 drop constraint f1_pos;
RESULT:
	[]

-----------
QUERY:

-- \d p1p2_c*
drop table p1, p2 cascade;
RESULT:
	[]

-----------
QUERY:


create table p1(f1 int constraint f1_pos CHECK (f1 > 0));
RESULT:
	[]

-----------
QUERY:

create table p1_c1() inherits (p1);
RESULT:
	[]

-----------
QUERY:

create table p1_c2() inherits (p1);
RESULT:
	[]

-----------
QUERY:

create table p1_c1c2() inherits (p1_c1, p1_c2);
RESULT:
	[]

-----------
QUERY:

-- \d p1_c1c2
alter table p1 drop constraint f1_pos;
RESULT:
	[]

-----------
QUERY:

-- \d p1_c1c2
drop table p1 cascade;
RESULT:
	[]

-----------
QUERY:


create table p1(f1 int constraint f1_pos CHECK (f1 > 0));
RESULT:
	[]

-----------
QUERY:

create table p1_c1() inherits (p1);
RESULT:
	[]

-----------
QUERY:

create table p1_c2(constraint f1_pos CHECK (f1 > 0)) inherits (p1);
RESULT:
	[]

-----------
QUERY:

create table p1_c1c2() inherits (p1_c1, p1_c2, p1);
RESULT:
	[]

-----------
QUERY:

alter table p1_c2 drop constraint f1_pos;
RESULT:
	ERROR - cannot drop inherited constraint "f1_pos" of relation "p1_c2"


-----------
QUERY:

alter table p1 drop constraint f1_pos;
RESULT:
	[]

-----------
QUERY:

alter table p1_c1c2 drop constraint f1_pos;
RESULT:
	ERROR - cannot drop inherited constraint "f1_pos" of relation "p1_c1c2"


-----------
QUERY:

alter table p1_c2 drop constraint f1_pos;
RESULT:
	[]

-----------
QUERY:

-- \d p1_c1c2
drop table p1 cascade;
RESULT:
	[]

-----------
QUERY:


-- Test that a valid child can have not-valid parent, but not vice versa
create table invalid_check_con(f1 int);
RESULT:
	[]

-----------
QUERY:

create table invalid_check_con_child() inherits(invalid_check_con);
RESULT:
	[]

-----------
QUERY:


alter table invalid_check_con_child add constraint inh_check_constraint check(f1 > 0) not valid;
RESULT:
	[]

-----------
QUERY:

alter table invalid_check_con add constraint inh_check_constraint check(f1 > 0);
RESULT:
	ERROR - constraint "inh_check_constraint" conflicts with NOT VALID constraint on relation "invalid_check_con_child"


-----------
QUERY:
 -- fail
alter table invalid_check_con_child drop constraint inh_check_constraint;
RESULT:
	[]

-----------
QUERY:


insert into invalid_check_con values(0);
RESULT:
	[]

-----------
QUERY:


alter table invalid_check_con_child add constraint inh_check_constraint check(f1 > 0);
RESULT:
	[]

-----------
QUERY:

alter table invalid_check_con add constraint inh_check_constraint check(f1 > 0) not valid;
RESULT:
	[]

-----------
QUERY:


insert into invalid_check_con values(0);
RESULT:
	ERROR - new row for relation "invalid_check_con" violates check constraint "inh_check_constraint"
DETAIL:  Failing row contains (0).


-----------
QUERY:
 -- fail
insert into invalid_check_con_child values(0);
RESULT:
	ERROR - new row for relation "invalid_check_con_child" violates check constraint "inh_check_constraint"
DETAIL:  Failing row contains (0).


-----------
QUERY:
 -- fail

select conrelid::regclass::text as relname, conname,
       convalidated, conislocal, coninhcount, connoinherit
from pg_constraint where conname like 'inh\_check\_constraint%'
order by 1, 2;
RESULT:
	[('invalid_check_con', 'inh_check_constraint', False, True, 0, False), ('invalid_check_con_child', 'inh_check_constraint', True, True, 1, False)]

-----------
QUERY:


-- We don/* REPLACED */''t drop the invalid_check_con* tables, to test dump/reload with

--
-- Test parameterized append plans for inheritance trees
--

create temp table patest0 (id, x) as
  select x, x from generate_series(0,1000) x;
RESULT:
	[]

-----------
QUERY:

create temp table patest1() inherits (patest0);
RESULT:
	[]

-----------
QUERY:

insert into patest1
  select x, x from generate_series(0,1000) x;
RESULT:
	[]

-----------
QUERY:

create temp table patest2() inherits (patest0);
RESULT:
	[]

-----------
QUERY:

insert into patest2
  select x, x from generate_series(0,1000) x;
RESULT:
	[]

-----------
QUERY:

create index patest0i on patest0(id);
RESULT:
	[]

-----------
QUERY:

create index patest1i on patest1(id);
RESULT:
	[]

-----------
QUERY:

create index patest2i on patest2(id);
RESULT:
	[]

-----------
QUERY:

analyze patest0;
RESULT:
	[]

-----------
QUERY:

analyze patest1;
RESULT:
	[]

-----------
QUERY:

analyze patest2;
RESULT:
	[]

-----------
QUERY:


explain (costs off)
select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
RESULT:
	[('Nested Loop',), ('  ->  Limit',), ('        ->  Seq Scan on int4_tbl',), ('  ->  Append',), ('        ->  Index Scan using patest0i on patest0 patest0_1',), ('              Index Cond: (id = int4_tbl.f1)',), ('        ->  Index Scan using patest1i on patest1 patest0_2',), ('              Index Cond: (id = int4_tbl.f1)',), ('        ->  Index Scan using patest2i on patest2 patest0_3',), ('              Index Cond: (id = int4_tbl.f1)',)]

-----------
QUERY:

select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
RESULT:
	[(0, 0, 0), (0, 0, 0), (0, 0, 0)]

-----------
QUERY:


drop index patest2i;
RESULT:
	[]

-----------
QUERY:


explain (costs off)
select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
RESULT:
	[('Nested Loop',), ('  ->  Limit',), ('        ->  Seq Scan on int4_tbl',), ('  ->  Append',), ('        ->  Index Scan using patest0i on patest0 patest0_1',), ('              Index Cond: (id = int4_tbl.f1)',), ('        ->  Index Scan using patest1i on patest1 patest0_2',), ('              Index Cond: (id = int4_tbl.f1)',), ('        ->  Seq Scan on patest2 patest0_3',), ('              Filter: (int4_tbl.f1 = id)',)]

-----------
QUERY:

select * from patest0 join (select f1 from int4_tbl limit 1) ss on id = f1;
RESULT:
	[(0, 0, 0), (0, 0, 0), (0, 0, 0)]

-----------
QUERY:


drop table patest0 cascade;
RESULT:
	[]

-----------
QUERY:


--
-- Test merge-append plans for inheritance trees
--

create table matest0 (id serial primary key, name text);
RESULT:
	[]

-----------
QUERY:

create table matest1 (id integer primary key) inherits (matest0);
RESULT:
	[]

-----------
QUERY:

create table matest2 (id integer primary key) inherits (matest0);
RESULT:
	[]

-----------
QUERY:

create table matest3 (id integer primary key) inherits (matest0);
RESULT:
	[]

-----------
QUERY:


create index matest0i on matest0 ((1-id));
RESULT:
	[]

-----------
QUERY:

create index matest1i on matest1 ((1-id));
RESULT:
	[]

-----------
QUERY:

-- create index matest2i on matest2 ((1-id)) /* REPLACED */,  -- intentionally missing
create index matest3i on matest3 ((1-id));
RESULT:
	[]

-----------
QUERY:


insert into matest1 (name) values ('Test 1');
RESULT:
	[]

-----------
QUERY:

insert into matest1 (name) values ('Test 2');
RESULT:
	[]

-----------
QUERY:

insert into matest2 (name) values ('Test 3');
RESULT:
	[]

-----------
QUERY:

insert into matest2 (name) values ('Test 4');
RESULT:
	[]

-----------
QUERY:

insert into matest3 (name) values ('Test 5');
RESULT:
	[]

-----------
QUERY:

insert into matest3 (name) values ('Test 6');
RESULT:
	[]

-----------
QUERY:


set enable_indexscan = off;
RESULT:
	[]

-----------
QUERY:
  -- force use of seqscan/sort, so no merge
explain (verbose, costs off) select * from matest0 order by 1-id;
RESULT:
	[('Sort',), ('  Output: matest0.id, matest0.name, ((1 - matest0.id))',), ('  Sort Key: ((1 - matest0.id))',), ('  ->  Result',), ('        Output: matest0.id, matest0.name, (1 - matest0.id)',), ('        ->  Append',), ('              ->  Seq Scan on public.matest0 matest0_1',), ('                    Output: matest0_1.id, matest0_1.name',), ('              ->  Seq Scan on public.matest1 matest0_2',), ('                    Output: matest0_2.id, matest0_2.name',), ('              ->  Seq Scan on public.matest2 matest0_3',), ('                    Output: matest0_3.id, matest0_3.name',), ('              ->  Seq Scan on public.matest3 matest0_4',), ('                    Output: matest0_4.id, matest0_4.name',)]

-----------
QUERY:

select * from matest0 order by 1-id;
RESULT:
	[(6, 'Test 6'), (5, 'Test 5'), (4, 'Test 4'), (3, 'Test 3'), (2, 'Test 2'), (1, 'Test 1')]

-----------
QUERY:

explain (verbose, costs off) select min(1-id) from matest0;
RESULT:
	[('Aggregate',), ('  Output: min((1 - matest0.id))',), ('  ->  Append',), ('        ->  Seq Scan on public.matest0 matest0_1',), ('              Output: matest0_1.id',), ('        ->  Seq Scan on public.matest1 matest0_2',), ('              Output: matest0_2.id',), ('        ->  Seq Scan on public.matest2 matest0_3',), ('              Output: matest0_3.id',), ('        ->  Seq Scan on public.matest3 matest0_4',), ('              Output: matest0_4.id',)]

-----------
QUERY:

select min(1-id) from matest0;
RESULT:
	[(-5,)]

-----------
QUERY:

reset enable_indexscan;
RESULT:
	[]

-----------
QUERY:


set enable_seqscan = off;
RESULT:
	[]

-----------
QUERY:
  -- plan with fewest seqscans should be merge
set enable_parallel_append = off;
RESULT:
	[]

-----------
QUERY:
 -- Don/* REPLACED */''t let parallel-append interfere
explain (verbose, costs off) select * from matest0 order by 1-id;
RESULT:
	[('Merge Append',), ('  Sort Key: ((1 - matest0.id))',), ('  ->  Index Scan using matest0i on public.matest0 matest0_1',), ('        Output: matest0_1.id, matest0_1.name, (1 - matest0_1.id)',), ('  ->  Index Scan using matest1i on public.matest1 matest0_2',), ('        Output: matest0_2.id, matest0_2.name, (1 - matest0_2.id)',), ('  ->  Sort',), ('        Output: matest0_3.id, matest0_3.name, ((1 - matest0_3.id))',), ('        Sort Key: ((1 - matest0_3.id))',), ('        ->  Seq Scan on public.matest2 matest0_3',), ('              Output: matest0_3.id, matest0_3.name, (1 - matest0_3.id)',), ('  ->  Index Scan using matest3i on public.matest3 matest0_4',), ('        Output: matest0_4.id, matest0_4.name, (1 - matest0_4.id)',)]

-----------
QUERY:

select * from matest0 order by 1-id;
RESULT:
	[(6, 'Test 6'), (5, 'Test 5'), (4, 'Test 4'), (3, 'Test 3'), (2, 'Test 2'), (1, 'Test 1')]

-----------
QUERY:

explain (verbose, costs off) select min(1-id) from matest0;
RESULT:
	[('Result',), ('  Output: (InitPlan 1).col1',), ('  InitPlan 1',), ('    ->  Limit',), ('          Output: ((1 - matest0.id))',), ('          ->  Result',), ('                Output: ((1 - matest0.id))',), ('                ->  Merge Append',), ('                      Sort Key: ((1 - matest0.id))',), ('                      ->  Index Scan using matest0i on public.matest0 matest0_1',), ('                            Output: matest0_1.id, (1 - matest0_1.id)',), ('                            Index Cond: ((1 - matest0_1.id) IS NOT NULL)',), ('                      ->  Index Scan using matest1i on public.matest1 matest0_2',), ('                            Output: matest0_2.id, (1 - matest0_2.id)',), ('                            Index Cond: ((1 - matest0_2.id) IS NOT NULL)',), ('                      ->  Sort',), ('                            Output: matest0_3.id, ((1 - matest0_3.id))',), ('                            Sort Key: ((1 - matest0_3.id))',), ('                            ->  Bitmap Heap Scan on public.matest2 matest0_3',), ('                                  Output: matest0_3.id, (1 - matest0_3.id)',), ('                                  Filter: ((1 - matest0_3.id) IS NOT NULL)',), ('                                  ->  Bitmap Index Scan on matest2_pkey',), ('                      ->  Index Scan using matest3i on public.matest3 matest0_4',), ('                            Output: matest0_4.id, (1 - matest0_4.id)',), ('                            Index Cond: ((1 - matest0_4.id) IS NOT NULL)',)]

-----------
QUERY:

select min(1-id) from matest0;
RESULT:
	[(-5,)]

-----------
QUERY:

reset enable_seqscan;
RESULT:
	[]

-----------
QUERY:

reset enable_parallel_append;
RESULT:
	[]

-----------
QUERY:


drop table matest0 cascade;
RESULT:
	[]

-----------
QUERY:


--
-- Check that use of an index with an extraneous column doesn/* REPLACED */''t produce
-- a plan with extraneous sorting
--

create table matest0 (a int, b int, c int, d int);
RESULT:
	[]

-----------
QUERY:

create table matest1 () inherits(matest0);
RESULT:
	[]

-----------
QUERY:

create index matest0i on matest0 (b, c);
RESULT:
	[]

-----------
QUERY:

create index matest1i on matest1 (b, c);
RESULT:
	[]

-----------
QUERY:


set enable_nestloop = off;
RESULT:
	[]

-----------
QUERY:
  -- we want a plan with two MergeAppends

explain (costs off)
select t1.* from matest0 t1, matest0 t2
where t1.b = t2.b and t2.c = t2.d
order by t1.b limit 10;
RESULT:
	[('Limit',), ('  ->  Merge Join',), ('        Merge Cond: (t1.b = t2.b)',), ('        ->  Merge Append',), ('              Sort Key: t1.b',), ('              ->  Index Scan using matest0i on matest0 t1_1',), ('              ->  Index Scan using matest1i on matest1 t1_2',), ('        ->  Materialize',), ('              ->  Merge Append',), ('                    Sort Key: t2.b',), ('                    ->  Index Scan using matest0i on matest0 t2_1',), ('                          Filter: (c = d)',), ('                    ->  Index Scan using matest1i on matest1 t2_2',), ('                          Filter: (c = d)',)]

-----------
QUERY:


reset enable_nestloop;
RESULT:
	[]

-----------
QUERY:


drop table matest0 cascade;
RESULT:
	[]

-----------
QUERY:


-- Test a MergeAppend plan where one child requires a sort
create table matest0(a int primary key);
RESULT:
	[]

-----------
QUERY:

create table matest1() inherits (matest0);
RESULT:
	[]

-----------
QUERY:

insert into matest0 select generate_series(1, 400);
RESULT:
	[]

-----------
QUERY:

insert into matest1 select generate_series(1, 200);
RESULT:
	[]

-----------
QUERY:

analyze matest0;
RESULT:
	[]

-----------
QUERY:

analyze matest1;
RESULT:
	[]

-----------
QUERY:


explain (costs off)
select * from matest0 where a < 100 order by a;
RESULT:
	[('Merge Append',), ('  Sort Key: matest0.a',), ('  ->  Index Only Scan using matest0_pkey on matest0 matest0_1',), ('        Index Cond: (a < 100)',), ('  ->  Sort',), ('        Sort Key: matest0_2.a',), ('        ->  Seq Scan on matest1 matest0_2',), ('              Filter: (a < 100)',)]

-----------
QUERY:


drop table matest0 cascade;
RESULT:
	[]

-----------
QUERY:


--
-- Test merge-append for UNION ALL append relations
--

set enable_seqscan = off;
RESULT:
	[]

-----------
QUERY:

set enable_indexscan = on;
RESULT:
	[]

-----------
QUERY:

set enable_bitmapscan = off;
RESULT:
	[]

-----------
QUERY:


-- Check handling of duplicated, constant, or volatile targetlist items
explain (costs off)
SELECT thousand, tenthous FROM tenk1
UNION ALL
SELECT thousand, thousand FROM tenk1
ORDER BY thousand, tenthous;
RESULT:
	[('Merge Append',), ('  Sort Key: tenk1.thousand, tenk1.tenthous',), ('  ->  Index Only Scan using tenk1_thous_tenthous on tenk1',), ('  ->  Sort',), ('        Sort Key: tenk1_1.thousand, tenk1_1.thousand',), ('        ->  Index Only Scan using tenk1_thous_tenthous on tenk1 tenk1_1',)]

-----------
QUERY:


explain (costs off)
SELECT thousand, tenthous, thousand+tenthous AS x FROM tenk1
UNION ALL
SELECT 42, 42, hundred FROM tenk1
ORDER BY thousand, tenthous;
RESULT:
	[('Merge Append',), ('  Sort Key: tenk1.thousand, tenk1.tenthous',), ('  ->  Index Only Scan using tenk1_thous_tenthous on tenk1',), ('  ->  Sort',), ('        Sort Key: 42, 42',), ('        ->  Index Only Scan using tenk1_hundred on tenk1 tenk1_1',)]

-----------
QUERY:


explain (costs off)
SELECT thousand, tenthous FROM tenk1
UNION ALL
SELECT thousand, random()::integer FROM tenk1
ORDER BY thousand, tenthous;
RESULT:
	[('Merge Append',), ('  Sort Key: tenk1.thousand, tenk1.tenthous',), ('  ->  Index Only Scan using tenk1_thous_tenthous on tenk1',), ('  ->  Sort',), ('        Sort Key: tenk1_1.thousand, ((random())::integer)',), ('        ->  Index Only Scan using tenk1_thous_tenthous on tenk1 tenk1_1',)]

-----------
QUERY:


-- Check min/max aggregate optimization
explain (costs off)
SELECT min(x) FROM
  (SELECT unique1 AS x FROM tenk1 a
   UNION ALL
   SELECT unique2 AS x FROM tenk1 b) s;
RESULT:
	[('Result',), ('  InitPlan 1',), ('    ->  Limit',), ('          ->  Merge Append',), ('                Sort Key: a.unique1',), ('                ->  Index Only Scan using tenk1_unique1 on tenk1 a',), ('                      Index Cond: (unique1 IS NOT NULL)',), ('                ->  Index Only Scan using tenk1_unique2 on tenk1 b',), ('                      Index Cond: (unique2 IS NOT NULL)',)]

-----------
QUERY:


explain (costs off)
SELECT min(y) FROM
  (SELECT unique1 AS x, unique1 AS y FROM tenk1 a
   UNION ALL
   SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s;
RESULT:
	[('Result',), ('  InitPlan 1',), ('    ->  Limit',), ('          ->  Merge Append',), ('                Sort Key: a.unique1',), ('                ->  Index Only Scan using tenk1_unique1 on tenk1 a',), ('                      Index Cond: (unique1 IS NOT NULL)',), ('                ->  Index Only Scan using tenk1_unique2 on tenk1 b',), ('                      Index Cond: (unique2 IS NOT NULL)',)]

-----------
QUERY:


-- XXX planner doesn/* REPLACED */''t recognize that index on unique2 is sufficiently sorted
explain (costs off)
SELECT x, y FROM
  (SELECT thousand AS x, tenthous AS y FROM tenk1 a
   UNION ALL
   SELECT unique2 AS x, unique2 AS y FROM tenk1 b) s
ORDER BY x, y;
RESULT:
	[('Merge Append',), ('  Sort Key: a.thousand, a.tenthous',), ('  ->  Index Only Scan using tenk1_thous_tenthous on tenk1 a',), ('  ->  Sort',), ('        Sort Key: b.unique2, b.unique2',), ('        ->  Index Only Scan using tenk1_unique2 on tenk1 b',)]

-----------
QUERY:


-- exercise rescan code path via a repeatedly-evaluated subquery
explain (costs off)
SELECT
    ARRAY(SELECT f.i FROM (
        (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)
        UNION ALL
        (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)
    ) f(i)
    ORDER BY f.i LIMIT 10)
FROM generate_series(1, 3) g(i);
RESULT:
	[('Function Scan on generate_series g',), ('  SubPlan 1',), ('    ->  Limit',), ('          ->  Merge Append',), ('                Sort Key: ((d.d + g.i))',), ('                ->  Sort',), ('                      Sort Key: ((d.d + g.i))',), ('                      ->  Function Scan on generate_series d',), ('                ->  Sort',), ('                      Sort Key: ((d_1.d + g.i))',), ('                      ->  Function Scan on generate_series d_1',)]

-----------
QUERY:


SELECT
    ARRAY(SELECT f.i FROM (
        (SELECT d + g.i FROM generate_series(4, 30, 3) d ORDER BY 1)
        UNION ALL
        (SELECT d + g.i FROM generate_series(0, 30, 5) d ORDER BY 1)
    ) f(i)
    ORDER BY f.i LIMIT 10)
FROM generate_series(1, 3) g(i);
RESULT:
	[([1, 5, 6, 8, 11, 11, 14, 16, 17, 20],), ([2, 6, 7, 9, 12, 12, 15, 17, 18, 21],), ([3, 7, 8, 10, 13, 13, 16, 18, 19, 22],)]

-----------
QUERY:


reset enable_seqscan;
RESULT:
	[]

-----------
QUERY:

reset enable_indexscan;
RESULT:
	[]

-----------
QUERY:

reset enable_bitmapscan;
RESULT:
	[]

-----------
QUERY:


--
-- Check handling of MULTIEXPR SubPlans in inherited updates
--
create table inhpar(f1 int, f2 name);
RESULT:
	[]

-----------
QUERY:

create table inhcld(f2 name, f1 int);
RESULT:
	[]

-----------
QUERY:

alter table inhcld inherit inhpar;
RESULT:
	[]

-----------
QUERY:

insert into inhpar select x, x::text from generate_series(1,5) x;
RESULT:
	[]

-----------
QUERY:

insert into inhcld select x::text, x from generate_series(6,10) x;
RESULT:
	[]

-----------
QUERY:


explain (verbose, costs off)
update inhpar i set (f1, f2) = (select i.f1, i.f2 || '-' from int4_tbl limit 1);
RESULT:
	[('Update on public.inhpar i',), ('  Update on public.inhpar i_1',), ('  Update on public.inhcld i_2',), ('  ->  Result',), ('        Output: (SubPlan 1).col1, (SubPlan 1).col2, (rescan SubPlan 1), i.tableoid, i.ctid',), ('        ->  Append',), ('              ->  Seq Scan on public.inhpar i_1',), ('                    Output: i_1.f1, i_1.f2, i_1.tableoid, i_1.ctid',), ('              ->  Seq Scan on public.inhcld i_2',), ('                    Output: i_2.f1, i_2.f2, i_2.tableoid, i_2.ctid',), ('        SubPlan 1',), ('          ->  Limit',), ("                Output: (i.f1), (((i.f2)::text || '-'::text))",), ('                ->  Seq Scan on public.int4_tbl',), ("                      Output: i.f1, ((i.f2)::text || '-'::text)",)]

-----------
QUERY:

update inhpar i set (f1, f2) = (select i.f1, i.f2 || '-' from int4_tbl limit 1);
RESULT:
	[]

-----------
QUERY:

select * from inhpar;
RESULT:
	[(1, '1-'), (2, '2-'), (3, '3-'), (4, '4-'), (5, '5-'), (6, '6-'), (7, '7-'), (8, '8-'), (9, '9-'), (10, '10-')]

-----------
QUERY:


drop table inhpar cascade;
RESULT:
	[]

-----------
QUERY:


--
-- And the same for partitioned cases
--
create table inhpar(f1 int primary key, f2 name) partition by range (f1);
RESULT:
	[]

-----------
QUERY:

create table inhcld1(f2 name, f1 int primary key);
RESULT:
	[]

-----------
QUERY:

create table inhcld2(f1 int primary key, f2 name);
RESULT:
	[]

-----------
QUERY:

alter table inhpar attach partition inhcld1 for values from (1) to (5);
RESULT:
	[]

-----------
QUERY:

alter table inhpar attach partition inhcld2 for values from (5) to (100);
RESULT:
	[]

-----------
QUERY:

insert into inhpar select x, x::text from generate_series(1,10) x;
RESULT:
	[]

-----------
QUERY:


explain (verbose, costs off)
update inhpar i set (f1, f2) = (select i.f1, i.f2 || '-' from int4_tbl limit 1);
RESULT:
	[('Update on public.inhpar i',), ('  Update on public.inhcld1 i_1',), ('  Update on public.inhcld2 i_2',), ('  ->  Append',), ('        ->  Seq Scan on public.inhcld1 i_1',), ('              Output: (SubPlan 1).col1, (SubPlan 1).col2, (rescan SubPlan 1), i_1.tableoid, i_1.ctid',), ('              SubPlan 1',), ('                ->  Limit',), ("                      Output: (i_1.f1), (((i_1.f2)::text || '-'::text))",), ('                      ->  Seq Scan on public.int4_tbl',), ("                            Output: i_1.f1, ((i_1.f2)::text || '-'::text)",), ('        ->  Seq Scan on public.inhcld2 i_2',), ('              Output: (SubPlan 1).col1, (SubPlan 1).col2, (rescan SubPlan 1), i_2.tableoid, i_2.ctid',)]

-----------
QUERY:

update inhpar i set (f1, f2) = (select i.f1, i.f2 || '-' from int4_tbl limit 1);
RESULT:
	[]

-----------
QUERY:

select * from inhpar;
RESULT:
	[(1, '1-'), (2, '2-'), (3, '3-'), (4, '4-'), (5, '5-'), (6, '6-'), (7, '7-'), (8, '8-'), (9, '9-'), (10, '10-')]

-----------
QUERY:


-- Also check ON CONFLICT
insert into inhpar as i values (3), (7) on conflict (f1)
  do update set (f1, f2) = (select i.f1, i.f2 || '+');
RESULT:
	[]

-----------
QUERY:

select * from inhpar order by f1;
RESULT:
	[(1, '1-'), (2, '2-'), (3, '3-+'), (4, '4-'), (5, '5-'), (6, '6-'), (7, '7-+'), (8, '8-'), (9, '9-'), (10, '10-')]

-----------
QUERY:
  -- tuple order might be unstable here

drop table inhpar cascade;
RESULT:
	[]

-----------
QUERY:


--
-- Check handling of a constant-null CHECK constraint
--
create table cnullparent (f1 int);
RESULT:
	[]

-----------
QUERY:

create table cnullchild (check (f1 = 1 or f1 = null)) inherits(cnullparent);
RESULT:
	[]

-----------
QUERY:

insert into cnullchild values(1);
RESULT:
	[]

-----------
QUERY:

insert into cnullchild values(2);
RESULT:
	[]

-----------
QUERY:

insert into cnullchild values(null);
RESULT:
	[]

-----------
QUERY:

select * from cnullparent;
RESULT:
	[(1,), (2,), (None,)]

-----------
QUERY:

select * from cnullparent where f1 = 2;
RESULT:
	[(2,)]

-----------
QUERY:

drop table cnullparent cascade;
RESULT:
	[]

-----------
QUERY:


--
-- Test inheritance of NOT NULL constraints
--
create table pp1 (f1 int);
RESULT:
	[]

-----------
QUERY:

create table cc1 (f2 text, f3 int) inherits (pp1);
RESULT:
	[]

-----------
QUERY:

-- \d cc1
create table cc2(f4 float) inherits(pp1,cc1);
RESULT:
	[]

-----------
QUERY:

-- \d cc2

-- named NOT NULL constraint
alter table cc1 add column a2 int constraint nn not null;
RESULT:
	[]

-----------
QUERY:

-- \d+ cc1
-- \d+ cc2
alter table pp1 alter column f1 set not null;
RESULT:
	[]

-----------
QUERY:

-- \d+ pp1
-- \d+ cc1
-- \d+ cc2

-- cannot create table with inconsistent NO INHERIT constraint
create table cc3 (a2 int not null no inherit) inherits (cc1);
RESULT:
	ERROR - cannot define not-null constraint on column "a2" with NO INHERIT
DETAIL:  The column has an inherited not-null constraint.


-----------
QUERY:


-- change NO INHERIT status of inherited constraint: no dice, it/* REPLACED */''s inherited
alter table cc2 add not null a2 no inherit;
RESULT:
	ERROR - cannot change NO INHERIT status of inherited NOT NULL constraint "nn" on relation "cc2"


-----------
QUERY:


-- remove constraint from cc2: no dice, it/* REPLACED */''s inherited
alter table cc2 alter column a2 drop not null;
RESULT:
	ERROR - cannot drop inherited constraint "nn" of relation "cc2"


-----------
QUERY:


-- remove constraint cc1, should succeed
alter table cc1 alter column a2 drop not null;
RESULT:
	[]

-----------
QUERY:

-- \d+ cc1

-- same for cc2
alter table cc2 alter column f1 drop not null;
RESULT:
	ERROR - cannot drop inherited constraint "pp1_f1_not_null" of relation "cc2"


-----------
QUERY:

-- \d+ cc2

-- remove from cc1, should fail again
alter table cc1 alter column f1 drop not null;
RESULT:
	ERROR - cannot drop inherited constraint "pp1_f1_not_null" of relation "cc1"


-----------
QUERY:


-- remove from pp1, should succeed
alter table pp1 alter column f1 drop not null;
RESULT:
	[]

-----------
QUERY:

-- \d+ pp1

alter table pp1 add primary key (f1);
RESULT:
	[]

-----------
QUERY:

-- Leave these tables around, for pg_upgrade testing

-- Test the same constraint name for different columns in different parents
create table inh_parent1(a int constraint nn not null);
RESULT:
	[]

-----------
QUERY:

create table inh_parent2(b int constraint nn not null);
RESULT:
	[]

-----------
QUERY:

create table inh_child () inherits (inh_parent1, inh_parent2);
RESULT:
	[]

-----------
QUERY:

-- \d+ inh_child
drop table inh_parent1, inh_parent2, inh_child;
RESULT:
	[]

-----------
QUERY:


-- Test multiple parents with overlapping primary keys
create table inh_parent1(a int, b int, c int, primary key (a, b));
RESULT:
	[]

-----------
QUERY:

create table inh_parent2(d int, e int, b int, primary key (d, b));
RESULT:
	[]

-----------
QUERY:

create table inh_child() inherits (inh_parent1, inh_parent2);
RESULT:
	[]

-----------
QUERY:

select conrelid::regclass, conname, contype, conkey,
 coninhcount, conislocal, connoinherit
 from pg_constraint where contype in ('n','p') and
 conrelid::regclass::text in ('inh_child', 'inh_parent1', 'inh_parent2')
 order by 1, 2;
RESULT:
	[('inh_parent1', 'inh_parent1_pkey', 'p', [1, 2], 0, True, True), ('inh_parent2', 'inh_parent2_pkey', 'p', [1, 3], 0, True, True), ('inh_child', 'inh_child_a_not_null', 'n', [1], 1, False, False), ('inh_child', 'inh_child_b_not_null', 'n', [2], 2, False, False), ('inh_child', 'inh_child_d_not_null', 'n', [4], 1, False, False)]

-----------
QUERY:

-- \d+ inh_child
drop table inh_parent1, inh_parent2, inh_child;
RESULT:
	[]

-----------
QUERY:


-- NOT NULL NO INHERIT
create table inh_nn_parent(a int);
RESULT:
	[]

-----------
QUERY:

create table inh_nn_child() inherits (inh_nn_parent);
RESULT:
	[]

-----------
QUERY:

alter table inh_nn_parent add not null a no inherit;
RESULT:
	[]

-----------
QUERY:

create table inh_nn_child2() inherits (inh_nn_parent);
RESULT:
	[]

-----------
QUERY:

select conrelid::regclass, conname, contype, conkey,
 (select attname from pg_attribute where attrelid = conrelid and attnum = conkey[1]),
 coninhcount, conislocal, connoinherit
 from pg_constraint where contype = 'n' and
 conrelid::regclass::text like 'inh\_nn\_%'
 order by 2, 1;
RESULT:
	[('inh_nn_parent', 'inh_nn_parent_a_not_null', 'n', [1], 'a', 0, True, True)]

-----------
QUERY:

-- \d+ inh_nn*
drop table inh_nn_parent, inh_nn_child, inh_nn_child2;
RESULT:
	[]

-----------
QUERY:


--
-- test inherit/deinherit
--
create table inh_parent(f1 int);
RESULT:
	[]

-----------
QUERY:

create table inh_child1(f1 int not null);
RESULT:
	[]

-----------
QUERY:

create table inh_child2(f1 int);
RESULT:
	[]

-----------
QUERY:


-- inh_child1 should have not null constraint
alter table inh_child1 inherit inh_parent;
RESULT:
	[]

-----------
QUERY:


-- should fail, missing NOT NULL constraint
alter table inh_child2 inherit inh_child1;
RESULT:
	ERROR - column "f1" in child table must be marked NOT NULL


-----------
QUERY:


alter table inh_child2 alter column f1 set not null;
RESULT:
	[]

-----------
QUERY:

alter table inh_child2 inherit inh_child1;
RESULT:
	[]

-----------
QUERY:


-- add NOT NULL constraint recursively
alter table inh_parent alter column f1 set not null;
RESULT:
	[]

-----------
QUERY:


-- \d+ inh_parent
-- \d+ inh_child1
-- \d+ inh_child2

select conrelid::regclass, conname, contype, coninhcount, conislocal
 from pg_constraint where contype = 'n' and
 conrelid in ('inh_parent'::regclass, 'inh_child1'::regclass, 'inh_child2'::regclass)
 order by 2, 1;
RESULT:
	[('inh_child1', 'inh_child1_f1_not_null', 'n', 1, True), ('inh_child2', 'inh_child2_f1_not_null', 'n', 1, True), ('inh_parent', 'inh_parent_f1_not_null', 'n', 0, True)]

-----------
QUERY:


--
-- test deinherit procedure
--

-- deinherit inh_child1
create table inh_child3 () inherits (inh_child1);
RESULT:
	[]

-----------
QUERY:

alter table inh_child1 no inherit inh_parent;
RESULT:
	[]

-----------
QUERY:

-- \d+ inh_parent
-- \d+ inh_child1
-- \d+ inh_child2
select conrelid::regclass, conname, contype, coninhcount, conislocal
 from pg_constraint where contype = 'n' and
 conrelid::regclass::text in ('inh_parent', 'inh_child1', 'inh_child2', 'inh_child3')
 order by 2, 1;
RESULT:
	[('inh_child1', 'inh_child1_f1_not_null', 'n', 0, True), ('inh_child3', 'inh_child1_f1_not_null', 'n', 1, False), ('inh_child2', 'inh_child2_f1_not_null', 'n', 1, True), ('inh_parent', 'inh_parent_f1_not_null', 'n', 0, True)]

-----------
QUERY:

drop table inh_parent, inh_child1, inh_child2, inh_child3;
RESULT:
	[]

-----------
QUERY:


-- a PK in parent must have a not-null in child that it can mark inherited
create table inh_parent (a int primary key);
RESULT:
	[]

-----------
QUERY:

create table inh_child (a int primary key);
RESULT:
	[]

-----------
QUERY:

alter table inh_child inherit inh_parent;
RESULT:
	ERROR - column "a" in child table must be marked NOT NULL


-----------
QUERY:
		-- nope
alter table inh_child alter a set not null;
RESULT:
	[]

-----------
QUERY:

alter table inh_child inherit inh_parent;
RESULT:
	[]

-----------
QUERY:
		-- now it works

-- don/* REPLACED */''t interfere with other types of constraints
alter table inh_parent add constraint inh_parent_excl exclude ((1) with =);
RESULT:
	[]

-----------
QUERY:

alter table inh_parent add constraint inh_parent_uq unique (a);
RESULT:
	[]

-----------
QUERY:

alter table inh_parent add constraint inh_parent_fk foreign key (a) references inh_parent (a);
RESULT:
	[]

-----------
QUERY:

create table inh_child2 () inherits (inh_parent);
RESULT:
	[]

-----------
QUERY:

create table inh_child3 (like inh_parent);
RESULT:
	[]

-----------
QUERY:

alter table inh_child3 inherit inh_parent;
RESULT:
	[]

-----------
QUERY:

select conrelid::regclass, conname, contype, coninhcount, conislocal
 from pg_constraint
 where conrelid::regclass::text in ('inh_parent', 'inh_child', 'inh_child2', 'inh_child3')
 order by 2, 1;
RESULT:
	[('inh_child2', 'inh_child2_a_not_null', 'n', 1, False), ('inh_child3', 'inh_child3_a_not_null', 'n', 1, True), ('inh_child', 'inh_child_a_not_null', 'n', 1, True), ('inh_child', 'inh_child_pkey', 'p', 0, True), ('inh_parent', 'inh_parent_excl', 'x', 0, True), ('inh_parent', 'inh_parent_fk', 'f', 0, True), ('inh_parent', 'inh_parent_pkey', 'p', 0, True), ('inh_parent', 'inh_parent_uq', 'u', 0, True)]

-----------
QUERY:


drop table inh_parent, inh_child, inh_child2, inh_child3;
RESULT:
	[]

-----------
QUERY:


--
-- test multi inheritance tree
--
create table inh_parent(f1 int not null);
RESULT:
	[]

-----------
QUERY:

create table inh_child1() inherits(inh_parent);
RESULT:
	[]

-----------
QUERY:

create table inh_child2() inherits(inh_parent);
RESULT:
	[]

-----------
QUERY:

create table inh_child3() inherits(inh_child1, inh_child2);
RESULT:
	[]

-----------
QUERY:


-- show constraint info
select conrelid::regclass, conname, contype, coninhcount, conislocal
 from pg_constraint where contype = 'n' and
 conrelid in ('inh_parent'::regclass, 'inh_child1'::regclass, 'inh_child2'::regclass, 'inh_child3'::regclass)
 order by 2, conrelid::regclass::text;
RESULT:
	[('inh_child1', 'inh_parent_f1_not_null', 'n', 1, False), ('inh_child2', 'inh_parent_f1_not_null', 'n', 1, False), ('inh_child3', 'inh_parent_f1_not_null', 'n', 2, False), ('inh_parent', 'inh_parent_f1_not_null', 'n', 0, True)]

-----------
QUERY:


drop table inh_parent cascade;
RESULT:
	[]

-----------
QUERY:


-- test child table with inherited columns and
-- with explicitly specified not null constraints
create table inh_parent_1(f1 int);
RESULT:
	[]

-----------
QUERY:

create table inh_parent_2(f2 text);
RESULT:
	[]

-----------
QUERY:

create table inh_child(f1 int not null, f2 text not null) inherits(inh_parent_1, inh_parent_2);
RESULT:
	[]

-----------
QUERY:


-- show constraint info
select conrelid::regclass, conname, contype, coninhcount, conislocal
 from pg_constraint where contype = 'n' and
 conrelid in ('inh_parent_1'::regclass, 'inh_parent_2'::regclass, 'inh_child'::regclass)
 order by 2, conrelid::regclass::text;
RESULT:
	[('inh_child', 'inh_child_f1_not_null', 'n', 0, True), ('inh_child', 'inh_child_f2_not_null', 'n', 0, True)]

-----------
QUERY:


-- also drops inh_child table
drop table inh_parent_1 cascade;
RESULT:
	[]

-----------
QUERY:

drop table inh_parent_2;
RESULT:
	[]

-----------
QUERY:


-- test multi layer inheritance tree
create table inh_p1(f1 int not null);
RESULT:
	[]

-----------
QUERY:

create table inh_p2(f1 int not null);
RESULT:
	[]

-----------
QUERY:

create table inh_p3(f2 int);
RESULT:
	[]

-----------
QUERY:

create table inh_p4(f1 int not null, f3 text not null);
RESULT:
	[]

-----------
QUERY:


create table inh_multiparent() inherits(inh_p1, inh_p2, inh_p3, inh_p4);
RESULT:
	[]

-----------
QUERY:


-- constraint on f1 should have three parents
select conrelid::regclass, contype, conname,
  (select attname from pg_attribute where attrelid = conrelid and attnum = conkey[1]),
  coninhcount, conislocal
 from pg_constraint where contype = 'n' and
 conrelid::regclass in ('inh_p1', 'inh_p2', 'inh_p3', 'inh_p4',
	'inh_multiparent')
 order by conrelid::regclass::text, conname;
RESULT:
	[('inh_multiparent', 'n', 'inh_p1_f1_not_null', 'f1', 3, False), ('inh_multiparent', 'n', 'inh_p4_f3_not_null', 'f3', 1, False), ('inh_p1', 'n', 'inh_p1_f1_not_null', 'f1', 0, True), ('inh_p2', 'n', 'inh_p2_f1_not_null', 'f1', 0, True), ('inh_p4', 'n', 'inh_p4_f1_not_null', 'f1', 0, True), ('inh_p4', 'n', 'inh_p4_f3_not_null', 'f3', 0, True)]

-----------
QUERY:


create table inh_multiparent2 (a int not null, f1 int) inherits(inh_p3, inh_multiparent);
RESULT:
	[]

-----------
QUERY:

select conrelid::regclass, contype, conname,
  (select attname from pg_attribute where attrelid = conrelid and attnum = conkey[1]),
  coninhcount, conislocal
 from pg_constraint where contype = 'n' and
 conrelid::regclass in ('inh_p3', 'inh_multiparent', 'inh_multiparent2')
 order by conrelid::regclass::text, conname;
RESULT:
	[('inh_multiparent', 'n', 'inh_p1_f1_not_null', 'f1', 3, False), ('inh_multiparent', 'n', 'inh_p4_f3_not_null', 'f3', 1, False), ('inh_multiparent2', 'n', 'inh_multiparent2_a_not_null', 'a', 0, True), ('inh_multiparent2', 'n', 'inh_p1_f1_not_null', 'f1', 1, False), ('inh_multiparent2', 'n', 'inh_p4_f3_not_null', 'f3', 1, False)]

-----------
QUERY:


drop table inh_p1, inh_p2, inh_p3, inh_p4 cascade;
RESULT:
	[]

-----------
QUERY:


--
-- Mixed ownership inheritance tree
--
create role regress_alice;
RESULT:
	[]

-----------
QUERY:

create role regress_bob;
RESULT:
	[]

-----------
QUERY:

grant all on schema public to regress_alice, regress_bob;
RESULT:
	[]

-----------
QUERY:

grant regress_alice to regress_bob;
RESULT:
	[]

-----------
QUERY:

set session authorization regress_alice;
RESULT:
	[]

-----------
QUERY:

create table inh_parent (a int not null);
RESULT:
	[]

-----------
QUERY:

set session authorization regress_bob;
RESULT:
	[]

-----------
QUERY:

create table inh_child () inherits (inh_parent);
RESULT:
	[]

-----------
QUERY:

set session authorization regress_alice;
RESULT:
	[]

-----------
QUERY:

-- alice can/* REPLACED */''t do this: she doesn/* REPLACED */''t own inh_child
alter table inh_parent alter a drop not null;
RESULT:
	ERROR - must be owner of table inh_child


-----------
QUERY:

set session authorization regress_bob;
RESULT:
	[]

-----------
QUERY:

alter table inh_parent alter a drop not null;
RESULT:
	[]

-----------
QUERY:

reset session authorization;
RESULT:
	[]

-----------
QUERY:

drop table inh_parent, inh_child;
RESULT:
	[]

-----------
QUERY:

revoke all on schema public from regress_alice, regress_bob;
RESULT:
	[]

-----------
QUERY:

drop role regress_alice, regress_bob;
RESULT:
	[]

-----------
QUERY:


--
-- Check use of temporary tables with inheritance trees
--
create table inh_perm_parent (a1 int);
RESULT:
	[]

-----------
QUERY:

create temp table inh_temp_parent (a1 int);
RESULT:
	[]

-----------
QUERY:

create temp table inh_temp_child () inherits (inh_perm_parent);
RESULT:
	[]

-----------
QUERY:
 -- ok
create table inh_perm_child () inherits (inh_temp_parent);
RESULT:
	ERROR - cannot inherit from temporary relation "inh_temp_parent"


-----------
QUERY:
 -- error
create temp table inh_temp_child_2 () inherits (inh_temp_parent);
RESULT:
	[]

-----------
QUERY:
 -- ok
insert into inh_perm_parent values (1);
RESULT:
	[]

-----------
QUERY:

insert into inh_temp_parent values (2);
RESULT:
	[]

-----------
QUERY:

insert into inh_temp_child values (3);
RESULT:
	[]

-----------
QUERY:

insert into inh_temp_child_2 values (4);
RESULT:
	[]

-----------
QUERY:

select tableoid::regclass, a1 from inh_perm_parent;
RESULT:
	[('inh_perm_parent', 1), ('inh_temp_child', 3)]

-----------
QUERY:

select tableoid::regclass, a1 from inh_temp_parent;
RESULT:
	[('inh_temp_parent', 2), ('inh_temp_child_2', 4)]

-----------
QUERY:

drop table inh_perm_parent cascade;
RESULT:
	[]

-----------
QUERY:

drop table inh_temp_parent cascade;
RESULT:
	[]

-----------
QUERY:


--
-- Check that constraint exclusion works correctly with partitions using
-- implicit constraints generated from the partition bound information.
--
create table list_parted (
	a	varchar
) partition by list (a);
RESULT:
	[]

-----------
QUERY:

create table part_ab_cd partition of list_parted for values in ('ab', 'cd');
RESULT:
	[]

-----------
QUERY:

create table part_ef_gh partition of list_parted for values in ('ef', 'gh');
RESULT:
	[]

-----------
QUERY:

create table part_null_xy partition of list_parted for values in (null, 'xy');
RESULT:
	[]

-----------
QUERY:


explain (costs off) select * from list_parted;
RESULT:
	[('Append',), ('  ->  Seq Scan on part_ab_cd list_parted_1',), ('  ->  Seq Scan on part_ef_gh list_parted_2',), ('  ->  Seq Scan on part_null_xy list_parted_3',)]

-----------
QUERY:

explain (costs off) select * from list_parted where a is null;
RESULT:
	[('Seq Scan on part_null_xy list_parted',), ('  Filter: (a IS NULL)',)]

-----------
QUERY:

explain (costs off) select * from list_parted where a is not null;
RESULT:
	[('Append',), ('  ->  Seq Scan on part_ab_cd list_parted_1',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on part_ef_gh list_parted_2',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on part_null_xy list_parted_3',), ('        Filter: (a IS NOT NULL)',)]

-----------
QUERY:

explain (costs off) select * from list_parted where a in ('ab', 'cd', 'ef');
RESULT:
	[('Append',), ('  ->  Seq Scan on part_ab_cd list_parted_1',), ("        Filter: ((a)::text = ANY ('{ab,cd,ef}'::text[]))",), ('  ->  Seq Scan on part_ef_gh list_parted_2',), ("        Filter: ((a)::text = ANY ('{ab,cd,ef}'::text[]))",)]

-----------
QUERY:

explain (costs off) select * from list_parted where a = 'ab' or a in (null, 'cd');
RESULT:
	[('Seq Scan on part_ab_cd list_parted',), ("  Filter: (((a)::text = 'ab'::text) OR ((a)::text = ANY ('{NULL,cd}'::text[])))",)]

-----------
QUERY:

explain (costs off) select * from list_parted where a = 'ab';
RESULT:
	[('Seq Scan on part_ab_cd list_parted',), ("  Filter: ((a)::text = 'ab'::text)",)]

-----------
QUERY:


create table range_list_parted (
	a	int,
	b	char(2)
) partition by range (a);
RESULT:
	[]

-----------
QUERY:

create table part_1_10 partition of range_list_parted for values from (1) to (10) partition by list (b);
RESULT:
	[]

-----------
QUERY:

create table part_1_10_ab partition of part_1_10 for values in ('ab');
RESULT:
	[]

-----------
QUERY:

create table part_1_10_cd partition of part_1_10 for values in ('cd');
RESULT:
	[]

-----------
QUERY:

create table part_10_20 partition of range_list_parted for values from (10) to (20) partition by list (b);
RESULT:
	[]

-----------
QUERY:

create table part_10_20_ab partition of part_10_20 for values in ('ab');
RESULT:
	[]

-----------
QUERY:

create table part_10_20_cd partition of part_10_20 for values in ('cd');
RESULT:
	[]

-----------
QUERY:

create table part_21_30 partition of range_list_parted for values from (21) to (30) partition by list (b);
RESULT:
	[]

-----------
QUERY:

create table part_21_30_ab partition of part_21_30 for values in ('ab');
RESULT:
	[]

-----------
QUERY:

create table part_21_30_cd partition of part_21_30 for values in ('cd');
RESULT:
	[]

-----------
QUERY:

create table part_40_inf partition of range_list_parted for values from (40) to (maxvalue) partition by list (b);
RESULT:
	[]

-----------
QUERY:

create table part_40_inf_ab partition of part_40_inf for values in ('ab');
RESULT:
	[]

-----------
QUERY:

create table part_40_inf_cd partition of part_40_inf for values in ('cd');
RESULT:
	[]

-----------
QUERY:

create table part_40_inf_null partition of part_40_inf for values in (null);
RESULT:
	[]

-----------
QUERY:


explain (costs off) select * from range_list_parted;
RESULT:
	[('Append',), ('  ->  Seq Scan on part_1_10_ab range_list_parted_1',), ('  ->  Seq Scan on part_1_10_cd range_list_parted_2',), ('  ->  Seq Scan on part_10_20_ab range_list_parted_3',), ('  ->  Seq Scan on part_10_20_cd range_list_parted_4',), ('  ->  Seq Scan on part_21_30_ab range_list_parted_5',), ('  ->  Seq Scan on part_21_30_cd range_list_parted_6',), ('  ->  Seq Scan on part_40_inf_ab range_list_parted_7',), ('  ->  Seq Scan on part_40_inf_cd range_list_parted_8',), ('  ->  Seq Scan on part_40_inf_null range_list_parted_9',)]

-----------
QUERY:

explain (costs off) select * from range_list_parted where a = 5;
RESULT:
	[('Append',), ('  ->  Seq Scan on part_1_10_ab range_list_parted_1',), ('        Filter: (a = 5)',), ('  ->  Seq Scan on part_1_10_cd range_list_parted_2',), ('        Filter: (a = 5)',)]

-----------
QUERY:

explain (costs off) select * from range_list_parted where b = 'ab';
RESULT:
	[('Append',), ('  ->  Seq Scan on part_1_10_ab range_list_parted_1',), ("        Filter: (b = 'ab'::bpchar)",), ('  ->  Seq Scan on part_10_20_ab range_list_parted_2',), ("        Filter: (b = 'ab'::bpchar)",), ('  ->  Seq Scan on part_21_30_ab range_list_parted_3',), ("        Filter: (b = 'ab'::bpchar)",), ('  ->  Seq Scan on part_40_inf_ab range_list_parted_4',), ("        Filter: (b = 'ab'::bpchar)",)]

-----------
QUERY:

explain (costs off) select * from range_list_parted where a between 3 and 23 and b in ('ab');
RESULT:
	[('Append',), ('  ->  Seq Scan on part_1_10_ab range_list_parted_1',), ("        Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))",), ('  ->  Seq Scan on part_10_20_ab range_list_parted_2',), ("        Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))",), ('  ->  Seq Scan on part_21_30_ab range_list_parted_3',), ("        Filter: ((a >= 3) AND (a <= 23) AND (b = 'ab'::bpchar))",)]

-----------
QUERY:


/* Should select no rows because range partition key cannot be null */
explain (costs off) select * from range_list_parted where a is null;
RESULT:
	[('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


/* Should only select rows from the null-accepting partition */
explain (costs off) select * from range_list_parted where b is null;
RESULT:
	[('Seq Scan on part_40_inf_null range_list_parted',), ('  Filter: (b IS NULL)',)]

-----------
QUERY:

explain (costs off) select * from range_list_parted where a is not null and a < 67;
RESULT:
	[('Append',), ('  ->  Seq Scan on part_1_10_ab range_list_parted_1',), ('        Filter: ((a IS NOT NULL) AND (a < 67))',), ('  ->  Seq Scan on part_1_10_cd range_list_parted_2',), ('        Filter: ((a IS NOT NULL) AND (a < 67))',), ('  ->  Seq Scan on part_10_20_ab range_list_parted_3',), ('        Filter: ((a IS NOT NULL) AND (a < 67))',), ('  ->  Seq Scan on part_10_20_cd range_list_parted_4',), ('        Filter: ((a IS NOT NULL) AND (a < 67))',), ('  ->  Seq Scan on part_21_30_ab range_list_parted_5',), ('        Filter: ((a IS NOT NULL) AND (a < 67))',), ('  ->  Seq Scan on part_21_30_cd range_list_parted_6',), ('        Filter: ((a IS NOT NULL) AND (a < 67))',), ('  ->  Seq Scan on part_40_inf_ab range_list_parted_7',), ('        Filter: ((a IS NOT NULL) AND (a < 67))',), ('  ->  Seq Scan on part_40_inf_cd range_list_parted_8',), ('        Filter: ((a IS NOT NULL) AND (a < 67))',), ('  ->  Seq Scan on part_40_inf_null range_list_parted_9',), ('        Filter: ((a IS NOT NULL) AND (a < 67))',)]

-----------
QUERY:

explain (costs off) select * from range_list_parted where a >= 30;
RESULT:
	[('Append',), ('  ->  Seq Scan on part_40_inf_ab range_list_parted_1',), ('        Filter: (a >= 30)',), ('  ->  Seq Scan on part_40_inf_cd range_list_parted_2',), ('        Filter: (a >= 30)',), ('  ->  Seq Scan on part_40_inf_null range_list_parted_3',), ('        Filter: (a >= 30)',)]

-----------
QUERY:


drop table list_parted;
RESULT:
	[]

-----------
QUERY:

drop table range_list_parted;
RESULT:
	[]

-----------
QUERY:


-- check that constraint exclusion is able to cope with the partition
-- constraint emitted for multi-column range partitioned tables
create table mcrparted (a int, b int, c int) partition by range (a, abs(b), c);
RESULT:
	[]

-----------
QUERY:

create table mcrparted_def partition of mcrparted default;
RESULT:
	[]

-----------
QUERY:

create table mcrparted0 partition of mcrparted for values from (minvalue, minvalue, minvalue) to (1, 1, 1);
RESULT:
	[]

-----------
QUERY:

create table mcrparted1 partition of mcrparted for values from (1, 1, 1) to (10, 5, 10);
RESULT:
	[]

-----------
QUERY:

create table mcrparted2 partition of mcrparted for values from (10, 5, 10) to (10, 10, 10);
RESULT:
	[]

-----------
QUERY:

create table mcrparted3 partition of mcrparted for values from (11, 1, 1) to (20, 10, 10);
RESULT:
	[]

-----------
QUERY:

create table mcrparted4 partition of mcrparted for values from (20, 10, 10) to (20, 20, 20);
RESULT:
	[]

-----------
QUERY:

create table mcrparted5 partition of mcrparted for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue);
RESULT:
	[]

-----------
QUERY:

explain (costs off) select * from mcrparted where a = 0;
RESULT:
	[('Append',), ('  ->  Seq Scan on mcrparted0 mcrparted_1',), ('        Filter: (a = 0)',), ('  ->  Seq Scan on mcrparted_def mcrparted_2',), ('        Filter: (a = 0)',)]

-----------
QUERY:
	-- scans mcrparted0, mcrparted_def
explain (costs off) select * from mcrparted where a = 10 and abs(b) < 5;
RESULT:
	[('Append',), ('  ->  Seq Scan on mcrparted1 mcrparted_1',), ('        Filter: ((a = 10) AND (abs(b) < 5))',), ('  ->  Seq Scan on mcrparted_def mcrparted_2',), ('        Filter: ((a = 10) AND (abs(b) < 5))',)]

-----------
QUERY:
	-- scans mcrparted1, mcrparted_def
explain (costs off) select * from mcrparted where a = 10 and abs(b) = 5;
RESULT:
	[('Append',), ('  ->  Seq Scan on mcrparted1 mcrparted_1',), ('        Filter: ((a = 10) AND (abs(b) = 5))',), ('  ->  Seq Scan on mcrparted2 mcrparted_2',), ('        Filter: ((a = 10) AND (abs(b) = 5))',), ('  ->  Seq Scan on mcrparted_def mcrparted_3',), ('        Filter: ((a = 10) AND (abs(b) = 5))',)]

-----------
QUERY:
	-- scans mcrparted1, mcrparted2, mcrparted_def
explain (costs off) select * from mcrparted where abs(b) = 5;
RESULT:
	[('Append',), ('  ->  Seq Scan on mcrparted0 mcrparted_1',), ('        Filter: (abs(b) = 5)',), ('  ->  Seq Scan on mcrparted1 mcrparted_2',), ('        Filter: (abs(b) = 5)',), ('  ->  Seq Scan on mcrparted2 mcrparted_3',), ('        Filter: (abs(b) = 5)',), ('  ->  Seq Scan on mcrparted3 mcrparted_4',), ('        Filter: (abs(b) = 5)',), ('  ->  Seq Scan on mcrparted4 mcrparted_5',), ('        Filter: (abs(b) = 5)',), ('  ->  Seq Scan on mcrparted5 mcrparted_6',), ('        Filter: (abs(b) = 5)',), ('  ->  Seq Scan on mcrparted_def mcrparted_7',), ('        Filter: (abs(b) = 5)',)]

-----------
QUERY:
	-- scans all partitions
explain (costs off) select * from mcrparted where a > -1;
RESULT:
	[('Append',), ('  ->  Seq Scan on mcrparted0 mcrparted_1',), ("        Filter: (a > '-1'::integer)",), ('  ->  Seq Scan on mcrparted1 mcrparted_2',), ("        Filter: (a > '-1'::integer)",), ('  ->  Seq Scan on mcrparted2 mcrparted_3',), ("        Filter: (a > '-1'::integer)",), ('  ->  Seq Scan on mcrparted3 mcrparted_4',), ("        Filter: (a > '-1'::integer)",), ('  ->  Seq Scan on mcrparted4 mcrparted_5',), ("        Filter: (a > '-1'::integer)",), ('  ->  Seq Scan on mcrparted5 mcrparted_6',), ("        Filter: (a > '-1'::integer)",), ('  ->  Seq Scan on mcrparted_def mcrparted_7',), ("        Filter: (a > '-1'::integer)",)]

-----------
QUERY:
	-- scans all partitions
explain (costs off) select * from mcrparted where a = 20 and abs(b) = 10 and c > 10;
RESULT:
	[('Seq Scan on mcrparted4 mcrparted',), ('  Filter: ((c > 10) AND (a = 20) AND (abs(b) = 10))',)]

-----------
QUERY:
	-- scans mcrparted4
explain (costs off) select * from mcrparted where a = 20 and c > 20;
RESULT:
	[('Append',), ('  ->  Seq Scan on mcrparted3 mcrparted_1',), ('        Filter: ((c > 20) AND (a = 20))',), ('  ->  Seq Scan on mcrparted4 mcrparted_2',), ('        Filter: ((c > 20) AND (a = 20))',), ('  ->  Seq Scan on mcrparted5 mcrparted_3',), ('        Filter: ((c > 20) AND (a = 20))',), ('  ->  Seq Scan on mcrparted_def mcrparted_4',), ('        Filter: ((c > 20) AND (a = 20))',)]

-----------
QUERY:
 -- scans mcrparted3, mcrparte4, mcrparte5, mcrparted_def

-- check that partitioned table Appends cope with being referenced in
-- subplans
create table parted_minmax (a int, b varchar(16)) partition by range (a);
RESULT:
	[]

-----------
QUERY:

create table parted_minmax1 partition of parted_minmax for values from (1) to (10);
RESULT:
	[]

-----------
QUERY:

create index parted_minmax1i on parted_minmax1 (a, b);
RESULT:
	[]

-----------
QUERY:

insert into parted_minmax values (1,'12345');
RESULT:
	[]

-----------
QUERY:

explain (costs off) select min(a), max(a) from parted_minmax where b = '12345';
RESULT:
	[('Result',), ('  InitPlan 1',), ('    ->  Limit',), ('          ->  Index Only Scan using parted_minmax1i on parted_minmax1 parted_minmax',), ("                Index Cond: ((a IS NOT NULL) AND (b = '12345'::text))",), ('  InitPlan 2',), ('    ->  Limit',), ('          ->  Index Only Scan Backward using parted_minmax1i on parted_minmax1 parted_minmax_1',), ("                Index Cond: ((a IS NOT NULL) AND (b = '12345'::text))",)]

-----------
QUERY:

select min(a), max(a) from parted_minmax where b = '12345';
RESULT:
	[(1, 1)]

-----------
QUERY:

drop table parted_minmax;
RESULT:
	[]

-----------
QUERY:


-- Test code that uses Append nodes in place of MergeAppend when the
-- partition ordering matches the desired ordering.

create index mcrparted_a_abs_c_idx on mcrparted (a, abs(b), c);
RESULT:
	[]

-----------
QUERY:


-- MergeAppend must be used when a default partition exists
explain (costs off) select * from mcrparted order by a, abs(b), c;
RESULT:
	[('Merge Append',), ('  Sort Key: mcrparted.a, (abs(mcrparted.b)), mcrparted.c',), ('  ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1',), ('  ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2',), ('  ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3',), ('  ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4',), ('  ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_5',), ('  ->  Index Scan using mcrparted5_a_abs_c_idx on mcrparted5 mcrparted_6',), ('  ->  Index Scan using mcrparted_def_a_abs_c_idx on mcrparted_def mcrparted_7',)]

-----------
QUERY:


drop table mcrparted_def;
RESULT:
	[]

-----------
QUERY:


-- Append is used for a RANGE partitioned table with no default
-- and no subpartitions
explain (costs off) select * from mcrparted order by a, abs(b), c;
RESULT:
	[('Append',), ('  ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1',), ('  ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2',), ('  ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3',), ('  ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4',), ('  ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_5',), ('  ->  Index Scan using mcrparted5_a_abs_c_idx on mcrparted5 mcrparted_6',)]

-----------
QUERY:


-- Append is used with subpaths in reverse order with backwards index scans
explain (costs off) select * from mcrparted order by a desc, abs(b) desc, c desc;
RESULT:
	[('Append',), ('  ->  Index Scan Backward using mcrparted5_a_abs_c_idx on mcrparted5 mcrparted_6',), ('  ->  Index Scan Backward using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_5',), ('  ->  Index Scan Backward using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4',), ('  ->  Index Scan Backward using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3',), ('  ->  Index Scan Backward using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2',), ('  ->  Index Scan Backward using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1',)]

-----------
QUERY:


-- check that Append plan is used containing a MergeAppend for sub-partitions
-- that are unordered.
drop table mcrparted5;
RESULT:
	[]

-----------
QUERY:

create table mcrparted5 partition of mcrparted for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue) partition by list (a);
RESULT:
	[]

-----------
QUERY:

create table mcrparted5a partition of mcrparted5 for values in(20);
RESULT:
	[]

-----------
QUERY:

create table mcrparted5_def partition of mcrparted5 default;
RESULT:
	[]

-----------
QUERY:


explain (costs off) select * from mcrparted order by a, abs(b), c;
RESULT:
	[('Append',), ('  ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1',), ('  ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2',), ('  ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3',), ('  ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4',), ('  ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_5',), ('  ->  Merge Append',), ('        Sort Key: mcrparted_7.a, (abs(mcrparted_7.b)), mcrparted_7.c',), ('        ->  Index Scan using mcrparted5a_a_abs_c_idx on mcrparted5a mcrparted_7',), ('        ->  Index Scan using mcrparted5_def_a_abs_c_idx on mcrparted5_def mcrparted_8',)]

-----------
QUERY:


drop table mcrparted5_def;
RESULT:
	[]

-----------
QUERY:


-- check that an Append plan is used and the sub-partitions are flattened
-- into the main Append when the sub-partition is unordered but contains
-- just a single sub-partition.
explain (costs off) select a, abs(b) from mcrparted order by a, abs(b), c;
RESULT:
	[('Append',), ('  ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1',), ('  ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2',), ('  ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3',), ('  ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4',), ('  ->  Index Scan using mcrparted4_a_abs_c_idx on mcrparted4 mcrparted_5',), ('  ->  Index Scan using mcrparted5a_a_abs_c_idx on mcrparted5a mcrparted_6',)]

-----------
QUERY:


-- check that Append is used when the sub-partitioned tables are pruned
-- during planning.
explain (costs off) select * from mcrparted where a < 20 order by a, abs(b), c;
RESULT:
	[('Append',), ('  ->  Index Scan using mcrparted0_a_abs_c_idx on mcrparted0 mcrparted_1',), ('        Index Cond: (a < 20)',), ('  ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2',), ('        Index Cond: (a < 20)',), ('  ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3',), ('        Index Cond: (a < 20)',), ('  ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4',), ('        Index Cond: (a < 20)',)]

-----------
QUERY:


set enable_bitmapscan to off;
RESULT:
	[]

-----------
QUERY:

set enable_sort to off;
RESULT:
	[]

-----------
QUERY:

create table mclparted (a int) partition by list(a);
RESULT:
	[]

-----------
QUERY:

create table mclparted1 partition of mclparted for values in(1);
RESULT:
	[]

-----------
QUERY:

create table mclparted2 partition of mclparted for values in(2);
RESULT:
	[]

-----------
QUERY:

create index on mclparted (a);
RESULT:
	[]

-----------
QUERY:


-- Ensure an Append is used for a list partition with an order by.
explain (costs off) select * from mclparted order by a;
RESULT:
	[('Append',), ('  ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1',), ('  ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2',)]

-----------
QUERY:


-- Ensure a MergeAppend is used when a partition exists with interleaved
-- datums in the partition bound.
create table mclparted3_5 partition of mclparted for values in(3,5);
RESULT:
	[]

-----------
QUERY:

create table mclparted4 partition of mclparted for values in(4);
RESULT:
	[]

-----------
QUERY:


explain (costs off) select * from mclparted order by a;
RESULT:
	[('Merge Append',), ('  Sort Key: mclparted.a',), ('  ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1',), ('  ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2',), ('  ->  Index Only Scan using mclparted3_5_a_idx on mclparted3_5 mclparted_3',), ('  ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_4',)]

-----------
QUERY:

explain (costs off) select * from mclparted where a in(3,4,5) order by a;
RESULT:
	[('Merge Append',), ('  Sort Key: mclparted.a',), ('  ->  Index Only Scan using mclparted3_5_a_idx on mclparted3_5 mclparted_1',), ("        Index Cond: (a = ANY ('{3,4,5}'::integer[]))",), ('  ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_2',), ("        Index Cond: (a = ANY ('{3,4,5}'::integer[]))",)]

-----------
QUERY:


-- Introduce a NULL and DEFAULT partition so we can test more complex cases
create table mclparted_null partition of mclparted for values in(null);
RESULT:
	[]

-----------
QUERY:

create table mclparted_def partition of mclparted default;
RESULT:
	[]

-----------
QUERY:


-- Append can be used providing we don/* REPLACED */''t scan the interleaved partition
explain (costs off) select * from mclparted where a in(1,2,4) order by a;
RESULT:
	[('Append',), ('  ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1',), ("        Index Cond: (a = ANY ('{1,2,4}'::integer[]))",), ('  ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2',), ("        Index Cond: (a = ANY ('{1,2,4}'::integer[]))",), ('  ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_3',), ("        Index Cond: (a = ANY ('{1,2,4}'::integer[]))",)]

-----------
QUERY:

explain (costs off) select * from mclparted where a in(1,2,4) or a is null order by a;
RESULT:
	[('Append',), ('  ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1',), ("        Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))",), ('  ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2',), ("        Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))",), ('  ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_3',), ("        Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))",), ('  ->  Index Only Scan using mclparted_null_a_idx on mclparted_null mclparted_4',), ("        Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))",)]

-----------
QUERY:


-- Test a more complex case where the NULL partition allows some other value
drop table mclparted_null;
RESULT:
	[]

-----------
QUERY:

create table mclparted_0_null partition of mclparted for values in(0,null);
RESULT:
	[]

-----------
QUERY:


-- Ensure MergeAppend is used since 0 and NULLs are in the same partition.
explain (costs off) select * from mclparted where a in(1,2,4) or a is null order by a;
RESULT:
	[('Merge Append',), ('  Sort Key: mclparted.a',), ('  ->  Index Only Scan using mclparted_0_null_a_idx on mclparted_0_null mclparted_1',), ("        Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))",), ('  ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_2',), ("        Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))",), ('  ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_3',), ("        Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))",), ('  ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_4',), ("        Filter: ((a = ANY ('{1,2,4}'::integer[])) OR (a IS NULL))",)]

-----------
QUERY:

explain (costs off) select * from mclparted where a in(0,1,2,4) order by a;
RESULT:
	[('Merge Append',), ('  Sort Key: mclparted.a',), ('  ->  Index Only Scan using mclparted_0_null_a_idx on mclparted_0_null mclparted_1',), ("        Index Cond: (a = ANY ('{0,1,2,4}'::integer[]))",), ('  ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_2',), ("        Index Cond: (a = ANY ('{0,1,2,4}'::integer[]))",), ('  ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_3',), ("        Index Cond: (a = ANY ('{0,1,2,4}'::integer[]))",), ('  ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_4',), ("        Index Cond: (a = ANY ('{0,1,2,4}'::integer[]))",)]

-----------
QUERY:


-- Ensure Append is used when the null partition is pruned
explain (costs off) select * from mclparted where a in(1,2,4) order by a;
RESULT:
	[('Append',), ('  ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1',), ("        Index Cond: (a = ANY ('{1,2,4}'::integer[]))",), ('  ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2',), ("        Index Cond: (a = ANY ('{1,2,4}'::integer[]))",), ('  ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_3',), ("        Index Cond: (a = ANY ('{1,2,4}'::integer[]))",)]

-----------
QUERY:


-- Ensure MergeAppend is used when the default partition is not pruned
explain (costs off) select * from mclparted where a in(1,2,4,100) order by a;
RESULT:
	[('Merge Append',), ('  Sort Key: mclparted.a',), ('  ->  Index Only Scan using mclparted1_a_idx on mclparted1 mclparted_1',), ("        Index Cond: (a = ANY ('{1,2,4,100}'::integer[]))",), ('  ->  Index Only Scan using mclparted2_a_idx on mclparted2 mclparted_2',), ("        Index Cond: (a = ANY ('{1,2,4,100}'::integer[]))",), ('  ->  Index Only Scan using mclparted4_a_idx on mclparted4 mclparted_3',), ("        Index Cond: (a = ANY ('{1,2,4,100}'::integer[]))",), ('  ->  Index Only Scan using mclparted_def_a_idx on mclparted_def mclparted_4',), ("        Index Cond: (a = ANY ('{1,2,4,100}'::integer[]))",)]

-----------
QUERY:


drop table mclparted;
RESULT:
	[]

-----------
QUERY:

reset enable_sort;
RESULT:
	[]

-----------
QUERY:

reset enable_bitmapscan;
RESULT:
	[]

-----------
QUERY:


-- Ensure subplans which don/* REPLACED */''t have a path with the correct pathkeys get
-- sorted correctly.
drop index mcrparted_a_abs_c_idx;
RESULT:
	[]

-----------
QUERY:

create index on mcrparted1 (a, abs(b), c);
RESULT:
	[]

-----------
QUERY:

create index on mcrparted2 (a, abs(b), c);
RESULT:
	[]

-----------
QUERY:

create index on mcrparted3 (a, abs(b), c);
RESULT:
	[]

-----------
QUERY:

create index on mcrparted4 (a, abs(b), c);
RESULT:
	[]

-----------
QUERY:


explain (costs off) select * from mcrparted where a < 20 order by a, abs(b), c limit 1;
RESULT:
	[('Limit',), ('  ->  Append',), ('        ->  Sort',), ('              Sort Key: mcrparted_1.a, (abs(mcrparted_1.b)), mcrparted_1.c',), ('              ->  Seq Scan on mcrparted0 mcrparted_1',), ('                    Filter: (a < 20)',), ('        ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_2',), ('              Index Cond: (a < 20)',), ('        ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_3',), ('              Index Cond: (a < 20)',), ('        ->  Index Scan using mcrparted3_a_abs_c_idx on mcrparted3 mcrparted_4',), ('              Index Cond: (a < 20)',)]

-----------
QUERY:


set enable_bitmapscan = 0;
RESULT:
	[]

-----------
QUERY:

-- Ensure Append node can be used when the partition is ordered by some
-- pathkeys which were deemed redundant.
explain (costs off) select * from mcrparted where a = 10 order by a, abs(b), c;
RESULT:
	[('Append',), ('  ->  Index Scan using mcrparted1_a_abs_c_idx on mcrparted1 mcrparted_1',), ('        Index Cond: (a = 10)',), ('  ->  Index Scan using mcrparted2_a_abs_c_idx on mcrparted2 mcrparted_2',), ('        Index Cond: (a = 10)',)]

-----------
QUERY:

reset enable_bitmapscan;
RESULT:
	[]

-----------
QUERY:


drop table mcrparted;
RESULT:
	[]

-----------
QUERY:


-- Ensure LIST partitions allow an Append to be used instead of a MergeAppend
create table bool_lp (b bool) partition by list(b);
RESULT:
	[]

-----------
QUERY:

create table bool_lp_true partition of bool_lp for values in(true);
RESULT:
	[]

-----------
QUERY:

create table bool_lp_false partition of bool_lp for values in(false);
RESULT:
	[]

-----------
QUERY:

create index on bool_lp (b);
RESULT:
	[]

-----------
QUERY:


explain (costs off) select * from bool_lp order by b;
RESULT:
	[('Append',), ('  ->  Index Only Scan using bool_lp_false_b_idx on bool_lp_false bool_lp_1',), ('  ->  Index Only Scan using bool_lp_true_b_idx on bool_lp_true bool_lp_2',)]

-----------
QUERY:


drop table bool_lp;
RESULT:
	[]

-----------
QUERY:


-- Ensure const bool quals can be properly detected as redundant
create table bool_rp (b bool, a int) partition by range(b,a);
RESULT:
	[]

-----------
QUERY:

create table bool_rp_false_1k partition of bool_rp for values from (false,0) to (false,1000);
RESULT:
	[]

-----------
QUERY:

create table bool_rp_true_1k partition of bool_rp for values from (true,0) to (true,1000);
RESULT:
	[]

-----------
QUERY:

create table bool_rp_false_2k partition of bool_rp for values from (false,1000) to (false,2000);
RESULT:
	[]

-----------
QUERY:

create table bool_rp_true_2k partition of bool_rp for values from (true,1000) to (true,2000);
RESULT:
	[]

-----------
QUERY:

create index on bool_rp (b,a);
RESULT:
	[]

-----------
QUERY:

explain (costs off) select * from bool_rp where b = true order by b,a;
RESULT:
	[('Append',), ('  ->  Index Only Scan using bool_rp_true_1k_b_a_idx on bool_rp_true_1k bool_rp_1',), ('        Index Cond: (b = true)',), ('  ->  Index Only Scan using bool_rp_true_2k_b_a_idx on bool_rp_true_2k bool_rp_2',), ('        Index Cond: (b = true)',)]

-----------
QUERY:

explain (costs off) select * from bool_rp where b = false order by b,a;
RESULT:
	[('Append',), ('  ->  Index Only Scan using bool_rp_false_1k_b_a_idx on bool_rp_false_1k bool_rp_1',), ('        Index Cond: (b = false)',), ('  ->  Index Only Scan using bool_rp_false_2k_b_a_idx on bool_rp_false_2k bool_rp_2',), ('        Index Cond: (b = false)',)]

-----------
QUERY:

explain (costs off) select * from bool_rp where b = true order by a;
RESULT:
	[('Append',), ('  ->  Index Only Scan using bool_rp_true_1k_b_a_idx on bool_rp_true_1k bool_rp_1',), ('        Index Cond: (b = true)',), ('  ->  Index Only Scan using bool_rp_true_2k_b_a_idx on bool_rp_true_2k bool_rp_2',), ('        Index Cond: (b = true)',)]

-----------
QUERY:

explain (costs off) select * from bool_rp where b = false order by a;
RESULT:
	[('Append',), ('  ->  Index Only Scan using bool_rp_false_1k_b_a_idx on bool_rp_false_1k bool_rp_1',), ('        Index Cond: (b = false)',), ('  ->  Index Only Scan using bool_rp_false_2k_b_a_idx on bool_rp_false_2k bool_rp_2',), ('        Index Cond: (b = false)',)]

-----------
QUERY:


drop table bool_rp;
RESULT:
	[]

-----------
QUERY:


-- Ensure an Append scan is chosen when the partition order is a subset of
-- the required order.
create table range_parted (a int, b int, c int) partition by range(a, b);
RESULT:
	[]

-----------
QUERY:

create table range_parted1 partition of range_parted for values from (0,0) to (10,10);
RESULT:
	[]

-----------
QUERY:

create table range_parted2 partition of range_parted for values from (10,10) to (20,20);
RESULT:
	[]

-----------
QUERY:

create index on range_parted (a,b,c);
RESULT:
	[]

-----------
QUERY:


explain (costs off) select * from range_parted order by a,b,c;
RESULT:
	[('Append',), ('  ->  Index Only Scan using range_parted1_a_b_c_idx on range_parted1 range_parted_1',), ('  ->  Index Only Scan using range_parted2_a_b_c_idx on range_parted2 range_parted_2',)]

-----------
QUERY:

explain (costs off) select * from range_parted order by a desc,b desc,c desc;
RESULT:
	[('Append',), ('  ->  Index Only Scan Backward using range_parted2_a_b_c_idx on range_parted2 range_parted_2',), ('  ->  Index Only Scan Backward using range_parted1_a_b_c_idx on range_parted1 range_parted_1',)]

-----------
QUERY:


drop table range_parted;
RESULT:
	[]

-----------
QUERY:


-- Check that we allow access to a child table/* REPLACED */''s statistics when the user
-- has permissions only for the parent table.
create table permtest_parent (a int, b text, c text) partition by list (a);
RESULT:
	[]

-----------
QUERY:

create table permtest_child (b text, c text, a int) partition by list (b);
RESULT:
	[]

-----------
QUERY:

create table permtest_grandchild (c text, b text, a int);
RESULT:
	[]

-----------
QUERY:

alter table permtest_child attach partition permtest_grandchild for values in ('a');
RESULT:
	[]

-----------
QUERY:

alter table permtest_parent attach partition permtest_child for values in (1);
RESULT:
	[]

-----------
QUERY:

create index on permtest_parent (left(c, 3));
RESULT:
	[]

-----------
QUERY:

insert into permtest_parent
  select 1, 'a', left(fipshash(i::text), 5) from generate_series(0, 100) i;
RESULT:
	[]

-----------
QUERY:

analyze permtest_parent;
RESULT:
	[]

-----------
QUERY:

create role regress_no_child_access;
RESULT:
	[]

-----------
QUERY:

revoke all on permtest_grandchild from regress_no_child_access;
RESULT:
	[]

-----------
QUERY:

grant select on permtest_parent to regress_no_child_access;
RESULT:
	[]

-----------
QUERY:

set session authorization regress_no_child_access;
RESULT:
	[]

-----------
QUERY:

-- without stats access, these queries would produce hash join plans:
explain (costs off)
  select * from permtest_parent p1 inner join permtest_parent p2
  on p1.a = p2.a and p1.c ~ 'a1$';
RESULT:
	[('Nested Loop',), ('  Join Filter: (p1.a = p2.a)',), ('  ->  Seq Scan on permtest_grandchild p1',), ("        Filter: (c ~ 'a1$'::text)",), ('  ->  Seq Scan on permtest_grandchild p2',)]

-----------
QUERY:

explain (costs off)
  select * from permtest_parent p1 inner join permtest_parent p2
  on p1.a = p2.a and left(p1.c, 3) ~ 'a1$';
RESULT:
	[('Nested Loop',), ('  Join Filter: (p1.a = p2.a)',), ('  ->  Seq Scan on permtest_grandchild p1',), ('        Filter: ("left"(c, 3) ~ \'a1$\'::text)',), ('  ->  Seq Scan on permtest_grandchild p2',)]

-----------
QUERY:

reset session authorization;
RESULT:
	[]

-----------
QUERY:

revoke all on permtest_parent from regress_no_child_access;
RESULT:
	[]

-----------
QUERY:

grant select(a,c) on permtest_parent to regress_no_child_access;
RESULT:
	[]

-----------
QUERY:

set session authorization regress_no_child_access;
RESULT:
	[]

-----------
QUERY:

explain (costs off)
  select p2.a, p1.c from permtest_parent p1 inner join permtest_parent p2
  on p1.a = p2.a and p1.c ~ 'a1$';
RESULT:
	[('Nested Loop',), ('  Join Filter: (p1.a = p2.a)',), ('  ->  Seq Scan on permtest_grandchild p1',), ("        Filter: (c ~ 'a1$'::text)",), ('  ->  Seq Scan on permtest_grandchild p2',)]

-----------
QUERY:

-- we will not have access to the expression index/* REPLACED */''s stats here:
explain (costs off)
  select p2.a, p1.c from permtest_parent p1 inner join permtest_parent p2
  on p1.a = p2.a and left(p1.c, 3) ~ 'a1$';
RESULT:
	[('Hash Join',), ('  Hash Cond: (p2.a = p1.a)',), ('  ->  Seq Scan on permtest_grandchild p2',), ('  ->  Hash',), ('        ->  Seq Scan on permtest_grandchild p1',), ('              Filter: ("left"(c, 3) ~ \'a1$\'::text)',)]

-----------
QUERY:

reset session authorization;
RESULT:
	[]

-----------
QUERY:

revoke all on permtest_parent from regress_no_child_access;
RESULT:
	[]

-----------
QUERY:

drop role regress_no_child_access;
RESULT:
	[]

-----------
QUERY:

drop table permtest_parent;
RESULT:
	[]

-----------
QUERY:


-- Verify that constraint errors across partition root / child are
-- handled correctly (Bug #16293)
CREATE TABLE errtst_parent (
    partid int not null,
    shdata int not null,
    data int NOT NULL DEFAULT 0,
    CONSTRAINT shdata_small CHECK(shdata < 3)
) PARTITION BY RANGE (partid);
RESULT:
	[]

-----------
QUERY:


-- fast defaults lead to attribute mapping being used in one
-- direction, but not the other
CREATE TABLE errtst_child_fastdef (
    partid int not null,
    shdata int not null,
    CONSTRAINT shdata_small CHECK(shdata < 3)
);
RESULT:
	[]

-----------
QUERY:


-- no remapping in either direction necessary
CREATE TABLE errtst_child_plaindef (
    partid int not null,
    shdata int not null,
    data int NOT NULL DEFAULT 0,
    CONSTRAINT shdata_small CHECK(shdata < 3),
    CHECK(data < 10)
);
RESULT:
	[]

-----------
QUERY:


-- remapping in both direction
CREATE TABLE errtst_child_reorder (
    data int NOT NULL DEFAULT 0,
    shdata int not null,
    partid int not null,
    CONSTRAINT shdata_small CHECK(shdata < 3),
    CHECK(data < 10)
);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE errtst_child_fastdef ADD COLUMN data int NOT NULL DEFAULT 0;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE errtst_child_fastdef ADD CONSTRAINT errtest_child_fastdef_data_check CHECK (data < 10);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE errtst_parent ATTACH PARTITION errtst_child_fastdef FOR VALUES FROM (0) TO (10);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE errtst_parent ATTACH PARTITION errtst_child_plaindef FOR VALUES FROM (10) TO (20);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE errtst_parent ATTACH PARTITION errtst_child_reorder FOR VALUES FROM (20) TO (30);
RESULT:
	[]

-----------
QUERY:


-- insert without child check constraint error
INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '1', '5');
RESULT:
	[]

-----------
QUERY:

INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '1', '5');
RESULT:
	[]

-----------
QUERY:

INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '1', '5');
RESULT:
	[]

-----------
QUERY:


-- insert with child check constraint error
INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '1', '10');
RESULT:
	ERROR - new row for relation "errtst_child_fastdef" violates check constraint "errtest_child_fastdef_data_check"
DETAIL:  Failing row contains (0, 1, 10).


-----------
QUERY:

INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '1', '10');
RESULT:
	ERROR - new row for relation "errtst_child_plaindef" violates check constraint "errtst_child_plaindef_data_check"
DETAIL:  Failing row contains (10, 1, 10).


-----------
QUERY:

INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '1', '10');
RESULT:
	ERROR - new row for relation "errtst_child_reorder" violates check constraint "errtst_child_reorder_data_check"
DETAIL:  Failing row contains (20, 1, 10).


-----------
QUERY:


-- insert with child not null constraint error
INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '1', NULL);
RESULT:
	ERROR - null value in column "data" of relation "errtst_child_fastdef" violates not-null constraint
DETAIL:  Failing row contains (0, 1, null).


-----------
QUERY:

INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '1', NULL);
RESULT:
	ERROR - null value in column "data" of relation "errtst_child_plaindef" violates not-null constraint
DETAIL:  Failing row contains (10, 1, null).


-----------
QUERY:

INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '1', NULL);
RESULT:
	ERROR - null value in column "data" of relation "errtst_child_reorder" violates not-null constraint
DETAIL:  Failing row contains (20, 1, null).


-----------
QUERY:


-- insert with shared check constraint error
INSERT INTO errtst_parent(partid, shdata, data) VALUES ( '0', '5', '5');
RESULT:
	ERROR - new row for relation "errtst_child_fastdef" violates check constraint "shdata_small"
DETAIL:  Failing row contains (0, 5, 5).


-----------
QUERY:

INSERT INTO errtst_parent(partid, shdata, data) VALUES ('10', '5', '5');
RESULT:
	ERROR - new row for relation "errtst_child_plaindef" violates check constraint "shdata_small"
DETAIL:  Failing row contains (10, 5, 5).


-----------
QUERY:

INSERT INTO errtst_parent(partid, shdata, data) VALUES ('20', '5', '5');
RESULT:
	ERROR - new row for relation "errtst_child_reorder" violates check constraint "shdata_small"
DETAIL:  Failing row contains (20, 5, 5).


-----------
QUERY:


-- within partition update without child check constraint violation
BEGIN;
RESULT:
	[]

-----------
QUERY:

UPDATE errtst_parent SET data = data + 1 WHERE partid = 0;
RESULT:
	[]

-----------
QUERY:

UPDATE errtst_parent SET data = data + 1 WHERE partid = 10;
RESULT:
	[]

-----------
QUERY:

UPDATE errtst_parent SET data = data + 1 WHERE partid = 20;
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- within partition update with child check constraint violation
UPDATE errtst_parent SET data = data + 10 WHERE partid = 0;
RESULT:
	ERROR - new row for relation "errtst_child_fastdef" violates check constraint "errtest_child_fastdef_data_check"
DETAIL:  Failing row contains (0, 1, 15).


-----------
QUERY:

UPDATE errtst_parent SET data = data + 10 WHERE partid = 10;
RESULT:
	ERROR - new row for relation "errtst_child_plaindef" violates check constraint "errtst_child_plaindef_data_check"
DETAIL:  Failing row contains (10, 1, 15).


-----------
QUERY:

UPDATE errtst_parent SET data = data + 10 WHERE partid = 20;
RESULT:
	ERROR - new row for relation "errtst_child_reorder" violates check constraint "errtst_child_reorder_data_check"
DETAIL:  Failing row contains (20, 1, 15).


-----------
QUERY:


-- direct leaf partition update, without partition id violation
BEGIN;
RESULT:
	[]

-----------
QUERY:

UPDATE errtst_child_fastdef SET partid = 1 WHERE partid = 0;
RESULT:
	[]

-----------
QUERY:

UPDATE errtst_child_plaindef SET partid = 11 WHERE partid = 10;
RESULT:
	[]

-----------
QUERY:

UPDATE errtst_child_reorder SET partid = 21 WHERE partid = 20;
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- direct leaf partition update, with partition id violation
UPDATE errtst_child_fastdef SET partid = partid + 10 WHERE partid = 0;
RESULT:
	ERROR - new row for relation "errtst_child_fastdef" violates partition constraint
DETAIL:  Failing row contains (10, 1, 5).


-----------
QUERY:

UPDATE errtst_child_plaindef SET partid = partid + 10 WHERE partid = 10;
RESULT:
	ERROR - new row for relation "errtst_child_plaindef" violates partition constraint
DETAIL:  Failing row contains (20, 1, 5).


-----------
QUERY:

UPDATE errtst_child_reorder SET partid = partid + 10 WHERE partid = 20;
RESULT:
	ERROR - new row for relation "errtst_child_reorder" violates partition constraint
DETAIL:  Failing row contains (5, 1, 30).


-----------
QUERY:


-- partition move, without child check constraint violation
BEGIN;
RESULT:
	[]

-----------
QUERY:

UPDATE errtst_parent SET partid = 10, data = data + 1 WHERE partid = 0;
RESULT:
	[]

-----------
QUERY:

UPDATE errtst_parent SET partid = 20, data = data + 1 WHERE partid = 10;
RESULT:
	[]

-----------
QUERY:

UPDATE errtst_parent SET partid = 0, data = data + 1 WHERE partid = 20;
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- partition move, with child check constraint violation
UPDATE errtst_parent SET partid = 10, data = data + 10 WHERE partid = 0;
RESULT:
	ERROR - new row for relation "errtst_child_plaindef" violates check constraint "errtst_child_plaindef_data_check"
DETAIL:  Failing row contains (10, 1, 15).


-----------
QUERY:

UPDATE errtst_parent SET partid = 20, data = data + 10 WHERE partid = 10;
RESULT:
	ERROR - new row for relation "errtst_child_reorder" violates check constraint "errtst_child_reorder_data_check"
DETAIL:  Failing row contains (20, 1, 15).


-----------
QUERY:

UPDATE errtst_parent SET partid = 0, data = data + 10 WHERE partid = 20;
RESULT:
	ERROR - new row for relation "errtst_child_fastdef" violates check constraint "errtest_child_fastdef_data_check"
DETAIL:  Failing row contains (0, 1, 15).


-----------
QUERY:


-- partition move, without target partition
UPDATE errtst_parent SET partid = 30, data = data + 10 WHERE partid = 20;
RESULT:
	ERROR - no partition of relation "errtst_parent" found for row
DETAIL:  Partition key of the failing row contains (partid) = (30).


-----------
QUERY:


DROP TABLE errtst_parent;
RESULT:
	[]
