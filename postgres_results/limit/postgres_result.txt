
-----------
QUERY:
--
-- LIMIT
-- Check the LIMIT/OFFSET feature of SELECT
--

SELECT ''::text AS two, unique1, unique2, stringu1
		FROM onek WHERE unique1 > 50
		ORDER BY unique1 LIMIT 2;
RESULT:
	[('', 51, 76, 'ZBAAAA'), ('', 52, 985, 'ACAAAA')]

-----------
QUERY:

SELECT ''::text AS five, unique1, unique2, stringu1
		FROM onek WHERE unique1 > 60
		ORDER BY unique1 LIMIT 5;
RESULT:
	[('', 61, 560, 'JCAAAA'), ('', 62, 633, 'KCAAAA'), ('', 63, 296, 'LCAAAA'), ('', 64, 479, 'MCAAAA'), ('', 65, 64, 'NCAAAA')]

-----------
QUERY:

SELECT ''::text AS two, unique1, unique2, stringu1
		FROM onek WHERE unique1 > 60 AND unique1 < 63
		ORDER BY unique1 LIMIT 5;
RESULT:
	[('', 61, 560, 'JCAAAA'), ('', 62, 633, 'KCAAAA')]

-----------
QUERY:

SELECT ''::text AS three, unique1, unique2, stringu1
		FROM onek WHERE unique1 > 100
		ORDER BY unique1 LIMIT 3 OFFSET 20;
RESULT:
	[('', 121, 700, 'REAAAA'), ('', 122, 519, 'SEAAAA'), ('', 123, 777, 'TEAAAA')]

-----------
QUERY:

SELECT ''::text AS zero, unique1, unique2, stringu1
		FROM onek WHERE unique1 < 50
		ORDER BY unique1 DESC LIMIT 8 OFFSET 99;
RESULT:
	[]

-----------
QUERY:

SELECT ''::text AS eleven, unique1, unique2, stringu1
		FROM onek WHERE unique1 < 50
		ORDER BY unique1 DESC LIMIT 20 OFFSET 39;
RESULT:
	[('', 10, 520, 'KAAAAA'), ('', 9, 49, 'JAAAAA'), ('', 8, 653, 'IAAAAA'), ('', 7, 647, 'HAAAAA'), ('', 6, 978, 'GAAAAA'), ('', 5, 541, 'FAAAAA'), ('', 4, 833, 'EAAAAA'), ('', 3, 431, 'DAAAAA'), ('', 2, 326, 'CAAAAA'), ('', 1, 214, 'BAAAAA'), ('', 0, 998, 'AAAAAA')]

-----------
QUERY:

SELECT ''::text AS ten, unique1, unique2, stringu1
		FROM onek
		ORDER BY unique1 OFFSET 990;
RESULT:
	[('', 990, 369, 'CMAAAA'), ('', 991, 426, 'DMAAAA'), ('', 992, 363, 'EMAAAA'), ('', 993, 661, 'FMAAAA'), ('', 994, 695, 'GMAAAA'), ('', 995, 144, 'HMAAAA'), ('', 996, 258, 'IMAAAA'), ('', 997, 21, 'JMAAAA'), ('', 998, 549, 'KMAAAA'), ('', 999, 152, 'LMAAAA')]

-----------
QUERY:

SELECT ''::text AS five, unique1, unique2, stringu1
		FROM onek
		ORDER BY unique1 OFFSET 990 LIMIT 5;
RESULT:
	[('', 990, 369, 'CMAAAA'), ('', 991, 426, 'DMAAAA'), ('', 992, 363, 'EMAAAA'), ('', 993, 661, 'FMAAAA'), ('', 994, 695, 'GMAAAA')]

-----------
QUERY:

SELECT ''::text AS five, unique1, unique2, stringu1
		FROM onek
		ORDER BY unique1 LIMIT 5 OFFSET 900;
RESULT:
	[('', 900, 913, 'QIAAAA'), ('', 901, 931, 'RIAAAA'), ('', 902, 702, 'SIAAAA'), ('', 903, 641, 'TIAAAA'), ('', 904, 793, 'UIAAAA')]

-----------
QUERY:


-- Test null limit and offset.  The planner would discard a simple null
-- constant, so to ensure executor is exercised, do this:
select * from int8_tbl limit (case when random() < 0.5 then null::bigint end);
RESULT:
	[(123, 456), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789)]

-----------
QUERY:

select * from int8_tbl offset (case when random() < 0.5 then null::bigint end);
RESULT:
	[(123, 456), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789)]

-----------
QUERY:


-- Test assorted cases involving backwards fetch from a LIMIT plan node
begin;
RESULT:
	[]

-----------
QUERY:


declare c1 cursor for select * from int8_tbl limit 10;
RESULT:
	[]

-----------
QUERY:

fetch all in c1;
RESULT:
	[(123, 456), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789)]

-----------
QUERY:

fetch 1 in c1;
RESULT:
	[]

-----------
QUERY:

fetch backward 1 in c1;
RESULT:
	[(4567890123456789, -4567890123456789)]

-----------
QUERY:

fetch backward all in c1;
RESULT:
	[(4567890123456789, 4567890123456789), (4567890123456789, 123), (123, 4567890123456789), (123, 456)]

-----------
QUERY:

fetch backward 1 in c1;
RESULT:
	[]

-----------
QUERY:

fetch all in c1;
RESULT:
	[(123, 456), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789)]

-----------
QUERY:


declare c2 cursor for select * from int8_tbl limit 3;
RESULT:
	[]

-----------
QUERY:

fetch all in c2;
RESULT:
	[(123, 456), (123, 4567890123456789), (4567890123456789, 123)]

-----------
QUERY:

fetch 1 in c2;
RESULT:
	[]

-----------
QUERY:

fetch backward 1 in c2;
RESULT:
	[(4567890123456789, 123)]

-----------
QUERY:

fetch backward all in c2;
RESULT:
	[(123, 4567890123456789), (123, 456)]

-----------
QUERY:

fetch backward 1 in c2;
RESULT:
	[]

-----------
QUERY:

fetch all in c2;
RESULT:
	[(123, 456), (123, 4567890123456789), (4567890123456789, 123)]

-----------
QUERY:


declare c3 cursor for select * from int8_tbl offset 3;
RESULT:
	[]

-----------
QUERY:

fetch all in c3;
RESULT:
	[(4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789)]

-----------
QUERY:

fetch 1 in c3;
RESULT:
	[]

-----------
QUERY:

fetch backward 1 in c3;
RESULT:
	[(4567890123456789, -4567890123456789)]

-----------
QUERY:

fetch backward all in c3;
RESULT:
	[(4567890123456789, 4567890123456789)]

-----------
QUERY:

fetch backward 1 in c3;
RESULT:
	[]

-----------
QUERY:

fetch all in c3;
RESULT:
	[(4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789)]

-----------
QUERY:


declare c4 cursor for select * from int8_tbl offset 10;
RESULT:
	[]

-----------
QUERY:

fetch all in c4;
RESULT:
	[]

-----------
QUERY:

fetch 1 in c4;
RESULT:
	[]

-----------
QUERY:

fetch backward 1 in c4;
RESULT:
	[]

-----------
QUERY:

fetch backward all in c4;
RESULT:
	[]

-----------
QUERY:

fetch backward 1 in c4;
RESULT:
	[]

-----------
QUERY:

fetch all in c4;
RESULT:
	[]

-----------
QUERY:


declare c5 cursor for select * from int8_tbl order by q1 fetch first 2 rows with ties;
RESULT:
	[]

-----------
QUERY:

fetch all in c5;
RESULT:
	[(123, 456), (123, 4567890123456789)]

-----------
QUERY:

fetch 1 in c5;
RESULT:
	[]

-----------
QUERY:

fetch backward 1 in c5;
RESULT:
	[(123, 4567890123456789)]

-----------
QUERY:

fetch backward 1 in c5;
RESULT:
	[(123, 456)]

-----------
QUERY:

fetch all in c5;
RESULT:
	[(123, 4567890123456789)]

-----------
QUERY:

fetch backward all in c5;
RESULT:
	[(123, 4567890123456789), (123, 456)]

-----------
QUERY:

fetch all in c5;
RESULT:
	[(123, 456), (123, 4567890123456789)]

-----------
QUERY:

fetch backward all in c5;
RESULT:
	[(123, 4567890123456789), (123, 456)]

-----------
QUERY:


rollback;
RESULT:
	[]

-----------
QUERY:


-- Stress test for variable LIMIT in conjunction with bounded-heap sorting

SELECT
  (SELECT n
     FROM (VALUES (1)) AS x,
          (SELECT n FROM generate_series(1,10) AS n
             ORDER BY n LIMIT 1 OFFSET s-1) AS y) AS z
  FROM generate_series(1,10) AS s;
RESULT:
	[(1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,), (10,)]

-----------
QUERY:


--
-- Test behavior of volatile and set-returning functions in conjunction
-- with ORDER BY and LIMIT.
--

create temp sequence testseq;
RESULT:
	[]

-----------
QUERY:


explain (verbose, costs off)
select unique1, unique2, nextval('testseq')
  from tenk1 order by unique2 limit 10;
RESULT:
	[('Limit',), ("  Output: unique1, unique2, (nextval('testseq'::regclass))",), ('  ->  Index Scan using tenk1_unique2 on public.tenk1',), ("        Output: unique1, unique2, nextval('testseq'::regclass)",)]

-----------
QUERY:


select unique1, unique2, nextval('testseq')
  from tenk1 order by unique2 limit 10;
RESULT:
	[(8800, 0, 1), (1891, 1, 2), (3420, 2, 3), (9850, 3, 4), (7164, 4, 5), (8009, 5, 6), (5057, 6, 7), (6701, 7, 8), (4321, 8, 9), (3043, 9, 10)]

-----------
QUERY:


select currval('testseq');
RESULT:
	[(10,)]

-----------
QUERY:


explain (verbose, costs off)
select unique1, unique2, nextval('testseq')
  from tenk1 order by tenthous limit 10;
RESULT:
	[('Limit',), ("  Output: unique1, unique2, (nextval('testseq'::regclass)), tenthous",), ('  ->  Result',), ("        Output: unique1, unique2, nextval('testseq'::regclass), tenthous",), ('        ->  Sort',), ('              Output: unique1, unique2, tenthous',), ('              Sort Key: tenk1.tenthous',), ('              ->  Seq Scan on public.tenk1',), ('                    Output: unique1, unique2, tenthous',)]

-----------
QUERY:


select unique1, unique2, nextval('testseq')
  from tenk1 order by tenthous limit 10;
RESULT:
	[(0, 9998, 11), (1, 2838, 12), (2, 2716, 13), (3, 5679, 14), (4, 1621, 15), (5, 5557, 16), (6, 2855, 17), (7, 8518, 18), (8, 5435, 19), (9, 4463, 20)]

-----------
QUERY:


select currval('testseq');
RESULT:
	[(20,)]

-----------
QUERY:


explain (verbose, costs off)
select unique1, unique2, generate_series(1,10)
  from tenk1 order by unique2 limit 7;
RESULT:
	[('Limit',), ('  Output: unique1, unique2, (generate_series(1, 10))',), ('  ->  ProjectSet',), ('        Output: unique1, unique2, generate_series(1, 10)',), ('        ->  Index Scan using tenk1_unique2 on public.tenk1',), ('              Output: unique1, unique2, two, four, ten, twenty, hundred, thousand, twothousand, fivethous, tenthous, odd, even, stringu1, stringu2, string4',)]

-----------
QUERY:


select unique1, unique2, generate_series(1,10)
  from tenk1 order by unique2 limit 7;
RESULT:
	[(8800, 0, 1), (8800, 0, 2), (8800, 0, 3), (8800, 0, 4), (8800, 0, 5), (8800, 0, 6), (8800, 0, 7)]

-----------
QUERY:


explain (verbose, costs off)
select unique1, unique2, generate_series(1,10)
  from tenk1 order by tenthous limit 7;
RESULT:
	[('Limit',), ('  Output: unique1, unique2, (generate_series(1, 10)), tenthous',), ('  ->  ProjectSet',), ('        Output: unique1, unique2, generate_series(1, 10), tenthous',), ('        ->  Sort',), ('              Output: unique1, unique2, tenthous',), ('              Sort Key: tenk1.tenthous',), ('              ->  Seq Scan on public.tenk1',), ('                    Output: unique1, unique2, tenthous',)]

-----------
QUERY:


select unique1, unique2, generate_series(1,10)
  from tenk1 order by tenthous limit 7;
RESULT:
	[(0, 9998, 1), (0, 9998, 2), (0, 9998, 3), (0, 9998, 4), (0, 9998, 5), (0, 9998, 6), (0, 9998, 7)]

-----------
QUERY:


-- use of random() is to keep planner from folding the expressions together
explain (verbose, costs off)
select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;
RESULT:
	[('ProjectSet',), ("  Output: generate_series(0, 2), generate_series(((random() * '0.1'::double precision))::integer, 2)",), ('  ->  Result',)]

-----------
QUERY:


select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2;
RESULT:
	[(0, 0), (1, 1), (2, 2)]

-----------
QUERY:


explain (verbose, costs off)
select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2
order by s2 desc;
RESULT:
	[('Sort',), ("  Output: (generate_series(0, 2)), (generate_series(((random() * '0.1'::double precision))::integer, 2))",), ("  Sort Key: (generate_series(((random() * '0.1'::double precision))::integer, 2)) DESC",), ('  ->  ProjectSet',), ("        Output: generate_series(0, 2), generate_series(((random() * '0.1'::double precision))::integer, 2)",), ('        ->  Result',)]

-----------
QUERY:


select generate_series(0,2) as s1, generate_series((random()*.1)::int,2) as s2
order by s2 desc;
RESULT:
	[(2, 2), (1, 1), (0, 0)]

-----------
QUERY:


-- test for failure to set all aggregates/* REPLACED */'' aggtranstype
explain (verbose, costs off)
select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2
  from tenk1 group by thousand order by thousand limit 3;
RESULT:
	[('Limit',), ("  Output: (sum(tenthous)), (((sum(tenthous))::double precision + (random() * '0'::double precision))), thousand",), ('  ->  GroupAggregate',), ("        Output: sum(tenthous), ((sum(tenthous))::double precision + (random() * '0'::double precision)), thousand",), ('        Group Key: tenk1.thousand',), ('        ->  Index Only Scan using tenk1_thous_tenthous on public.tenk1',), ('              Output: thousand, tenthous',)]

-----------
QUERY:


select sum(tenthous) as s1, sum(tenthous) + random()*0 as s2
  from tenk1 group by thousand order by thousand limit 3;
RESULT:
	[(45000, 45000.0), (45010, 45010.0), (45020, 45020.0)]

-----------
QUERY:


--
-- FETCH FIRST
-- Check the WITH TIES clause
--

SELECT  thousand
		FROM onek WHERE thousand < 5
		ORDER BY thousand FETCH FIRST 2 ROW WITH TIES;
RESULT:
	[(0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,)]

-----------
QUERY:


SELECT  thousand
		FROM onek WHERE thousand < 5
		ORDER BY thousand FETCH FIRST ROWS WITH TIES;
RESULT:
	[(0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,)]

-----------
QUERY:


SELECT  thousand
		FROM onek WHERE thousand < 5
		ORDER BY thousand FETCH FIRST 1 ROW WITH TIES;
RESULT:
	[(0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,), (0,)]

-----------
QUERY:


SELECT  thousand
		FROM onek WHERE thousand < 5
		ORDER BY thousand FETCH FIRST 2 ROW ONLY;
RESULT:
	[(0,), (0,)]

-----------
QUERY:


-- SKIP LOCKED and WITH TIES are incompatible
SELECT  thousand
		FROM onek WHERE thousand < 5
		ORDER BY thousand FETCH FIRST 1 ROW WITH TIES FOR UPDATE SKIP LOCKED;
RESULT:
	ERROR - SKIP LOCKED and WITH TIES options cannot be used together


-----------
QUERY:


-- should fail
SELECT ''::text AS two, unique1, unique2, stringu1
		FROM onek WHERE unique1 > 50
		FETCH FIRST 2 ROW WITH TIES;
RESULT:
	ERROR - WITH TIES cannot be specified without ORDER BY clause


-----------
QUERY:


-- test ruleutils
CREATE VIEW limit_thousand_v_1 AS SELECT thousand FROM onek WHERE thousand < 995
		ORDER BY thousand FETCH FIRST 5 ROWS WITH TIES OFFSET 10;
RESULT:
	[]

-----------
QUERY:

-- \d+ limit_thousand_v_1
CREATE VIEW limit_thousand_v_2 AS SELECT thousand FROM onek WHERE thousand < 995
		ORDER BY thousand OFFSET 10 FETCH FIRST 5 ROWS ONLY;
RESULT:
	[]

-----------
QUERY:

-- \d+ limit_thousand_v_2
CREATE VIEW limit_thousand_v_3 AS SELECT thousand FROM onek WHERE thousand < 995
		ORDER BY thousand FETCH FIRST NULL ROWS WITH TIES;
RESULT:
	ERROR - row count cannot be null in FETCH FIRST ... WITH TIES clause


-----------
QUERY:
		-- fails
CREATE VIEW limit_thousand_v_3 AS SELECT thousand FROM onek WHERE thousand < 995
		ORDER BY thousand FETCH FIRST (NULL+1) ROWS WITH TIES;
RESULT:
	[]

-----------
QUERY:

-- \d+ limit_thousand_v_3
CREATE VIEW limit_thousand_v_4 AS SELECT thousand FROM onek WHERE thousand < 995
		ORDER BY thousand FETCH FIRST NULL ROWS ONLY;
RESULT:
	[]

-----------
QUERY:

-- \d+ limit_thousand_v_4
-- leave these views

RESULT:
	ERROR - can't execute an empty query
