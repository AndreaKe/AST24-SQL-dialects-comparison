
-----------
QUERY:
--
-- MERGE
--

CREATE USER regress_merge_privs;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_merge_no_privs;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_merge_none;
RESULT:
	[]

-----------
QUERY:


DROP TABLE IF EXISTS target;
RESULT:
	[]

-----------
QUERY:

DROP TABLE IF EXISTS source;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE target (tid integer, balance integer)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE source (sid integer, delta integer) -- no index
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

INSERT INTO target VALUES (1, 10);
RESULT:
	[]

-----------
QUERY:

INSERT INTO target VALUES (2, 20);
RESULT:
	[]

-----------
QUERY:

INSERT INTO target VALUES (3, 30);
RESULT:
	[]

-----------
QUERY:

SELECT t.ctid is not null as matched, t.*, s.* FROM source s FULL OUTER JOIN target t ON s.sid = t.tid ORDER BY t.tid, s.sid;
RESULT:
	[(True, 1, 10, None, None), (True, 2, 20, None, None), (True, 3, 30, None, None)]

-----------
QUERY:


ALTER TABLE target OWNER TO regress_merge_privs;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE source OWNER TO regress_merge_privs;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE target2 (tid integer, balance integer)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE source2 (sid integer, delta integer)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE target2 OWNER TO regress_merge_no_privs;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE source2 OWNER TO regress_merge_no_privs;
RESULT:
	[]

-----------
QUERY:


GRANT INSERT ON target TO regress_merge_no_privs;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_merge_privs;
RESULT:
	[]

-----------
QUERY:


EXPLAIN (COSTS OFF)
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE;
RESULT:
	[('Merge on target t',), ('  ->  Merge Join',), ('        Merge Cond: (t.tid = s.sid)',), ('        ->  Sort',), ('              Sort Key: t.tid',), ('              ->  Seq Scan on target t',), ('        ->  Sort',), ('              Sort Key: s.sid',), ('              ->  Seq Scan on source s',)]

-----------
QUERY:


--
-- Errors
--
MERGE INTO target t RANDOMWORD
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	ERROR - syntax error at or near "RANDOMWORD"
LINE 6: MERGE INTO target t RANDOMWORD
                            ^


-----------
QUERY:

-- MATCHED/INSERT error
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	INSERT DEFAULT VALUES;
RESULT:
	ERROR - syntax error at or near "INSERT"
LINE 7:  INSERT DEFAULT VALUES;
         ^


-----------
QUERY:

-- incorrectly specifying INTO target
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT INTO target DEFAULT VALUES;
RESULT:
	ERROR - syntax error at or near "INTO"
LINE 7:  INSERT INTO target DEFAULT VALUES;
                ^


-----------
QUERY:

-- Multiple VALUES clause
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT VALUES (1,1), (2,2);
RESULT:
	ERROR - syntax error at or near ","
LINE 7:  INSERT VALUES (1,1), (2,2);
                            ^


-----------
QUERY:

-- SELECT query for INSERT
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT SELECT (1, 1);
RESULT:
	ERROR - syntax error at or near "SELECT"
LINE 7:  INSERT SELECT (1, 1);
                ^


-----------
QUERY:

-- NOT MATCHED/UPDATE
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	ERROR - syntax error at or near "UPDATE"
LINE 7:  UPDATE SET balance = 0;
         ^


-----------
QUERY:

-- UPDATE tablename
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE target SET balance = 0;
RESULT:
	ERROR - syntax error at or near "target"
LINE 7:  UPDATE target SET balance = 0;
                ^


-----------
QUERY:

-- source and target names the same
MERGE INTO target
USING target
ON tid = tid
WHEN MATCHED THEN DO NOTHING;
RESULT:
	ERROR - name "target" specified more than once
DETAIL:  The name is used both as MERGE target table and data source.


-----------
QUERY:

-- used in a CTE without RETURNING
WITH foo AS (
  MERGE INTO target USING source ON (true)
  WHEN MATCHED THEN DELETE
) SELECT * FROM foo;
RESULT:
	ERROR - WITH query "foo" does not have a RETURNING clause
LINE 6: ) SELECT * FROM foo;
                        ^


-----------
QUERY:

-- used in COPY without RETURNING
COPY (
  MERGE INTO target USING source ON (true)
  WHEN MATCHED THEN DELETE
) TO stdout;
RESULT:
	ERROR - COPY query must have a RETURNING clause


-----------
QUERY:


-- unsupported relation types
-- materialized view
CREATE MATERIALIZED VIEW mv AS SELECT * FROM target;
RESULT:
	[]

-----------
QUERY:

MERGE INTO mv t
USING source s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT DEFAULT VALUES;
RESULT:
	ERROR - cannot execute MERGE on relation "mv"
DETAIL:  This operation is not supported for materialized views.


-----------
QUERY:

DROP MATERIALIZED VIEW mv;
RESULT:
	[]

-----------
QUERY:


-- permissions

SET SESSION AUTHORIZATION regress_merge_none;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target
USING (SELECT 1)
ON true
WHEN MATCHED THEN
	DO NOTHING;
RESULT:
	ERROR - permission denied for table target


-----------
QUERY:


SET SESSION AUTHORIZATION regress_merge_privs;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target
USING source2
ON target.tid = source2.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	ERROR - permission denied for table source2


-----------
QUERY:


GRANT INSERT ON target TO regress_merge_no_privs;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_merge_no_privs;
RESULT:
	[]

-----------
QUERY:


MERGE INTO target
USING source2
ON target.tid = source2.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	ERROR - permission denied for table target


-----------
QUERY:


GRANT UPDATE ON target2 TO regress_merge_privs;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_merge_privs;
RESULT:
	[]

-----------
QUERY:


MERGE INTO target2
USING source
ON target2.tid = source.sid
WHEN MATCHED THEN
	DELETE;
RESULT:
	ERROR - permission denied for table target2


-----------
QUERY:


MERGE INTO target2
USING source
ON target2.tid = source.sid
WHEN NOT MATCHED THEN
	INSERT DEFAULT VALUES;
RESULT:
	ERROR - permission denied for table target2


-----------
QUERY:


-- check if the target can be accessed from source relation subquery /* REPLACED */, we should
-- not be able to do so
MERGE INTO target t
USING (SELECT * FROM source WHERE t.tid > sid) s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT DEFAULT VALUES;
RESULT:
	ERROR - invalid reference to FROM-clause entry for table "t"
LINE 6: USING (SELECT * FROM source WHERE t.tid > sid) s
                                          ^
DETAIL:  There is an entry for table "t", but it cannot be referenced from this part of the query.


-----------
QUERY:


--
-- initial tests
--
-- zero rows in source has no effect
MERGE INTO target
USING source
ON target.tid = source.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	[]

-----------
QUERY:


MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT DEFAULT VALUES;
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- insert some non-matching source rows to work from
INSERT INTO source VALUES (4, 40);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM source ORDER BY sid;
RESULT:
	[(4, 40)]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30)]

-----------
QUERY:


MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	DO NOTHING;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT DEFAULT VALUES;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30), (None, None)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- index plans
INSERT INTO target SELECT generate_series(1000,2500), 0;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE target ADD PRIMARY KEY (tid);
RESULT:
	[]

-----------
QUERY:

ANALYZE target;
RESULT:
	[]

-----------
QUERY:


EXPLAIN (COSTS OFF)
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	[('Merge on target t',), ('  ->  Hash Join',), ('        Hash Cond: (s.sid = t.tid)',), ('        ->  Seq Scan on source s',), ('        ->  Hash',), ('              ->  Seq Scan on target t',)]

-----------
QUERY:

EXPLAIN (COSTS OFF)
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE;
RESULT:
	[('Merge on target t',), ('  ->  Hash Join',), ('        Hash Cond: (s.sid = t.tid)',), ('        ->  Seq Scan on source s',), ('        ->  Hash',), ('              ->  Seq Scan on target t',)]

-----------
QUERY:

EXPLAIN (COSTS OFF)
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT VALUES (4, NULL);
RESULT:
	[('Merge on target t',), ('  ->  Hash Left Join',), ('        Hash Cond: (s.sid = t.tid)',), ('        ->  Seq Scan on source s',), ('        ->  Hash',), ('              ->  Seq Scan on target t',)]

-----------
QUERY:

DELETE FROM target WHERE tid > 100;
RESULT:
	[]

-----------
QUERY:

ANALYZE target;
RESULT:
	[]

-----------
QUERY:


-- insert some matching source rows to work from
INSERT INTO source VALUES (2, 5);
RESULT:
	[]

-----------
QUERY:

INSERT INTO source VALUES (3, 20);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM source ORDER BY sid;
RESULT:
	[(2, 5), (3, 20), (4, 40)]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30)]

-----------
QUERY:


-- equivalent of an UPDATE join
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 0), (3, 0)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- equivalent of a DELETE join
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DO NOTHING;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT VALUES (4, NULL);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30), (4, None)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- duplicate source row causes multiple target row update ERROR
INSERT INTO source VALUES (2, 5);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM source ORDER BY sid;
RESULT:
	[(2, 5), (2, 5), (3, 20), (4, 40)]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30)]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	ERROR - MERGE command cannot affect row a second time
HINT:  Ensure that not more than one source row matches any one target row.


-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	DELETE;
RESULT:
	ERROR - MERGE command cannot affect row a second time
HINT:  Ensure that not more than one source row matches any one target row.


-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- remove duplicate MATCHED data from source data
DELETE FROM source WHERE sid = 2;
RESULT:
	[]

-----------
QUERY:

INSERT INTO source VALUES (2, 5);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM source ORDER BY sid;
RESULT:
	[(2, 5), (3, 20), (4, 40)]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30)]

-----------
QUERY:


-- duplicate source row on INSERT should fail because of target_pkey
INSERT INTO source VALUES (4, 40);
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
  INSERT VALUES (4, NULL);
RESULT:
	ERROR - duplicate key value violates unique constraint "target_pkey"
DETAIL:  Key (tid)=(4) already exists.


-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- remove duplicate NOT MATCHED data from source data
DELETE FROM source WHERE sid = 4;
RESULT:
	[]

-----------
QUERY:

INSERT INTO source VALUES (4, 40);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM source ORDER BY sid;
RESULT:
	[(2, 5), (3, 20), (4, 40)]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30)]

-----------
QUERY:


-- remove constraints
alter table target drop CONSTRAINT target_pkey;
RESULT:
	[]

-----------
QUERY:

alter table target alter column tid drop not null;
RESULT:
	[]

-----------
QUERY:


-- multiple actions
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT VALUES (4, 4)
WHEN MATCHED THEN
	UPDATE SET balance = 0;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 0), (3, 0), (4, 4)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- should be equivalent
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = 0
WHEN NOT MATCHED THEN
	INSERT VALUES (4, 4);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 0), (3, 0), (4, 4)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- column references
-- do a simple equivalent of an UPDATE join
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = t.balance + s.delta;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 25), (3, 50)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- do a simple equivalent of an INSERT SELECT
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT VALUES (s.sid, s.delta);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30), (4, 40)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- and again with duplicate source rows
INSERT INTO source VALUES (5, 50);
RESULT:
	[]

-----------
QUERY:

INSERT INTO source VALUES (5, 50);
RESULT:
	[]

-----------
QUERY:


-- do a simple equivalent of an INSERT SELECT
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
  INSERT VALUES (s.sid, s.delta);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30), (4, 40), (5, 50), (5, 50)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- removing duplicate source rows
DELETE FROM source WHERE sid = 5;
RESULT:
	[]

-----------
QUERY:


-- and again with explicitly identified column list
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.delta);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30), (4, 40)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- and again with a subtle error: referring to non-existent target row for NOT MATCHED
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (t.tid, s.delta);
RESULT:
	ERROR - invalid reference to FROM-clause entry for table "t"
LINE 8:  INSERT (tid, balance) VALUES (t.tid, s.delta);
                                       ^
DETAIL:  There is an entry for table "t", but it cannot be referenced from this part of the query.


-----------
QUERY:


-- and again with a constant ON clause
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON (SELECT true)
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (t.tid, s.delta);
RESULT:
	ERROR - invalid reference to FROM-clause entry for table "t"
LINE 6:  INSERT (tid, balance) VALUES (t.tid, s.delta);
                                       ^
DETAIL:  There is an entry for table "t", but it cannot be referenced from this part of the query.


-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- now the classic UPSERT
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = t.balance + s.delta
WHEN NOT MATCHED THEN
	INSERT VALUES (s.sid, s.delta);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 25), (3, 50), (4, 40)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- unreachable WHEN clause should ERROR
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED THEN /* Terminal WHEN clause for MATCHED */
	DELETE
WHEN MATCHED THEN
	UPDATE SET balance = t.balance - s.delta;
RESULT:
	ERROR - unreachable WHEN clause specified after unconditional WHEN clause


-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- conditional WHEN clause
CREATE TABLE wq_target (tid integer not null, balance integer DEFAULT -1)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE wq_source (balance integer, sid integer)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:


INSERT INTO wq_source (sid, balance) VALUES (1, 100);
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

-- try a simple INSERT with default values first
MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid) VALUES (s.sid);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, -1)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- this time with a FALSE condition
MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN NOT MATCHED AND FALSE THEN
	INSERT (tid) VALUES (s.sid);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[]

-----------
QUERY:


-- this time with an actual condition which returns false
MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN NOT MATCHED AND s.balance <> 100 THEN
	INSERT (tid) VALUES (s.sid);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

-- and now with a condition which returns true
MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN NOT MATCHED AND s.balance = 100 THEN
	INSERT (tid) VALUES (s.sid);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, -1)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- conditions in the NOT MATCHED clause can only refer to source columns
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN NOT MATCHED AND t.balance = 100 THEN
	INSERT (tid) VALUES (s.sid);
RESULT:
	ERROR - invalid reference to FROM-clause entry for table "t"
LINE 4: WHEN NOT MATCHED AND t.balance = 100 THEN
                             ^
DETAIL:  There is an entry for table "t", but it cannot be referenced from this part of the query.


-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN NOT MATCHED AND s.balance = 100 THEN
	INSERT (tid) VALUES (s.sid);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, -1)]

-----------
QUERY:


-- conditions in MATCHED clause can refer to both source and target
SELECT * FROM wq_source;
RESULT:
	[(100, 1)]

-----------
QUERY:

MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN MATCHED AND s.balance = 100 THEN
	UPDATE SET balance = t.balance + s.balance;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, 99)]

-----------
QUERY:


MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN MATCHED AND t.balance = 100 THEN
	UPDATE SET balance = t.balance + s.balance;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, 99)]

-----------
QUERY:


-- check if AND works
MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN MATCHED AND t.balance = 99 AND s.balance > 100 THEN
	UPDATE SET balance = t.balance + s.balance;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, 99)]

-----------
QUERY:


MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN MATCHED AND t.balance = 99 AND s.balance = 100 THEN
	UPDATE SET balance = t.balance + s.balance;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, 199)]

-----------
QUERY:


-- check if OR works
MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN MATCHED AND t.balance = 99 OR s.balance > 100 THEN
	UPDATE SET balance = t.balance + s.balance;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, 199)]

-----------
QUERY:


MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN MATCHED AND t.balance = 199 OR s.balance > 100 THEN
	UPDATE SET balance = t.balance + s.balance;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, 299)]

-----------
QUERY:


-- check source-side whole-row references
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO wq_target t
USING wq_source s ON (t.tid = s.sid)
WHEN matched and t = s or t.tid = s.sid THEN
	UPDATE SET balance = t.balance + s.balance;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, 399)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- check if subqueries work in the conditions?
MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN MATCHED AND t.balance > (SELECT max(balance) FROM target) THEN
	UPDATE SET balance = t.balance + s.balance;
RESULT:
	[]

-----------
QUERY:


-- check if we can access system columns in the conditions
MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN MATCHED AND t.xmin = t.xmax THEN
	UPDATE SET balance = t.balance + s.balance;
RESULT:
	ERROR - cannot use system column "xmin" in MERGE WHEN condition
LINE 6: WHEN MATCHED AND t.xmin = t.xmax THEN
                         ^


-----------
QUERY:


MERGE INTO wq_target t
USING wq_source s ON t.tid = s.sid
WHEN MATCHED AND t.tableoid >= 0 THEN
	UPDATE SET balance = t.balance + s.balance;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM wq_target;
RESULT:
	[(1, 499)]

-----------
QUERY:


DROP TABLE wq_target, wq_source;
RESULT:
	[]

-----------
QUERY:


-- test triggers
create or replace function merge_trigfunc () returns trigger
language plpgsql as
$$
DECLARE
	line text;
BEGIN
	SELECT INTO line format('%s %s %s trigger%s',
		TG_WHEN, TG_OP, TG_LEVEL, CASE
		WHEN TG_OP = 'INSERT' AND TG_LEVEL = 'ROW'
			THEN format(' row: %s', NEW)
		WHEN TG_OP = 'UPDATE' AND TG_LEVEL = 'ROW'
			THEN format(' row: %s -> %s', OLD, NEW)
		WHEN TG_OP = 'DELETE' AND TG_LEVEL = 'ROW'
			THEN format(' row: %s', OLD)
		END);

	RAISE NOTICE '%', line;
	IF (TG_WHEN = 'BEFORE' AND TG_LEVEL = 'ROW') THEN
		IF (TG_OP = 'DELETE') THEN
			RETURN OLD;
		ELSE
			RETURN NEW;
		END IF;
	ELSE
		RETURN NULL;
	END IF;
END;
$$;
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_bsi BEFORE INSERT ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_bsu BEFORE UPDATE ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_bsd BEFORE DELETE ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_asi AFTER INSERT ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_asu AFTER UPDATE ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_asd AFTER DELETE ON target FOR EACH STATEMENT EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_bri BEFORE INSERT ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_bru BEFORE UPDATE ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_brd BEFORE DELETE ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_ari AFTER INSERT ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_aru AFTER UPDATE ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER merge_ard AFTER DELETE ON target FOR EACH ROW EXECUTE PROCEDURE merge_trigfunc ();
RESULT:
	[]

-----------
QUERY:


-- now the classic UPSERT, with a DELETE
BEGIN;
RESULT:
	[]

-----------
QUERY:

UPDATE target SET balance = 0 WHERE tid = 3;
RESULT:
	[]

-----------
QUERY:

--EXPLAIN (ANALYZE ON, COSTS OFF, SUMMARY OFF, TIMING OFF)
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED AND t.balance > s.delta THEN
	UPDATE SET balance = t.balance - s.delta
WHEN MATCHED THEN
	DELETE
WHEN NOT MATCHED THEN
	INSERT VALUES (s.sid, s.delta);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 15), (4, 40)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- Test behavior of triggers that turn UPDATE/DELETE into no-ops
create or replace function skip_merge_op() returns trigger
language plpgsql as
$$
BEGIN
	RETURN NULL;
END;
$$;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM target full outer join source on (sid = tid);
RESULT:
	[(3, 30, 3, 20), (2, 20, 2, 5), (None, None, 4, 40), (1, 10, None, None)]

-----------
QUERY:

create trigger merge_skip BEFORE INSERT OR UPDATE or DELETE
  ON target FOR EACH ROW EXECUTE FUNCTION skip_merge_op();
RESULT:
	[]

-----------
QUERY:

DO $$
DECLARE
  result integer;
BEGIN
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED AND s.sid = 3 THEN UPDATE SET balance = t.balance + s.delta
WHEN MATCHED THEN DELETE
WHEN NOT MATCHED THEN INSERT VALUES (sid, delta);
IF FOUND THEN
  RAISE NOTICE 'Found';
ELSE
  RAISE NOTICE 'Not found';
END IF;
GET DIAGNOSTICS result := ROW_COUNT;
RAISE NOTICE 'ROW_COUNT = %', result;
END;
$$;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target FULL OUTER JOIN source ON (sid = tid);
RESULT:
	[(3, 30, 3, 20), (2, 20, 2, 5), (None, None, 4, 40), (1, 10, None, None)]

-----------
QUERY:

DROP TRIGGER merge_skip ON target;
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION skip_merge_op();
RESULT:
	[]

-----------
QUERY:


-- test from PL/pgSQL
-- make sure MERGE INTO isn/* REPLACED */''t interpreted to mean returning variables like SELECT INTO
BEGIN;
RESULT:
	[]

-----------
QUERY:

DO LANGUAGE plpgsql $$
BEGIN
MERGE INTO target t
USING source AS s
ON t.tid = s.sid
WHEN MATCHED AND t.balance > s.delta THEN
	UPDATE SET balance = t.balance - s.delta;
END;
$$;
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


--source constants
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING (SELECT 9 AS sid, 57 AS delta) AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.delta);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30), (9, 57)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


--source query
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING (SELECT sid, delta FROM source WHERE delta > 0) AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.delta);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30), (4, 40)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING (SELECT sid, delta as newname FROM source WHERE delta > 0) AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.newname);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30), (4, 40)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


--self-merge
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t1
USING target t2
ON t1.tid = t2.tid
WHEN MATCHED THEN
	UPDATE SET balance = t1.balance + t2.balance
WHEN NOT MATCHED THEN
	INSERT VALUES (t2.tid, t2.balance);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 20), (2, 40), (3, 60)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING (SELECT tid as sid, balance as delta FROM target WHERE balance > 0) AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.delta);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO target t
USING
(SELECT sid, max(delta) AS delta
 FROM source
 GROUP BY sid
 HAVING count(*) = 1
 ORDER BY sid ASC) AS s
ON t.tid = s.sid
WHEN NOT MATCHED THEN
	INSERT (tid, balance) VALUES (s.sid, s.delta);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 30), (4, 40)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- plpgsql parameters and results
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION merge_func (p_id integer, p_bal integer)
RETURNS INTEGER
LANGUAGE plpgsql
AS $$
DECLARE
 result integer;
BEGIN
MERGE INTO target t
USING (SELECT p_id AS sid) AS s
ON t.tid = s.sid
WHEN MATCHED THEN
	UPDATE SET balance = t.balance - p_bal;
IF FOUND THEN
	GET DIAGNOSTICS result := ROW_COUNT;
END IF;
RETURN result;
END;
$$;
RESULT:
	[]

-----------
QUERY:

SELECT merge_func(3, 4);
RESULT:
	[(1,)]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 10), (2, 20), (3, 26)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- PREPARE
BEGIN;
RESULT:
	[]

-----------
QUERY:

prepare foom as merge into target t using (select 1 as sid) s on (t.tid = s.sid) when matched then update set balance = 1;
RESULT:
	[]

-----------
QUERY:

execute foom;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 1), (2, 20), (3, 30)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

PREPARE foom2 (integer, integer) AS
MERGE INTO target t
USING (SELECT 1) s
ON t.tid = $1
WHEN MATCHED THEN
UPDATE SET balance = $2;
RESULT:
	[]

-----------
QUERY:

--EXPLAIN (ANALYZE ON, COSTS OFF, SUMMARY OFF, TIMING OFF)
execute foom2 (1, 1);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM target ORDER BY tid;
RESULT:
	[(1, 1), (2, 20), (3, 30)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- subqueries in source relation

CREATE TABLE sq_target (tid integer NOT NULL, balance integer)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE sq_source (delta integer, sid integer, balance integer DEFAULT 0)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:


INSERT INTO sq_target(tid, balance) VALUES (1,100), (2,200), (3,300);
RESULT:
	[]

-----------
QUERY:

INSERT INTO sq_source(sid, delta) VALUES (1,10), (2,20), (4,40);
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO sq_target t
USING (SELECT * FROM sq_source) s
ON tid = sid
WHEN MATCHED AND t.balance > delta THEN
	UPDATE SET balance = t.balance + delta;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM sq_target;
RESULT:
	[(3, 300), (1, 110), (2, 220)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- try a view
CREATE VIEW v AS SELECT * FROM sq_source WHERE sid < 2;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO sq_target
USING v
ON tid = sid
WHEN MATCHED THEN
    UPDATE SET balance = v.balance + delta;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM sq_target;
RESULT:
	[(2, 200), (3, 300), (1, 10)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- ambiguous reference to a column
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO sq_target
USING v
ON tid = sid
WHEN MATCHED AND tid >= 2 THEN
    UPDATE SET balance = balance + delta
WHEN NOT MATCHED THEN
	INSERT (balance, tid) VALUES (balance + delta, sid)
WHEN MATCHED AND tid < 2 THEN
	DELETE;
RESULT:
	ERROR - column reference "balance" is ambiguous
LINE 6:     UPDATE SET balance = balance + delta
                                 ^


-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

INSERT INTO sq_source (sid, balance, delta) VALUES (-1, -1, -10);
RESULT:
	[]

-----------
QUERY:

MERGE INTO sq_target t
USING v
ON tid = sid
WHEN MATCHED AND tid >= 2 THEN
    UPDATE SET balance = t.balance + delta
WHEN NOT MATCHED THEN
	INSERT (balance, tid) VALUES (balance + delta, sid)
WHEN MATCHED AND tid < 2 THEN
	DELETE;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM sq_target;
RESULT:
	[(2, 200), (3, 300), (-1, -11)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- CTEs
BEGIN;
RESULT:
	[]

-----------
QUERY:

INSERT INTO sq_source (sid, balance, delta) VALUES (-1, -1, -10);
RESULT:
	[]

-----------
QUERY:

WITH targq AS (
	SELECT * FROM v
)
MERGE INTO sq_target t
USING v
ON tid = sid
WHEN MATCHED AND tid >= 2 THEN
    UPDATE SET balance = t.balance + delta
WHEN NOT MATCHED THEN
	INSERT (balance, tid) VALUES (balance + delta, sid)
WHEN MATCHED AND tid < 2 THEN
	DELETE;
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- RETURNING
SELECT * FROM sq_source ORDER BY sid;
RESULT:
	[(10, 1, 0), (20, 2, 0), (40, 4, 0)]

-----------
QUERY:

SELECT * FROM sq_target ORDER BY tid;
RESULT:
	[(1, 100), (2, 200), (3, 300)]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE merge_actions(action text, abbrev text);
RESULT:
	[]

-----------
QUERY:

INSERT INTO merge_actions VALUES ('INSERT', 'ins'), ('UPDATE', 'upd'), ('DELETE', 'del');
RESULT:
	[]

-----------
QUERY:

MERGE INTO sq_target t
USING sq_source s
ON tid = sid
WHEN MATCHED AND tid >= 2 THEN
    UPDATE SET balance = t.balance + delta
WHEN NOT MATCHED THEN
    INSERT (balance, tid) VALUES (balance + delta, sid)
WHEN MATCHED AND tid < 2 THEN
    DELETE
RETURNING (SELECT abbrev FROM merge_actions
            WHERE action = merge_action()) AS action,
          t.*,
          CASE merge_action()
              WHEN 'INSERT' THEN 'Inserted '||t
              WHEN 'UPDATE' THEN 'Added '||delta||' to balance'
              WHEN 'DELETE' THEN 'Removed '||t
          END AS description;
RESULT:
	[('del', 1, 100, 'Removed (1,100)'), ('upd', 2, 220, 'Added 20 to balance'), ('ins', 4, 40, 'Inserted (4,40)')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- error when using merge_action() outside MERGE
SELECT merge_action() FROM sq_target;
RESULT:
	ERROR - MERGE_ACTION() can only be used in the RETURNING list of a MERGE command
LINE 4: SELECT merge_action() FROM sq_target;
               ^


-----------
QUERY:

UPDATE sq_target SET balance = balance + 1 RETURNING merge_action();
RESULT:
	ERROR - MERGE_ACTION() can only be used in the RETURNING list of a MERGE command
LINE 2: ...ATE sq_target SET balance = balance + 1 RETURNING merge_acti...
                                                             ^


-----------
QUERY:


-- RETURNING in CTEs
CREATE TABLE sq_target_merge_log (tid integer NOT NULL, last_change text);
RESULT:
	[]

-----------
QUERY:

INSERT INTO sq_target_merge_log VALUES (1, 'Original value');
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

WITH m AS (
    MERGE INTO sq_target t
    USING sq_source s
    ON tid = sid
    WHEN MATCHED AND tid >= 2 THEN
        UPDATE SET balance = t.balance + delta
    WHEN NOT MATCHED THEN
        INSERT (balance, tid) VALUES (balance + delta, sid)
    WHEN MATCHED AND tid < 2 THEN
        DELETE
    RETURNING merge_action() AS action, t.*,
              CASE merge_action()
                  WHEN 'INSERT' THEN 'Inserted '||t
                  WHEN 'UPDATE' THEN 'Added '||delta||' to balance'
                  WHEN 'DELETE' THEN 'Removed '||t
              END AS description
), m2 AS (
    MERGE INTO sq_target_merge_log l
    USING m
    ON l.tid = m.tid
    WHEN MATCHED THEN
        UPDATE SET last_change = description
    WHEN NOT MATCHED THEN
        INSERT VALUES (m.tid, description)
    RETURNING action, merge_action() AS log_action, l.*
)
SELECT * FROM m2;
RESULT:
	[('DELETE', 'UPDATE', 1, 'Removed (1,100)'), ('UPDATE', 'INSERT', 2, 'Added 20 to balance'), ('INSERT', 'INSERT', 4, 'Inserted (4,40)')]

-----------
QUERY:

SELECT * FROM sq_target_merge_log ORDER BY tid;
RESULT:
	[(1, 'Removed (1,100)'), (2, 'Added 20 to balance'), (4, 'Inserted (4,40)')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- COPY (MERGE ... RETURNING) TO ...
BEGIN;
RESULT:
	[]

-----------
QUERY:

COPY (
    MERGE INTO sq_target t
    USING sq_source s
    ON tid = sid
    WHEN MATCHED AND tid >= 2 THEN
        UPDATE SET balance = t.balance + delta
    WHEN NOT MATCHED THEN
        INSERT (balance, tid) VALUES (balance + delta, sid)
    WHEN MATCHED AND tid < 2 THEN
        DELETE
    RETURNING merge_action(), t.*
) TO stdout;
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- SQL function with MERGE ... RETURNING
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION merge_into_sq_target(sid int, balance int, delta int,
                                     OUT action text, OUT tid int, OUT new_balance int)
LANGUAGE sql AS
$$
    MERGE INTO sq_target t
    USING (VALUES ($1, $2, $3)) AS v(sid, balance, delta)
    ON tid = v.sid
    WHEN MATCHED AND tid >= 2 THEN
        UPDATE SET balance = t.balance + v.delta
    WHEN NOT MATCHED THEN
        INSERT (balance, tid) VALUES (v.balance + v.delta, v.sid)
    WHEN MATCHED AND tid < 2 THEN
        DELETE
    RETURNING merge_action(), t.*;
$$;
RESULT:
	[]

-----------
QUERY:

SELECT m.*
FROM (VALUES (1, 0, 0), (3, 0, 20), (4, 100, 10)) AS v(sid, balance, delta),
LATERAL (SELECT action, tid, new_balance FROM merge_into_sq_target(sid, balance, delta)) m;
RESULT:
	[('DELETE', 1, 100), ('UPDATE', 3, 320), ('INSERT', 4, 110)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- SQL SRF with MERGE ... RETURNING
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION merge_sq_source_into_sq_target()
RETURNS TABLE (action text, tid int, balance int)
LANGUAGE sql AS
$$
    MERGE INTO sq_target t
    USING sq_source s
    ON tid = sid
    WHEN MATCHED AND tid >= 2 THEN
        UPDATE SET balance = t.balance + delta
    WHEN NOT MATCHED THEN
        INSERT (balance, tid) VALUES (balance + delta, sid)
    WHEN MATCHED AND tid < 2 THEN
        DELETE
    RETURNING merge_action(), t.*;
$$;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM merge_sq_source_into_sq_target();
RESULT:
	[('DELETE', 1, 100), ('UPDATE', 2, 220), ('INSERT', 4, 40)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- PL/pgSQL function with MERGE ... RETURNING ... INTO
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION merge_into_sq_target(sid int, balance int, delta int,
                                     OUT r_action text, OUT r_tid int, OUT r_balance int)
LANGUAGE plpgsql AS
$$
BEGIN
    MERGE INTO sq_target t
    USING (VALUES ($1, $2, $3)) AS v(sid, balance, delta)
    ON tid = v.sid
    WHEN MATCHED AND tid >= 2 THEN
        UPDATE SET balance = t.balance + v.delta
    WHEN NOT MATCHED THEN
        INSERT (balance, tid) VALUES (v.balance + v.delta, v.sid)
    WHEN MATCHED AND tid < 2 THEN
        DELETE
    RETURNING merge_action(), t.* INTO r_action, r_tid, r_balance;
END;
$$;
RESULT:
	[]

-----------
QUERY:

SELECT m.*
FROM (VALUES (1, 0, 0), (3, 0, 20), (4, 100, 10)) AS v(sid, balance, delta),
LATERAL (SELECT r_action, r_tid, r_balance FROM merge_into_sq_target(sid, balance, delta)) m;
RESULT:
	[('DELETE', 1, 100), ('UPDATE', 3, 320), ('INSERT', 4, 110)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- EXPLAIN
CREATE TABLE ex_mtarget (a int, b int)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE ex_msource (a int, b int)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

INSERT INTO ex_mtarget SELECT i, i*10 FROM generate_series(1,100,2) i;
RESULT:
	[]

-----------
QUERY:

INSERT INTO ex_msource SELECT i, i*10 FROM generate_series(1,100,1) i;
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION explain_merge(query text) RETURNS SETOF text
LANGUAGE plpgsql AS
$$
DECLARE ln text;
BEGIN
    FOR ln IN
        EXECUTE 'explain (analyze, timing off, summary off, costs off) ' ||
		  query
    LOOP
        ln := regexp_replace(ln, '(Memory( Usage)?|Buckets|Batches): \S*',  '\1: xxx', 'g');
        RETURN NEXT ln;
    END LOOP;
END;
$$;
RESULT:
	[]

-----------
QUERY:


-- only updates
SELECT explain_merge('
MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a
WHEN MATCHED THEN
	UPDATE SET b = t.b + 1');
RESULT:
	[('Merge on ex_mtarget t (actual rows=0 loops=1)',), ('  Tuples: updated=50',), ('  ->  Merge Join (actual rows=50 loops=1)',), ('        Merge Cond: (t.a = s.a)',), ('        ->  Sort (actual rows=50 loops=1)',), ('              Sort Key: t.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_mtarget t (actual rows=50 loops=1)',), ('        ->  Sort (actual rows=100 loops=1)',), ('              Sort Key: s.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_msource s (actual rows=100 loops=1)',)]

-----------
QUERY:


-- only updates to selected tuples
SELECT explain_merge('
MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a
WHEN MATCHED AND t.a < 10 THEN
	UPDATE SET b = t.b + 1');
RESULT:
	[('Merge on ex_mtarget t (actual rows=0 loops=1)',), ('  Tuples: updated=5 skipped=45',), ('  ->  Merge Join (actual rows=50 loops=1)',), ('        Merge Cond: (t.a = s.a)',), ('        ->  Sort (actual rows=50 loops=1)',), ('              Sort Key: t.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_mtarget t (actual rows=50 loops=1)',), ('        ->  Sort (actual rows=100 loops=1)',), ('              Sort Key: s.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_msource s (actual rows=100 loops=1)',)]

-----------
QUERY:


-- updates + deletes
SELECT explain_merge('
MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a
WHEN MATCHED AND t.a < 10 THEN
	UPDATE SET b = t.b + 1
WHEN MATCHED AND t.a >= 10 AND t.a <= 20 THEN
	DELETE');
RESULT:
	[('Merge on ex_mtarget t (actual rows=0 loops=1)',), ('  Tuples: updated=5 deleted=5 skipped=40',), ('  ->  Merge Join (actual rows=50 loops=1)',), ('        Merge Cond: (t.a = s.a)',), ('        ->  Sort (actual rows=50 loops=1)',), ('              Sort Key: t.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_mtarget t (actual rows=50 loops=1)',), ('        ->  Sort (actual rows=100 loops=1)',), ('              Sort Key: s.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_msource s (actual rows=100 loops=1)',)]

-----------
QUERY:


-- only inserts
SELECT explain_merge('
MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a
WHEN NOT MATCHED AND s.a < 10 THEN
	INSERT VALUES (a, b)');
RESULT:
	[('Merge on ex_mtarget t (actual rows=0 loops=1)',), ('  Tuples: inserted=4 skipped=96',), ('  ->  Merge Left Join (actual rows=100 loops=1)',), ('        Merge Cond: (s.a = t.a)',), ('        ->  Sort (actual rows=100 loops=1)',), ('              Sort Key: s.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_msource s (actual rows=100 loops=1)',), ('        ->  Sort (actual rows=45 loops=1)',), ('              Sort Key: t.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_mtarget t (actual rows=45 loops=1)',)]

-----------
QUERY:


-- all three
SELECT explain_merge('
MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a
WHEN MATCHED AND t.a < 10 THEN
	UPDATE SET b = t.b + 1
WHEN MATCHED AND t.a >= 30 AND t.a <= 40 THEN
	DELETE
WHEN NOT MATCHED AND s.a < 20 THEN
	INSERT VALUES (a, b)');
RESULT:
	[('Merge on ex_mtarget t (actual rows=0 loops=1)',), ('  Tuples: inserted=10 updated=9 deleted=5 skipped=76',), ('  ->  Merge Left Join (actual rows=100 loops=1)',), ('        Merge Cond: (s.a = t.a)',), ('        ->  Sort (actual rows=100 loops=1)',), ('              Sort Key: s.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_msource s (actual rows=100 loops=1)',), ('        ->  Sort (actual rows=49 loops=1)',), ('              Sort Key: t.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_mtarget t (actual rows=49 loops=1)',)]

-----------
QUERY:


-- nothing
SELECT explain_merge('
MERGE INTO ex_mtarget t USING ex_msource s ON t.a = s.a AND t.a < -1000
WHEN MATCHED AND t.a < 10 THEN
	DO NOTHING');
RESULT:
	[('Merge on ex_mtarget t (actual rows=0 loops=1)',), ('  ->  Merge Join (actual rows=0 loops=1)',), ('        Merge Cond: (t.a = s.a)',), ('        ->  Sort (actual rows=0 loops=1)',), ('              Sort Key: t.a',), ('              Sort Method: quicksort  Memory: xxx',), ('              ->  Seq Scan on ex_mtarget t (actual rows=0 loops=1)',), ("                    Filter: (a < '-1000'::integer)",), ('                    Rows Removed by Filter: 54',), ('        ->  Sort (never executed)',), ('              Sort Key: s.a',), ('              ->  Seq Scan on ex_msource s (never executed)',)]

-----------
QUERY:


DROP TABLE ex_msource, ex_mtarget;
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION explain_merge(text);
RESULT:
	[]

-----------
QUERY:


-- EXPLAIN SubPlans and InitPlans
CREATE TABLE src (a int, b int, c int, d int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE tgt (a int, b int, c int, d int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE ref (ab int, cd int);
RESULT:
	[]

-----------
QUERY:


EXPLAIN (verbose, costs off)
MERGE INTO tgt t
USING (SELECT *, (SELECT count(*) FROM ref r
                   WHERE r.ab = s.a + s.b
                     AND r.cd = s.c - s.d) cnt
         FROM src s) s
ON t.a = s.a AND t.b < s.cnt
WHEN MATCHED AND t.c > s.cnt THEN
  UPDATE SET (b, c) = (SELECT s.b, s.cnt);
RESULT:
	[('Merge on public.tgt t',), ('  ->  Hash Join',), ('        Output: t.ctid, s.a, s.b, s.c, s.d, s.ctid',), ('        Hash Cond: (t.a = s.a)',), ('        Join Filter: (t.b < (SubPlan 1))',), ('        ->  Seq Scan on public.tgt t',), ('              Output: t.ctid, t.a, t.b',), ('        ->  Hash',), ('              Output: s.a, s.b, s.c, s.d, s.ctid',), ('              ->  Seq Scan on public.src s',), ('                    Output: s.a, s.b, s.c, s.d, s.ctid',), ('        SubPlan 1',), ('          ->  Aggregate',), ('                Output: count(*)',), ('                ->  Seq Scan on public.ref r',), ('                      Output: r.ab, r.cd',), ('                      Filter: ((r.ab = (s.a + s.b)) AND (r.cd = (s.c - s.d)))',), ('  SubPlan 4',), ('    ->  Aggregate',), ('          Output: count(*)',), ('          ->  Seq Scan on public.ref r_2',), ('                Output: r_2.ab, r_2.cd',), ('                Filter: ((r_2.ab = (s.a + s.b)) AND (r_2.cd = (s.c - s.d)))',), ('  SubPlan 3',), ('    ->  Result',), ('          Output: s.b, (InitPlan 2).col1',), ('          InitPlan 2',), ('            ->  Aggregate',), ('                  Output: count(*)',), ('                  ->  Seq Scan on public.ref r_1',), ('                        Output: r_1.ab, r_1.cd',), ('                        Filter: ((r_1.ab = (s.a + s.b)) AND (r_1.cd = (s.c - s.d)))',)]

-----------
QUERY:


DROP TABLE src, tgt, ref;
RESULT:
	[]

-----------
QUERY:


-- Subqueries
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO sq_target t
USING v
ON tid = sid
WHEN MATCHED THEN
    UPDATE SET balance = (SELECT count(*) FROM sq_target);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM sq_target WHERE tid = 1;
RESULT:
	[(1, 3)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO sq_target t
USING v
ON tid = sid
WHEN MATCHED AND (SELECT count(*) > 0 FROM sq_target) THEN
    UPDATE SET balance = 42;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM sq_target WHERE tid = 1;
RESULT:
	[(1, 42)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO sq_target t
USING v
ON tid = sid AND (SELECT count(*) > 0 FROM sq_target)
WHEN MATCHED THEN
    UPDATE SET balance = 42;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM sq_target WHERE tid = 1;
RESULT:
	[(1, 42)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


DROP TABLE sq_target, sq_target_merge_log, sq_source CASCADE;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE pa_target (tid integer, balance float, val text)
	PARTITION BY LIST (tid);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE part1 PARTITION OF pa_target FOR VALUES IN (1,4)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part2 PARTITION OF pa_target FOR VALUES IN (2,5,6)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part3 PARTITION OF pa_target FOR VALUES IN (3,8,9)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part4 PARTITION OF pa_target DEFAULT
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE pa_source (sid integer, delta float);
RESULT:
	[]

-----------
QUERY:

-- insert many rows to the source table
INSERT INTO pa_source SELECT id, id * 10  FROM generate_series(1,14) AS id;
RESULT:
	[]

-----------
QUERY:

-- insert a few rows in the target table (odd numbered tid)
INSERT INTO pa_target SELECT id, id * 100, 'initial' FROM generate_series(1,14,2) AS id;
RESULT:
	[]

-----------
QUERY:


-- try simple MERGE
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO pa_target t
  USING pa_source s
  ON t.tid = s.sid
  WHEN MATCHED THEN
    UPDATE SET balance = balance + delta, val = val || ' updated by merge'
  WHEN NOT MATCHED THEN
    INSERT VALUES (sid, delta, 'inserted by merge');
RESULT:
	[]

-----------
QUERY:

SELECT * FROM pa_target ORDER BY tid;
RESULT:
	[(1, 110.0, 'initial updated by merge'), (2, 20.0, 'inserted by merge'), (3, 330.0, 'initial updated by merge'), (4, 40.0, 'inserted by merge'), (5, 550.0, 'initial updated by merge'), (6, 60.0, 'inserted by merge'), (7, 770.0, 'initial updated by merge'), (8, 80.0, 'inserted by merge'), (9, 990.0, 'initial updated by merge'), (10, 100.0, 'inserted by merge'), (11, 1210.0, 'initial updated by merge'), (12, 120.0, 'inserted by merge'), (13, 1430.0, 'initial updated by merge'), (14, 140.0, 'inserted by merge')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- same with a constant qual
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO pa_target t
  USING pa_source s
  ON t.tid = s.sid AND tid = 1
  WHEN MATCHED THEN
    UPDATE SET balance = balance + delta, val = val || ' updated by merge'
  WHEN NOT MATCHED THEN
    INSERT VALUES (sid, delta, 'inserted by merge');
RESULT:
	[]

-----------
QUERY:

SELECT * FROM pa_target ORDER BY tid;
RESULT:
	[(1, 110.0, 'initial updated by merge'), (2, 20.0, 'inserted by merge'), (3, 30.0, 'inserted by merge'), (3, 300.0, 'initial'), (4, 40.0, 'inserted by merge'), (5, 500.0, 'initial'), (5, 50.0, 'inserted by merge'), (6, 60.0, 'inserted by merge'), (7, 700.0, 'initial'), (7, 70.0, 'inserted by merge'), (8, 80.0, 'inserted by merge'), (9, 90.0, 'inserted by merge'), (9, 900.0, 'initial'), (10, 100.0, 'inserted by merge'), (11, 1100.0, 'initial'), (11, 110.0, 'inserted by merge'), (12, 120.0, 'inserted by merge'), (13, 1300.0, 'initial'), (13, 130.0, 'inserted by merge'), (14, 140.0, 'inserted by merge')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- try updating the partition key column
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION merge_func() RETURNS integer LANGUAGE plpgsql AS $$
DECLARE
  result integer;
BEGIN
MERGE INTO pa_target t
  USING pa_source s
  ON t.tid = s.sid
  WHEN MATCHED THEN
    UPDATE SET tid = tid + 1, balance = balance + delta, val = val || ' updated by merge'
  WHEN NOT MATCHED THEN
    INSERT VALUES (sid, delta, 'inserted by merge');
IF FOUND THEN
  GET DIAGNOSTICS result := ROW_COUNT;
END IF;
RETURN result;
END;
$$;
RESULT:
	[]

-----------
QUERY:

SELECT merge_func();
RESULT:
	[(14,)]

-----------
QUERY:

SELECT * FROM pa_target ORDER BY tid;
RESULT:
	[(2, 110.0, 'initial updated by merge'), (2, 20.0, 'inserted by merge'), (4, 40.0, 'inserted by merge'), (4, 330.0, 'initial updated by merge'), (6, 550.0, 'initial updated by merge'), (6, 60.0, 'inserted by merge'), (8, 80.0, 'inserted by merge'), (8, 770.0, 'initial updated by merge'), (10, 990.0, 'initial updated by merge'), (10, 100.0, 'inserted by merge'), (12, 1210.0, 'initial updated by merge'), (12, 120.0, 'inserted by merge'), (14, 1430.0, 'initial updated by merge'), (14, 140.0, 'inserted by merge')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- update partition key to partition not initially scanned
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO pa_target t
  USING pa_source s
  ON t.tid = s.sid AND t.tid = 1
  WHEN MATCHED THEN
    UPDATE SET tid = tid + 1, balance = balance + delta, val = val || ' updated by merge'
  RETURNING merge_action(), t.*;
RESULT:
	[('UPDATE', 2, 110.0, 'initial updated by merge')]

-----------
QUERY:

SELECT * FROM pa_target ORDER BY tid;
RESULT:
	[(2, 110.0, 'initial updated by merge'), (3, 300.0, 'initial'), (5, 500.0, 'initial'), (7, 700.0, 'initial'), (9, 900.0, 'initial'), (11, 1100.0, 'initial'), (13, 1300.0, 'initial')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


DROP TABLE pa_target CASCADE;
RESULT:
	[]

-----------
QUERY:


-- The target table is partitioned in the same way, but this time by attaching
-- partitions which have columns in different order, dropped columns etc.
CREATE TABLE pa_target (tid integer, balance float, val text)
	PARTITION BY LIST (tid);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE part1 (tid integer, balance float, val text)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part2 (balance float, tid integer, val text)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part3 (tid integer, balance float, val text)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part4 (extraid text, tid integer, balance float, val text)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE part4 DROP COLUMN extraid;
RESULT:
	[]

-----------
QUERY:


ALTER TABLE pa_target ATTACH PARTITION part1 FOR VALUES IN (1,4);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE pa_target ATTACH PARTITION part2 FOR VALUES IN (2,5,6);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE pa_target ATTACH PARTITION part3 FOR VALUES IN (3,8,9);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE pa_target ATTACH PARTITION part4 DEFAULT;
RESULT:
	[]

-----------
QUERY:


-- insert a few rows in the target table (odd numbered tid)
INSERT INTO pa_target SELECT id, id * 100, 'initial' FROM generate_series(1,14,2) AS id;
RESULT:
	[]

-----------
QUERY:


-- try simple MERGE
BEGIN;
RESULT:
	[]

-----------
QUERY:

DO $$
DECLARE
  result integer;
BEGIN
MERGE INTO pa_target t
  USING pa_source s
  ON t.tid = s.sid
  WHEN MATCHED THEN
    UPDATE SET balance = balance + delta, val = val || ' updated by merge'
  WHEN NOT MATCHED THEN
    INSERT VALUES (sid, delta, 'inserted by merge');
GET DIAGNOSTICS result := ROW_COUNT;
RAISE NOTICE 'ROW_COUNT = %', result;
END;
$$;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM pa_target ORDER BY tid;
RESULT:
	[(1, 110.0, 'initial updated by merge'), (2, 20.0, 'inserted by merge'), (3, 330.0, 'initial updated by merge'), (4, 40.0, 'inserted by merge'), (5, 550.0, 'initial updated by merge'), (6, 60.0, 'inserted by merge'), (7, 770.0, 'initial updated by merge'), (8, 80.0, 'inserted by merge'), (9, 990.0, 'initial updated by merge'), (10, 100.0, 'inserted by merge'), (11, 1210.0, 'initial updated by merge'), (12, 120.0, 'inserted by merge'), (13, 1430.0, 'initial updated by merge'), (14, 140.0, 'inserted by merge')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- same with a constant qual
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO pa_target t
  USING pa_source s
  ON t.tid = s.sid AND tid IN (1, 5)
  WHEN MATCHED AND tid % 5 = 0 THEN DELETE
  WHEN MATCHED THEN
    UPDATE SET balance = balance + delta, val = val || ' updated by merge'
  WHEN NOT MATCHED THEN
    INSERT VALUES (sid, delta, 'inserted by merge');
RESULT:
	[]

-----------
QUERY:

SELECT * FROM pa_target ORDER BY tid;
RESULT:
	[(1, 110.0, 'initial updated by merge'), (2, 20.0, 'inserted by merge'), (3, 30.0, 'inserted by merge'), (3, 300.0, 'initial'), (4, 40.0, 'inserted by merge'), (6, 60.0, 'inserted by merge'), (7, 700.0, 'initial'), (7, 70.0, 'inserted by merge'), (8, 80.0, 'inserted by merge'), (9, 900.0, 'initial'), (9, 90.0, 'inserted by merge'), (10, 100.0, 'inserted by merge'), (11, 110.0, 'inserted by merge'), (11, 1100.0, 'initial'), (12, 120.0, 'inserted by merge'), (13, 1300.0, 'initial'), (13, 130.0, 'inserted by merge'), (14, 140.0, 'inserted by merge')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- try updating the partition key column
BEGIN;
RESULT:
	[]

-----------
QUERY:

DO $$
DECLARE
  result integer;
BEGIN
MERGE INTO pa_target t
  USING pa_source s
  ON t.tid = s.sid
  WHEN MATCHED THEN
    UPDATE SET tid = tid + 1, balance = balance + delta, val = val || ' updated by merge'
  WHEN NOT MATCHED THEN
    INSERT VALUES (sid, delta, 'inserted by merge');
GET DIAGNOSTICS result := ROW_COUNT;
RAISE NOTICE 'ROW_COUNT = %', result;
END;
$$;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM pa_target ORDER BY tid;
RESULT:
	[(2, 110.0, 'initial updated by merge'), (2, 20.0, 'inserted by merge'), (4, 40.0, 'inserted by merge'), (4, 330.0, 'initial updated by merge'), (6, 550.0, 'initial updated by merge'), (6, 60.0, 'inserted by merge'), (8, 80.0, 'inserted by merge'), (8, 770.0, 'initial updated by merge'), (10, 990.0, 'initial updated by merge'), (10, 100.0, 'inserted by merge'), (12, 1210.0, 'initial updated by merge'), (12, 120.0, 'inserted by merge'), (14, 1430.0, 'initial updated by merge'), (14, 140.0, 'inserted by merge')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- as above, but blocked by BEFORE DELETE ROW trigger
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION trig_fn() RETURNS trigger LANGUAGE plpgsql AS
  $$ BEGIN RETURN NULL; END; $$;
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER del_trig BEFORE DELETE ON pa_target
  FOR EACH ROW EXECUTE PROCEDURE trig_fn();
RESULT:
	[]

-----------
QUERY:

DO $$
DECLARE
  result integer;
BEGIN
MERGE INTO pa_target t
  USING pa_source s
  ON t.tid = s.sid
  WHEN MATCHED THEN
    UPDATE SET tid = tid + 1, balance = balance + delta, val = val || ' updated by merge'
  WHEN NOT MATCHED THEN
    INSERT VALUES (sid, delta, 'inserted by merge');
GET DIAGNOSTICS result := ROW_COUNT;
RAISE NOTICE 'ROW_COUNT = %', result;
END;
$$;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM pa_target ORDER BY tid;
RESULT:
	[(1, 100.0, 'initial'), (2, 20.0, 'inserted by merge'), (3, 300.0, 'initial'), (4, 40.0, 'inserted by merge'), (6, 550.0, 'initial updated by merge'), (6, 60.0, 'inserted by merge'), (7, 700.0, 'initial'), (8, 80.0, 'inserted by merge'), (9, 900.0, 'initial'), (10, 100.0, 'inserted by merge'), (12, 1210.0, 'initial updated by merge'), (12, 120.0, 'inserted by merge'), (14, 1430.0, 'initial updated by merge'), (14, 140.0, 'inserted by merge')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- as above, but blocked by BEFORE INSERT ROW trigger
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION trig_fn() RETURNS trigger LANGUAGE plpgsql AS
  $$ BEGIN RETURN NULL; END; $$;
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER ins_trig BEFORE INSERT ON pa_target
  FOR EACH ROW EXECUTE PROCEDURE trig_fn();
RESULT:
	[]

-----------
QUERY:

DO $$
DECLARE
  result integer;
BEGIN
MERGE INTO pa_target t
  USING pa_source s
  ON t.tid = s.sid
  WHEN MATCHED THEN
    UPDATE SET tid = tid + 1, balance = balance + delta, val = val || ' updated by merge'
  WHEN NOT MATCHED THEN
    INSERT VALUES (sid, delta, 'inserted by merge');
GET DIAGNOSTICS result := ROW_COUNT;
RAISE NOTICE 'ROW_COUNT = %', result;
END;
$$;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM pa_target ORDER BY tid;
RESULT:
	[(6, 550.0, 'initial updated by merge'), (12, 1210.0, 'initial updated by merge'), (14, 1430.0, 'initial updated by merge')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- test RLS enforcement
BEGIN;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE pa_target ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE pa_target FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY pa_target_pol ON pa_target USING (tid != 0);
RESULT:
	[]

-----------
QUERY:

MERGE INTO pa_target t
  USING pa_source s
  ON t.tid = s.sid AND t.tid IN (1,2,3,4)
  WHEN MATCHED THEN
    UPDATE SET tid = tid - 1;
RESULT:
	ERROR - new row violates row-level security policy for table "pa_target"


-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


DROP TABLE pa_source;
RESULT:
	[]

-----------
QUERY:

DROP TABLE pa_target CASCADE;
RESULT:
	[]

-----------
QUERY:


-- Sub-partitioning
CREATE TABLE pa_target (logts timestamp, tid integer, balance float, val text)
	PARTITION BY RANGE (logts);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE part_m01 PARTITION OF pa_target
	FOR VALUES FROM ('2017-01-01') TO ('2017-02-01')
	PARTITION BY LIST (tid);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_m01_odd PARTITION OF part_m01
	FOR VALUES IN (1,3,5,7,9) WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_m01_even PARTITION OF part_m01
	FOR VALUES IN (2,4,6,8) WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_m02 PARTITION OF pa_target
	FOR VALUES FROM ('2017-02-01') TO ('2017-03-01')
	PARTITION BY LIST (tid);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_m02_odd PARTITION OF part_m02
	FOR VALUES IN (1,3,5,7,9) WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_m02_even PARTITION OF part_m02
	FOR VALUES IN (2,4,6,8) WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE pa_source (sid integer, delta float)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

-- insert many rows to the source table
INSERT INTO pa_source SELECT id, id * 10  FROM generate_series(1,14) AS id;
RESULT:
	[]

-----------
QUERY:

-- insert a few rows in the target table (odd numbered tid)
INSERT INTO pa_target SELECT '2017-01-31', id, id * 100, 'initial' FROM generate_series(1,9,3) AS id;
RESULT:
	[]

-----------
QUERY:

INSERT INTO pa_target SELECT '2017-02-28', id, id * 100, 'initial' FROM generate_series(2,9,3) AS id;
RESULT:
	[]

-----------
QUERY:


-- try simple MERGE
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO pa_target t
  USING (SELECT '2017-01-15' AS slogts, * FROM pa_source WHERE sid < 10) s
  ON t.tid = s.sid
  WHEN MATCHED THEN
    UPDATE SET balance = balance + delta, val = val || ' updated by merge'
  WHEN NOT MATCHED THEN
    INSERT VALUES (slogts::timestamp, sid, delta, 'inserted by merge')
  RETURNING merge_action(), t.*;
RESULT:
	[('UPDATE', datetime.datetime(2017, 1, 31, 0, 0), 1, 110.0, 'initial updated by merge'), ('UPDATE', datetime.datetime(2017, 2, 28, 0, 0), 2, 220.0, 'initial updated by merge'), ('INSERT', datetime.datetime(2017, 1, 15, 0, 0), 3, 30.0, 'inserted by merge'), ('UPDATE', datetime.datetime(2017, 1, 31, 0, 0), 4, 440.0, 'initial updated by merge'), ('UPDATE', datetime.datetime(2017, 2, 28, 0, 0), 5, 550.0, 'initial updated by merge'), ('INSERT', datetime.datetime(2017, 1, 15, 0, 0), 6, 60.0, 'inserted by merge'), ('UPDATE', datetime.datetime(2017, 1, 31, 0, 0), 7, 770.0, 'initial updated by merge'), ('UPDATE', datetime.datetime(2017, 2, 28, 0, 0), 8, 880.0, 'initial updated by merge'), ('INSERT', datetime.datetime(2017, 1, 15, 0, 0), 9, 90.0, 'inserted by merge')]

-----------
QUERY:

SELECT * FROM pa_target ORDER BY tid;
RESULT:
	[(datetime.datetime(2017, 1, 31, 0, 0), 1, 110.0, 'initial updated by merge'), (datetime.datetime(2017, 2, 28, 0, 0), 2, 220.0, 'initial updated by merge'), (datetime.datetime(2017, 1, 15, 0, 0), 3, 30.0, 'inserted by merge'), (datetime.datetime(2017, 1, 31, 0, 0), 4, 440.0, 'initial updated by merge'), (datetime.datetime(2017, 2, 28, 0, 0), 5, 550.0, 'initial updated by merge'), (datetime.datetime(2017, 1, 15, 0, 0), 6, 60.0, 'inserted by merge'), (datetime.datetime(2017, 1, 31, 0, 0), 7, 770.0, 'initial updated by merge'), (datetime.datetime(2017, 2, 28, 0, 0), 8, 880.0, 'initial updated by merge'), (datetime.datetime(2017, 1, 15, 0, 0), 9, 90.0, 'inserted by merge')]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


DROP TABLE pa_source;
RESULT:
	[]

-----------
QUERY:

DROP TABLE pa_target CASCADE;
RESULT:
	[]

-----------
QUERY:


-- Partitioned table with primary key

CREATE TABLE pa_target (tid integer PRIMARY KEY) PARTITION BY LIST (tid);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE pa_targetp PARTITION OF pa_target DEFAULT;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE pa_source (sid integer);
RESULT:
	[]

-----------
QUERY:


INSERT INTO pa_source VALUES (1), (2);
RESULT:
	[]

-----------
QUERY:


EXPLAIN (VERBOSE, COSTS OFF)
MERGE INTO pa_target t USING pa_source s ON t.tid = s.sid
  WHEN NOT MATCHED THEN INSERT VALUES (s.sid);
RESULT:
	[('Merge on public.pa_target t',), ('  Merge on public.pa_targetp t_1',), ('  ->  Hash Left Join',), ('        Output: s.sid, s.ctid, t_1.tableoid, t_1.ctid',), ('        Inner Unique: true',), ('        Hash Cond: (s.sid = t_1.tid)',), ('        ->  Seq Scan on public.pa_source s',), ('              Output: s.sid, s.ctid',), ('        ->  Hash',), ('              Output: t_1.tid, t_1.tableoid, t_1.ctid',), ('              ->  Seq Scan on public.pa_targetp t_1',), ('                    Output: t_1.tid, t_1.tableoid, t_1.ctid',)]

-----------
QUERY:


MERGE INTO pa_target t USING pa_source s ON t.tid = s.sid
  WHEN NOT MATCHED THEN INSERT VALUES (s.sid);
RESULT:
	[]

-----------
QUERY:


TABLE pa_target;
RESULT:
	[(1,), (2,)]

-----------
QUERY:


-- Partition-less partitioned table
-- (the bug we are checking for appeared only if table had partitions before)

DROP TABLE pa_targetp;
RESULT:
	[]

-----------
QUERY:


EXPLAIN (VERBOSE, COSTS OFF)
MERGE INTO pa_target t USING pa_source s ON t.tid = s.sid
  WHEN NOT MATCHED THEN INSERT VALUES (s.sid);
RESULT:
	[('Merge on public.pa_target t',), ('  ->  Hash Left Join',), ('        Output: s.sid, s.ctid, t.ctid',), ('        Inner Unique: true',), ('        Hash Cond: (s.sid = t.tid)',), ('        ->  Seq Scan on public.pa_source s',), ('              Output: s.sid, s.ctid',), ('        ->  Hash',), ('              Output: t.tid, t.ctid',), ('              ->  Result',), ('                    Output: t.tid, t.ctid',), ('                    One-Time Filter: false',)]

-----------
QUERY:


MERGE INTO pa_target t USING pa_source s ON t.tid = s.sid
  WHEN NOT MATCHED THEN INSERT VALUES (s.sid);
RESULT:
	ERROR - no partition of relation "pa_target" found for row
DETAIL:  Partition key of the failing row contains (tid) = (1).


-----------
QUERY:


DROP TABLE pa_source;
RESULT:
	[]

-----------
QUERY:

DROP TABLE pa_target CASCADE;
RESULT:
	[]

-----------
QUERY:


-- some complex joins on the source side

CREATE TABLE cj_target (tid integer, balance float, val text)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE cj_source1 (sid1 integer, scat integer, delta integer)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE cj_source2 (sid2 integer, sval text)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

INSERT INTO cj_source1 VALUES (1, 10, 100);
RESULT:
	[]

-----------
QUERY:

INSERT INTO cj_source1 VALUES (1, 20, 200);
RESULT:
	[]

-----------
QUERY:

INSERT INTO cj_source1 VALUES (2, 20, 300);
RESULT:
	[]

-----------
QUERY:

INSERT INTO cj_source1 VALUES (3, 10, 400);
RESULT:
	[]

-----------
QUERY:

INSERT INTO cj_source2 VALUES (1, 'initial source2');
RESULT:
	[]

-----------
QUERY:

INSERT INTO cj_source2 VALUES (2, 'initial source2');
RESULT:
	[]

-----------
QUERY:

INSERT INTO cj_source2 VALUES (3, 'initial source2');
RESULT:
	[]

-----------
QUERY:


-- source relation is an unaliased join
MERGE INTO cj_target t
USING cj_source1 s1
	INNER JOIN cj_source2 s2 ON sid1 = sid2
ON t.tid = sid1
WHEN NOT MATCHED THEN
	INSERT VALUES (sid1, delta, sval);
RESULT:
	[]

-----------
QUERY:


-- try accessing columns from either side of the source join
MERGE INTO cj_target t
USING cj_source2 s2
	INNER JOIN cj_source1 s1 ON sid1 = sid2 AND scat = 20
ON t.tid = sid1
WHEN NOT MATCHED THEN
	INSERT VALUES (sid2, delta, sval)
WHEN MATCHED THEN
	DELETE;
RESULT:
	[]

-----------
QUERY:


-- some simple expressions in INSERT targetlist
MERGE INTO cj_target t
USING cj_source2 s2
	INNER JOIN cj_source1 s1 ON sid1 = sid2
ON t.tid = sid1
WHEN NOT MATCHED THEN
	INSERT VALUES (sid2, delta + scat, sval)
WHEN MATCHED THEN
	UPDATE SET val = val || ' updated by merge';
RESULT:
	[]

-----------
QUERY:


MERGE INTO cj_target t
USING cj_source2 s2
	INNER JOIN cj_source1 s1 ON sid1 = sid2 AND scat = 20
ON t.tid = sid1
WHEN MATCHED THEN
	UPDATE SET val = val || ' ' || delta::text;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM cj_target;
RESULT:
	[(3, 400.0, 'initial source2 updated by merge'), (1, 220.0, 'initial source2 200'), (1, 110.0, 'initial source2 200'), (2, 320.0, 'initial source2 300')]

-----------
QUERY:


-- try it with an outer join and PlaceHolderVar
MERGE INTO cj_target t
USING (SELECT *, 'join input'::text AS phv FROM cj_source1) fj
	FULL JOIN cj_source2 fj2 ON fj.scat = fj2.sid2 * 10
ON t.tid = fj.scat
WHEN NOT MATCHED THEN
	INSERT (tid, balance, val) VALUES (fj.scat, fj.delta, fj.phv);
RESULT:
	[]

-----------
QUERY:


SELECT * FROM cj_target;
RESULT:
	[(3, 400.0, 'initial source2 updated by merge'), (1, 220.0, 'initial source2 200'), (1, 110.0, 'initial source2 200'), (2, 320.0, 'initial source2 300'), (10, 100.0, 'join input'), (10, 400.0, 'join input'), (20, 200.0, 'join input'), (20, 300.0, 'join input'), (None, None, None)]

-----------
QUERY:


ALTER TABLE cj_source1 RENAME COLUMN sid1 TO sid;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE cj_source2 RENAME COLUMN sid2 TO sid;
RESULT:
	[]

-----------
QUERY:


TRUNCATE cj_target;
RESULT:
	[]

-----------
QUERY:


MERGE INTO cj_target t
USING cj_source1 s1
	INNER JOIN cj_source2 s2 ON s1.sid = s2.sid
ON t.tid = s1.sid
WHEN NOT MATCHED THEN
	INSERT VALUES (s2.sid, delta, sval);
RESULT:
	[]

-----------
QUERY:


DROP TABLE cj_source2, cj_source1, cj_target;
RESULT:
	[]

-----------
QUERY:


-- Function scans
CREATE TABLE fs_target (a int, b int, c text)
  WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

MERGE INTO fs_target t
USING generate_series(1,100,1) AS id
ON t.a = id
WHEN MATCHED THEN
	UPDATE SET b = b + id
WHEN NOT MATCHED THEN
	INSERT VALUES (id, -1);
RESULT:
	[]

-----------
QUERY:


MERGE INTO fs_target t
USING generate_series(1,100,2) AS id
ON t.a = id
WHEN MATCHED THEN
	UPDATE SET b = b + id, c = 'updated '|| id.*::text
WHEN NOT MATCHED THEN
	INSERT VALUES (id, -1, 'inserted ' || id.*::text);
RESULT:
	[]

-----------
QUERY:


SELECT count(*) FROM fs_target;
RESULT:
	[(100,)]

-----------
QUERY:

DROP TABLE fs_target;
RESULT:
	[]

-----------
QUERY:


-- SERIALIZABLE test
-- handled in isolation tests

-- Inheritance-based partitioning
CREATE TABLE measurement (
    city_id         int not null,
    logdate         date not null,
    peaktemp        int,
    unitsales       int
) WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE measurement_y2006m02 (
    CHECK ( logdate >= DATE '2006-02-01' AND logdate < DATE '2006-03-01' )
) INHERITS (measurement) WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE measurement_y2006m03 (
    CHECK ( logdate >= DATE '2006-03-01' AND logdate < DATE '2006-04-01' )
) INHERITS (measurement) WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE measurement_y2007m01 (
    filler          text,
    peaktemp        int,
    logdate         date not null,
    city_id         int not null,
    unitsales       int
    CHECK ( logdate >= DATE '2007-01-01' AND logdate < DATE '2007-02-01')
) WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE measurement_y2007m01 DROP COLUMN filler;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE measurement_y2007m01 INHERIT measurement;
RESULT:
	[]

-----------
QUERY:

INSERT INTO measurement VALUES (0, '2005-07-21', 5, 15);
RESULT:
	[]

-----------
QUERY:


CREATE OR REPLACE FUNCTION measurement_insert_trigger()
RETURNS TRIGGER AS $$
BEGIN
    IF ( NEW.logdate >= DATE '2006-02-01' AND
         NEW.logdate < DATE '2006-03-01' ) THEN
        INSERT INTO measurement_y2006m02 VALUES (NEW.*);
    ELSIF ( NEW.logdate >= DATE '2006-03-01' AND
            NEW.logdate < DATE '2006-04-01' ) THEN
        INSERT INTO measurement_y2006m03 VALUES (NEW.*);
    ELSIF ( NEW.logdate >= DATE '2007-01-01' AND
            NEW.logdate < DATE '2007-02-01' ) THEN
        INSERT INTO measurement_y2007m01 (city_id, logdate, peaktemp, unitsales)
            VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 'Date out of range.  Fix the measurement_insert_trigger() function!';
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql ;
RESULT:
	[]

-----------
QUERY:

CREATE TRIGGER insert_measurement_trigger
    BEFORE INSERT ON measurement
    FOR EACH ROW EXECUTE PROCEDURE measurement_insert_trigger();
RESULT:
	[]

-----------
QUERY:

INSERT INTO measurement VALUES (1, '2006-02-10', 35, 10);
RESULT:
	[]

-----------
QUERY:

INSERT INTO measurement VALUES (1, '2006-02-16', 45, 20);
RESULT:
	[]

-----------
QUERY:

INSERT INTO measurement VALUES (1, '2006-03-17', 25, 10);
RESULT:
	[]

-----------
QUERY:

INSERT INTO measurement VALUES (1, '2006-03-27', 15, 40);
RESULT:
	[]

-----------
QUERY:

INSERT INTO measurement VALUES (1, '2007-01-15', 10, 10);
RESULT:
	[]

-----------
QUERY:

INSERT INTO measurement VALUES (1, '2007-01-17', 10, 10);
RESULT:
	[]

-----------
QUERY:


SELECT tableoid::regclass, * FROM measurement ORDER BY city_id, logdate;
RESULT:
	[('measurement', 0, datetime.date(2005, 7, 21), 5, 15), ('measurement_y2006m02', 1, datetime.date(2006, 2, 10), 35, 10), ('measurement_y2006m02', 1, datetime.date(2006, 2, 16), 45, 20), ('measurement_y2006m03', 1, datetime.date(2006, 3, 17), 25, 10), ('measurement_y2006m03', 1, datetime.date(2006, 3, 27), 15, 40), ('measurement_y2007m01', 1, datetime.date(2007, 1, 15), 10, 10), ('measurement_y2007m01', 1, datetime.date(2007, 1, 17), 10, 10)]

-----------
QUERY:


CREATE TABLE new_measurement (LIKE measurement) WITH (autovacuum_enabled=off);
RESULT:
	[]

-----------
QUERY:

INSERT INTO new_measurement VALUES (0, '2005-07-21', 25, 20);
RESULT:
	[]

-----------
QUERY:

INSERT INTO new_measurement VALUES (1, '2006-03-01', 20, 10);
RESULT:
	[]

-----------
QUERY:

INSERT INTO new_measurement VALUES (1, '2006-02-16', 50, 10);
RESULT:
	[]

-----------
QUERY:

INSERT INTO new_measurement VALUES (2, '2006-02-10', 20, 20);
RESULT:
	[]

-----------
QUERY:

INSERT INTO new_measurement VALUES (1, '2006-03-27', NULL, NULL);
RESULT:
	[]

-----------
QUERY:

INSERT INTO new_measurement VALUES (1, '2007-01-17', NULL, NULL);
RESULT:
	[]

-----------
QUERY:

INSERT INTO new_measurement VALUES (1, '2007-01-15', 5, NULL);
RESULT:
	[]

-----------
QUERY:

INSERT INTO new_measurement VALUES (1, '2007-01-16', 10, 10);
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO ONLY measurement m
 USING new_measurement nm ON
      (m.city_id = nm.city_id and m.logdate=nm.logdate)
WHEN MATCHED AND nm.peaktemp IS NULL THEN DELETE
WHEN MATCHED THEN UPDATE
     SET peaktemp = greatest(m.peaktemp, nm.peaktemp),
        unitsales = m.unitsales + coalesce(nm.unitsales, 0)
WHEN NOT MATCHED THEN INSERT
     (city_id, logdate, peaktemp, unitsales)
   VALUES (city_id, logdate, peaktemp, unitsales);
RESULT:
	[]

-----------
QUERY:


SELECT tableoid::regclass, * FROM measurement ORDER BY city_id, logdate, peaktemp;
RESULT:
	[('measurement', 0, datetime.date(2005, 7, 21), 25, 35), ('measurement_y2006m02', 1, datetime.date(2006, 2, 10), 35, 10), ('measurement_y2006m02', 1, datetime.date(2006, 2, 16), 45, 20), ('measurement_y2006m02', 1, datetime.date(2006, 2, 16), 50, 10), ('measurement_y2006m03', 1, datetime.date(2006, 3, 1), 20, 10), ('measurement_y2006m03', 1, datetime.date(2006, 3, 17), 25, 10), ('measurement_y2006m03', 1, datetime.date(2006, 3, 27), 15, 40), ('measurement_y2006m03', 1, datetime.date(2006, 3, 27), None, None), ('measurement_y2007m01', 1, datetime.date(2007, 1, 15), 5, None), ('measurement_y2007m01', 1, datetime.date(2007, 1, 15), 10, 10), ('measurement_y2007m01', 1, datetime.date(2007, 1, 16), 10, 10), ('measurement_y2007m01', 1, datetime.date(2007, 1, 17), 10, 10), ('measurement_y2007m01', 1, datetime.date(2007, 1, 17), None, None), ('measurement_y2006m02', 2, datetime.date(2006, 2, 10), 20, 20)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


MERGE into measurement m
 USING new_measurement nm ON
      (m.city_id = nm.city_id and m.logdate=nm.logdate)
WHEN MATCHED AND nm.peaktemp IS NULL THEN DELETE
WHEN MATCHED THEN UPDATE
     SET peaktemp = greatest(m.peaktemp, nm.peaktemp),
        unitsales = m.unitsales + coalesce(nm.unitsales, 0)
WHEN NOT MATCHED THEN INSERT
     (city_id, logdate, peaktemp, unitsales)
   VALUES (city_id, logdate, peaktemp, unitsales);
RESULT:
	[]

-----------
QUERY:


SELECT tableoid::regclass, * FROM measurement ORDER BY city_id, logdate;
RESULT:
	[('measurement', 0, datetime.date(2005, 7, 21), 25, 35), ('measurement_y2006m02', 1, datetime.date(2006, 2, 10), 35, 10), ('measurement_y2006m02', 1, datetime.date(2006, 2, 16), 50, 30), ('measurement_y2006m03', 1, datetime.date(2006, 3, 1), 20, 10), ('measurement_y2006m03', 1, datetime.date(2006, 3, 17), 25, 10), ('measurement_y2007m01', 1, datetime.date(2007, 1, 15), 10, 10), ('measurement_y2007m01', 1, datetime.date(2007, 1, 16), 10, 10), ('measurement_y2006m02', 2, datetime.date(2006, 2, 10), 20, 20)]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO new_measurement nm
 USING ONLY measurement m ON
      (nm.city_id = m.city_id and nm.logdate=m.logdate)
WHEN MATCHED THEN DELETE;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM new_measurement ORDER BY city_id, logdate;
RESULT:
	[(1, datetime.date(2006, 2, 16), 50, 10), (1, datetime.date(2006, 3, 1), 20, 10), (1, datetime.date(2006, 3, 27), None, None), (1, datetime.date(2007, 1, 15), 5, None), (1, datetime.date(2007, 1, 16), 10, 10), (1, datetime.date(2007, 1, 17), None, None), (2, datetime.date(2006, 2, 10), 20, 20)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


MERGE INTO new_measurement nm
 USING measurement m ON
      (nm.city_id = m.city_id and nm.logdate=m.logdate)
WHEN MATCHED THEN DELETE;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM new_measurement ORDER BY city_id, logdate;
RESULT:
	[(1, datetime.date(2006, 3, 27), None, None), (1, datetime.date(2007, 1, 17), None, None)]

-----------
QUERY:


DROP TABLE measurement, new_measurement CASCADE;
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION measurement_insert_trigger();
RESULT:
	[]

-----------
QUERY:


-- prepare

RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

DROP TABLE target, target2;
RESULT:
	[]

-----------
QUERY:

DROP TABLE source, source2;
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION merge_trigfunc();
RESULT:
	[]

-----------
QUERY:

DROP USER regress_merge_privs;
RESULT:
	[]

-----------
QUERY:

DROP USER regress_merge_no_privs;
RESULT:
	[]

-----------
QUERY:

DROP USER regress_merge_none;
RESULT:
	[]
