-- directory paths and dlsuffix are passed to us in environment variables
-- \getenv libdir ''/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress''
-- \getenv dlsuffix ''.so''

-- \set regresslib /* REPLACED */ ''/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress'' ''/regress'' /* REPLACED */ ''.so''

--
-- num_nulls()
--

SELECT num_nonnulls(NULL)
RESULT: 
	[(0,)]

SELECT num_nonnulls('1')
RESULT: 
	[(1,)]

SELECT num_nonnulls(NULL::text)
RESULT: 
	[(0,)]

SELECT num_nonnulls(NULL::text, NULL::int)
RESULT: 
	[(0,)]

SELECT num_nonnulls(1, 2, NULL::text, NULL::point, '', int8 '9', 1.0 / NULL)
RESULT: 
	[(4,)]

SELECT num_nonnulls(VARIADIC '{1,2,NULL,3}'::int[])
RESULT: 
	[(3,)]

SELECT num_nonnulls(VARIADIC '{"1","2","3","4"}'::text[])
RESULT: 
	[(4,)]

SELECT num_nonnulls(VARIADIC ARRAY(SELECT CASE WHEN i <> 40 THEN i END FROM generate_series(1, 100) i))
RESULT: 
	[(99,)]


SELECT num_nulls(NULL)
RESULT: 
	[(1,)]

SELECT num_nulls('1')
RESULT: 
	[(0,)]

SELECT num_nulls(NULL::text)
RESULT: 
	[(1,)]

SELECT num_nulls(NULL::text, NULL::int)
RESULT: 
	[(2,)]

SELECT num_nulls(1, 2, NULL::text, NULL::point, '', int8 '9', 1.0 / NULL)
RESULT: 
	[(3,)]

SELECT num_nulls(VARIADIC '{1,2,NULL,3}'::int[])
RESULT: 
	[(1,)]

SELECT num_nulls(VARIADIC '{"1","2","3","4"}'::text[])
RESULT: 
	[(0,)]

SELECT num_nulls(VARIADIC ARRAY(SELECT CASE WHEN i <> 40 THEN i END FROM generate_series(1, 100) i))
RESULT: 
	[(1,)]


-- special cases
SELECT num_nonnulls(VARIADIC NULL::text[])
RESULT: 
	[(None,)]

SELECT num_nonnulls(VARIADIC '{}'::int[])
RESULT: 
	[(0,)]

SELECT num_nulls(VARIADIC NULL::text[])
RESULT: 
	[(None,)]

SELECT num_nulls(VARIADIC '{}'::int[])
RESULT: 
	[(0,)]


-- should fail, one or more arguments is required
SELECT num_nonnulls()
ProgrammingError: 

-- should fail, one or more arguments is required
SELECT num_nonnulls()

function num_nonnulls() does not exist
LINE 4: SELECT num_nonnulls()
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


SELECT num_nulls()
ProgrammingError: 
SELECT num_nulls()

function num_nulls() does not exist
LINE 2: SELECT num_nulls()
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.



--
-- canonicalize_path()
--

CREATE FUNCTION test_canonicalize_path(text)
   RETURNS text
   AS /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/regress.so'
   LANGUAGE C STRICT IMMUTABLE


SELECT test_canonicalize_path('/')
RESULT: 
	[('/',)]

SELECT test_canonicalize_path('/./abc/def/')
RESULT: 
	[('/abc/def',)]

SELECT test_canonicalize_path('/./../abc/def')
RESULT: 
	[('/abc/def',)]

SELECT test_canonicalize_path('/./../../abc/def/')
RESULT: 
	[('/abc/def',)]

SELECT test_canonicalize_path('/abc/.././def/ghi')
RESULT: 
	[('/def/ghi',)]

SELECT test_canonicalize_path('/abc/./../def/ghi//')
RESULT: 
	[('/def/ghi',)]

SELECT test_canonicalize_path('/abc/def/../..')
RESULT: 
	[('/',)]

SELECT test_canonicalize_path('/abc/def/../../..')
RESULT: 
	[('/',)]

SELECT test_canonicalize_path('/abc/def/../../../../ghi/jkl')
RESULT: 
	[('/ghi/jkl',)]

SELECT test_canonicalize_path('.')
RESULT: 
	[('.',)]

SELECT test_canonicalize_path('./')
RESULT: 
	[('.',)]

SELECT test_canonicalize_path('./abc/..')
RESULT: 
	[('.',)]

SELECT test_canonicalize_path('abc/../')
RESULT: 
	[('.',)]

SELECT test_canonicalize_path('abc/../def')
RESULT: 
	[('def',)]

SELECT test_canonicalize_path('..')
RESULT: 
	[('..',)]

SELECT test_canonicalize_path('../abc/def')
RESULT: 
	[('../abc/def',)]

SELECT test_canonicalize_path('../abc/..')
RESULT: 
	[('..',)]

SELECT test_canonicalize_path('../abc/../def')
RESULT: 
	[('../def',)]

SELECT test_canonicalize_path('../abc/../../def/ghi')
RESULT: 
	[('../../def/ghi',)]

SELECT test_canonicalize_path('./abc/./def/.')
RESULT: 
	[('abc/def',)]

SELECT test_canonicalize_path('./abc/././def/.')
RESULT: 
	[('abc/def',)]

SELECT test_canonicalize_path('./abc/./def/.././ghi/../../../jkl/mno')
RESULT: 
	[('../jkl/mno',)]


--
-- pg_log_backend_memory_contexts()
--
-- Memory contexts are logged and they are not returned to the function.
-- Furthermore, their contents can vary depending on the timing. However,
-- we can at least verify that the code doesn''t fail, and that the
-- permissions are set properly.
--

SELECT pg_log_backend_memory_contexts(pg_backend_pid())
RESULT: 
	[(True,)]


SELECT pg_log_backend_memory_contexts(pid) FROM pg_stat_activity
  WHERE backend_type = 'checkpointer'
RESULT: 
	[(True,)]


CREATE ROLE regress_log_memory


SELECT has_function_privilege('regress_log_memory',
  'pg_log_backend_memory_contexts(integer)', 'EXECUTE')
RESULT: 
	[(False,)]
 -- no

GRANT EXECUTE ON FUNCTION pg_log_backend_memory_contexts(integer)
  TO regress_log_memory


SELECT has_function_privilege('regress_log_memory',
  'pg_log_backend_memory_contexts(integer)', 'EXECUTE')
RESULT: 
	[(True,)]
 -- yes

SET ROLE regress_log_memory

SELECT pg_log_backend_memory_contexts(pg_backend_pid())
RESULT: 
	[(True,)]

RESET ROLE


REVOKE EXECUTE ON FUNCTION pg_log_backend_memory_contexts(integer)
  FROM regress_log_memory


DROP ROLE regress_log_memory


--
-- Test some built-in SRFs
--
-- The outputs of these are variable, so we can''t just print their results
-- directly, but we can at least verify that the code doesn''t fail.
--
select setting as segsize
from pg_settings where name = 'wal_segment_size'
\gset

select count(*) > 0 as ok from pg_ls_waldir()
ProgrammingError: 

--
-- Test some built-in SRFs
--
-- The outputs of these are variable, so we can''t just print their results
-- directly, but we can at least verify that the code doesn''t fail.
--
select setting as segsize
from pg_settings where name = 'wal_segment_size'
\gset

select count(*) > 0 as ok from pg_ls_waldir()

syntax error at or near "\"
LINE 11: \gset
         ^


-- Test ProjectSet as well as FunctionScan
select count(*) > 0 as ok from (select pg_ls_waldir()) ss
RESULT: 
	[(True,)]

-- Test not-run-to-completion cases.
select * from pg_ls_waldir() limit 0
RESULT: 
	[]

select count(*) > 0 as ok from (select * from pg_ls_waldir() limit 1) ss
RESULT: 
	[(True,)]

select (w).size = :segsize as ok
from (select pg_ls_waldir() w) ss where length((w).name) = 24 limit 1
ProgrammingError: 
select (w).size = :segsize as ok
from (select pg_ls_waldir() w) ss where length((w).name) = 24 limit 1

syntax error at or near ":"
LINE 2: select (w).size = :segsize as ok
                          ^



select count(*) >= 0 as ok from pg_ls_archive_statusdir()
RESULT: 
	[(True,)]


-- pg_read_file()
select length(pg_read_file('postmaster.pid')) > 20
RESULT: 
	[(True,)]

select length(pg_read_file('postmaster.pid', 1, 20))
RESULT: 
	[(20,)]

-- Test missing_ok
select pg_read_file('does not exist')
ERROR: 
-- Test missing_ok
select pg_read_file('does not exist')

could not open file "does not exist" for reading: Datei oder Verzeichnis nicht gefunden

 -- error
select pg_read_file('does not exist', true) IS NULL
RESULT: 
	[(True,)]
 -- ok
-- Test invalid argument
select pg_read_file('does not exist', 0, -1)
ERROR:  -- ok
-- Test invalid argument
select pg_read_file('does not exist', 0, -1)

requested length cannot be negative

 -- error
select pg_read_file('does not exist', 0, -1, true)
ERROR:  -- error
select pg_read_file('does not exist', 0, -1, true)

requested length cannot be negative

 -- error

-- pg_read_binary_file()
select length(pg_read_binary_file('postmaster.pid')) > 20
RESULT: 
	[(True,)]

select length(pg_read_binary_file('postmaster.pid', 1, 20))
RESULT: 
	[(20,)]

-- Test missing_ok
select pg_read_binary_file('does not exist')
ERROR: 
-- Test missing_ok
select pg_read_binary_file('does not exist')

could not open file "does not exist" for reading: Datei oder Verzeichnis nicht gefunden

 -- error
select pg_read_binary_file('does not exist', true) IS NULL
RESULT: 
	[(True,)]
 -- ok
-- Test invalid argument
select pg_read_binary_file('does not exist', 0, -1)
ERROR:  -- ok
-- Test invalid argument
select pg_read_binary_file('does not exist', 0, -1)

requested length cannot be negative

 -- error
select pg_read_binary_file('does not exist', 0, -1, true)
ERROR:  -- error
select pg_read_binary_file('does not exist', 0, -1, true)

requested length cannot be negative

 -- error

-- pg_stat_file()
select size > 20, isdir from pg_stat_file('postmaster.pid')
RESULT: 
	[(True, False)]


-- pg_ls_dir()
select * from (select pg_ls_dir('.') a) a where a = 'base' limit 1
RESULT: 
	[('base',)]

-- Test missing_ok (second argument)
select pg_ls_dir('does not exist', false, false)
ERROR: 
-- Test missing_ok (second argument)
select pg_ls_dir('does not exist', false, false)

could not open directory "does not exist": Datei oder Verzeichnis nicht gefunden

 -- error
select pg_ls_dir('does not exist', true, false)
RESULT: 
	[]
 -- ok
-- Test include_dot_dirs (third argument)
select count(*) = 1 as dot_found
  from pg_ls_dir('.', false, true) as ls where ls = '.'
RESULT: 
	[(True,)]

select count(*) = 1 as dot_found
  from pg_ls_dir('.', false, false) as ls where ls = '.'
RESULT: 
	[(False,)]


-- pg_timezone_names()
select * from (select (pg_timezone_names()).name) ptn where name='UTC' limit 1
RESULT: 
	[('UTC',)]


-- pg_tablespace_databases()
select count(*) > 0 from
  (select pg_tablespace_databases(oid) as pts from pg_tablespace
   where spcname = 'pg_default') pts
  join pg_database db on pts.pts = db.oid
RESULT: 
	[(True,)]


--
-- Test replication slot directory functions
--
CREATE ROLE regress_slot_dir_funcs

-- Not available by default.
SELECT has_function_privilege('regress_slot_dir_funcs',
  'pg_ls_logicalsnapdir()', 'EXECUTE')
RESULT: 
	[(False,)]

SELECT has_function_privilege('regress_slot_dir_funcs',
  'pg_ls_logicalmapdir()', 'EXECUTE')
RESULT: 
	[(False,)]

SELECT has_function_privilege('regress_slot_dir_funcs',
  'pg_ls_replslotdir(text)', 'EXECUTE')
RESULT: 
	[(False,)]

GRANT pg_monitor TO regress_slot_dir_funcs

-- Role is now part of pg_monitor, so these are available.
SELECT has_function_privilege('regress_slot_dir_funcs',
  'pg_ls_logicalsnapdir()', 'EXECUTE')
RESULT: 
	[(True,)]

SELECT has_function_privilege('regress_slot_dir_funcs',
  'pg_ls_logicalmapdir()', 'EXECUTE')
RESULT: 
	[(True,)]

SELECT has_function_privilege('regress_slot_dir_funcs',
  'pg_ls_replslotdir(text)', 'EXECUTE')
RESULT: 
	[(True,)]

DROP ROLE regress_slot_dir_funcs


--
-- Test adding a support function to a subject function
--

CREATE FUNCTION my_int_eq(int, int) RETURNS bool
  LANGUAGE internal STRICT IMMUTABLE PARALLEL SAFE
  AS $$int4eq$$


-- By default, planner does not think that''s selective
EXPLAIN (COSTS OFF)
SELECT * FROM tenk1 a JOIN tenk1 b ON a.unique1 = b.unique1
WHERE my_int_eq(a.unique2, 42)
RESULT: 
	[('Hash Join',), ('  Hash Cond: (b.unique1 = a.unique1)',), ('  ->  Seq Scan on tenk1 b',), ('  ->  Hash',), ('        ->  Seq Scan on tenk1 a',), ('              Filter: my_int_eq(unique2, 42)',)]


-- With support function that knows it''s int4eq, we get a different plan
CREATE FUNCTION test_support_func(internal)
    RETURNS internal
    AS /* REPLACED */ '/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/regress.so', 'test_support_func'
    LANGUAGE C STRICT


ALTER FUNCTION my_int_eq(int, int) SUPPORT test_support_func


EXPLAIN (COSTS OFF)
SELECT * FROM tenk1 a JOIN tenk1 b ON a.unique1 = b.unique1
WHERE my_int_eq(a.unique2, 42)
RESULT: 
	[('Nested Loop',), ('  ->  Seq Scan on tenk1 a',), ('        Filter: my_int_eq(unique2, 42)',), ('  ->  Index Scan using tenk1_unique1 on tenk1 b',), ('        Index Cond: (unique1 = a.unique1)',)]


-- Also test non-default rowcount estimate
CREATE FUNCTION my_gen_series(int, int) RETURNS SETOF integer
  LANGUAGE internal STRICT IMMUTABLE PARALLEL SAFE
  AS $$generate_series_int4$$
  SUPPORT test_support_func


EXPLAIN (COSTS OFF)
SELECT * FROM tenk1 a JOIN my_gen_series(1,1000) g ON a.unique1 = g
RESULT: 
	[('Hash Join',), ('  Hash Cond: (g.g = a.unique1)',), ('  ->  Function Scan on my_gen_series g',), ('  ->  Hash',), ('        ->  Seq Scan on tenk1 a',)]


EXPLAIN (COSTS OFF)
SELECT * FROM tenk1 a JOIN my_gen_series(1,10) g ON a.unique1 = g
RESULT: 
	[('Nested Loop',), ('  ->  Function Scan on my_gen_series g',), ('  ->  Index Scan using tenk1_unique1 on tenk1 a',), ('        Index Cond: (unique1 = g.g)',)]


-- Test functions for control data
SELECT count(*) > 0 AS ok FROM pg_control_checkpoint()
RESULT: 
	[(True,)]

SELECT count(*) > 0 AS ok FROM pg_control_init()
RESULT: 
	[(True,)]

SELECT count(*) > 0 AS ok FROM pg_control_recovery()
RESULT: 
	[(True,)]

SELECT count(*) > 0 AS ok FROM pg_control_system()
RESULT: 
	[(True,)]


-- pg_split_walfile_name, pg_walfile_name & pg_walfile_name_offset
SELECT * FROM pg_split_walfile_name(NULL)
RESULT: 
	[(None, None)]

SELECT * FROM pg_split_walfile_name('invalid')
ERROR: 
SELECT * FROM pg_split_walfile_name('invalid')

invalid WAL file name "invalid"


SELECT segment_number > 0 AS ok_segment_number, timeline_id
  FROM pg_split_walfile_name('000000010000000100000000')
RESULT: 
	[(True, 1)]

SELECT segment_number > 0 AS ok_segment_number, timeline_id
  FROM pg_split_walfile_name('ffffffFF00000001000000af')
RESULT: 
	[(True, 4294967295)]

SELECT setting::int8 AS segment_size
FROM pg_settings
WHERE name = 'wal_segment_size'
\gset
SELECT segment_number, file_offset
FROM pg_walfile_name_offset('0/0'::pg_lsn + :segment_size),
     pg_split_walfile_name(file_name)
ProgrammingError: 
SELECT setting::int8 AS segment_size
FROM pg_settings
WHERE name = 'wal_segment_size'
\gset
SELECT segment_number, file_offset
FROM pg_walfile_name_offset('0/0'::pg_lsn + :segment_size),
     pg_split_walfile_name(file_name)

syntax error at or near "\"
LINE 5: \gset
        ^


SELECT segment_number, file_offset
FROM pg_walfile_name_offset('0/0'::pg_lsn + :segment_size + 1),
     pg_split_walfile_name(file_name)
ProgrammingError: 
SELECT segment_number, file_offset
FROM pg_walfile_name_offset('0/0'::pg_lsn + :segment_size + 1),
     pg_split_walfile_name(file_name)

syntax error at or near ":"
LINE 3: FROM pg_walfile_name_offset('0/0'::pg_lsn + :segment_size + ...
                                                    ^


SELECT segment_number, file_offset = :segment_size - 1
FROM pg_walfile_name_offset('0/0'::pg_lsn + :segment_size - 1),
     pg_split_walfile_name(file_name)
ProgrammingError: 
SELECT segment_number, file_offset = :segment_size - 1
FROM pg_walfile_name_offset('0/0'::pg_lsn + :segment_size - 1),
     pg_split_walfile_name(file_name)

syntax error at or near ":"
LINE 2: SELECT segment_number, file_offset = :segment_size - 1
                                             ^



-- test stratnum support functions
SELECT gist_stratnum_identity(3::smallint)
RESULT: 
	[(3,)]

SELECT gist_stratnum_identity(18::smallint)
RESULT: 
	[(18,)]


-- pg_current_logfile
CREATE ROLE regress_current_logfile

-- not available by default
SELECT has_function_privilege('regress_current_logfile',
  'pg_current_logfile()', 'EXECUTE')
RESULT: 
	[(False,)]

GRANT pg_monitor TO regress_current_logfile

-- role has privileges of pg_monitor and can execute the function
SELECT has_function_privilege('regress_current_logfile',
  'pg_current_logfile()', 'EXECUTE')
RESULT: 
	[(True,)]

DROP ROLE regress_current_logfile


-- pg_column_toast_chunk_id
CREATE TABLE test_chunk_id (a TEXT, b TEXT STORAGE EXTERNAL)

INSERT INTO test_chunk_id VALUES ('x', repeat('x', 8192))

SELECT t.relname AS toastrel FROM pg_class c
  LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
  WHERE c.relname = 'test_chunk_id'
\gset
SELECT pg_column_toast_chunk_id(a) IS NULL,
  pg_column_toast_chunk_id(b) IN (SELECT chunk_id FROM pg_toast.:toastrel)
  FROM test_chunk_id
ProgrammingError: 
SELECT t.relname AS toastrel FROM pg_class c
  LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
  WHERE c.relname = 'test_chunk_id'
\gset
SELECT pg_column_toast_chunk_id(a) IS NULL,
  pg_column_toast_chunk_id(b) IN (SELECT chunk_id FROM pg_toast.:toastrel)
  FROM test_chunk_id

syntax error at or near "\"
LINE 5: \gset
        ^


DROP TABLE test_chunk_id


