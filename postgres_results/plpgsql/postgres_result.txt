
-----------
QUERY:
--
-- PLPGSQL
--
-- Scenario:
--
--     A building with a modern TP cable installation where any
--     of the wall connectors can be used to plug in phones,
--     ethernet interfaces or local office hubs. The backside
--     of the wall connectors is wired to one of several patch-
--     fields in the building.
--
--     In the patchfields, there are hubs and all the slots
--     representing the wall connectors. In addition there are
--     slots that can represent a phone line from the central
--     phone system.
--
--     Triggers ensure consistency of the patching information.
--
--     Functions are used to build up powerful views that let
--     you look behind the wall when looking at a patchfield
--     or into a room.
--


create table Room (
    roomno	char(8),
    comment	text
);
RESULT:
	[]

-----------
QUERY:


create unique index Room_rno on Room using btree (roomno bpchar_ops);
RESULT:
	[]

-----------
QUERY:



create table WSlot (
    slotname	char(20),
    roomno	char(8),
    slotlink	char(20),
    backlink	char(20)
);
RESULT:
	[]

-----------
QUERY:


create unique index WSlot_name on WSlot using btree (slotname bpchar_ops);
RESULT:
	[]

-----------
QUERY:



create table PField (
    name	text,
    comment	text
);
RESULT:
	[]

-----------
QUERY:


create unique index PField_name on PField using btree (name text_ops);
RESULT:
	[]

-----------
QUERY:



create table PSlot (
    slotname	char(20),
    pfname	text,
    slotlink	char(20),
    backlink	char(20)
);
RESULT:
	[]

-----------
QUERY:


create unique index PSlot_name on PSlot using btree (slotname bpchar_ops);
RESULT:
	[]

-----------
QUERY:



create table PLine (
    slotname	char(20),
    phonenumber	char(20),
    comment	text,
    backlink	char(20)
);
RESULT:
	[]

-----------
QUERY:


create unique index PLine_name on PLine using btree (slotname bpchar_ops);
RESULT:
	[]

-----------
QUERY:



create table Hub (
    name	char(14),
    comment	text,
    nslots	integer
);
RESULT:
	[]

-----------
QUERY:


create unique index Hub_name on Hub using btree (name bpchar_ops);
RESULT:
	[]

-----------
QUERY:



create table HSlot (
    slotname	char(20),
    hubname	char(14),
    slotno	integer,
    slotlink	char(20)
);
RESULT:
	[]

-----------
QUERY:


create unique index HSlot_name on HSlot using btree (slotname bpchar_ops);
RESULT:
	[]

-----------
QUERY:

create index HSlot_hubname on HSlot using btree (hubname bpchar_ops);
RESULT:
	[]

-----------
QUERY:



create table System (
    name	text,
    comment	text
);
RESULT:
	[]

-----------
QUERY:


create unique index System_name on System using btree (name text_ops);
RESULT:
	[]

-----------
QUERY:



create table IFace (
    slotname	char(20),
    sysname	text,
    ifname	text,
    slotlink	char(20)
);
RESULT:
	[]

-----------
QUERY:


create unique index IFace_name on IFace using btree (slotname bpchar_ops);
RESULT:
	[]

-----------
QUERY:



create table PHone (
    slotname	char(20),
    comment	text,
    slotlink	char(20)
);
RESULT:
	[]

-----------
QUERY:


create unique index PHone_name on PHone using btree (slotname bpchar_ops);
RESULT:
	[]

-----------
QUERY:



-- ************************************************************
-- *
-- * Trigger procedures and functions for the patchfield
-- * test of PL/pgSQL
-- *
-- ************************************************************


-- ************************************************************
-- * AFTER UPDATE on Room
-- *	- If room no changes let wall slots follow
-- ************************************************************
create function tg_room_au() returns trigger as '
begin
    if new.roomno != old.roomno then
        update WSlot set roomno = new.roomno where roomno = old.roomno;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.roomno != old.roomno then
        update WSlot set roomno = new.roomno where roomno = old.roomno;"
LINE 16: create function tg_room_au() returns trigger as '
                                                         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_room_au after update
    on Room for each row execute procedure tg_room_au();
RESULT:
	ERROR - function tg_room_au() does not exist


-----------
QUERY:



-- ************************************************************
-- * AFTER DELETE on Room
-- *	- delete wall slots in this room
-- ************************************************************
create function tg_room_ad() returns trigger as '
begin
    delete from WSlot where roomno = old.roomno;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    delete from WSlot where roomno = old.roomno;"
LINE 8: create function tg_room_ad() returns trigger as '
                                                        ^


-----------
QUERY:

    return old;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return old;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_room_ad after delete
    on Room for each row execute procedure tg_room_ad();
RESULT:
	ERROR - function tg_room_ad() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE INSERT or UPDATE on WSlot
-- *	- Check that room exists
-- ************************************************************
create function tg_wslot_biu() returns trigger as $$
begin
    if count(*) = 0 from Room where roomno = new.roomno then
        raise exception 'Room % does not exist', new.roomno;
    end if;
    return new;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


create trigger tg_wslot_biu before insert or update
    on WSlot for each row execute procedure tg_wslot_biu();
RESULT:
	[]

-----------
QUERY:



-- ************************************************************
-- * AFTER UPDATE on PField
-- *	- Let PSlots of this field follow
-- ************************************************************
create function tg_pfield_au() returns trigger as '
begin
    if new.name != old.name then
        update PSlot set pfname = new.name where pfname = old.name;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.name != old.name then
        update PSlot set pfname = new.name where pfname = old.name;"
LINE 8: create function tg_pfield_au() returns trigger as '
                                                          ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_pfield_au after update
    on PField for each row execute procedure tg_pfield_au();
RESULT:
	ERROR - function tg_pfield_au() does not exist


-----------
QUERY:



-- ************************************************************
-- * AFTER DELETE on PField
-- *	- Remove all slots of this patchfield
-- ************************************************************
create function tg_pfield_ad() returns trigger as '
begin
    delete from PSlot where pfname = old.name;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    delete from PSlot where pfname = old.name;"
LINE 8: create function tg_pfield_ad() returns trigger as '
                                                          ^


-----------
QUERY:

    return old;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return old;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_pfield_ad after delete
    on PField for each row execute procedure tg_pfield_ad();
RESULT:
	ERROR - function tg_pfield_ad() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE INSERT or UPDATE on PSlot
-- *	- Ensure that our patchfield does exist
-- ************************************************************
create function tg_pslot_biu() returns trigger as $proc$
declare
    pfrec	record;
RESULT:
	ERROR - unterminated dollar-quoted string at or near "$proc$
declare
    pfrec	record;"
LINE 8: create function tg_pslot_biu() returns trigger as $proc$
                                                          ^


-----------
QUERY:

    ps          alias for new;
RESULT:
	ERROR - syntax error at or near "ps"
LINE 2:     ps          alias for new;
            ^


-----------
QUERY:

begin
    select into pfrec * from PField where name = ps.pfname;
RESULT:
	ERROR - syntax error at or near "select"
LINE 3:     select into pfrec * from PField where name = ps.pfname;
            ^


-----------
QUERY:

    if not found then
        raise exception $$Patchfield "%" does not exist$$, ps.pfname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if not found then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return ps;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return ps;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

$proc$ language plpgsql;
RESULT:
	ERROR - unterminated dollar-quoted string at or near "$proc$ language plpgsql;"
LINE 2: $proc$ language plpgsql;
        ^


-----------
QUERY:


create trigger tg_pslot_biu before insert or update
    on PSlot for each row execute procedure tg_pslot_biu();
RESULT:
	ERROR - function tg_pslot_biu() does not exist


-----------
QUERY:



-- ************************************************************
-- * AFTER UPDATE on System
-- *	- If system name changes let interfaces follow
-- ************************************************************
create function tg_system_au() returns trigger as '
begin
    if new.name != old.name then
        update IFace set sysname = new.name where sysname = old.name;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.name != old.name then
        update IFace set sysname = new.name where sysname = old.name;"
LINE 8: create function tg_system_au() returns trigger as '
                                                          ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_system_au after update
    on System for each row execute procedure tg_system_au();
RESULT:
	ERROR - function tg_system_au() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE INSERT or UPDATE on IFace
-- *	- set the slotname to IF.sysname.ifname
-- ************************************************************
create function tg_iface_biu() returns trigger as $$
declare
    sname	text;
    sysrec	record;
begin
    select into sysrec * from system where name = new.sysname;
    if not found then
        raise exception $q$system "%" does not exist$q$, new.sysname;
    end if;
    sname := 'IF.' || new.sysname;
    sname := sname || '.';
    sname := sname || new.ifname;
    if length(sname) > 20 then
        raise exception 'IFace slotname "%" too long (20 char max)', sname;
    end if;
    new.slotname := sname;
    return new;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


create trigger tg_iface_biu before insert or update
    on IFace for each row execute procedure tg_iface_biu();
RESULT:
	[]

-----------
QUERY:



-- ************************************************************
-- * AFTER INSERT or UPDATE or DELETE on Hub
-- *	- insert/delete/rename slots as required
-- ************************************************************
create function tg_hub_a() returns trigger as '
declare
    hname	text;
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    hname	text;"
LINE 8: create function tg_hub_a() returns trigger as '
                                                      ^


-----------
QUERY:

    dummy	integer;
RESULT:
	ERROR - syntax error at or near "dummy"
LINE 2:     dummy integer;
            ^


-----------
QUERY:

begin
    if tg_op = ''INSERT'' then
	dummy := tg_hub_adjustslots(new.name, 0, new.nslots);
RESULT:
	ERROR - syntax error at or near "if"
LINE 3:     if tg_op = ''INSERT'' then
            ^


-----------
QUERY:

	return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return new;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if tg_op = ''UPDATE'' then
	if new.name != old.name then
	    update HSlot set hubname = new.name where hubname = old.name;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if tg_op = ''UPDATE'' then
            ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	dummy := tg_hub_adjustslots(new.name, old.nslots, new.nslots);
RESULT:
	ERROR - syntax error at or near "dummy"
LINE 2:  dummy := tg_hub_adjustslots(new.name, old.nslots, new.nslot...
         ^


-----------
QUERY:

	return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return new;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if tg_op = ''DELETE'' then
	dummy := tg_hub_adjustslots(old.name, old.nslots, 0);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if tg_op = ''DELETE'' then
            ^


-----------
QUERY:

	return old;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return old;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_hub_a after insert or update or delete
    on Hub for each row execute procedure tg_hub_a();
RESULT:
	ERROR - function tg_hub_a() does not exist


-----------
QUERY:



-- ************************************************************
-- * Support function to add/remove slots of Hub
-- ************************************************************
create function tg_hub_adjustslots(hname bpchar,
                                   oldnslots integer,
                                   newnslots integer)
returns integer as '
begin
    if newnslots = oldnslots then
        return 0;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if newnslots = oldnslots then
        return 0;"
LINE 10: returns integer as '
                            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if newnslots < oldnslots then
        delete from HSlot where hubname = hname and slotno > newnslots;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if newnslots < oldnslots then
            ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    for i in oldnslots + 1 .. newnslots loop
        insert into HSlot (slotname, hubname, slotno, slotlink)
		values (''HS.dummy'', hname, i, '''');
RESULT:
	ERROR - syntax error at or near "for"
LINE 2:     for i in oldnslots + 1 .. newnslots loop
            ^


-----------
QUERY:

    end loop;
RESULT:
	ERROR - syntax error at or near "loop"
LINE 2:     end loop;
                ^


-----------
QUERY:

    return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return 0;
            ^


-----------
QUERY:

end
' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 3: ' language plpgsql;
        ^


-----------
QUERY:


-- Test comments
COMMENT ON FUNCTION tg_hub_adjustslots_wrong(bpchar, integer, integer) IS 'function with args';
RESULT:
	ERROR - function tg_hub_adjustslots_wrong(character, integer, integer) does not exist


-----------
QUERY:

COMMENT ON FUNCTION tg_hub_adjustslots(bpchar, integer, integer) IS 'function with args';
RESULT:
	ERROR - function tg_hub_adjustslots(character, integer, integer) does not exist


-----------
QUERY:

COMMENT ON FUNCTION tg_hub_adjustslots(bpchar, integer, integer) IS NULL;
RESULT:
	ERROR - function tg_hub_adjustslots(character, integer, integer) does not exist


-----------
QUERY:


-- ************************************************************
-- * BEFORE INSERT or UPDATE on HSlot
-- *	- prevent from manual manipulation
-- *	- set the slotname to HS.hubname.slotno
-- ************************************************************
create function tg_hslot_biu() returns trigger as '
declare
    sname	text;
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    sname	text;"
LINE 8: create function tg_hslot_biu() returns trigger as '
                                                          ^


-----------
QUERY:

    xname	HSlot.slotname%TYPE;
RESULT:
	ERROR - syntax error at or near "xname"
LINE 2:     xname HSlot.slotname%TYPE;
            ^


-----------
QUERY:

    hubrec	record;
RESULT:
	ERROR - syntax error at or near "hubrec"
LINE 2:     hubrec record;
            ^


-----------
QUERY:

begin
    select into hubrec * from Hub where name = new.hubname;
RESULT:
	ERROR - syntax error at or near "select"
LINE 3:     select into hubrec * from Hub where name = new.hubname;
            ^


-----------
QUERY:

    if not found then
        raise exception ''no manual manipulation of HSlot'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if not found then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if new.slotno < 1 or new.slotno > hubrec.nslots then
        raise exception ''no manual manipulation of HSlot'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if new.slotno < 1 or new.slotno > hubrec.nslots then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if tg_op = ''UPDATE'' and new.hubname != old.hubname then
	if count(*) > 0 from Hub where name = old.hubname then
	    raise exception ''no manual manipulation of HSlot'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if tg_op = ''UPDATE'' and new.hubname != old.hubname the...
            ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    sname := ''HS.'' || trim(new.hubname);
RESULT:
	ERROR - syntax error at or near "sname"
LINE 2:     sname := ''HS.'' || trim(new.hubname);
            ^


-----------
QUERY:

    sname := sname || ''.'';
RESULT:
	ERROR - syntax error at or near "sname"
LINE 2:     sname := sname || ''.'';
            ^


-----------
QUERY:

    sname := sname || new.slotno::text;
RESULT:
	ERROR - syntax error at or near "sname"
LINE 2:     sname := sname || new.slotno::text;
            ^


-----------
QUERY:

    if length(sname) > 20 then
        raise exception ''HSlot slotname "%" too long (20 char max)'', sname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if length(sname) > 20 then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    new.slotname := sname;
RESULT:
	ERROR - syntax error at or near "new"
LINE 2:     new.slotname := sname;
            ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_hslot_biu before insert or update
    on HSlot for each row execute procedure tg_hslot_biu();
RESULT:
	ERROR - function tg_hslot_biu() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE DELETE on HSlot
-- *	- prevent from manual manipulation
-- ************************************************************
create function tg_hslot_bd() returns trigger as '
declare
    hubrec	record;
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    hubrec	record;"
LINE 8: create function tg_hslot_bd() returns trigger as '
                                                         ^


-----------
QUERY:

begin
    select into hubrec * from Hub where name = old.hubname;
RESULT:
	ERROR - syntax error at or near "select"
LINE 3:     select into hubrec * from Hub where name = old.hubname;
            ^


-----------
QUERY:

    if not found then
        return old;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if not found then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if old.slotno > hubrec.nslots then
        return old;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if old.slotno > hubrec.nslots then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    raise exception ''no manual manipulation of HSlot'';
RESULT:
	ERROR - syntax error at or near "raise"
LINE 2:     raise exception ''no manual manipulation of HSlot'';
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_hslot_bd before delete
    on HSlot for each row execute procedure tg_hslot_bd();
RESULT:
	ERROR - function tg_hslot_bd() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE INSERT on all slots
-- *	- Check name prefix
-- ************************************************************
create function tg_chkslotname() returns trigger as '
begin
    if substr(new.slotname, 1, 2) != tg_argv[0] then
        raise exception ''slotname must begin with %'', tg_argv[0];
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if substr(new.slotname, 1, 2) != tg_argv[0] then
        raise exception ''slotname must begin with %'', tg_argv[0];"
LINE 8: create function tg_chkslotname() returns trigger as '
                                                            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_chkslotname before insert
    on PSlot for each row execute procedure tg_chkslotname('PS');
RESULT:
	ERROR - function tg_chkslotname() does not exist


-----------
QUERY:


create trigger tg_chkslotname before insert
    on WSlot for each row execute procedure tg_chkslotname('WS');
RESULT:
	ERROR - function tg_chkslotname() does not exist


-----------
QUERY:


create trigger tg_chkslotname before insert
    on PLine for each row execute procedure tg_chkslotname('PL');
RESULT:
	ERROR - function tg_chkslotname() does not exist


-----------
QUERY:


create trigger tg_chkslotname before insert
    on IFace for each row execute procedure tg_chkslotname('IF');
RESULT:
	ERROR - function tg_chkslotname() does not exist


-----------
QUERY:


create trigger tg_chkslotname before insert
    on PHone for each row execute procedure tg_chkslotname('PH');
RESULT:
	ERROR - function tg_chkslotname() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE INSERT or UPDATE on all slots with slotlink
-- *	- Set slotlink to empty string if NULL value given
-- ************************************************************
create function tg_chkslotlink() returns trigger as '
begin
    if new.slotlink isnull then
        new.slotlink := '''';
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.slotlink isnull then
        new.slotlink := '''';"
LINE 8: create function tg_chkslotlink() returns trigger as '
                                                            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_chkslotlink before insert or update
    on PSlot for each row execute procedure tg_chkslotlink();
RESULT:
	ERROR - function tg_chkslotlink() does not exist


-----------
QUERY:


create trigger tg_chkslotlink before insert or update
    on WSlot for each row execute procedure tg_chkslotlink();
RESULT:
	ERROR - function tg_chkslotlink() does not exist


-----------
QUERY:


create trigger tg_chkslotlink before insert or update
    on IFace for each row execute procedure tg_chkslotlink();
RESULT:
	ERROR - function tg_chkslotlink() does not exist


-----------
QUERY:


create trigger tg_chkslotlink before insert or update
    on HSlot for each row execute procedure tg_chkslotlink();
RESULT:
	ERROR - function tg_chkslotlink() does not exist


-----------
QUERY:


create trigger tg_chkslotlink before insert or update
    on PHone for each row execute procedure tg_chkslotlink();
RESULT:
	ERROR - function tg_chkslotlink() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE INSERT or UPDATE on all slots with backlink
-- *	- Set backlink to empty string if NULL value given
-- ************************************************************
create function tg_chkbacklink() returns trigger as '
begin
    if new.backlink isnull then
        new.backlink := '''';
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.backlink isnull then
        new.backlink := '''';"
LINE 8: create function tg_chkbacklink() returns trigger as '
                                                            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_chkbacklink before insert or update
    on PSlot for each row execute procedure tg_chkbacklink();
RESULT:
	ERROR - function tg_chkbacklink() does not exist


-----------
QUERY:


create trigger tg_chkbacklink before insert or update
    on WSlot for each row execute procedure tg_chkbacklink();
RESULT:
	ERROR - function tg_chkbacklink() does not exist


-----------
QUERY:


create trigger tg_chkbacklink before insert or update
    on PLine for each row execute procedure tg_chkbacklink();
RESULT:
	ERROR - function tg_chkbacklink() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE UPDATE on PSlot
-- *	- do delete/insert instead of update if name changes
-- ************************************************************
create function tg_pslot_bu() returns trigger as '
begin
    if new.slotname != old.slotname then
        delete from PSlot where slotname = old.slotname;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.slotname != old.slotname then
        delete from PSlot where slotname = old.slotname;"
LINE 8: create function tg_pslot_bu() returns trigger as '
                                                         ^


-----------
QUERY:

	insert into PSlot (
		    slotname,
		    pfname,
		    slotlink,
		    backlink
		) values (
		    new.slotname,
		    new.pfname,
		    new.slotlink,
		    new.backlink
		);
RESULT:
	ERROR - missing FROM-clause entry for table "new"
LINE 8:       new.slotname,
              ^


-----------
QUERY:

        return null;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:         return null;
                ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_pslot_bu before update
    on PSlot for each row execute procedure tg_pslot_bu();
RESULT:
	ERROR - function tg_pslot_bu() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE UPDATE on WSlot
-- *	- do delete/insert instead of update if name changes
-- ************************************************************
create function tg_wslot_bu() returns trigger as '
begin
    if new.slotname != old.slotname then
        delete from WSlot where slotname = old.slotname;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.slotname != old.slotname then
        delete from WSlot where slotname = old.slotname;"
LINE 8: create function tg_wslot_bu() returns trigger as '
                                                         ^


-----------
QUERY:

	insert into WSlot (
		    slotname,
		    roomno,
		    slotlink,
		    backlink
		) values (
		    new.slotname,
		    new.roomno,
		    new.slotlink,
		    new.backlink
		);
RESULT:
	ERROR - missing FROM-clause entry for table "new"
LINE 8:       new.slotname,
              ^


-----------
QUERY:

        return null;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:         return null;
                ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_wslot_bu before update
    on WSlot for each row execute procedure tg_Wslot_bu();
RESULT:
	ERROR - function tg_wslot_bu() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE UPDATE on PLine
-- *	- do delete/insert instead of update if name changes
-- ************************************************************
create function tg_pline_bu() returns trigger as '
begin
    if new.slotname != old.slotname then
        delete from PLine where slotname = old.slotname;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.slotname != old.slotname then
        delete from PLine where slotname = old.slotname;"
LINE 8: create function tg_pline_bu() returns trigger as '
                                                         ^


-----------
QUERY:

	insert into PLine (
		    slotname,
		    phonenumber,
		    comment,
		    backlink
		) values (
		    new.slotname,
		    new.phonenumber,
		    new.comment,
		    new.backlink
		);
RESULT:
	ERROR - missing FROM-clause entry for table "new"
LINE 8:       new.slotname,
              ^


-----------
QUERY:

        return null;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:         return null;
                ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_pline_bu before update
    on PLine for each row execute procedure tg_pline_bu();
RESULT:
	ERROR - function tg_pline_bu() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE UPDATE on IFace
-- *	- do delete/insert instead of update if name changes
-- ************************************************************
create function tg_iface_bu() returns trigger as '
begin
    if new.slotname != old.slotname then
        delete from IFace where slotname = old.slotname;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.slotname != old.slotname then
        delete from IFace where slotname = old.slotname;"
LINE 8: create function tg_iface_bu() returns trigger as '
                                                         ^


-----------
QUERY:

	insert into IFace (
		    slotname,
		    sysname,
		    ifname,
		    slotlink
		) values (
		    new.slotname,
		    new.sysname,
		    new.ifname,
		    new.slotlink
		);
RESULT:
	ERROR - missing FROM-clause entry for table "new"
LINE 8:       new.slotname,
              ^


-----------
QUERY:

        return null;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:         return null;
                ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_iface_bu before update
    on IFace for each row execute procedure tg_iface_bu();
RESULT:
	ERROR - function tg_iface_bu() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE UPDATE on HSlot
-- *	- do delete/insert instead of update if name changes
-- ************************************************************
create function tg_hslot_bu() returns trigger as '
begin
    if new.slotname != old.slotname or new.hubname != old.hubname then
        delete from HSlot where slotname = old.slotname;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.slotname != old.slotname or new.hubname != old.hubname then
        delete from HSlot where slotname = old.slotname;"
LINE 8: create function tg_hslot_bu() returns trigger as '
                                                         ^


-----------
QUERY:

	insert into HSlot (
		    slotname,
		    hubname,
		    slotno,
		    slotlink
		) values (
		    new.slotname,
		    new.hubname,
		    new.slotno,
		    new.slotlink
		);
RESULT:
	ERROR - missing FROM-clause entry for table "new"
LINE 8:       new.slotname,
              ^


-----------
QUERY:

        return null;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:         return null;
                ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_hslot_bu before update
    on HSlot for each row execute procedure tg_hslot_bu();
RESULT:
	ERROR - function tg_hslot_bu() does not exist


-----------
QUERY:



-- ************************************************************
-- * BEFORE UPDATE on PHone
-- *	- do delete/insert instead of update if name changes
-- ************************************************************
create function tg_phone_bu() returns trigger as '
begin
    if new.slotname != old.slotname then
        delete from PHone where slotname = old.slotname;
RESULT:
	ERROR - unterminated quoted string at or near "'
begin
    if new.slotname != old.slotname then
        delete from PHone where slotname = old.slotname;"
LINE 8: create function tg_phone_bu() returns trigger as '
                                                         ^


-----------
QUERY:

	insert into PHone (
		    slotname,
		    comment,
		    slotlink
		) values (
		    new.slotname,
		    new.comment,
		    new.slotlink
		);
RESULT:
	ERROR - missing FROM-clause entry for table "new"
LINE 7:       new.slotname,
              ^


-----------
QUERY:

        return null;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:         return null;
                ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return new;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:


create trigger tg_phone_bu before update
    on PHone for each row execute procedure tg_phone_bu();
RESULT:
	ERROR - function tg_phone_bu() does not exist


-----------
QUERY:



-- ************************************************************
-- * AFTER INSERT or UPDATE or DELETE on slot with backlink
-- *	- Ensure that the opponent correctly points back to us
-- ************************************************************
create function tg_backlink_a() returns trigger as '
declare
    dummy	integer;
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    dummy	integer;"
LINE 8: create function tg_backlink_a() returns trigger as '
                                                           ^


-----------
QUERY:

begin
    if tg_op = ''INSERT'' then
        if new.backlink != '''' then
	    dummy := tg_backlink_set(new.backlink, new.slotname);
RESULT:
	ERROR - syntax error at or near "if"
LINE 3:     if tg_op = ''INSERT'' then
            ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return new;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if tg_op = ''UPDATE'' then
        if new.backlink != old.backlink then
	    if old.backlink != '''' then
	        dummy := tg_backlink_unset(old.backlink, old.slotname);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if tg_op = ''UPDATE'' then
            ^


-----------
QUERY:

	    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      end if;
                 ^


-----------
QUERY:

	    if new.backlink != '''' then
	        dummy := tg_backlink_set(new.backlink, new.slotname);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      if new.backlink != '''' then
             ^


-----------
QUERY:

	    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      end if;
                 ^


-----------
QUERY:

	else
	    if new.slotname != old.slotname and new.backlink != '''' then
	        dummy := tg_slotlink_set(new.backlink, new.slotname);
RESULT:
	ERROR - syntax error at or near "else"
LINE 2:  else
         ^


-----------
QUERY:

	    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      end if;
                 ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return new;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if tg_op = ''DELETE'' then
        if old.backlink != '''' then
	    dummy := tg_backlink_unset(old.backlink, old.slotname);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if tg_op = ''DELETE'' then
            ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return old;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return old;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:



create trigger tg_backlink_a after insert or update or delete
    on PSlot for each row execute procedure tg_backlink_a('PS');
RESULT:
	ERROR - function tg_backlink_a() does not exist


-----------
QUERY:


create trigger tg_backlink_a after insert or update or delete
    on WSlot for each row execute procedure tg_backlink_a('WS');
RESULT:
	ERROR - function tg_backlink_a() does not exist


-----------
QUERY:


create trigger tg_backlink_a after insert or update or delete
    on PLine for each row execute procedure tg_backlink_a('PL');
RESULT:
	ERROR - function tg_backlink_a() does not exist


-----------
QUERY:



-- ************************************************************
-- * Support function to set the opponents backlink field
-- * if it does not already point to the requested slot
-- ************************************************************
create function tg_backlink_set(myname bpchar, blname bpchar)
returns integer as '
declare
    mytype	char(2);
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    mytype	char(2);"
LINE 9: returns integer as '
                           ^


-----------
QUERY:

    link	char(4);
RESULT:
	ERROR - syntax error at or near "link"
LINE 2:     link char(4);
            ^


-----------
QUERY:

    rec		record;
RESULT:
	ERROR - syntax error at or near "rec"
LINE 2:     rec  record;
            ^


-----------
QUERY:

begin
    mytype := substr(myname, 1, 2);
RESULT:
	ERROR - syntax error at or near "mytype"
LINE 3:     mytype := substr(myname, 1, 2);
            ^


-----------
QUERY:

    link := mytype || substr(blname, 1, 2);
RESULT:
	ERROR - syntax error at or near "link"
LINE 2:     link := mytype || substr(blname, 1, 2);
            ^


-----------
QUERY:

    if link = ''PLPL'' then
        raise exception
		''backlink between two phone lines does not make sense'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if link = ''PLPL'' then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if link in (''PLWS'', ''WSPL'') then
        raise exception
		''direct link of phone line to wall slot not permitted'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if link in (''PLWS'', ''WSPL'') then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''PS'' then
        select into rec * from PSlot where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''PS'' then
            ^


-----------
QUERY:

	if not found then
	    raise exception ''% does not exist'', myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.backlink != blname then
	    update PSlot set backlink = blname where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.backlink != blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''WS'' then
        select into rec * from WSlot where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''WS'' then
            ^


-----------
QUERY:

	if not found then
	    raise exception ''% does not exist'', myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.backlink != blname then
	    update WSlot set backlink = blname where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.backlink != blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''PL'' then
        select into rec * from PLine where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''PL'' then
            ^


-----------
QUERY:

	if not found then
	    raise exception ''% does not exist'', myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.backlink != blname then
	    update PLine set backlink = blname where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.backlink != blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    raise exception ''illegal backlink beginning with %'', mytype;
RESULT:
	ERROR - syntax error at or near "raise"
LINE 2:     raise exception ''illegal backlink beginning with %'', m...
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:



-- ************************************************************
-- * Support function to clear out the backlink field if
-- * it still points to specific slot
-- ************************************************************
create function tg_backlink_unset(bpchar, bpchar)
returns integer as '
declare
    myname	alias for $1;
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    myname	alias for $1;"
LINE 9: returns integer as '
                           ^


-----------
QUERY:

    blname	alias for $2;
RESULT:
	ERROR - syntax error at or near "blname"
LINE 2:     blname alias for $2;
            ^


-----------
QUERY:

    mytype	char(2);
RESULT:
	ERROR - syntax error at or near "mytype"
LINE 2:     mytype char(2);
            ^


-----------
QUERY:

    rec		record;
RESULT:
	ERROR - syntax error at or near "rec"
LINE 2:     rec  record;
            ^


-----------
QUERY:

begin
    mytype := substr(myname, 1, 2);
RESULT:
	ERROR - syntax error at or near "mytype"
LINE 3:     mytype := substr(myname, 1, 2);
            ^


-----------
QUERY:

    if mytype = ''PS'' then
        select into rec * from PSlot where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''PS'' then
            ^


-----------
QUERY:

	if not found then
	    return 0;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.backlink = blname then
	    update PSlot set backlink = '''' where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.backlink = blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''WS'' then
        select into rec * from WSlot where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''WS'' then
            ^


-----------
QUERY:

	if not found then
	    return 0;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.backlink = blname then
	    update WSlot set backlink = '''' where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.backlink = blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''PL'' then
        select into rec * from PLine where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''PL'' then
            ^


-----------
QUERY:

	if not found then
	    return 0;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.backlink = blname then
	    update PLine set backlink = '''' where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.backlink = blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

end
' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 3: ' language plpgsql;
        ^


-----------
QUERY:



-- ************************************************************
-- * AFTER INSERT or UPDATE or DELETE on slot with slotlink
-- *	- Ensure that the opponent correctly points back to us
-- ************************************************************
create function tg_slotlink_a() returns trigger as '
declare
    dummy	integer;
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    dummy	integer;"
LINE 8: create function tg_slotlink_a() returns trigger as '
                                                           ^


-----------
QUERY:

begin
    if tg_op = ''INSERT'' then
        if new.slotlink != '''' then
	    dummy := tg_slotlink_set(new.slotlink, new.slotname);
RESULT:
	ERROR - syntax error at or near "if"
LINE 3:     if tg_op = ''INSERT'' then
            ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return new;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if tg_op = ''UPDATE'' then
        if new.slotlink != old.slotlink then
	    if old.slotlink != '''' then
	        dummy := tg_slotlink_unset(old.slotlink, old.slotname);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if tg_op = ''UPDATE'' then
            ^


-----------
QUERY:

	    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      end if;
                 ^


-----------
QUERY:

	    if new.slotlink != '''' then
	        dummy := tg_slotlink_set(new.slotlink, new.slotname);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      if new.slotlink != '''' then
             ^


-----------
QUERY:

	    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      end if;
                 ^


-----------
QUERY:

	else
	    if new.slotname != old.slotname and new.slotlink != '''' then
	        dummy := tg_slotlink_set(new.slotlink, new.slotname);
RESULT:
	ERROR - syntax error at or near "else"
LINE 2:  else
         ^


-----------
QUERY:

	    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      end if;
                 ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return new;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return new;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if tg_op = ''DELETE'' then
        if old.slotlink != '''' then
	    dummy := tg_slotlink_unset(old.slotlink, old.slotname);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if tg_op = ''DELETE'' then
            ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return old;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return old;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:



create trigger tg_slotlink_a after insert or update or delete
    on PSlot for each row execute procedure tg_slotlink_a('PS');
RESULT:
	ERROR - function tg_slotlink_a() does not exist


-----------
QUERY:


create trigger tg_slotlink_a after insert or update or delete
    on WSlot for each row execute procedure tg_slotlink_a('WS');
RESULT:
	ERROR - function tg_slotlink_a() does not exist


-----------
QUERY:


create trigger tg_slotlink_a after insert or update or delete
    on IFace for each row execute procedure tg_slotlink_a('IF');
RESULT:
	ERROR - function tg_slotlink_a() does not exist


-----------
QUERY:


create trigger tg_slotlink_a after insert or update or delete
    on HSlot for each row execute procedure tg_slotlink_a('HS');
RESULT:
	ERROR - function tg_slotlink_a() does not exist


-----------
QUERY:


create trigger tg_slotlink_a after insert or update or delete
    on PHone for each row execute procedure tg_slotlink_a('PH');
RESULT:
	ERROR - function tg_slotlink_a() does not exist


-----------
QUERY:



-- ************************************************************
-- * Support function to set the opponents slotlink field
-- * if it does not already point to the requested slot
-- ************************************************************
create function tg_slotlink_set(bpchar, bpchar)
returns integer as '
declare
    myname	alias for $1;
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    myname	alias for $1;"
LINE 9: returns integer as '
                           ^


-----------
QUERY:

    blname	alias for $2;
RESULT:
	ERROR - syntax error at or near "blname"
LINE 2:     blname alias for $2;
            ^


-----------
QUERY:

    mytype	char(2);
RESULT:
	ERROR - syntax error at or near "mytype"
LINE 2:     mytype char(2);
            ^


-----------
QUERY:

    link	char(4);
RESULT:
	ERROR - syntax error at or near "link"
LINE 2:     link char(4);
            ^


-----------
QUERY:

    rec		record;
RESULT:
	ERROR - syntax error at or near "rec"
LINE 2:     rec  record;
            ^


-----------
QUERY:

begin
    mytype := substr(myname, 1, 2);
RESULT:
	ERROR - syntax error at or near "mytype"
LINE 3:     mytype := substr(myname, 1, 2);
            ^


-----------
QUERY:

    link := mytype || substr(blname, 1, 2);
RESULT:
	ERROR - syntax error at or near "link"
LINE 2:     link := mytype || substr(blname, 1, 2);
            ^


-----------
QUERY:

    if link = ''PHPH'' then
        raise exception
		''slotlink between two phones does not make sense'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if link = ''PHPH'' then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if link in (''PHHS'', ''HSPH'') then
        raise exception
		''link of phone to hub does not make sense'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if link in (''PHHS'', ''HSPH'') then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if link in (''PHIF'', ''IFPH'') then
        raise exception
		''link of phone to hub does not make sense'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if link in (''PHIF'', ''IFPH'') then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if link in (''PSWS'', ''WSPS'') then
        raise exception
		''slotlink from patchslot to wallslot not permitted'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if link in (''PSWS'', ''WSPS'') then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''PS'' then
        select into rec * from PSlot where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''PS'' then
            ^


-----------
QUERY:

	if not found then
	    raise exception ''% does not exist'', myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.slotlink != blname then
	    update PSlot set slotlink = blname where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.slotlink != blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''WS'' then
        select into rec * from WSlot where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''WS'' then
            ^


-----------
QUERY:

	if not found then
	    raise exception ''% does not exist'', myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.slotlink != blname then
	    update WSlot set slotlink = blname where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.slotlink != blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''IF'' then
        select into rec * from IFace where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''IF'' then
            ^


-----------
QUERY:

	if not found then
	    raise exception ''% does not exist'', myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.slotlink != blname then
	    update IFace set slotlink = blname where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.slotlink != blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''HS'' then
        select into rec * from HSlot where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''HS'' then
            ^


-----------
QUERY:

	if not found then
	    raise exception ''% does not exist'', myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.slotlink != blname then
	    update HSlot set slotlink = blname where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.slotlink != blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''PH'' then
        select into rec * from PHone where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''PH'' then
            ^


-----------
QUERY:

	if not found then
	    raise exception ''% does not exist'', myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.slotlink != blname then
	    update PHone set slotlink = blname where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.slotlink != blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    raise exception ''illegal slotlink beginning with %'', mytype;
RESULT:
	ERROR - syntax error at or near "raise"
LINE 2:     raise exception ''illegal slotlink beginning with %'', m...
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:



-- ************************************************************
-- * Support function to clear out the slotlink field if
-- * it still points to specific slot
-- ************************************************************
create function tg_slotlink_unset(bpchar, bpchar)
returns integer as '
declare
    myname	alias for $1;
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    myname	alias for $1;"
LINE 9: returns integer as '
                           ^


-----------
QUERY:

    blname	alias for $2;
RESULT:
	ERROR - syntax error at or near "blname"
LINE 2:     blname alias for $2;
            ^


-----------
QUERY:

    mytype	char(2);
RESULT:
	ERROR - syntax error at or near "mytype"
LINE 2:     mytype char(2);
            ^


-----------
QUERY:

    rec		record;
RESULT:
	ERROR - syntax error at or near "rec"
LINE 2:     rec  record;
            ^


-----------
QUERY:

begin
    mytype := substr(myname, 1, 2);
RESULT:
	ERROR - syntax error at or near "mytype"
LINE 3:     mytype := substr(myname, 1, 2);
            ^


-----------
QUERY:

    if mytype = ''PS'' then
        select into rec * from PSlot where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''PS'' then
            ^


-----------
QUERY:

	if not found then
	    return 0;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.slotlink = blname then
	    update PSlot set slotlink = '''' where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.slotlink = blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''WS'' then
        select into rec * from WSlot where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''WS'' then
            ^


-----------
QUERY:

	if not found then
	    return 0;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.slotlink = blname then
	    update WSlot set slotlink = '''' where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.slotlink = blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''IF'' then
        select into rec * from IFace where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''IF'' then
            ^


-----------
QUERY:

	if not found then
	    return 0;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.slotlink = blname then
	    update IFace set slotlink = '''' where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.slotlink = blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''HS'' then
        select into rec * from HSlot where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''HS'' then
            ^


-----------
QUERY:

	if not found then
	    return 0;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.slotlink = blname then
	    update HSlot set slotlink = '''' where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.slotlink = blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if mytype = ''PH'' then
        select into rec * from PHone where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if mytype = ''PH'' then
            ^


-----------
QUERY:

	if not found then
	    return 0;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if not found then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	if rec.slotlink = blname then
	    update PHone set slotlink = '''' where slotname = myname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.slotlink = blname then
         ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return 0;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return 0;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:



-- ************************************************************
-- * Describe the backside of a patchfield slot
-- ************************************************************
create function pslot_backlink_view(bpchar)
returns text as '
<<outer>>
declare
    rec		record;
RESULT:
	ERROR - unterminated quoted string at or near "'
<<outer>>
declare
    rec		record;"
LINE 8: returns text as '
                        ^


-----------
QUERY:

    bltype	char(2);
RESULT:
	ERROR - syntax error at or near "bltype"
LINE 2:     bltype char(2);
            ^


-----------
QUERY:

    retval	text;
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:     retval text;
            ^


-----------
QUERY:

begin
    select into rec * from PSlot where slotname = $1;
RESULT:
	ERROR - syntax error at or near "select"
LINE 3:     select into rec * from PSlot where slotname = $1;
            ^


-----------
QUERY:

    if not found then
        return '''';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if not found then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if rec.backlink = '''' then
        return ''-'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if rec.backlink = '''' then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    bltype := substr(rec.backlink, 1, 2);
RESULT:
	ERROR - syntax error at or near "bltype"
LINE 2:     bltype := substr(rec.backlink, 1, 2);
            ^


-----------
QUERY:

    if bltype = ''PL'' then
        declare
	    rec		record;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if bltype = ''PL'' then
            ^


-----------
QUERY:

	begin
	    select into rec * from PLine where slotname = "outer".rec.backlink;
RESULT:
	ERROR - syntax error at or near "select"
LINE 3:      select into rec * from PLine where slotname = "outer".r...
             ^


-----------
QUERY:

	    retval := ''Phone line '' || trim(rec.phonenumber);
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:      retval := ''Phone line '' || trim(rec.phonenumber);
             ^


-----------
QUERY:

	    if rec.comment != '''' then
	        retval := retval || '' ('';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      if rec.comment != '''' then
             ^


-----------
QUERY:

		retval := retval || rec.comment;
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:   retval := retval || rec.comment;
          ^


-----------
QUERY:

		retval := retval || '')'';
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:   retval := retval || '')'';
          ^


-----------
QUERY:

	    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      end if;
                 ^


-----------
QUERY:

	    return retval;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:      return retval;
             ^


-----------
QUERY:

	end;
RESULT:
	[]

-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if bltype = ''WS'' then
        select into rec * from WSlot where slotname = rec.backlink;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if bltype = ''WS'' then
            ^


-----------
QUERY:

	retval := trim(rec.slotname) || '' in room '';
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:  retval := trim(rec.slotname) || '' in room '';
         ^


-----------
QUERY:

	retval := retval || trim(rec.roomno);
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:  retval := retval || trim(rec.roomno);
         ^


-----------
QUERY:

	retval := retval || '' -> '';
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:  retval := retval || '' -> '';
         ^


-----------
QUERY:

	return retval || wslot_slotlink_view(rec.slotname);
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return retval || wslot_slotlink_view(rec.slotname);
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return rec.backlink;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return rec.backlink;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:



-- ************************************************************
-- * Describe the front of a patchfield slot
-- ************************************************************
create function pslot_slotlink_view(bpchar)
returns text as '
declare
    psrec	record;
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    psrec	record;"
LINE 8: returns text as '
                        ^


-----------
QUERY:

    sltype	char(2);
RESULT:
	ERROR - syntax error at or near "sltype"
LINE 2:     sltype char(2);
            ^


-----------
QUERY:

    retval	text;
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:     retval text;
            ^


-----------
QUERY:

begin
    select into psrec * from PSlot where slotname = $1;
RESULT:
	ERROR - syntax error at or near "select"
LINE 3:     select into psrec * from PSlot where slotname = $1;
            ^


-----------
QUERY:

    if not found then
        return '''';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if not found then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if psrec.slotlink = '''' then
        return ''-'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if psrec.slotlink = '''' then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    sltype := substr(psrec.slotlink, 1, 2);
RESULT:
	ERROR - syntax error at or near "sltype"
LINE 2:     sltype := substr(psrec.slotlink, 1, 2);
            ^


-----------
QUERY:

    if sltype = ''PS'' then
	retval := trim(psrec.slotlink) || '' -> '';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if sltype = ''PS'' then
            ^


-----------
QUERY:

	return retval || pslot_backlink_view(psrec.slotlink);
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return retval || pslot_backlink_view(psrec.slotlink);
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if sltype = ''HS'' then
        retval := comment from Hub H, HSlot HS
			where HS.slotname = psrec.slotlink
			  and H.name = HS.hubname;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if sltype = ''HS'' then
            ^


-----------
QUERY:

        retval := retval || '' slot '';
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:         retval := retval || '' slot '';
                ^


-----------
QUERY:

	retval := retval || slotno::text from HSlot
			where slotname = psrec.slotlink;
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:  retval := retval || slotno::text from HSlot
         ^


-----------
QUERY:

	return retval;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return retval;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return psrec.slotlink;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return psrec.slotlink;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:



-- ************************************************************
-- * Describe the front of a wall connector slot
-- ************************************************************
create function wslot_slotlink_view(bpchar)
returns text as '
declare
    rec		record;
RESULT:
	ERROR - unterminated quoted string at or near "'
declare
    rec		record;"
LINE 8: returns text as '
                        ^


-----------
QUERY:

    sltype	char(2);
RESULT:
	ERROR - syntax error at or near "sltype"
LINE 2:     sltype char(2);
            ^


-----------
QUERY:

    retval	text;
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:     retval text;
            ^


-----------
QUERY:

begin
    select into rec * from WSlot where slotname = $1;
RESULT:
	ERROR - syntax error at or near "select"
LINE 3:     select into rec * from WSlot where slotname = $1;
            ^


-----------
QUERY:

    if not found then
        return '''';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if not found then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if rec.slotlink = '''' then
        return ''-'';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if rec.slotlink = '''' then
            ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    sltype := substr(rec.slotlink, 1, 2);
RESULT:
	ERROR - syntax error at or near "sltype"
LINE 2:     sltype := substr(rec.slotlink, 1, 2);
            ^


-----------
QUERY:

    if sltype = ''PH'' then
        select into rec * from PHone where slotname = rec.slotlink;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if sltype = ''PH'' then
            ^


-----------
QUERY:

	retval := ''Phone '' || trim(rec.slotname);
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:  retval := ''Phone '' || trim(rec.slotname);
         ^


-----------
QUERY:

	if rec.comment != '''' then
	    retval := retval || '' ('';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  if rec.comment != '''' then
         ^


-----------
QUERY:

	    retval := retval || rec.comment;
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:      retval := retval || rec.comment;
             ^


-----------
QUERY:

	    retval := retval || '')'';
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:      retval := retval || '')'';
             ^


-----------
QUERY:

	end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:  end if;
             ^


-----------
QUERY:

	return retval;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:  return retval;
         ^


-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    if sltype = ''IF'' then
	declare
	    syrow	System%RowType;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     if sltype = ''IF'' then
            ^


-----------
QUERY:

	    ifrow	IFace%ROWTYPE;
RESULT:
	ERROR - syntax error at or near "ifrow"
LINE 2:      ifrow IFace%ROWTYPE;
             ^


-----------
QUERY:

        begin
	    select into ifrow * from IFace where slotname = rec.slotlink;
RESULT:
	ERROR - syntax error at or near "select"
LINE 3:      select into ifrow * from IFace where slotname = rec.slo...
             ^


-----------
QUERY:

	    select into syrow * from System where name = ifrow.sysname;
RESULT:
	ERROR - syntax error at or near "*"
LINE 2:      select into syrow * from System where name = ifrow.sysn...
                               ^


-----------
QUERY:

	    retval := syrow.name || '' IF '';
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:      retval := syrow.name || '' IF '';
             ^


-----------
QUERY:

	    retval := retval || ifrow.ifname;
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:      retval := retval || ifrow.ifname;
             ^


-----------
QUERY:

	    if syrow.comment != '''' then
	        retval := retval || '' ('';
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      if syrow.comment != '''' then
             ^


-----------
QUERY:

		retval := retval || syrow.comment;
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:   retval := retval || syrow.comment;
          ^


-----------
QUERY:

		retval := retval || '')'';
RESULT:
	ERROR - syntax error at or near "retval"
LINE 2:   retval := retval || '')'';
          ^


-----------
QUERY:

	    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:      end if;
                 ^


-----------
QUERY:

	    return retval;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:      return retval;
             ^


-----------
QUERY:

	end;
RESULT:
	[]

-----------
QUERY:

    end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:     end if;
                ^


-----------
QUERY:

    return rec.slotlink;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:     return rec.slotlink;
            ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 2: ' language plpgsql;
        ^


-----------
QUERY:




-- ************************************************************
-- * View of a patchfield describing backside and patches
-- ************************************************************
create view Pfield_v1 as select PF.pfname, PF.slotname,
	pslot_backlink_view(PF.slotname) as backside,
	pslot_slotlink_view(PF.slotname) as patch
    from PSlot PF;
RESULT:
	ERROR - function pslot_backlink_view(character) does not exist
LINE 9:  pslot_backlink_view(PF.slotname) as backside,
         ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:



--
-- First we build the house - so we create the rooms
--
insert into Room values ('001', 'Entrance');
RESULT:
	[]

-----------
QUERY:

insert into Room values ('002', 'Office');
RESULT:
	[]

-----------
QUERY:

insert into Room values ('003', 'Office');
RESULT:
	[]

-----------
QUERY:

insert into Room values ('004', 'Technical');
RESULT:
	[]

-----------
QUERY:

insert into Room values ('101', 'Office');
RESULT:
	[]

-----------
QUERY:

insert into Room values ('102', 'Conference');
RESULT:
	[]

-----------
QUERY:

insert into Room values ('103', 'Restroom');
RESULT:
	[]

-----------
QUERY:

insert into Room values ('104', 'Technical');
RESULT:
	[]

-----------
QUERY:

insert into Room values ('105', 'Office');
RESULT:
	[]

-----------
QUERY:

insert into Room values ('106', 'Office');
RESULT:
	[]

-----------
QUERY:


--
-- Second we install the wall connectors
--
insert into WSlot values ('WS.001.1a', '001', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.001.1b', '001', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.001.2a', '001', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.001.2b', '001', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.001.3a', '001', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.001.3b', '001', '', '');
RESULT:
	[]

-----------
QUERY:


insert into WSlot values ('WS.002.1a', '002', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.002.1b', '002', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.002.2a', '002', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.002.2b', '002', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.002.3a', '002', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.002.3b', '002', '', '');
RESULT:
	[]

-----------
QUERY:


insert into WSlot values ('WS.003.1a', '003', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.003.1b', '003', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.003.2a', '003', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.003.2b', '003', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.003.3a', '003', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.003.3b', '003', '', '');
RESULT:
	[]

-----------
QUERY:


insert into WSlot values ('WS.101.1a', '101', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.101.1b', '101', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.101.2a', '101', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.101.2b', '101', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.101.3a', '101', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.101.3b', '101', '', '');
RESULT:
	[]

-----------
QUERY:


insert into WSlot values ('WS.102.1a', '102', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.102.1b', '102', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.102.2a', '102', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.102.2b', '102', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.102.3a', '102', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.102.3b', '102', '', '');
RESULT:
	[]

-----------
QUERY:


insert into WSlot values ('WS.105.1a', '105', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.105.1b', '105', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.105.2a', '105', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.105.2b', '105', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.105.3a', '105', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.105.3b', '105', '', '');
RESULT:
	[]

-----------
QUERY:


insert into WSlot values ('WS.106.1a', '106', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.106.1b', '106', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.106.2a', '106', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.106.2b', '106', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.106.3a', '106', '', '');
RESULT:
	[]

-----------
QUERY:

insert into WSlot values ('WS.106.3b', '106', '', '');
RESULT:
	[]

-----------
QUERY:


--
-- Now create the patch fields and their slots
--
insert into PField values ('PF0_1', 'Wallslots basement');
RESULT:
	[]

-----------
QUERY:


--
-- The cables for these will be made later, so they are unconnected for now
--
insert into PSlot values ('PS.base.a1', 'PF0_1', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.a2', 'PF0_1', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.a3', 'PF0_1', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.a4', 'PF0_1', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.a5', 'PF0_1', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.a6', 'PF0_1', '', '');
RESULT:
	[]

-----------
QUERY:


--
-- These are already wired to the wall connectors
--
insert into PSlot values ('PS.base.b1', 'PF0_1', '', 'WS.002.1a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.b2', 'PF0_1', '', 'WS.002.1b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.b3', 'PF0_1', '', 'WS.002.2a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.b4', 'PF0_1', '', 'WS.002.2b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.b5', 'PF0_1', '', 'WS.002.3a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.b6', 'PF0_1', '', 'WS.002.3b');
RESULT:
	[]

-----------
QUERY:


insert into PSlot values ('PS.base.c1', 'PF0_1', '', 'WS.003.1a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.c2', 'PF0_1', '', 'WS.003.1b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.c3', 'PF0_1', '', 'WS.003.2a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.c4', 'PF0_1', '', 'WS.003.2b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.c5', 'PF0_1', '', 'WS.003.3a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.c6', 'PF0_1', '', 'WS.003.3b');
RESULT:
	[]

-----------
QUERY:


--
-- This patchfield will be renamed later into PF0_2 - so its
-- slots references in pfname should follow
--
insert into PField values ('PF0_X', 'Phonelines basement');
RESULT:
	[]

-----------
QUERY:


insert into PSlot values ('PS.base.ta1', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.ta2', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.ta3', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.ta4', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.ta5', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.ta6', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:


insert into PSlot values ('PS.base.tb1', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.tb2', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.tb3', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.tb4', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.tb5', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.base.tb6', 'PF0_X', '', '');
RESULT:
	[]

-----------
QUERY:


insert into PField values ('PF1_1', 'Wallslots first floor');
RESULT:
	[]

-----------
QUERY:


insert into PSlot values ('PS.first.a1', 'PF1_1', '', 'WS.101.1a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.a2', 'PF1_1', '', 'WS.101.1b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.a3', 'PF1_1', '', 'WS.101.2a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.a4', 'PF1_1', '', 'WS.101.2b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.a5', 'PF1_1', '', 'WS.101.3a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.a6', 'PF1_1', '', 'WS.101.3b');
RESULT:
	[]

-----------
QUERY:


insert into PSlot values ('PS.first.b1', 'PF1_1', '', 'WS.102.1a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.b2', 'PF1_1', '', 'WS.102.1b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.b3', 'PF1_1', '', 'WS.102.2a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.b4', 'PF1_1', '', 'WS.102.2b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.b5', 'PF1_1', '', 'WS.102.3a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.b6', 'PF1_1', '', 'WS.102.3b');
RESULT:
	[]

-----------
QUERY:


insert into PSlot values ('PS.first.c1', 'PF1_1', '', 'WS.105.1a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.c2', 'PF1_1', '', 'WS.105.1b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.c3', 'PF1_1', '', 'WS.105.2a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.c4', 'PF1_1', '', 'WS.105.2b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.c5', 'PF1_1', '', 'WS.105.3a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.c6', 'PF1_1', '', 'WS.105.3b');
RESULT:
	[]

-----------
QUERY:


insert into PSlot values ('PS.first.d1', 'PF1_1', '', 'WS.106.1a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.d2', 'PF1_1', '', 'WS.106.1b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.d3', 'PF1_1', '', 'WS.106.2a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.d4', 'PF1_1', '', 'WS.106.2b');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.d5', 'PF1_1', '', 'WS.106.3a');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.d6', 'PF1_1', '', 'WS.106.3b');
RESULT:
	[]

-----------
QUERY:


--
-- Now we wire the wall connectors 1a-2a in room 001 to the
-- patchfield. In the second update we make an error, and
-- correct it after
--
update PSlot set backlink = 'WS.001.1a' where slotname = 'PS.base.a1';
RESULT:
	[]

-----------
QUERY:

update PSlot set backlink = 'WS.001.1b' where slotname = 'PS.base.a3';
RESULT:
	[]

-----------
QUERY:

select * from WSlot where roomno = '001' order by slotname;
RESULT:
	[('WS.001.1a           ', '001     ', '                    ', '                    '), ('WS.001.1b           ', '001     ', '                    ', '                    '), ('WS.001.2a           ', '001     ', '                    ', '                    '), ('WS.001.2b           ', '001     ', '                    ', '                    '), ('WS.001.3a           ', '001     ', '                    ', '                    '), ('WS.001.3b           ', '001     ', '                    ', '                    ')]

-----------
QUERY:

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
RESULT:
	[('PS.base.a1          ', 'PF0_1', '                    ', 'WS.001.1a           '), ('PS.base.a2          ', 'PF0_1', '                    ', '                    '), ('PS.base.a3          ', 'PF0_1', '                    ', 'WS.001.1b           '), ('PS.base.a4          ', 'PF0_1', '                    ', '                    '), ('PS.base.a5          ', 'PF0_1', '                    ', '                    '), ('PS.base.a6          ', 'PF0_1', '                    ', '                    ')]

-----------
QUERY:

update PSlot set backlink = 'WS.001.2a' where slotname = 'PS.base.a3';
RESULT:
	[]

-----------
QUERY:

select * from WSlot where roomno = '001' order by slotname;
RESULT:
	[('WS.001.1a           ', '001     ', '                    ', '                    '), ('WS.001.1b           ', '001     ', '                    ', '                    '), ('WS.001.2a           ', '001     ', '                    ', '                    '), ('WS.001.2b           ', '001     ', '                    ', '                    '), ('WS.001.3a           ', '001     ', '                    ', '                    '), ('WS.001.3b           ', '001     ', '                    ', '                    ')]

-----------
QUERY:

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
RESULT:
	[('PS.base.a1          ', 'PF0_1', '                    ', 'WS.001.1a           '), ('PS.base.a2          ', 'PF0_1', '                    ', '                    '), ('PS.base.a3          ', 'PF0_1', '                    ', 'WS.001.2a           '), ('PS.base.a4          ', 'PF0_1', '                    ', '                    '), ('PS.base.a5          ', 'PF0_1', '                    ', '                    '), ('PS.base.a6          ', 'PF0_1', '                    ', '                    ')]

-----------
QUERY:

update PSlot set backlink = 'WS.001.1b' where slotname = 'PS.base.a2';
RESULT:
	[]

-----------
QUERY:

select * from WSlot where roomno = '001' order by slotname;
RESULT:
	[('WS.001.1a           ', '001     ', '                    ', '                    '), ('WS.001.1b           ', '001     ', '                    ', '                    '), ('WS.001.2a           ', '001     ', '                    ', '                    '), ('WS.001.2b           ', '001     ', '                    ', '                    '), ('WS.001.3a           ', '001     ', '                    ', '                    '), ('WS.001.3b           ', '001     ', '                    ', '                    ')]

-----------
QUERY:

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
RESULT:
	[('PS.base.a1          ', 'PF0_1', '                    ', 'WS.001.1a           '), ('PS.base.a2          ', 'PF0_1', '                    ', 'WS.001.1b           '), ('PS.base.a3          ', 'PF0_1', '                    ', 'WS.001.2a           '), ('PS.base.a4          ', 'PF0_1', '                    ', '                    '), ('PS.base.a5          ', 'PF0_1', '                    ', '                    '), ('PS.base.a6          ', 'PF0_1', '                    ', '                    ')]

-----------
QUERY:


--
-- Same procedure for 2b-3b but this time updating the WSlot instead
-- of the PSlot. Due to the triggers the result is the same:
-- WSlot and corresponding PSlot point to each other.
--
update WSlot set backlink = 'PS.base.a4' where slotname = 'WS.001.2b';
RESULT:
	[]

-----------
QUERY:

update WSlot set backlink = 'PS.base.a6' where slotname = 'WS.001.3a';
RESULT:
	[]

-----------
QUERY:

select * from WSlot where roomno = '001' order by slotname;
RESULT:
	[('WS.001.1a           ', '001     ', '                    ', '                    '), ('WS.001.1b           ', '001     ', '                    ', '                    '), ('WS.001.2a           ', '001     ', '                    ', '                    '), ('WS.001.2b           ', '001     ', '                    ', 'PS.base.a4          '), ('WS.001.3a           ', '001     ', '                    ', 'PS.base.a6          '), ('WS.001.3b           ', '001     ', '                    ', '                    ')]

-----------
QUERY:

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
RESULT:
	[('PS.base.a1          ', 'PF0_1', '                    ', 'WS.001.1a           '), ('PS.base.a2          ', 'PF0_1', '                    ', 'WS.001.1b           '), ('PS.base.a3          ', 'PF0_1', '                    ', 'WS.001.2a           '), ('PS.base.a4          ', 'PF0_1', '                    ', '                    '), ('PS.base.a5          ', 'PF0_1', '                    ', '                    '), ('PS.base.a6          ', 'PF0_1', '                    ', '                    ')]

-----------
QUERY:

update WSlot set backlink = 'PS.base.a6' where slotname = 'WS.001.3b';
RESULT:
	[]

-----------
QUERY:

select * from WSlot where roomno = '001' order by slotname;
RESULT:
	[('WS.001.1a           ', '001     ', '                    ', '                    '), ('WS.001.1b           ', '001     ', '                    ', '                    '), ('WS.001.2a           ', '001     ', '                    ', '                    '), ('WS.001.2b           ', '001     ', '                    ', 'PS.base.a4          '), ('WS.001.3a           ', '001     ', '                    ', 'PS.base.a6          '), ('WS.001.3b           ', '001     ', '                    ', 'PS.base.a6          ')]

-----------
QUERY:

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
RESULT:
	[('PS.base.a1          ', 'PF0_1', '                    ', 'WS.001.1a           '), ('PS.base.a2          ', 'PF0_1', '                    ', 'WS.001.1b           '), ('PS.base.a3          ', 'PF0_1', '                    ', 'WS.001.2a           '), ('PS.base.a4          ', 'PF0_1', '                    ', '                    '), ('PS.base.a5          ', 'PF0_1', '                    ', '                    '), ('PS.base.a6          ', 'PF0_1', '                    ', '                    ')]

-----------
QUERY:

update WSlot set backlink = 'PS.base.a5' where slotname = 'WS.001.3a';
RESULT:
	[]

-----------
QUERY:

select * from WSlot where roomno = '001' order by slotname;
RESULT:
	[('WS.001.1a           ', '001     ', '                    ', '                    '), ('WS.001.1b           ', '001     ', '                    ', '                    '), ('WS.001.2a           ', '001     ', '                    ', '                    '), ('WS.001.2b           ', '001     ', '                    ', 'PS.base.a4          '), ('WS.001.3a           ', '001     ', '                    ', 'PS.base.a5          '), ('WS.001.3b           ', '001     ', '                    ', 'PS.base.a6          ')]

-----------
QUERY:

select * from PSlot where slotname ~ 'PS.base.a' order by slotname;
RESULT:
	[('PS.base.a1          ', 'PF0_1', '                    ', 'WS.001.1a           '), ('PS.base.a2          ', 'PF0_1', '                    ', 'WS.001.1b           '), ('PS.base.a3          ', 'PF0_1', '                    ', 'WS.001.2a           '), ('PS.base.a4          ', 'PF0_1', '                    ', '                    '), ('PS.base.a5          ', 'PF0_1', '                    ', '                    '), ('PS.base.a6          ', 'PF0_1', '                    ', '                    ')]

-----------
QUERY:


insert into PField values ('PF1_2', 'Phonelines first floor');
RESULT:
	[]

-----------
QUERY:


insert into PSlot values ('PS.first.ta1', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.ta2', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.ta3', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.ta4', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.ta5', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.ta6', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:


insert into PSlot values ('PS.first.tb1', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.tb2', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.tb3', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.tb4', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.tb5', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:

insert into PSlot values ('PS.first.tb6', 'PF1_2', '', '');
RESULT:
	[]

-----------
QUERY:


--
-- Fix the wrong name for patchfield PF0_2
--
update PField set name = 'PF0_2' where name = 'PF0_X';
RESULT:
	[]

-----------
QUERY:


select * from PSlot order by slotname;
RESULT:
	[('PS.base.a1          ', 'PF0_1', '                    ', 'WS.001.1a           '), ('PS.base.a2          ', 'PF0_1', '                    ', 'WS.001.1b           '), ('PS.base.a3          ', 'PF0_1', '                    ', 'WS.001.2a           '), ('PS.base.a4          ', 'PF0_1', '                    ', '                    '), ('PS.base.a5          ', 'PF0_1', '                    ', '                    '), ('PS.base.a6          ', 'PF0_1', '                    ', '                    '), ('PS.base.b1          ', 'PF0_1', '                    ', 'WS.002.1a           '), ('PS.base.b2          ', 'PF0_1', '                    ', 'WS.002.1b           '), ('PS.base.b3          ', 'PF0_1', '                    ', 'WS.002.2a           '), ('PS.base.b4          ', 'PF0_1', '                    ', 'WS.002.2b           '), ('PS.base.b5          ', 'PF0_1', '                    ', 'WS.002.3a           '), ('PS.base.b6          ', 'PF0_1', '                    ', 'WS.002.3b           '), ('PS.base.c1          ', 'PF0_1', '                    ', 'WS.003.1a           '), ('PS.base.c2          ', 'PF0_1', '                    ', 'WS.003.1b           '), ('PS.base.c3          ', 'PF0_1', '                    ', 'WS.003.2a           '), ('PS.base.c4          ', 'PF0_1', '                    ', 'WS.003.2b           '), ('PS.base.c5          ', 'PF0_1', '                    ', 'WS.003.3a           '), ('PS.base.c6          ', 'PF0_1', '                    ', 'WS.003.3b           '), ('PS.base.ta1         ', 'PF0_X', '                    ', '                    '), ('PS.base.ta2         ', 'PF0_X', '                    ', '                    '), ('PS.base.ta3         ', 'PF0_X', '                    ', '                    '), ('PS.base.ta4         ', 'PF0_X', '                    ', '                    '), ('PS.base.ta5         ', 'PF0_X', '                    ', '                    '), ('PS.base.ta6         ', 'PF0_X', '                    ', '                    '), ('PS.base.tb1         ', 'PF0_X', '                    ', '                    '), ('PS.base.tb2         ', 'PF0_X', '                    ', '                    '), ('PS.base.tb3         ', 'PF0_X', '                    ', '                    '), ('PS.base.tb4         ', 'PF0_X', '                    ', '                    '), ('PS.base.tb5         ', 'PF0_X', '                    ', '                    '), ('PS.base.tb6         ', 'PF0_X', '                    ', '                    '), ('PS.first.a1         ', 'PF1_1', '                    ', 'WS.101.1a           '), ('PS.first.a2         ', 'PF1_1', '                    ', 'WS.101.1b           '), ('PS.first.a3         ', 'PF1_1', '                    ', 'WS.101.2a           '), ('PS.first.a4         ', 'PF1_1', '                    ', 'WS.101.2b           '), ('PS.first.a5         ', 'PF1_1', '                    ', 'WS.101.3a           '), ('PS.first.a6         ', 'PF1_1', '                    ', 'WS.101.3b           '), ('PS.first.b1         ', 'PF1_1', '                    ', 'WS.102.1a           '), ('PS.first.b2         ', 'PF1_1', '                    ', 'WS.102.1b           '), ('PS.first.b3         ', 'PF1_1', '                    ', 'WS.102.2a           '), ('PS.first.b4         ', 'PF1_1', '                    ', 'WS.102.2b           '), ('PS.first.b5         ', 'PF1_1', '                    ', 'WS.102.3a           '), ('PS.first.b6         ', 'PF1_1', '                    ', 'WS.102.3b           '), ('PS.first.c1         ', 'PF1_1', '                    ', 'WS.105.1a           '), ('PS.first.c2         ', 'PF1_1', '                    ', 'WS.105.1b           '), ('PS.first.c3         ', 'PF1_1', '                    ', 'WS.105.2a           '), ('PS.first.c4         ', 'PF1_1', '                    ', 'WS.105.2b           '), ('PS.first.c5         ', 'PF1_1', '                    ', 'WS.105.3a           '), ('PS.first.c6         ', 'PF1_1', '                    ', 'WS.105.3b           '), ('PS.first.d1         ', 'PF1_1', '                    ', 'WS.106.1a           '), ('PS.first.d2         ', 'PF1_1', '                    ', 'WS.106.1b           '), ('PS.first.d3         ', 'PF1_1', '                    ', 'WS.106.2a           '), ('PS.first.d4         ', 'PF1_1', '                    ', 'WS.106.2b           '), ('PS.first.d5         ', 'PF1_1', '                    ', 'WS.106.3a           '), ('PS.first.d6         ', 'PF1_1', '                    ', 'WS.106.3b           '), ('PS.first.ta1        ', 'PF1_2', '                    ', '                    '), ('PS.first.ta2        ', 'PF1_2', '                    ', '                    '), ('PS.first.ta3        ', 'PF1_2', '                    ', '                    '), ('PS.first.ta4        ', 'PF1_2', '                    ', '                    '), ('PS.first.ta5        ', 'PF1_2', '                    ', '                    '), ('PS.first.ta6        ', 'PF1_2', '                    ', '                    '), ('PS.first.tb1        ', 'PF1_2', '                    ', '                    '), ('PS.first.tb2        ', 'PF1_2', '                    ', '                    '), ('PS.first.tb3        ', 'PF1_2', '                    ', '                    '), ('PS.first.tb4        ', 'PF1_2', '                    ', '                    '), ('PS.first.tb5        ', 'PF1_2', '                    ', '                    '), ('PS.first.tb6        ', 'PF1_2', '                    ', '                    ')]

-----------
QUERY:

select * from WSlot order by slotname;
RESULT:
	[('WS.001.1a           ', '001     ', '                    ', '                    '), ('WS.001.1b           ', '001     ', '                    ', '                    '), ('WS.001.2a           ', '001     ', '                    ', '                    '), ('WS.001.2b           ', '001     ', '                    ', 'PS.base.a4          '), ('WS.001.3a           ', '001     ', '                    ', 'PS.base.a5          '), ('WS.001.3b           ', '001     ', '                    ', 'PS.base.a6          '), ('WS.002.1a           ', '002     ', '                    ', '                    '), ('WS.002.1b           ', '002     ', '                    ', '                    '), ('WS.002.2a           ', '002     ', '                    ', '                    '), ('WS.002.2b           ', '002     ', '                    ', '                    '), ('WS.002.3a           ', '002     ', '                    ', '                    '), ('WS.002.3b           ', '002     ', '                    ', '                    '), ('WS.003.1a           ', '003     ', '                    ', '                    '), ('WS.003.1b           ', '003     ', '                    ', '                    '), ('WS.003.2a           ', '003     ', '                    ', '                    '), ('WS.003.2b           ', '003     ', '                    ', '                    '), ('WS.003.3a           ', '003     ', '                    ', '                    '), ('WS.003.3b           ', '003     ', '                    ', '                    '), ('WS.101.1a           ', '101     ', '                    ', '                    '), ('WS.101.1b           ', '101     ', '                    ', '                    '), ('WS.101.2a           ', '101     ', '                    ', '                    '), ('WS.101.2b           ', '101     ', '                    ', '                    '), ('WS.101.3a           ', '101     ', '                    ', '                    '), ('WS.101.3b           ', '101     ', '                    ', '                    '), ('WS.102.1a           ', '102     ', '                    ', '                    '), ('WS.102.1b           ', '102     ', '                    ', '                    '), ('WS.102.2a           ', '102     ', '                    ', '                    '), ('WS.102.2b           ', '102     ', '                    ', '                    '), ('WS.102.3a           ', '102     ', '                    ', '                    '), ('WS.102.3b           ', '102     ', '                    ', '                    '), ('WS.105.1a           ', '105     ', '                    ', '                    '), ('WS.105.1b           ', '105     ', '                    ', '                    '), ('WS.105.2a           ', '105     ', '                    ', '                    '), ('WS.105.2b           ', '105     ', '                    ', '                    '), ('WS.105.3a           ', '105     ', '                    ', '                    '), ('WS.105.3b           ', '105     ', '                    ', '                    '), ('WS.106.1a           ', '106     ', '                    ', '                    '), ('WS.106.1b           ', '106     ', '                    ', '                    '), ('WS.106.2a           ', '106     ', '                    ', '                    '), ('WS.106.2b           ', '106     ', '                    ', '                    '), ('WS.106.3a           ', '106     ', '                    ', '                    '), ('WS.106.3b           ', '106     ', '                    ', '                    ')]

-----------
QUERY:


--
-- Install the central phone system and create the phone numbers.
-- They are wired on insert to the patchfields. Again the
-- triggers automatically tell the PSlots to update their
-- backlink field.
--
insert into PLine values ('PL.001', '-0', 'Central call', 'PS.base.ta1');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.002', '-101', '', 'PS.base.ta2');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.003', '-102', '', 'PS.base.ta3');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.004', '-103', '', 'PS.base.ta5');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.005', '-104', '', 'PS.base.ta6');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.006', '-106', '', 'PS.base.tb2');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.007', '-108', '', 'PS.base.tb3');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.008', '-109', '', 'PS.base.tb4');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.009', '-121', '', 'PS.base.tb5');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.010', '-122', '', 'PS.base.tb6');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.015', '-134', '', 'PS.first.ta1');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.016', '-137', '', 'PS.first.ta3');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.017', '-139', '', 'PS.first.ta4');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.018', '-362', '', 'PS.first.tb1');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.019', '-363', '', 'PS.first.tb2');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.020', '-364', '', 'PS.first.tb3');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.021', '-365', '', 'PS.first.tb5');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.022', '-367', '', 'PS.first.tb6');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.028', '-501', 'Fax entrance', 'PS.base.ta2');
RESULT:
	[]

-----------
QUERY:

insert into PLine values ('PL.029', '-502', 'Fax first floor', 'PS.first.ta1');
RESULT:
	[]

-----------
QUERY:


--
-- Buy some phones, plug them into the wall and patch the
-- phone lines to the corresponding patchfield slots.
--
insert into PHone values ('PH.hc001', 'Hicom standard', 'WS.001.1a');
RESULT:
	[]

-----------
QUERY:

update PSlot set slotlink = 'PS.base.ta1' where slotname = 'PS.base.a1';
RESULT:
	[]

-----------
QUERY:

insert into PHone values ('PH.hc002', 'Hicom standard', 'WS.002.1a');
RESULT:
	[]

-----------
QUERY:

update PSlot set slotlink = 'PS.base.ta5' where slotname = 'PS.base.b1';
RESULT:
	[]

-----------
QUERY:

insert into PHone values ('PH.hc003', 'Hicom standard', 'WS.002.2a');
RESULT:
	[]

-----------
QUERY:

update PSlot set slotlink = 'PS.base.tb2' where slotname = 'PS.base.b3';
RESULT:
	[]

-----------
QUERY:

insert into PHone values ('PH.fax001', 'Canon fax', 'WS.001.2a');
RESULT:
	[]

-----------
QUERY:

update PSlot set slotlink = 'PS.base.ta2' where slotname = 'PS.base.a3';
RESULT:
	[]

-----------
QUERY:


--
-- Install a hub at one of the patchfields, plug a computers
-- ethernet interface into the wall and patch it to the hub.
--
insert into Hub values ('base.hub1', 'Patchfield PF0_1 hub', 16);
RESULT:
	[]

-----------
QUERY:

insert into System values ('orion', 'PC');
RESULT:
	[]

-----------
QUERY:

insert into IFace values ('IF', 'orion', 'eth0', 'WS.002.1b');
RESULT:
	[]

-----------
QUERY:

update PSlot set slotlink = 'HS.base.hub1.1' where slotname = 'PS.base.b2';
RESULT:
	[]

-----------
QUERY:


--
-- Now we take a look at the patchfield
--
select * from PField_v1 where pfname = 'PF0_1' order by slotname;
RESULT:
	ERROR - relation "pfield_v1" does not exist
LINE 6: select * from PField_v1 where pfname = 'PF0_1' order by slot...
                      ^


-----------
QUERY:

select * from PField_v1 where pfname = 'PF0_2' order by slotname;
RESULT:
	ERROR - relation "pfield_v1" does not exist
LINE 2: select * from PField_v1 where pfname = 'PF0_2' order by slot...
                      ^


-----------
QUERY:


--
-- Finally we want errors
--
insert into PField values ('PF1_1', 'should fail due to unique index');
RESULT:
	ERROR - duplicate key value violates unique constraint "pfield_name"
DETAIL:  Key (name)=(PF1_1) already exists.


-----------
QUERY:

update PSlot set backlink = 'WS.not.there' where slotname = 'PS.base.a1';
RESULT:
	[]

-----------
QUERY:

update PSlot set backlink = 'XX.illegal' where slotname = 'PS.base.a1';
RESULT:
	[]

-----------
QUERY:

update PSlot set slotlink = 'PS.not.there' where slotname = 'PS.base.a1';
RESULT:
	[]

-----------
QUERY:

update PSlot set slotlink = 'XX.illegal' where slotname = 'PS.base.a1';
RESULT:
	[]

-----------
QUERY:

insert into HSlot values ('HS', 'base.hub1', 1, '');
RESULT:
	[]

-----------
QUERY:

insert into HSlot values ('HS', 'base.hub1', 20, '');
RESULT:
	ERROR - duplicate key value violates unique constraint "hslot_name"
DETAIL:  Key (slotname)=(HS                  ) already exists.


-----------
QUERY:

delete from HSlot;
RESULT:
	[]

-----------
QUERY:

insert into IFace values ('IF', 'notthere', 'eth0', '');
RESULT:
	ERROR - system "notthere" does not exist
CONTEXT:  PL/pgSQL function tg_iface_biu() line 8 at RAISE


-----------
QUERY:

insert into IFace values ('IF', 'orion', 'ethernet_interface_name_too_long', '');
RESULT:
	ERROR - IFace slotname "IF.orion.ethernet_interface_name_too_long" too long (20 char max)
CONTEXT:  PL/pgSQL function tg_iface_biu() line 14 at RAISE


-----------
QUERY:



--
-- The following tests are unrelated to the scenario outlined above /* REPLACED */,
-- they merely exercise specific parts of PL/pgSQL
--

--
-- Test recursion, per bug report 7-Sep-01
--
CREATE FUNCTION recursion_test(int,int) RETURNS text AS '
DECLARE rslt text;
RESULT:
	ERROR - unterminated quoted string at or near "'
DECLARE rslt text;"
LINE 12: CREATE FUNCTION recursion_test(int,int) RETURNS text AS '
                                                                 ^


-----------
QUERY:

BEGIN
    IF $1 <= 0 THEN
        rslt = CAST($2 AS TEXT);
RESULT:
	ERROR - syntax error at or near "IF"
LINE 3:     IF $1 <= 0 THEN
            ^


-----------
QUERY:

    ELSE
        rslt = CAST($1 AS TEXT) || '','' || recursion_test($1 - 1, $2);
RESULT:
	ERROR - syntax error at or near "ELSE"
LINE 2:     ELSE
            ^


-----------
QUERY:

    END IF;
RESULT:
	ERROR - syntax error at or near "IF"
LINE 2:     END IF;
                ^


-----------
QUERY:

    RETURN rslt;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:     RETURN rslt;
            ^


-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:
' LANGUAGE plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' LANGUAGE plpgsql;"
LINE 1: ' LANGUAGE plpgsql;
        ^


-----------
QUERY:


SELECT recursion_test(4,3);
RESULT:
	ERROR - function recursion_test(integer, integer) does not exist
LINE 3: SELECT recursion_test(4,3);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


--
-- Test the FOUND magic variable
--
CREATE TABLE found_test_tbl (a int);
RESULT:
	[]

-----------
QUERY:


create function test_found()
  returns boolean as '
  declare
  begin
  insert into found_test_tbl values (1);
RESULT:
	ERROR - unterminated quoted string at or near "'
  declare
  begin
  insert into found_test_tbl values (1);"
LINE 4:   returns boolean as '
                             ^


-----------
QUERY:

  if FOUND then
     insert into found_test_tbl values (2);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:   if FOUND then
          ^


-----------
QUERY:

  end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:   end if;
              ^


-----------
QUERY:


  update found_test_tbl set a = 100 where a = 1;
RESULT:
	[]

-----------
QUERY:

  if FOUND then
    insert into found_test_tbl values (3);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:   if FOUND then
          ^


-----------
QUERY:

  end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:   end if;
              ^


-----------
QUERY:


  delete from found_test_tbl where a = 9999;
RESULT:
	[]

-----------
QUERY:
 -- matches no rows
  if not FOUND then
    insert into found_test_tbl values (4);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:   if not FOUND then
          ^


-----------
QUERY:

  end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:   end if;
              ^


-----------
QUERY:


  for i in 1 .. 10 loop
    -- no need to do anything
  end loop;
RESULT:
	ERROR - syntax error at or near "for"
LINE 3:   for i in 1 .. 10 loop
          ^


-----------
QUERY:

  if FOUND then
    insert into found_test_tbl values (5);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:   if FOUND then
          ^


-----------
QUERY:

  end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:   end if;
              ^


-----------
QUERY:


  -- never executes the loop
  for i in 2 .. 1 loop
    -- no need to do anything
  end loop;
RESULT:
	ERROR - syntax error at or near "for"
LINE 4:   for i in 2 .. 1 loop
          ^


-----------
QUERY:

  if not FOUND then
    insert into found_test_tbl values (6);
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:   if not FOUND then
          ^


-----------
QUERY:

  end if;
RESULT:
	ERROR - syntax error at or near "if"
LINE 2:   end if;
              ^


-----------
QUERY:

  return true;
RESULT:
	ERROR - syntax error at or near "return"
LINE 2:   return true;
          ^


-----------
QUERY:

  end;
RESULT:
	[]

-----------
QUERY:
' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 1: ' language plpgsql;
        ^


-----------
QUERY:


select test_found();
RESULT:
	ERROR - function test_found() does not exist
LINE 3: select test_found();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

select * from found_test_tbl;
RESULT:
	[]

-----------
QUERY:


--
-- Test set-returning functions for PL/pgSQL
--

create function test_table_func_rec() returns setof found_test_tbl as '
DECLARE
	rec RECORD;
RESULT:
	ERROR - unterminated quoted string at or near "'
DECLARE
	rec RECORD;"
LINE 7: ...tion test_table_func_rec() returns setof found_test_tbl as '
                                                                      ^


-----------
QUERY:

BEGIN
	FOR rec IN select * from found_test_tbl LOOP
		RETURN NEXT rec;
RESULT:
	ERROR - syntax error at or near "FOR"
LINE 3:  FOR rec IN select * from found_test_tbl LOOP
         ^


-----------
QUERY:

	END LOOP;
RESULT:
	ERROR - syntax error at or near "LOOP"
LINE 2:  END LOOP;
             ^


-----------
QUERY:

	RETURN;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:  RETURN;
         ^


-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:
' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 1: ' language plpgsql;
        ^


-----------
QUERY:


select * from test_table_func_rec();
RESULT:
	ERROR - function test_table_func_rec() does not exist
LINE 3: select * from test_table_func_rec();
                      ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


create function test_table_func_row() returns setof found_test_tbl as '
DECLARE
	row found_test_tbl%ROWTYPE;
RESULT:
	ERROR - unterminated quoted string at or near "'
DECLARE
	row found_test_tbl%ROWTYPE;"
LINE 3: ...tion test_table_func_row() returns setof found_test_tbl as '
                                                                      ^


-----------
QUERY:

BEGIN
	FOR row IN select * from found_test_tbl LOOP
		RETURN NEXT row;
RESULT:
	ERROR - syntax error at or near "FOR"
LINE 3:  FOR row IN select * from found_test_tbl LOOP
         ^


-----------
QUERY:

	END LOOP;
RESULT:
	ERROR - syntax error at or near "LOOP"
LINE 2:  END LOOP;
             ^


-----------
QUERY:

	RETURN;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:  RETURN;
         ^


-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:
' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 1: ' language plpgsql;
        ^


-----------
QUERY:


select * from test_table_func_row();
RESULT:
	ERROR - function test_table_func_row() does not exist
LINE 3: select * from test_table_func_row();
                      ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


create function test_ret_set_scalar(int,int) returns setof int as '
DECLARE
	i int;
RESULT:
	ERROR - unterminated quoted string at or near "'
DECLARE
	i int;"
LINE 3: ...function test_ret_set_scalar(int,int) returns setof int as '
                                                                      ^


-----------
QUERY:

BEGIN
	FOR i IN $1 .. $2 LOOP
		RETURN NEXT i + 1;
RESULT:
	ERROR - syntax error at or near "FOR"
LINE 3:  FOR i IN $1 .. $2 LOOP
         ^


-----------
QUERY:

	END LOOP;
RESULT:
	ERROR - syntax error at or near "LOOP"
LINE 2:  END LOOP;
             ^


-----------
QUERY:

	RETURN;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:  RETURN;
         ^


-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:
' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 1: ' language plpgsql;
        ^


-----------
QUERY:


select * from test_ret_set_scalar(1,10);
RESULT:
	ERROR - function test_ret_set_scalar(integer, integer) does not exist
LINE 3: select * from test_ret_set_scalar(1,10);
                      ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


create function test_ret_set_rec_dyn(int) returns setof record as '
DECLARE
	retval RECORD;
RESULT:
	ERROR - unterminated quoted string at or near "'
DECLARE
	retval RECORD;"
LINE 3: ...function test_ret_set_rec_dyn(int) returns setof record as '
                                                                      ^


-----------
QUERY:

BEGIN
	IF $1 > 10 THEN
		SELECT INTO retval 5, 10, 15;
RESULT:
	ERROR - syntax error at or near "IF"
LINE 3:  IF $1 > 10 THEN
         ^


-----------
QUERY:

		RETURN NEXT retval;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:   RETURN NEXT retval;
          ^


-----------
QUERY:

		RETURN NEXT retval;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:   RETURN NEXT retval;
          ^


-----------
QUERY:

	ELSE
		SELECT INTO retval 50, 5::numeric, ''xxx''::text;
RESULT:
	ERROR - syntax error at or near "ELSE"
LINE 2:  ELSE
         ^


-----------
QUERY:

		RETURN NEXT retval;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:   RETURN NEXT retval;
          ^


-----------
QUERY:

		RETURN NEXT retval;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:   RETURN NEXT retval;
          ^


-----------
QUERY:

	END IF;
RESULT:
	ERROR - syntax error at or near "IF"
LINE 2:  END IF;
             ^


-----------
QUERY:

	RETURN;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:  RETURN;
         ^


-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:
' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 1: ' language plpgsql;
        ^


-----------
QUERY:


SELECT * FROM test_ret_set_rec_dyn(1500) AS (a int, b int, c int);
RESULT:
	ERROR - function test_ret_set_rec_dyn(integer) does not exist
LINE 3: SELECT * FROM test_ret_set_rec_dyn(1500) AS (a int, b int, c...
                      ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SELECT * FROM test_ret_set_rec_dyn(5) AS (a int, b numeric, c text);
RESULT:
	ERROR - function test_ret_set_rec_dyn(integer) does not exist
LINE 2: SELECT * FROM test_ret_set_rec_dyn(5) AS (a int, b numeric, ...
                      ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


create function test_ret_rec_dyn(int) returns record as '
DECLARE
	retval RECORD;
RESULT:
	ERROR - unterminated quoted string at or near "'
DECLARE
	retval RECORD;"
LINE 3: create function test_ret_rec_dyn(int) returns record as '
                                                                ^


-----------
QUERY:

BEGIN
	IF $1 > 10 THEN
		SELECT INTO retval 5, 10, 15;
RESULT:
	ERROR - syntax error at or near "IF"
LINE 3:  IF $1 > 10 THEN
         ^


-----------
QUERY:

		RETURN retval;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:   RETURN retval;
          ^


-----------
QUERY:

	ELSE
		SELECT INTO retval 50, 5::numeric, ''xxx''::text;
RESULT:
	ERROR - syntax error at or near "ELSE"
LINE 2:  ELSE
         ^


-----------
QUERY:

		RETURN retval;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:   RETURN retval;
          ^


-----------
QUERY:

	END IF;
RESULT:
	ERROR - syntax error at or near "IF"
LINE 2:  END IF;
             ^


-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:
' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 1: ' language plpgsql;
        ^


-----------
QUERY:


SELECT * FROM test_ret_rec_dyn(1500) AS (a int, b int, c int);
RESULT:
	ERROR - function test_ret_rec_dyn(integer) does not exist
LINE 3: SELECT * FROM test_ret_rec_dyn(1500) AS (a int, b int, c int...
                      ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SELECT * FROM test_ret_rec_dyn(5) AS (a int, b numeric, c text);
RESULT:
	ERROR - function test_ret_rec_dyn(integer) does not exist
LINE 2: SELECT * FROM test_ret_rec_dyn(5) AS (a int, b numeric, c te...
                      ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


--
-- Test some simple polymorphism cases.
--

create function f1(x anyelement) returns anyelement as $$
begin
  return x + 1;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(42) as int, f1(4.5) as num;
RESULT:
	[(43, Decimal('5.5'))]

-----------
QUERY:

select f1(point(3,4));
RESULT:
	ERROR - operator does not exist: point + integer
LINE 1: x + 1
          ^
HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
QUERY:  x + 1
CONTEXT:  PL/pgSQL function f1(anyelement) line 3 at RETURN


-----------
QUERY:
  -- fail for lack of + operator

drop function f1(x anyelement);
RESULT:
	[]

-----------
QUERY:


create function f1(x anyelement) returns anyarray as $$
begin
  return array[x + 1, x + 2];
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(42) as int, f1(4.5) as num;
RESULT:
	[([43, 44], [Decimal('5.5'), Decimal('6.5')])]

-----------
QUERY:


drop function f1(x anyelement);
RESULT:
	[]

-----------
QUERY:


create function f1(x anyarray) returns anyelement as $$
begin
  return x[1];
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(array[2,4]) as int, f1(array[4.5, 7.7]) as num;
RESULT:
	[(2, Decimal('4.5'))]

-----------
QUERY:


select f1(stavalues1) from pg_statistic;
RESULT:
	ERROR - cannot determine element type of "anyarray" argument


-----------
QUERY:
  -- fail, can/* REPLACED */''t infer element type

drop function f1(x anyarray);
RESULT:
	[]

-----------
QUERY:


create function f1(x anyarray) returns anyarray as $$
begin
  return x;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(array[2,4]) as int, f1(array[4.5, 7.7]) as num;
RESULT:
	[([2, 4], [Decimal('4.5'), Decimal('7.7')])]

-----------
QUERY:


select f1(stavalues1) from pg_statistic;
RESULT:
	ERROR - PL/pgSQL functions cannot accept type anyarray
CONTEXT:  compilation of PL/pgSQL function "f1" near line 1


-----------
QUERY:
  -- fail, can/* REPLACED */''t infer element type

drop function f1(x anyarray);
RESULT:
	[]

-----------
QUERY:


-- fail, can/* REPLACED */''t infer type:
create function f1(x anyelement) returns anyrange as $$
begin
  return array[x + 1, x + 2];
end$$ language plpgsql;
RESULT:
	ERROR - cannot determine result data type
DETAIL:  A result of type anyrange requires at least one input of type anyrange or anymultirange.


-----------
QUERY:


create function f1(x anyrange) returns anyarray as $$
begin
  return array[lower(x), upper(x)];
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(int4range(42, 49)) as int, f1(float8range(4.5, 7.8)) as num;
RESULT:
	[([42, 49], [4.5, 7.8])]

-----------
QUERY:


drop function f1(x anyrange);
RESULT:
	[]

-----------
QUERY:


create function f1(x anycompatible, y anycompatible) returns anycompatiblearray as $$
begin
  return array[x, y];
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(2, 4) as int, f1(2, 4.5) as num;
RESULT:
	[([2, 4], [Decimal('2'), Decimal('4.5')])]

-----------
QUERY:


drop function f1(x anycompatible, y anycompatible);
RESULT:
	[]

-----------
QUERY:


create function f1(x anycompatiblerange, y anycompatible, z anycompatible) returns anycompatiblearray as $$
begin
  return array[lower(x), upper(x), y, z];
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(int4range(42, 49), 11, 2::smallint) as int, f1(float8range(4.5, 7.8), 7.8, 11::real) as num;
RESULT:
	[([42, 49, 11, 2], [4.5, 7.8, 7.8, 11.0])]

-----------
QUERY:


select f1(int4range(42, 49), 11, 4.5) as fail;
RESULT:
	ERROR - function f1(int4range, integer, numeric) does not exist
LINE 3: select f1(int4range(42, 49), 11, 4.5) as fail;
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
  -- range type doesn/* REPLACED */''t fit

drop function f1(x anycompatiblerange, y anycompatible, z anycompatible);
RESULT:
	[]

-----------
QUERY:


-- fail, can/* REPLACED */''t infer type:
create function f1(x anycompatible) returns anycompatiblerange as $$
begin
  return array[x + 1, x + 2];
end$$ language plpgsql;
RESULT:
	ERROR - cannot determine result data type
DETAIL:  A result of type anycompatiblerange requires at least one input of type anycompatiblerange or anycompatiblemultirange.


-----------
QUERY:


create function f1(x anycompatiblerange, y anycompatiblearray) returns anycompatiblerange as $$
begin
  return x;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(int4range(42, 49), array[11]) as int, f1(float8range(4.5, 7.8), array[7]) as num;
RESULT:
	[(NumericRange(42, 49, '[)'), '[4.5,7.8)')]

-----------
QUERY:


drop function f1(x anycompatiblerange, y anycompatiblearray);
RESULT:
	[]

-----------
QUERY:


create function f1(a anyelement, b anyarray,
                   c anycompatible, d anycompatible,
                   OUT x anyarray, OUT y anycompatiblearray)
as $$
begin
  x := a || b;
  y := array[c, d];
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select x, pg_typeof(x), y, pg_typeof(y)
  from f1(11, array[1, 2], 42, 34.5);
RESULT:
	[([11, 1, 2], 'integer[]', [Decimal('42'), Decimal('34.5')], 'numeric[]')]

-----------
QUERY:

select x, pg_typeof(x), y, pg_typeof(y)
  from f1(11, array[1, 2], point(1,2), point(3,4));
RESULT:
	[([11, 1, 2], 'integer[]', '{"(1,2)","(3,4)"}', 'point[]')]

-----------
QUERY:

select x, pg_typeof(x), y, pg_typeof(y)
  from f1(11, '{1,2}', point(1,2), '(3,4)');
RESULT:
	[([11, 1, 2], 'integer[]', '{"(1,2)","(3,4)"}', 'point[]')]

-----------
QUERY:

select x, pg_typeof(x), y, pg_typeof(y)
  from f1(11, array[1, 2.2], 42, 34.5);
RESULT:
	ERROR - function f1(integer, numeric[], integer, numeric) does not exist
LINE 3:   from f1(11, array[1, 2.2], 42, 34.5);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
  -- fail

drop function f1(a anyelement, b anyarray,
                 c anycompatible, d anycompatible);
RESULT:
	[]

-----------
QUERY:


--
-- Test handling of OUT parameters, including polymorphic cases.
-- Note that RETURN is optional with OUT params /* REPLACED */, we try both ways.
--

-- wrong way to do it:
create function f1(in i int, out j int) returns int as $$
begin
  return i+1;
end$$ language plpgsql;
RESULT:
	ERROR - RETURN cannot have a parameter in function with OUT parameters
LINE 11:   return i+1;
                  ^


-----------
QUERY:


create function f1(in i int, out j int) as $$
begin
  j := i+1;
  return;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(42);
RESULT:
	[(43,)]

-----------
QUERY:

select * from f1(42);
RESULT:
	[(43,)]

-----------
QUERY:


create or replace function f1(inout i int) as $$
begin
  i := i+1;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(42);
RESULT:
	[(43,)]

-----------
QUERY:

select * from f1(42);
RESULT:
	[(43,)]

-----------
QUERY:


drop function f1(int);
RESULT:
	[]

-----------
QUERY:


create function f1(in i int, out j int) returns setof int as $$
begin
  j := i+1;
  return next;
  j := i+2;
  return next;
  return;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from f1(42);
RESULT:
	[(43,), (44,)]

-----------
QUERY:


drop function f1(int);
RESULT:
	[]

-----------
QUERY:


create function f1(in i int, out j int, out k text) as $$
begin
  j := i;
  j := j+1;
  k := 'foo';
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select f1(42);
RESULT:
	[('(43,foo)',)]

-----------
QUERY:

select * from f1(42);
RESULT:
	[(43, 'foo')]

-----------
QUERY:


drop function f1(int);
RESULT:
	[]

-----------
QUERY:


create function f1(in i int, out j int, out k text) returns setof record as $$
begin
  j := i+1;
  k := 'foo';
  return next;
  j := j+1;
  k := 'foot';
  return next;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from f1(42);
RESULT:
	[(43, 'foo'), (44, 'foot')]

-----------
QUERY:


drop function f1(int);
RESULT:
	[]

-----------
QUERY:


create function duplic(in i anyelement, out j anyelement, out k anyarray) as $$
begin
  j := i;
  k := array[j,j];
  return;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from duplic(42);
RESULT:
	[(42, [42, 42])]

-----------
QUERY:

select * from duplic('foo'::text);
RESULT:
	[('foo', ['foo', 'foo'])]

-----------
QUERY:


drop function duplic(anyelement);
RESULT:
	[]

-----------
QUERY:


create function duplic(in i anycompatiblerange, out j anycompatible, out k anycompatiblearray) as $$
begin
  j := lower(i);
  k := array[lower(i),upper(i)];
  return;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from duplic(int4range(42,49));
RESULT:
	[(42, [42, 49])]

-----------
QUERY:

select * from duplic(textrange('aaa', 'bbb'));
RESULT:
	[('aaa', ['aaa', 'bbb'])]

-----------
QUERY:


drop function duplic(anycompatiblerange);
RESULT:
	[]

-----------
QUERY:


--
-- test PERFORM
--

create table perform_test (
	a	INT,
	b	INT
);
RESULT:
	[]

-----------
QUERY:


create function perform_simple_func(int) returns boolean as '
BEGIN
	IF $1 < 20 THEN
		INSERT INTO perform_test VALUES ($1, $1 + 10);
RESULT:
	ERROR - unterminated quoted string at or near "'
BEGIN
	IF $1 < 20 THEN
		INSERT INTO perform_test VALUES ($1, $1 + 10);"
LINE 3: ...reate function perform_simple_func(int) returns boolean as '
                                                                      ^


-----------
QUERY:

		RETURN TRUE;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 2:   RETURN TRUE;
          ^


-----------
QUERY:

	ELSE
		RETURN FALSE;
RESULT:
	ERROR - syntax error at or near "ELSE"
LINE 2:  ELSE
         ^


-----------
QUERY:

	END IF;
RESULT:
	ERROR - syntax error at or near "IF"
LINE 2:  END IF;
             ^


-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:
' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 1: ' language plpgsql;
        ^


-----------
QUERY:


create function perform_test_func() returns void as '
BEGIN
	IF FOUND then
		INSERT INTO perform_test VALUES (100, 100);
RESULT:
	ERROR - unterminated quoted string at or near "'
BEGIN
	IF FOUND then
		INSERT INTO perform_test VALUES (100, 100);"
LINE 3: create function perform_test_func() returns void as '
                                                            ^


-----------
QUERY:

	END IF;
RESULT:
	ERROR - syntax error at or near "IF"
LINE 2:  END IF;
             ^


-----------
QUERY:


	PERFORM perform_simple_func(5);
RESULT:
	ERROR - syntax error at or near "PERFORM"
LINE 3:  PERFORM perform_simple_func(5);
         ^


-----------
QUERY:


	IF FOUND then
		INSERT INTO perform_test VALUES (100, 100);
RESULT:
	ERROR - syntax error at or near "IF"
LINE 3:  IF FOUND then
         ^


-----------
QUERY:

	END IF;
RESULT:
	ERROR - syntax error at or near "IF"
LINE 2:  END IF;
             ^


-----------
QUERY:


	PERFORM perform_simple_func(50);
RESULT:
	ERROR - syntax error at or near "PERFORM"
LINE 3:  PERFORM perform_simple_func(50);
         ^


-----------
QUERY:


	IF FOUND then
		INSERT INTO perform_test VALUES (100, 100);
RESULT:
	ERROR - syntax error at or near "IF"
LINE 3:  IF FOUND then
         ^


-----------
QUERY:

	END IF;
RESULT:
	ERROR - syntax error at or near "IF"
LINE 2:  END IF;
             ^


-----------
QUERY:


	RETURN;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 3:  RETURN;
         ^


-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:
' language plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "' language plpgsql;"
LINE 1: ' language plpgsql;
        ^


-----------
QUERY:


SELECT perform_test_func();
RESULT:
	ERROR - function perform_test_func() does not exist
LINE 3: SELECT perform_test_func();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SELECT * FROM perform_test;
RESULT:
	[]

-----------
QUERY:


drop table perform_test;
RESULT:
	[]

-----------
QUERY:


--
-- Test proper snapshot handling in simple expressions
--

create temp table users(login text, id serial);
RESULT:
	[]

-----------
QUERY:


create function sp_id_user(a_login text) returns int as $$
declare x int;
begin
  select into x id from users where login = a_login;
  if found then return x; end if;
  return 0;
end$$ language plpgsql stable;
RESULT:
	[]

-----------
QUERY:


insert into users values('user1');
RESULT:
	[]

-----------
QUERY:


select sp_id_user('user1');
RESULT:
	[(1,)]

-----------
QUERY:

select sp_id_user('userx');
RESULT:
	[(0,)]

-----------
QUERY:


create function sp_add_user(a_login text) returns int as $$
declare my_id_user int;
begin
  my_id_user = sp_id_user( a_login );
  IF  my_id_user > 0 THEN
    RETURN -1;  -- error code for existing user
  END IF;
  INSERT INTO users ( login ) VALUES ( a_login );
  my_id_user = sp_id_user( a_login );
  IF  my_id_user = 0 THEN
    RETURN -2;  -- error code for insertion failure
  END IF;
  RETURN my_id_user;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select sp_add_user('user1');
RESULT:
	[(-1,)]

-----------
QUERY:

select sp_add_user('user2');
RESULT:
	[(2,)]

-----------
QUERY:

select sp_add_user('user2');
RESULT:
	[(-1,)]

-----------
QUERY:

select sp_add_user('user3');
RESULT:
	[(3,)]

-----------
QUERY:

select sp_add_user('user3');
RESULT:
	[(-1,)]

-----------
QUERY:


drop function sp_add_user(text);
RESULT:
	[]

-----------
QUERY:

drop function sp_id_user(text);
RESULT:
	[]

-----------
QUERY:


--
-- tests for refcursors
--
create table rc_test (a int, b int);
RESULT:
	[]

-----------
QUERY:

copy rc_test from stdin;
RESULT:
	ERROR - can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

5	10
50	100
500	1000
\.

create function return_unnamed_refcursor() returns refcursor as $$
declare
    rc refcursor;
begin
    open rc for select a from rc_test;
    return rc;
end
$$ language plpgsql;
RESULT:
	ERROR - syntax error at or near "5"
LINE 2: 5 10
        ^


-----------
QUERY:


create function use_refcursor(rc refcursor) returns int as $$
declare
    rc refcursor;
    x record;
begin
    rc := return_unnamed_refcursor();
    fetch next from rc into x;
    return x.a;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select use_refcursor(return_unnamed_refcursor());
RESULT:
	ERROR - function return_unnamed_refcursor() does not exist
LINE 3: select use_refcursor(return_unnamed_refcursor());
                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


create function return_refcursor(rc refcursor) returns refcursor as $$
begin
    open rc for select a from rc_test;
    return rc;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


create function refcursor_test1(refcursor) returns refcursor as $$
begin
    perform return_refcursor($1);
    return $1;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


begin;
RESULT:
	[]

-----------
QUERY:


select refcursor_test1('test1');
RESULT:
	[('test1',)]

-----------
QUERY:

fetch next in test1;
RESULT:
	[]

-----------
QUERY:


select refcursor_test1('test2');
RESULT:
	[('test2',)]

-----------
QUERY:

fetch all from test2;
RESULT:
	[]

-----------
QUERY:


commit;
RESULT:
	[]

-----------
QUERY:


-- should fail
fetch next from test1;
RESULT:
	ERROR - cursor "test1" does not exist


-----------
QUERY:


create function refcursor_test2(int, int) returns boolean as $$
declare
    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
    nonsense record;
begin
    open c1($1, $2);
    fetch c1 into nonsense;
    close c1;
    if found then
        return true;
    else
        return false;
    end if;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select refcursor_test2(20000, 20000) as "Should be false",
       refcursor_test2(20, 20) as "Should be true";
RESULT:
	[(False, False)]

-----------
QUERY:


-- should fail
create function constant_refcursor() returns refcursor as $$
declare
    rc constant refcursor;
begin
    open rc for select a from rc_test;
    return rc;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select constant_refcursor();
RESULT:
	ERROR - variable "rc" is declared CONSTANT
CONTEXT:  PL/pgSQL function constant_refcursor() line 5 at OPEN


-----------
QUERY:


-- but it/* REPLACED */''s okay like this
create or replace function constant_refcursor() returns refcursor as $$
declare
    rc constant refcursor := 'my_cursor_name';
begin
    open rc for select a from rc_test;
    return rc;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select constant_refcursor();
RESULT:
	[('my_cursor_name',)]

-----------
QUERY:


--
-- tests for cursors with named parameter arguments
--
create function namedparmcursor_test1(int, int) returns boolean as $$
declare
    c1 cursor (param1 int, param12 int) for select * from rc_test where a > param1 and b > param12;
    nonsense record;
begin
    open c1(param12 := $2, param1 := $1);
    fetch c1 into nonsense;
    close c1;
    if found then
        return true;
    else
        return false;
    end if;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select namedparmcursor_test1(20000, 20000) as "Should be false",
       namedparmcursor_test1(20, 20) as "Should be true";
RESULT:
	[(False, False)]

-----------
QUERY:


-- mixing named and positional argument notations
create function namedparmcursor_test2(int, int) returns boolean as $$
declare
    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
    nonsense record;
begin
    open c1(param1 := $1, $2);
    fetch c1 into nonsense;
    close c1;
    if found then
        return true;
    else
        return false;
    end if;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

select namedparmcursor_test2(20, 20);
RESULT:
	[(False,)]

-----------
QUERY:


-- mixing named and positional: param2 is given twice, once in named notation
-- and second time in positional notation. Should throw an error at parse time
create function namedparmcursor_test3() returns void as $$
declare
    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
begin
    open c1(param2 := 20, 21);
end
$$ language plpgsql;
RESULT:
	ERROR - value for parameter "param2" of cursor "c1" specified more than once
LINE 9:     open c1(param2 := 20, 21);
                                  ^


-----------
QUERY:


-- mixing named and positional: same as previous test, but param1 is duplicated
create function namedparmcursor_test4() returns void as $$
declare
    c1 cursor (param1 int, param2 int) for select * from rc_test where a > param1 and b > param2;
begin
    open c1(20, param1 := 21);
end
$$ language plpgsql;
RESULT:
	ERROR - value for parameter "param1" of cursor "c1" specified more than once
LINE 8:     open c1(20, param1 := 21);
                        ^


-----------
QUERY:


-- duplicate named parameter, should throw an error at parse time
create function namedparmcursor_test5() returns void as $$
declare
  c1 cursor (p1 int, p2 int) for
    select * from tenk1 where thousand = p1 and tenthous = p2;
begin
  open c1 (p2 := 77, p2 := 42);
end
$$ language plpgsql;
RESULT:
	ERROR - value for parameter "p2" of cursor "c1" specified more than once
LINE 9:   open c1 (p2 := 77, p2 := 42);
                             ^


-----------
QUERY:


-- not enough parameters, should throw an error at parse time
create function namedparmcursor_test6() returns void as $$
declare
  c1 cursor (p1 int, p2 int) for
    select * from tenk1 where thousand = p1 and tenthous = p2;
begin
  open c1 (p2 := 77);
end
$$ language plpgsql;
RESULT:
	ERROR - not enough arguments for cursor "c1"
LINE 9:   open c1 (p2 := 77);
                           ^


-----------
QUERY:


-- division by zero runtime error, the context given in the error message
-- should be sensible
create function namedparmcursor_test7() returns void as $$
declare
  c1 cursor (p1 int, p2 int) for
    select * from tenk1 where thousand = p1 and tenthous = p2;
begin
  open c1 (p2 := 77, p1 := 42/0);
end $$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

select namedparmcursor_test7();
RESULT:
	ERROR - division by zero
CONTEXT:  SQL expression "42/0 AS p1, 77 AS p2"
PL/pgSQL function namedparmcursor_test7() line 6 at OPEN


-----------
QUERY:


-- check that line comments work correctly within the argument list (there
-- is some special handling of this case in the code: the newline after the
-- comment must be preserved when the argument-evaluating query is
-- constructed, otherwise the comment effectively comments out the next
-- argument, too)
create function namedparmcursor_test8() returns int4 as $$
declare
  c1 cursor (p1 int, p2 int) for
    select count(*) from tenk1 where thousand = p1 and tenthous = p2;
  n int4;
begin
  open c1 (77 -- test
  , 42);
  fetch c1 into n;
  return n;
end $$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

select namedparmcursor_test8();
RESULT:
	[(0,)]

-----------
QUERY:


-- cursor parameter name can match plpgsql variable or unreserved keyword
create function namedparmcursor_test9(p1 int) returns int4 as $$
declare
  c1 cursor (p1 int, p2 int, debug int) for
    select count(*) from tenk1 where thousand = p1 and tenthous = p2
      and four = debug;
  p2 int4 := 1006;
  n int4;
begin
  open c1 (p1 := p1, p2 := p2, debug := 2);
  fetch c1 into n;
  return n;
end $$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

select namedparmcursor_test9(6);
RESULT:
	[(1,)]

-----------
QUERY:


--
-- tests for /* REPLACED */''raise/* REPLACED */'' processing
--
create function raise_test1(int) returns int as $$
begin
    raise notice 'This message has too many parameters!', $1;
    return $1;
end;
$$ language plpgsql;
RESULT:
	ERROR - too many parameters specified for RAISE
CONTEXT:  compilation of PL/pgSQL function "raise_test1" near line 3


-----------
QUERY:


create function raise_test2(int) returns int as $$
begin
    raise notice 'This message has too few parameters: %, %, %', $1, $1;
    return $1;
end;
$$ language plpgsql;
RESULT:
	ERROR - too few parameters specified for RAISE
CONTEXT:  compilation of PL/pgSQL function "raise_test2" near line 3


-----------
QUERY:


create function raise_test3(int) returns int as $$
begin
    raise notice 'This message has no parameters (despite having %% signs in it)!';
    return $1;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test3(1);
RESULT:
	[(1,)]

-----------
QUERY:


-- Test re-RAISE inside a nested exception block.  This case is allowed
-- by Oracle/* REPLACED */''s PL/SQL but was handled differently by PG before 9.1.

CREATE FUNCTION reraise_test() RETURNS void AS $$
BEGIN
   BEGIN
       RAISE syntax_error;
   EXCEPTION
       WHEN syntax_error THEN
           BEGIN
               raise notice 'exception % thrown in inner block, reraising', sqlerrm;
               RAISE;
           EXCEPTION
               WHEN OTHERS THEN
                   raise notice 'RIGHT - exception % caught in inner block', sqlerrm;
           END;
   END;
EXCEPTION
   WHEN OTHERS THEN
       raise notice 'WRONG - exception % caught in outer block', sqlerrm;
END;
$$ LANGUAGE plpgsql;
RESULT:
	[]

-----------
QUERY:


SELECT reraise_test();
RESULT:
	[('',)]

-----------
QUERY:


--
-- reject function definitions that contain malformed SQL queries at
-- compile-time, where possible
--
create function bad_sql1() returns int as $$
declare a int;
begin
    a := 5;
    Johnny Yuma;
    a := 10;
    return a;
end$$ language plpgsql;
RESULT:
	ERROR - syntax error at or near "Johnny"
LINE 11:     Johnny Yuma;
             ^


-----------
QUERY:


create function bad_sql2() returns int as $$
declare r record;
begin
    for r in select I fought the law, the law won LOOP
        raise notice 'in loop';
    end loop;
    return 5;
end;$$ language plpgsql;
RESULT:
	ERROR - syntax error at or near "the"
LINE 6:     for r in select I fought the law, the law won LOOP
                                     ^


-----------
QUERY:


-- a RETURN expression is mandatory, except for void-returning
-- functions, where it is not allowed
create function missing_return_expr() returns int as $$
begin
    return ;
end;$$ language plpgsql;
RESULT:
	ERROR - missing expression at or near ";"
LINE 7:     return ;
                   ^


-----------
QUERY:


create function void_return_expr() returns void as $$
begin
    return 5;
end;$$ language plpgsql;
RESULT:
	ERROR - RETURN cannot have a parameter in function returning void
LINE 5:     return 5;
                   ^


-----------
QUERY:


-- VOID functions are allowed to omit RETURN
create function void_return_expr() returns void as $$
begin
    perform 2+2;
end;$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select void_return_expr();
RESULT:
	[('',)]

-----------
QUERY:


-- but ordinary functions are not
create function missing_return_expr() returns int as $$
begin
    perform 2+2;
end;$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select missing_return_expr();
RESULT:
	ERROR - control reached end of function without RETURN
CONTEXT:  PL/pgSQL function missing_return_expr()


-----------
QUERY:


drop function void_return_expr();
RESULT:
	[]

-----------
QUERY:

drop function missing_return_expr();
RESULT:
	[]

-----------
QUERY:


--
-- EXECUTE ... INTO test
--

create table eifoo (i integer, y integer);
RESULT:
	[]

-----------
QUERY:

create type eitype as (i integer, y integer);
RESULT:
	[]

-----------
QUERY:


create or replace function execute_into_test(varchar) returns record as $$
declare
    _r record;
    _rt eifoo%rowtype;
    _v eitype;
    i int;
    j int;
    k int;
begin
    execute 'insert into '||$1||' values(10,15)';
    execute 'select (row).* from (select row(10,1)::eifoo) s' into _r;
    raise notice '% %', _r.i, _r.y;
    execute 'select * from '||$1||' limit 1' into _rt;
    raise notice '% %', _rt.i, _rt.y;
    execute 'select *, 20 from '||$1||' limit 1' into i, j, k;
    raise notice '% % %', i, j, k;
    execute 'select 1,2' into _v;
    return _v;
end; $$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select execute_into_test('eifoo');
RESULT:
	[('(1,2)',)]

-----------
QUERY:


drop table eifoo cascade;
RESULT:
	[]

-----------
QUERY:

drop type eitype cascade;
RESULT:
	[]

-----------
QUERY:


--
-- SQLSTATE and SQLERRM test
--

create function excpt_test1() returns void as $$
begin
    raise notice '% %', sqlstate, sqlerrm;
end; $$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

-- should fail: SQLSTATE and SQLERRM are only in defined EXCEPTION
-- blocks
select excpt_test1();
RESULT:
	ERROR - column "sqlstate" does not exist
LINE 1: sqlstate
        ^
QUERY:  sqlstate
CONTEXT:  PL/pgSQL function excpt_test1() line 3 at RAISE


-----------
QUERY:


create function excpt_test2() returns void as $$
begin
    begin
        begin
            raise notice '% %', sqlstate, sqlerrm;
        end;
    end;
end; $$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

-- should fail
select excpt_test2();
RESULT:
	ERROR - column "sqlstate" does not exist
LINE 1: sqlstate
        ^
QUERY:  sqlstate
CONTEXT:  PL/pgSQL function excpt_test2() line 5 at RAISE


-----------
QUERY:


create function excpt_test3() returns void as $$
begin
    begin
        raise exception 'user exception';
    exception when others then
	    raise notice 'caught exception % %', sqlstate, sqlerrm;
	    begin
	        raise notice '% %', sqlstate, sqlerrm;
	        perform 10/0;
        exception
            when substring_error then
                -- this exception handler shouldn/* REPLACED */''t be invoked
                raise notice 'unexpected exception: % %', sqlstate, sqlerrm;
	        when division_by_zero then
	            raise notice 'caught exception % %', sqlstate, sqlerrm;
	    end;
	    raise notice '% %', sqlstate, sqlerrm;
    end;
end; $$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

select excpt_test3();
RESULT:
	[('',)]

-----------
QUERY:


create function excpt_test4() returns text as $$
begin
	begin perform 1/0;
	exception when others then return sqlerrm; end;
end; $$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

select excpt_test4();
RESULT:
	[('division by zero',)]

-----------
QUERY:


drop function excpt_test1();
RESULT:
	[]

-----------
QUERY:

drop function excpt_test2();
RESULT:
	[]

-----------
QUERY:

drop function excpt_test3();
RESULT:
	[]

-----------
QUERY:

drop function excpt_test4();
RESULT:
	[]

-----------
QUERY:


-- parameters of raise stmt can be expressions
create function raise_exprs() returns void as $$
declare
    a integer[] = '{10,20,30}';
    c varchar = 'xyz';
    i integer;
begin
    i := 2;
    raise notice '%; %; %; %; %; %', a, a[i], c, (select c || 'abc'), row(10,'aaa',NULL,30), NULL;
end;$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_exprs();
RESULT:
	[('',)]

-----------
QUERY:

drop function raise_exprs();
RESULT:
	[]

-----------
QUERY:


-- regression test: verify that multiple uses of same plpgsql datum within
-- a SQL command all get mapped to the same $n parameter.  The return value
-- of the SELECT is not important, we only care that it doesn/* REPLACED */''t fail with
-- a complaint about an ungrouped column reference.
create function multi_datum_use(p1 int) returns bool as $$
declare
  x int;
  y int;
begin
  select into x,y unique1/p1, unique1/$1 from tenk1 group by unique1/p1;
  return x = y;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select multi_datum_use(42);
RESULT:
	[(True,)]

-----------
QUERY:


--
-- Test STRICT limiter in both planned and EXECUTE invocations.
-- Note that a data-modifying query is quasi strict (disallow multi rows)
-- by default in the planned case, but not in EXECUTE.
--

create temp table foo (f1 int, f2 int);
RESULT:
	[]

-----------
QUERY:


insert into foo values (1,2), (3,4);
RESULT:
	[]

-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should work
  insert into foo values(5,6) returning * into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	[('',)]

-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should fail due to implicit strict
  insert into foo values(7,8),(9,10) returning * into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned more than one row
HINT:  Make sure the query returns a single row, or use LIMIT 1.
CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement


-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should work
  execute 'insert into foo values(5,6) returning *' into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	[('',)]

-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- this should work since EXECUTE isn/* REPLACED */''t as picky
  execute 'insert into foo values(7,8),(9,10) returning *' into x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	[('',)]

-----------
QUERY:


select * from foo;
RESULT:
	[(1, 2), (3, 4), (5, 6), (5, 6), (7, 8), (9, 10)]

-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should work
  select * from foo where f1 = 3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	[('',)]

-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should fail, no rows
  select * from foo where f1 = 0 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned no rows
CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement


-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should fail, too many rows
  select * from foo where f1 > 3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned more than one row
HINT:  Make sure the query returns a single row, or use LIMIT 1.
CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement


-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should work
  execute 'select * from foo where f1 = 3' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	[('',)]

-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should fail, no rows
  execute 'select * from foo where f1 = 0' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned no rows
CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE


-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- should fail, too many rows
  execute 'select * from foo where f1 > 3' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned more than one row
CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE


-----------
QUERY:


drop function stricttest();
RESULT:
	[]

-----------
QUERY:


-- test printing parameters after failure due to STRICT

set plpgsql.print_strict_params to true;
RESULT:
	[]

-----------
QUERY:


create or replace function stricttest() returns void as $$
declare
x record;
p1 int := 2;
p3 text := 'foo';
begin
  -- no rows
  select * from foo where f1 = p1 and f1::text = p3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned no rows
DETAIL:  parameters: p1 = '2', p3 = 'foo'
CONTEXT:  PL/pgSQL function stricttest() line 8 at SQL statement


-----------
QUERY:


create or replace function stricttest() returns void as $$
declare
x record;
p1 int := 2;
p3 text := $a$'Valame Dios!' dijo Sancho; 'no le dije yo a vuestra merced que mirase bien lo que hacia?'$a$;
begin
  -- no rows
  select * from foo where f1 = p1 and f1::text = p3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned no rows
DETAIL:  parameters: p1 = '2', p3 = '''Valame Dios!'' dijo Sancho; ''no le dije yo a vuestra merced que mirase bien lo que hacia?'''
CONTEXT:  PL/pgSQL function stricttest() line 8 at SQL statement


-----------
QUERY:


create or replace function stricttest() returns void as $$
declare
x record;
p1 int := 2;
p3 text := 'foo';
begin
  -- too many rows
  select * from foo where f1 > p1 or f1::text = p3  into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned more than one row
DETAIL:  parameters: p1 = '2', p3 = 'foo'
HINT:  Make sure the query returns a single row, or use LIMIT 1.
CONTEXT:  PL/pgSQL function stricttest() line 8 at SQL statement


-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- too many rows, no params
  select * from foo where f1 > 3 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned more than one row
HINT:  Make sure the query returns a single row, or use LIMIT 1.
CONTEXT:  PL/pgSQL function stricttest() line 5 at SQL statement


-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- no rows
  execute 'select * from foo where f1 = $1 or f1::text = $2' using 0, 'foo' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned no rows
DETAIL:  parameters: $1 = '0', $2 = 'foo'
CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE


-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- too many rows
  execute 'select * from foo where f1 > $1' using 1 into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned more than one row
DETAIL:  parameters: $1 = '1'
CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE


-----------
QUERY:


create or replace function stricttest() returns void as $$
declare x record;
begin
  -- too many rows, no parameters
  execute 'select * from foo where f1 > 3' into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned more than one row
CONTEXT:  PL/pgSQL function stricttest() line 5 at EXECUTE


-----------
QUERY:


create or replace function stricttest() returns void as $$
-- override the global
#print_strict_params off
declare
x record;
p1 int := 2;
p3 text := 'foo';
begin
  -- too many rows
  select * from foo where f1 > p1 or f1::text = p3  into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned more than one row
HINT:  Make sure the query returns a single row, or use LIMIT 1.
CONTEXT:  PL/pgSQL function stricttest() line 10 at SQL statement


-----------
QUERY:


reset plpgsql.print_strict_params;
RESULT:
	[]

-----------
QUERY:


create or replace function stricttest() returns void as $$
-- override the global
#print_strict_params on
declare
x record;
p1 int := 2;
p3 text := 'foo';
begin
  -- too many rows
  select * from foo where f1 > p1 or f1::text = p3  into strict x;
  raise notice 'x.f1 = %, x.f2 = %', x.f1, x.f2;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stricttest();
RESULT:
	ERROR - query returned more than one row
DETAIL:  parameters: p1 = '2', p3 = 'foo'
HINT:  Make sure the query returns a single row, or use LIMIT 1.
CONTEXT:  PL/pgSQL function stricttest() line 10 at SQL statement


-----------
QUERY:


-- test warnings and errors
set plpgsql.extra_warnings to 'all';
RESULT:
	[]

-----------
QUERY:

set plpgsql.extra_warnings to 'none';
RESULT:
	[]

-----------
QUERY:

set plpgsql.extra_errors to 'all';
RESULT:
	[]

-----------
QUERY:

set plpgsql.extra_errors to 'none';
RESULT:
	[]

-----------
QUERY:


-- test warnings when shadowing a variable

set plpgsql.extra_warnings to 'shadowed_variables';
RESULT:
	[]

-----------
QUERY:


-- simple shadowing of input and output parameters
create or replace function shadowtest(in1 int)
	returns table (out1 int) as $$
declare
in1 int;
out1 int;
begin
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

select shadowtest(1);
RESULT:
	[]

-----------
QUERY:


set plpgsql.extra_warnings to 'shadowed_variables';
RESULT:
	[]

-----------
QUERY:

select shadowtest(1);
RESULT:
	[]

-----------
QUERY:

create or replace function shadowtest(in1 int)
	returns table (out1 int) as $$
declare
in1 int;
out1 int;
begin
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

select shadowtest(1);
RESULT:
	[]

-----------
QUERY:

drop function shadowtest(int);
RESULT:
	[]

-----------
QUERY:


-- shadowing in a second DECLARE block
create or replace function shadowtest()
	returns void as $$
declare
f1 int;
begin
	declare
	f1 int;
	begin
	end;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

drop function shadowtest();
RESULT:
	[]

-----------
QUERY:


-- several levels of shadowing
create or replace function shadowtest(in1 int)
	returns void as $$
declare
in1 int;
begin
	declare
	in1 int;
	begin
	end;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

drop function shadowtest(int);
RESULT:
	[]

-----------
QUERY:


-- shadowing in cursor definitions
create or replace function shadowtest()
	returns void as $$
declare
f1 int;
c1 cursor (f1 int) for select 1;
begin
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:

drop function shadowtest();
RESULT:
	[]

-----------
QUERY:


-- test errors when shadowing a variable

set plpgsql.extra_errors to 'shadowed_variables';
RESULT:
	[]

-----------
QUERY:


create or replace function shadowtest(f1 int)
	returns boolean as $$
declare f1 int; begin return 1; end $$ language plpgsql;
RESULT:
	ERROR - variable "f1" shadows a previously defined variable
LINE 5: declare f1 int; begin return 1; end $$ language plpgsql;
                ^


-----------
QUERY:


select shadowtest(1);
RESULT:
	ERROR - function shadowtest(integer) does not exist
LINE 3: select shadowtest(1);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


reset plpgsql.extra_errors;
RESULT:
	[]

-----------
QUERY:

reset plpgsql.extra_warnings;
RESULT:
	[]

-----------
QUERY:


create or replace function shadowtest(f1 int)
	returns boolean as $$
declare f1 int; begin return 1; end $$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select shadowtest(1);
RESULT:
	[(True,)]

-----------
QUERY:


-- runtime extra checks
set plpgsql.extra_warnings to 'too_many_rows';
RESULT:
	[]

-----------
QUERY:


do $$
declare x int;
begin
  select v from generate_series(1,2) g(v) into x;
end;
$$;
RESULT:
	[]

-----------
QUERY:


set plpgsql.extra_errors to 'too_many_rows';
RESULT:
	[]

-----------
QUERY:


do $$
declare x int;
begin
  select v from generate_series(1,2) g(v) into x;
end;
$$;
RESULT:
	ERROR - query returned more than one row
HINT:  Make sure the query returns a single row, or use LIMIT 1.
CONTEXT:  PL/pgSQL function inline_code_block line 4 at SQL statement


-----------
QUERY:


reset plpgsql.extra_errors;
RESULT:
	[]

-----------
QUERY:

reset plpgsql.extra_warnings;
RESULT:
	[]

-----------
QUERY:


set plpgsql.extra_warnings to 'strict_multi_assignment';
RESULT:
	[]

-----------
QUERY:


do $$
declare
  x int;
  y int;
begin
  select 1 into x, y;
  select 1,2 into x, y;
  select 1,2,3 into x, y;
end
$$;
RESULT:
	[]

-----------
QUERY:


set plpgsql.extra_errors to 'strict_multi_assignment';
RESULT:
	[]

-----------
QUERY:


do $$
declare
  x int;
  y int;
begin
  select 1 into x, y;
  select 1,2 into x, y;
  select 1,2,3 into x, y;
end
$$;
RESULT:
	ERROR - number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_errors is active.
HINT:  Make sure the query returns the exact list of columns.
CONTEXT:  PL/pgSQL function inline_code_block line 6 at SQL statement


-----------
QUERY:


create table test_01(a int, b int, c int);
RESULT:
	[]

-----------
QUERY:


alter table test_01 drop column a;
RESULT:
	[]

-----------
QUERY:


-- the check is active only when source table is not empty
insert into test_01 values(10,20);
RESULT:
	[]

-----------
QUERY:


do $$
declare
  x int;
  y int;
begin
  select * from test_01 into x, y; -- should be ok
  raise notice 'ok';
  select * from test_01 into x;    -- should to fail
end;
$$;
RESULT:
	ERROR - number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_errors is active.
HINT:  Make sure the query returns the exact list of columns.
CONTEXT:  PL/pgSQL function inline_code_block line 8 at SQL statement


-----------
QUERY:


do $$
declare
  t test_01;
begin
  select 1, 2 into t;  -- should be ok
  raise notice 'ok';
  select 1, 2, 3 into t; -- should fail /* REPLACED */,
end;
$$;
RESULT:
	ERROR - number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_errors is active.
HINT:  Make sure the query returns the exact list of columns.
CONTEXT:  PL/pgSQL function inline_code_block line 7 at SQL statement


-----------
QUERY:


do $$
declare
  t test_01;
begin
  select 1 into t; -- should fail /* REPLACED */,
end;
$$;
RESULT:
	ERROR - number of source and target fields in assignment does not match
DETAIL:  strict_multi_assignment check of extra_errors is active.
HINT:  Make sure the query returns the exact list of columns.
CONTEXT:  PL/pgSQL function inline_code_block line 5 at SQL statement


-----------
QUERY:


drop table test_01;
RESULT:
	[]

-----------
QUERY:


reset plpgsql.extra_errors;
RESULT:
	[]

-----------
QUERY:

reset plpgsql.extra_warnings;
RESULT:
	[]

-----------
QUERY:


-- test scrollable cursor support

create function sc_test() returns setof integer as $$
declare
  c scroll cursor for select f1 from int4_tbl;
  x integer;
begin
  open c;
  fetch last from c into x;
  while found loop
    return next x;
    fetch prior from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from sc_test();
RESULT:
	[(-2147483647,), (2147483647,), (-123456,), (123456,), (0,)]

-----------
QUERY:


create or replace function sc_test() returns setof integer as $$
declare
  c no scroll cursor for select f1 from int4_tbl;
  x integer;
begin
  open c;
  fetch last from c into x;
  while found loop
    return next x;
    fetch prior from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from sc_test();
RESULT:
	ERROR - cursor can only scan forward
HINT:  Declare it with SCROLL option to enable backward scan.
CONTEXT:  PL/pgSQL function sc_test() line 7 at FETCH


-----------
QUERY:
  -- fails because of NO SCROLL specification

create or replace function sc_test() returns setof integer as $$
declare
  c refcursor;
  x integer;
begin
  open c scroll for select f1 from int4_tbl;
  fetch last from c into x;
  while found loop
    return next x;
    fetch prior from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from sc_test();
RESULT:
	[(-2147483647,), (2147483647,), (-123456,), (123456,), (0,)]

-----------
QUERY:


create or replace function sc_test() returns setof integer as $$
declare
  c refcursor;
  x integer;
begin
  open c scroll for execute 'select f1 from int4_tbl';
  fetch last from c into x;
  while found loop
    return next x;
    fetch relative -2 from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from sc_test();
RESULT:
	[(-2147483647,), (-123456,), (0,)]

-----------
QUERY:


create or replace function sc_test() returns setof integer as $$
declare
  c refcursor;
  x integer;
begin
  open c scroll for execute 'select f1 from int4_tbl';
  fetch last from c into x;
  while found loop
    return next x;
    move backward 2 from c;
    fetch relative -1 from c into x;
  end loop;
  close c;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from sc_test();
RESULT:
	[(-2147483647,), (123456,)]

-----------
QUERY:


create or replace function sc_test() returns setof integer as $$
declare
  c cursor for select * from generate_series(1, 10);
  x integer;
begin
  open c;
  loop
      move relative 2 in c;
      if not found then
          exit;
      end if;
      fetch next from c into x;
      if found then
          return next x;
      end if;
  end loop;
  close c;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from sc_test();
RESULT:
	[(3,), (6,), (9,)]

-----------
QUERY:


create or replace function sc_test() returns setof integer as $$
declare
  c cursor for select * from generate_series(1, 10);
  x integer;
begin
  open c;
  move forward all in c;
  fetch backward from c into x;
  if found then
    return next x;
  end if;
  close c;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from sc_test();
RESULT:
	[(10,)]

-----------
QUERY:


drop function sc_test();
RESULT:
	[]

-----------
QUERY:


-- test qualified variable names

create function pl_qual_names (param1 int) returns void as $$
<<outerblock>>
declare
  param1 int := 1;
begin
  <<innerblock>>
  declare
    param1 int := 2;
  begin
    raise notice 'param1 = %', param1;
    raise notice 'pl_qual_names.param1 = %', pl_qual_names.param1;
    raise notice 'outerblock.param1 = %', outerblock.param1;
    raise notice 'innerblock.param1 = %', innerblock.param1;
  end;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select pl_qual_names(42);
RESULT:
	[('',)]

-----------
QUERY:


drop function pl_qual_names(int);
RESULT:
	[]

-----------
QUERY:


-- tests for RETURN QUERY
create function ret_query1(out int, out int) returns setof record as $$
begin
    $1 := -1;
    $2 := -2;
    return next;
    return query select x + 1, x * 10 from generate_series(0, 10) s (x);
    return next;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from ret_query1();
RESULT:
	[(-1, -2), (1, 0), (2, 10), (3, 20), (4, 30), (5, 40), (6, 50), (7, 60), (8, 70), (9, 80), (10, 90), (11, 100), (-1, -2)]

-----------
QUERY:


create type record_type as (x text, y int, z boolean);
RESULT:
	[]

-----------
QUERY:


create or replace function ret_query2(lim int) returns setof record_type as $$
begin
    return query select fipshash(s.x::text), s.x, s.x > 0
                 from generate_series(-8, lim) s (x) where s.x % 2 = 0;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from ret_query2(8);
RESULT:
	[('e91592205d3881e3ea35d66973bb4898', -8, False), ('03b26944890929ff751653acb2f2af79', -6, False), ('e5e0093f285a4fb94c3fcc2ad7fd04ed', -4, False), ('cf3bae39dd692048a8bf961182e6a34d', -2, False), ('5feceb66ffc86f38d952786c6d696c79', 0, False), ('d4735e3a265e16eee03f59718b9b5d03', 2, True), ('4b227777d4dd1fc61c6f884f48641d02', 4, True), ('e7f6c011776e8db7cd330b54174fd76f', 6, True), ('2c624232cdd221771294dfbb310aca00', 8, True)]

-----------
QUERY:


-- test EXECUTE USING
create function exc_using(int, text) returns int as $$
declare i int;
begin
  for i in execute 'select * from generate_series(1,$1)' using $1+1 loop
    raise notice '%', i;
  end loop;
  execute 'select $2 + $2*3 + length($1)' into i using $2,$1;
  return i;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select exc_using(5, 'foobar');
RESULT:
	[(26,)]

-----------
QUERY:


drop function exc_using(int, text);
RESULT:
	[]

-----------
QUERY:


create or replace function exc_using(int) returns void as $$
declare
  c refcursor;
  i int;
begin
  open c for execute 'select * from generate_series(1,$1)' using $1+1;
  loop
    fetch c into i;
    exit when not found;
    raise notice '%', i;
  end loop;
  close c;
  return;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select exc_using(5);
RESULT:
	[('',)]

-----------
QUERY:


drop function exc_using(int);
RESULT:
	[]

-----------
QUERY:


-- test FOR-over-cursor

create or replace function forc01() returns void as $$
declare
  c cursor(r1 integer, r2 integer)
       for select * from generate_series(r1,r2) i;
  c2 cursor
       for select * from generate_series(41,43) i;
begin
  -- assign portal names to cursors to get stable output
  c := 'c';
  c2 := 'c2';
  for r in c(5,7) loop
    raise notice '% from %', r.i, c;
  end loop;
  -- again, to test if cursor was closed properly
  for r in c(9,10) loop
    raise notice '% from %', r.i, c;
  end loop;
  -- and test a parameterless cursor
  for r in c2 loop
    raise notice '% from %', r.i, c2;
  end loop;
  -- and try it with a hand-assigned name
  raise notice 'after loop, c2 = %', c2;
  c2 := 'special_name';
  for r in c2 loop
    raise notice '% from %', r.i, c2;
  end loop;
  raise notice 'after loop, c2 = %', c2;
  -- and try it with a generated name
  -- (which we can/* REPLACED */''t show in the output because it/* REPLACED */''s variable)
  c2 := null;
  for r in c2 loop
    raise notice '%', r.i;
  end loop;
  raise notice 'after loop, c2 = %', c2;
  return;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select forc01();
RESULT:
	[('',)]

-----------
QUERY:


-- try updating the cursor/* REPLACED */''s current row

create temp table forc_test as
  select n as i, n as j from generate_series(1,10) n;
RESULT:
	[]

-----------
QUERY:


create or replace function forc01() returns void as $$
declare
  c cursor for select * from forc_test;
begin
  for r in c loop
    raise notice '%, %', r.i, r.j;
    update forc_test set i = i * 100, j = r.j * 2 where current of c;
  end loop;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select forc01();
RESULT:
	[('',)]

-----------
QUERY:


select * from forc_test;
RESULT:
	[(100, 2), (200, 4), (300, 6), (400, 8), (500, 10), (600, 12), (700, 14), (800, 16), (900, 18), (1000, 20)]

-----------
QUERY:


-- same, with a cursor whose portal name doesn/* REPLACED */''t match variable name
create or replace function forc01() returns void as $$
declare
  c refcursor := 'fooled_ya';
  r record;
begin
  open c for select * from forc_test;
  loop
    fetch c into r;
    exit when not found;
    raise notice '%, %', r.i, r.j;
    update forc_test set i = i * 100, j = r.j * 2 where current of c;
  end loop;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select forc01();
RESULT:
	[('',)]

-----------
QUERY:


select * from forc_test;
RESULT:
	[(10000, 4), (20000, 8), (30000, 12), (40000, 16), (50000, 20), (60000, 24), (70000, 28), (80000, 32), (90000, 36), (100000, 40)]

-----------
QUERY:


drop function forc01();
RESULT:
	[]

-----------
QUERY:


-- it/* REPLACED */''s okay to re-use a cursor variable name, even when bound

do $$
declare cnt int := 0;
  c1 cursor for select * from forc_test;
begin
  for r1 in c1 loop
    declare c1 cursor for select * from forc_test;
    begin
      for r2 in c1 loop
        cnt := cnt + 1;
      end loop;
    end;
  end loop;
  raise notice 'cnt = %', cnt;
end $$;
RESULT:
	[]

-----------
QUERY:


-- fail because cursor has no query bound to it

create or replace function forc_bad() returns void as $$
declare
  c refcursor;
begin
  for r in c loop
    raise notice '%', r.i;
  end loop;
end;
$$ language plpgsql;
RESULT:
	ERROR - cursor FOR loop must use a bound cursor variable
LINE 9:   for r in c loop
                   ^


-----------
QUERY:


-- test RETURN QUERY EXECUTE

create or replace function return_dquery()
returns setof int as $$
begin
  return query execute 'select * from (values(10),(20)) f';
  return query execute 'select * from (values($1),($2)) f' using 40,50;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from return_dquery();
RESULT:
	[(10,), (20,), (40,), (50,)]

-----------
QUERY:


drop function return_dquery();
RESULT:
	[]

-----------
QUERY:


-- test RETURN QUERY with dropped columns

create table tabwithcols(a int, b int, c int, d int);
RESULT:
	[]

-----------
QUERY:

insert into tabwithcols values(10,20,30,40),(50,60,70,80);
RESULT:
	[]

-----------
QUERY:


create or replace function returnqueryf()
returns setof tabwithcols as $$
begin
  return query select * from tabwithcols;
  return query execute 'select * from tabwithcols';
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from returnqueryf();
RESULT:
	[(10, 20, 30, 40), (50, 60, 70, 80), (10, 20, 30, 40), (50, 60, 70, 80)]

-----------
QUERY:


alter table tabwithcols drop column b;
RESULT:
	[]

-----------
QUERY:


select * from returnqueryf();
RESULT:
	[(10, 30, 40), (50, 70, 80), (10, 30, 40), (50, 70, 80)]

-----------
QUERY:


alter table tabwithcols drop column d;
RESULT:
	[]

-----------
QUERY:


select * from returnqueryf();
RESULT:
	[(10, 30), (50, 70), (10, 30), (50, 70)]

-----------
QUERY:


alter table tabwithcols add column d int;
RESULT:
	[]

-----------
QUERY:


select * from returnqueryf();
RESULT:
	[(10, 30, None), (50, 70, None), (10, 30, None), (50, 70, None)]

-----------
QUERY:


drop function returnqueryf();
RESULT:
	[]

-----------
QUERY:

drop table tabwithcols;
RESULT:
	[]

-----------
QUERY:


--
-- Tests for composite-type results
--

create type compostype as (x int, y varchar);
RESULT:
	[]

-----------
QUERY:


-- test: use of variable of composite type in return statement
create or replace function compos() returns compostype as $$
declare
  v compostype;
begin
  v := (1, 'hello');
  return v;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select compos();
RESULT:
	[('(1,hello)',)]

-----------
QUERY:


-- test: use of variable of record type in return statement
create or replace function compos() returns compostype as $$
declare
  v record;
begin
  v := (1, 'hello'::varchar);
  return v;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select compos();
RESULT:
	[('(1,hello)',)]

-----------
QUERY:


-- test: use of row expr in return statement
create or replace function compos() returns compostype as $$
begin
  return (1, 'hello'::varchar);
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select compos();
RESULT:
	[('(1,hello)',)]

-----------
QUERY:


-- this does not work currently (no implicit casting)
create or replace function compos() returns compostype as $$
begin
  return (1, 'hello');
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select compos();
RESULT:
	ERROR - returned record type does not match expected record type
DETAIL:  Returned type unknown does not match expected type character varying in column 2.
CONTEXT:  PL/pgSQL function compos() while casting return value to function's return type


-----------
QUERY:


-- ... but this does
create or replace function compos() returns compostype as $$
begin
  return (1, 'hello')::compostype;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select compos();
RESULT:
	[('(1,hello)',)]

-----------
QUERY:


drop function compos();
RESULT:
	[]

-----------
QUERY:


-- test: return a row expr as record.
create or replace function composrec() returns record as $$
declare
  v record;
begin
  v := (1, 'hello');
  return v;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select composrec();
RESULT:
	[('(1,hello)',)]

-----------
QUERY:


-- test: return row expr in return statement.
create or replace function composrec() returns record as $$
begin
  return (1, 'hello');
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select composrec();
RESULT:
	[('(1,hello)',)]

-----------
QUERY:


drop function composrec();
RESULT:
	[]

-----------
QUERY:


-- test: row expr in RETURN NEXT statement.
create or replace function compos() returns setof compostype as $$
begin
  for i in 1..3
  loop
    return next (1, 'hello'::varchar);
  end loop;
  return next null::compostype;
  return next (2, 'goodbye')::compostype;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from compos();
RESULT:
	[(1, 'hello'), (1, 'hello'), (1, 'hello'), (None, None), (2, 'goodbye')]

-----------
QUERY:


drop function compos();
RESULT:
	[]

-----------
QUERY:


-- test: use invalid expr in return statement.
create or replace function compos() returns compostype as $$
begin
  return 1 + 1;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select compos();
RESULT:
	ERROR - cannot return non-composite value from function returning composite type
CONTEXT:  PL/pgSQL function compos() line 3 at RETURN


-----------
QUERY:


-- RETURN variable is a different code path ...
create or replace function compos() returns compostype as $$
declare x int := 42;
begin
  return x;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from compos();
RESULT:
	ERROR - cannot return non-composite value from function returning composite type
CONTEXT:  PL/pgSQL function compos() line 4 at RETURN


-----------
QUERY:


drop function compos();
RESULT:
	[]

-----------
QUERY:


-- test: invalid use of composite variable in scalar-returning function
create or replace function compos() returns int as $$
declare
  v compostype;
begin
  v := (1, 'hello');
  return v;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select compos();
RESULT:
	ERROR - invalid input syntax for type integer: "(1,hello)"
CONTEXT:  PL/pgSQL function compos() while casting return value to function's return type


-----------
QUERY:


-- test: invalid use of composite expression in scalar-returning function
create or replace function compos() returns int as $$
begin
  return (1, 'hello')::compostype;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select compos();
RESULT:
	ERROR - invalid input syntax for type integer: "(1,hello)"
CONTEXT:  PL/pgSQL function compos() while casting return value to function's return type


-----------
QUERY:


drop function compos();
RESULT:
	[]

-----------
QUERY:

drop type compostype;
RESULT:
	[]

-----------
QUERY:


--
-- Tests for 8.4/* REPLACED */''s new RAISE features
--

create or replace function raise_test() returns void as $$
begin
  raise notice '% % %', 1, 2, 3
     using errcode = '55001', detail = 'some detail info', hint = 'some hint';
  raise '% % %', 1, 2, 3
     using errcode = 'division_by_zero', detail = 'some detail info';
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - 1 2 3
DETAIL:  some detail info
CONTEXT:  PL/pgSQL function raise_test() line 5 at RAISE


-----------
QUERY:


-- Since we can/* REPLACED */''t actually see the thrown SQLSTATE in default psql output,
-- test it like this /* REPLACED */, this also tests re-RAISE

create or replace function raise_test() returns void as $$
begin
  raise 'check me'
     using errcode = 'division_by_zero', detail = 'some detail info';
  exception
    when others then
      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - check me
DETAIL:  some detail info
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


create or replace function raise_test() returns void as $$
begin
  raise 'check me'
     using errcode = '1234F', detail = 'some detail info';
  exception
    when others then
      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - check me
DETAIL:  some detail info
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


-- SQLSTATE specification in WHEN
create or replace function raise_test() returns void as $$
begin
  raise 'check me'
     using errcode = '1234F', detail = 'some detail info';
  exception
    when sqlstate '1234F' then
      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - check me
DETAIL:  some detail info
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


create or replace function raise_test() returns void as $$
begin
  raise division_by_zero using detail = 'some detail info';
  exception
    when others then
      raise notice 'SQLSTATE: % SQLERRM: %', sqlstate, sqlerrm;
      raise;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - division_by_zero
DETAIL:  some detail info
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


create or replace function raise_test() returns void as $$
begin
  raise division_by_zero;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - division_by_zero
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


create or replace function raise_test() returns void as $$
begin
  raise sqlstate '1234F';
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - 1234F
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


create or replace function raise_test() returns void as $$
begin
  raise division_by_zero using message = 'custom' || ' message';
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - custom message
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


create or replace function raise_test() returns void as $$
begin
  raise using message = 'custom' || ' message', errcode = '22012';
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - custom message
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


-- conflict on message
create or replace function raise_test() returns void as $$
begin
  raise notice 'some message' using message = 'custom' || ' message', errcode = '22012';
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - RAISE option already specified: MESSAGE
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


-- conflict on errcode
create or replace function raise_test() returns void as $$
begin
  raise division_by_zero using message = 'custom' || ' message', errcode = '22012';
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - RAISE option already specified: ERRCODE
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


-- nothing to re-RAISE
create or replace function raise_test() returns void as $$
begin
  raise;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - RAISE without parameters cannot be used outside an exception handler
CONTEXT:  PL/pgSQL function raise_test() line 3 at RAISE


-----------
QUERY:


-- test access to exception data
create function zero_divide() returns int as $$
declare v int := 0;
begin
  return 10 / v;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


create or replace function raise_test() returns void as $$
begin
  raise exception 'custom exception'
     using detail = 'some detail of custom exception',
           hint = 'some hint related to custom exception';
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


create function stacked_diagnostics_test() returns void as $$
declare _sqlstate text;
        _message text;
        _context text;
begin
  perform zero_divide();
exception when others then
  get stacked diagnostics
        _sqlstate = returned_sqlstate,
        _message = message_text,
        _context = pg_exception_context;
  raise notice 'sqlstate: %, message: %, context: [%]',
    _sqlstate, _message, replace(_context, E'\n', ' <- ');
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stacked_diagnostics_test();
RESULT:
	[('',)]

-----------
QUERY:


create or replace function stacked_diagnostics_test() returns void as $$
declare _detail text;
        _hint text;
        _message text;
begin
  perform raise_test();
exception when others then
  get stacked diagnostics
        _message = message_text,
        _detail = pg_exception_detail,
        _hint = pg_exception_hint;
  raise notice 'message: %, detail: %, hint: %', _message, _detail, _hint;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stacked_diagnostics_test();
RESULT:
	[('',)]

-----------
QUERY:


-- fail, cannot use stacked diagnostics statement outside handler
create or replace function stacked_diagnostics_test() returns void as $$
declare _detail text;
        _hint text;
        _message text;
begin
  get stacked diagnostics
        _message = message_text,
        _detail = pg_exception_detail,
        _hint = pg_exception_hint;
  raise notice 'message: %, detail: %, hint: %', _message, _detail, _hint;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stacked_diagnostics_test();
RESULT:
	ERROR - GET STACKED DIAGNOSTICS cannot be used outside an exception handler
CONTEXT:  PL/pgSQL function stacked_diagnostics_test() line 6 at GET STACKED DIAGNOSTICS


-----------
QUERY:


drop function zero_divide();
RESULT:
	[]

-----------
QUERY:

drop function stacked_diagnostics_test();
RESULT:
	[]

-----------
QUERY:


-- check cases where implicit SQLSTATE variable could be confused with
-- SQLSTATE as a keyword, cf bug #5524
create or replace function raise_test() returns void as $$
begin
  perform 1/0;
exception
  when sqlstate '22012' then
    raise notice using message = sqlstate;
    raise sqlstate '22012' using message = 'substitute message';
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select raise_test();
RESULT:
	ERROR - substitute message
CONTEXT:  PL/pgSQL function raise_test() line 7 at RAISE


-----------
QUERY:


drop function raise_test();
RESULT:
	[]

-----------
QUERY:


-- test passing column_name, constraint_name, datatype_name, table_name
-- and schema_name error fields

create or replace function stacked_diagnostics_test() returns void as $$
declare _column_name text;
        _constraint_name text;
        _datatype_name text;
        _table_name text;
        _schema_name text;
begin
  raise exception using
    column = '>>some column name<<',
    constraint = '>>some constraint name<<',
    datatype = '>>some datatype name<<',
    table = '>>some table name<<',
    schema = '>>some schema name<<';
exception when others then
  get stacked diagnostics
        _column_name = column_name,
        _constraint_name = constraint_name,
        _datatype_name = pg_datatype_name,
        _table_name = table_name,
        _schema_name = schema_name;
  raise notice 'column %, constraint %, type %, table %, schema %',
    _column_name, _constraint_name, _datatype_name, _table_name, _schema_name;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select stacked_diagnostics_test();
RESULT:
	[('',)]

-----------
QUERY:


drop function stacked_diagnostics_test();
RESULT:
	[]

-----------
QUERY:


-- test variadic functions

create or replace function vari(variadic int[])
returns void as $$
begin
  for i in array_lower($1,1)..array_upper($1,1) loop
    raise notice '%', $1[i];
  end loop; end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select vari(1,2,3,4,5);
RESULT:
	[('',)]

-----------
QUERY:

select vari(3,4,5);
RESULT:
	[('',)]

-----------
QUERY:

select vari(variadic array[5,6,7]);
RESULT:
	[('',)]

-----------
QUERY:


drop function vari(int[]);
RESULT:
	[]

-----------
QUERY:


-- coercion test
create or replace function pleast(variadic numeric[])
returns numeric as $$
declare aux numeric = $1[array_lower($1,1)];
begin
  for i in array_lower($1,1)+1..array_upper($1,1) loop
    if $1[i] < aux then aux := $1[i]; end if;
  end loop;
  return aux;
end;
$$ language plpgsql immutable strict;
RESULT:
	[]

-----------
QUERY:


select pleast(10,1,2,3,-16);
RESULT:
	[(Decimal('-16'),)]

-----------
QUERY:

select pleast(10.2,2.2,-1.1);
RESULT:
	[(Decimal('-1.1'),)]

-----------
QUERY:

select pleast(10.2,10, -20);
RESULT:
	[(Decimal('-20'),)]

-----------
QUERY:

select pleast(10,20, -1.0);
RESULT:
	[(Decimal('-1.0'),)]

-----------
QUERY:


-- in case of conflict, non-variadic version is preferred
create or replace function pleast(numeric)
returns numeric as $$
begin
  raise notice 'non-variadic function called';
  return $1;
end;
$$ language plpgsql immutable strict;
RESULT:
	[]

-----------
QUERY:


select pleast(10);
RESULT:
	[(Decimal('10'),)]

-----------
QUERY:


drop function pleast(numeric[]);
RESULT:
	[]

-----------
QUERY:

drop function pleast(numeric);
RESULT:
	[]

-----------
QUERY:


-- test table functions

create function tftest(int) returns table(a int, b int) as $$
begin
  return query select $1, $1+i from generate_series(1,5) g(i);
end;
$$ language plpgsql immutable strict;
RESULT:
	[]

-----------
QUERY:


select * from tftest(10);
RESULT:
	[(10, 11), (10, 12), (10, 13), (10, 14), (10, 15)]

-----------
QUERY:


create or replace function tftest(a1 int) returns table(a int, b int) as $$
begin
  a := a1; b := a1 + 1;
  return next;
  a := a1 * 10; b := a1 * 10 + 1;
  return next;
end;
$$ language plpgsql immutable strict;
RESULT:
	[]

-----------
QUERY:


select * from tftest(10);
RESULT:
	[(10, 11), (100, 101)]

-----------
QUERY:


drop function tftest(int);
RESULT:
	[]

-----------
QUERY:


create function rttest()
returns setof int as $$
declare rc int;
begin
  return query values(10),(20);
  get diagnostics rc = row_count;
  raise notice '% %', found, rc;
  return query select * from (values(10),(20)) f(a) where false;
  get diagnostics rc = row_count;
  raise notice '% %', found, rc;
  return query execute 'values(10),(20)';
  get diagnostics rc = row_count;
  raise notice '% %', found, rc;
  return query execute 'select * from (values(10),(20)) f(a) where false';
  get diagnostics rc = row_count;
  raise notice '% %', found, rc;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from rttest();
RESULT:
	[(10,), (20,), (10,), (20,)]

-----------
QUERY:


-- check some error cases, too

create or replace function rttest()
returns setof int as $$
begin
  return query select 10 into no_such_table;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from rttest();
RESULT:
	ERROR - SELECT INTO query does not return tuples
CONTEXT:  SQL statement "select 10 into no_such_table"
PL/pgSQL function rttest() line 3 at RETURN QUERY


-----------
QUERY:


create or replace function rttest()
returns setof int as $$
begin
  return query execute 'select 10 into no_such_table';
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from rttest();
RESULT:
	ERROR - SELECT INTO query does not return tuples
CONTEXT:  SQL statement "select 10 into no_such_table"
PL/pgSQL function rttest() line 3 at RETURN QUERY


-----------
QUERY:


select * from no_such_table;
RESULT:
	ERROR - relation "no_such_table" does not exist
LINE 3: select * from no_such_table;
                      ^


-----------
QUERY:


drop function rttest();
RESULT:
	[]

-----------
QUERY:


-- Test for proper cleanup at subtransaction exit.  This example
-- exposed a bug in PG 8.2.

CREATE FUNCTION leaker_1(fail BOOL) RETURNS INTEGER AS $$
DECLARE
  v_var INTEGER;
BEGIN
  BEGIN
    v_var := (leaker_2(fail)).error_code;
  EXCEPTION
    WHEN others THEN RETURN 0;
  END;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION leaker_2(fail BOOL, OUT error_code INTEGER, OUT new_id INTEGER)
  RETURNS RECORD AS $$
BEGIN
  IF fail THEN
    RAISE EXCEPTION 'fail ...';
  END IF;
  error_code := 1;
  new_id := 1;
  RETURN;
END;
$$ LANGUAGE plpgsql;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM leaker_1(false);
RESULT:
	[(1,)]

-----------
QUERY:

SELECT * FROM leaker_1(true);
RESULT:
	[(0,)]

-----------
QUERY:


DROP FUNCTION leaker_1(bool);
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION leaker_2(bool);
RESULT:
	[]

-----------
QUERY:


-- Test for appropriate cleanup of non-simple expression evaluations
-- (bug in all versions prior to August 2010)

CREATE FUNCTION nonsimple_expr_test() RETURNS text[] AS $$
DECLARE
  arr text[];
  lr text;
  i integer;
BEGIN
  arr := array[array['foo','bar'], array['baz', 'quux']];
  lr := 'fool';
  i := 1;
  -- use sub-SELECTs to make expressions non-simple
  arr[(SELECT i)][(SELECT i+1)] := (SELECT lr);
  RETURN arr;
END;
$$ LANGUAGE plpgsql;
RESULT:
	[]

-----------
QUERY:


SELECT nonsimple_expr_test();
RESULT:
	[([['foo', 'fool'], ['baz', 'quux']],)]

-----------
QUERY:


DROP FUNCTION nonsimple_expr_test();
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION nonsimple_expr_test() RETURNS integer AS $$
declare
   i integer NOT NULL := 0;
begin
  begin
    i := (SELECT NULL::integer);  -- should throw error
  exception
    WHEN OTHERS THEN
      i := (SELECT 1::integer);
  end;
  return i;
end;
$$ LANGUAGE plpgsql;
RESULT:
	[]

-----------
QUERY:


SELECT nonsimple_expr_test();
RESULT:
	[(1,)]

-----------
QUERY:


DROP FUNCTION nonsimple_expr_test();
RESULT:
	[]

-----------
QUERY:


--
-- Test cases involving recursion and error recovery in simple expressions
-- (bugs in all versions before October 2010).  The problems are most
-- easily exposed by mutual recursion between plpgsql and sql functions.
--

create function recurse(float8) returns float8 as
$$
begin
  if ($1 > 0) then
    return sql_recurse($1 - 1);
  else
    return $1;
  end if;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


-- /* REPLACED */''limit/* REPLACED */'' is to prevent this from being inlined
create function sql_recurse(float8) returns float8 as
$$ select recurse($1) limit 1; $$ language sql;
RESULT:
	[]

-----------
QUERY:


select recurse(10);
RESULT:
	[(0.0,)]

-----------
QUERY:


create function error1(text) returns text language sql as
$$ SELECT relname::text FROM pg_class c WHERE c.oid = $1::regclass $$;
RESULT:
	[]

-----------
QUERY:


create function error2(p_name_table text) returns text language plpgsql as $$
begin
  return error1(p_name_table);
end$$;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

create table public.stuffs (stuff text);
RESULT:
	[]

-----------
QUERY:

SAVEPOINT a;
RESULT:
	[]

-----------
QUERY:

select error2('nonexistent.stuffs');
RESULT:
	ERROR - schema "nonexistent" does not exist
CONTEXT:  SQL function "error1" statement 1
PL/pgSQL function error2(text) line 3 at RETURN


-----------
QUERY:

ROLLBACK TO a;
RESULT:
	[]

-----------
QUERY:

select error2('public.stuffs');
RESULT:
	[('stuffs',)]

-----------
QUERY:

rollback;
RESULT:
	[]

-----------
QUERY:


drop function error2(p_name_table text);
RESULT:
	[]

-----------
QUERY:

drop function error1(text);
RESULT:
	[]

-----------
QUERY:


-- Test for proper handling of cast-expression caching

create function sql_to_date(integer) returns date as $$
select $1::text::date
$$ language sql immutable strict;
RESULT:
	[]

-----------
QUERY:


create cast (integer as date) with function sql_to_date(integer) as assignment;
RESULT:
	[]

-----------
QUERY:


create function cast_invoker(integer) returns date as $$
begin
  return $1;
end$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select cast_invoker(20150717);
RESULT:
	[(datetime.date(2015, 7, 17),)]

-----------
QUERY:

select cast_invoker(20150718);
RESULT:
	[(datetime.date(2015, 7, 18),)]

-----------
QUERY:
  -- second call crashed in pre-release 9.5

begin;
RESULT:
	[]

-----------
QUERY:

select cast_invoker(20150717);
RESULT:
	[(datetime.date(2015, 7, 17),)]

-----------
QUERY:

select cast_invoker(20150718);
RESULT:
	[(datetime.date(2015, 7, 18),)]

-----------
QUERY:

savepoint s1;
RESULT:
	[]

-----------
QUERY:

select cast_invoker(20150718);
RESULT:
	[(datetime.date(2015, 7, 18),)]

-----------
QUERY:

select cast_invoker(-1);
RESULT:
	ERROR - invalid input syntax for type date: "-1"
CONTEXT:  SQL function "sql_to_date" statement 1
PL/pgSQL function cast_invoker(integer) while casting return value to function's return type


-----------
QUERY:
 -- fails
rollback to savepoint s1;
RESULT:
	[]

-----------
QUERY:

select cast_invoker(20150719);
RESULT:
	[(datetime.date(2015, 7, 19),)]

-----------
QUERY:

select cast_invoker(20150720);
RESULT:
	[(datetime.date(2015, 7, 20),)]

-----------
QUERY:

commit;
RESULT:
	[]

-----------
QUERY:


drop function cast_invoker(integer);
RESULT:
	[]

-----------
QUERY:

drop function sql_to_date(integer) cascade;
RESULT:
	[]

-----------
QUERY:


-- Test handling of cast cache inside DO blocks
-- (to check the original crash case, this must be a cast not previously
-- used in this session)

begin;
RESULT:
	[]

-----------
QUERY:

do $$ declare x text[]; begin x := '{1.23, 4.56}'::numeric[]; end $$;
RESULT:
	[]

-----------
QUERY:

do $$ declare x text[]; begin x := '{1.23, 4.56}'::numeric[]; end $$;
RESULT:
	[]

-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:


-- Test for consistent reporting of error context

create function fail() returns int language plpgsql as $$
begin
  return 1/0;
end
$$;
RESULT:
	[]

-----------
QUERY:


select fail();
RESULT:
	ERROR - division by zero
CONTEXT:  SQL expression "1/0"
PL/pgSQL function fail() line 3 at RETURN


-----------
QUERY:

select fail();
RESULT:
	ERROR - division by zero
CONTEXT:  SQL expression "1/0"
PL/pgSQL function fail() line 3 at RETURN


-----------
QUERY:


drop function fail();
RESULT:
	[]

-----------
QUERY:


-- Test handling of string literals.

set standard_conforming_strings = off;
RESULT:
	[]

-----------
QUERY:


create or replace function strtest() returns text as $$
begin
  raise notice 'foo\\bar\041baz';
  return 'foo\\bar\041baz';
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select strtest();
RESULT:
	[('foo\\bar!baz',)]

-----------
QUERY:


create or replace function strtest() returns text as $$
begin
  raise notice E'foo\\bar\041baz';
  return E'foo\\bar\041baz';
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select strtest();
RESULT:
	[('foo\\bar!baz',)]

-----------
QUERY:


set standard_conforming_strings = on;
RESULT:
	[]

-----------
QUERY:


create or replace function strtest() returns text as $$
begin
  raise notice 'foo\\bar\041baz\';
  return 'foo\\bar\041baz\';
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select strtest();
RESULT:
	[('foo\\\\bar\\041baz\\',)]

-----------
QUERY:


create or replace function strtest() returns text as $$
begin
  raise notice E'foo\\bar\041baz';
  return E'foo\\bar\041baz';
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select strtest();
RESULT:
	[('foo\\bar!baz',)]

-----------
QUERY:


drop function strtest();
RESULT:
	[]

-----------
QUERY:


-- Test anonymous code blocks.

DO $$
DECLARE r record;
BEGIN
    FOR r IN SELECT rtrim(roomno) AS roomno, comment FROM Room ORDER BY roomno
    LOOP
        RAISE NOTICE '%, %', r.roomno, r.comment;
    END LOOP;
END$$;
RESULT:
	[]

-----------
QUERY:


-- these are to check syntax error reporting
DO LANGUAGE plpgsql $$begin return 1; end$$;
RESULT:
	ERROR - RETURN cannot have a parameter in function returning void
LINE 4: DO LANGUAGE plpgsql $$begin return 1; end$$;
                                           ^


-----------
QUERY:


DO $$
DECLARE r record;
BEGIN
    FOR r IN SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno
    LOOP
        RAISE NOTICE '%, %', r.roomno, r.comment;
    END LOOP;
END$$;
RESULT:
	ERROR - column "foo" does not exist
LINE 1: SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomn...
                                        ^
QUERY:  SELECT rtrim(roomno) AS roomno, foo FROM Room ORDER BY roomno
CONTEXT:  PL/pgSQL function inline_code_block line 4 at FOR over SELECT rows


-----------
QUERY:


-- Check handling of errors thrown from/into anonymous code blocks.
do $outer$
begin
  for i in 1..10 loop
   begin
    execute $ex$
      do $$
      declare x int = 0;
      begin
        x := 1 / x;
      end;
      $$;
RESULT:
	ERROR - unterminated dollar-quoted string at or near "$outer$
begin
  for i in 1..10 loop
   begin
    execute $ex$
      do $$
      declare x int = 0;
      begin
        x := 1 / x;
      end;
      $$;"
LINE 4: do $outer$
           ^


-----------
QUERY:

    $ex$;
RESULT:
	ERROR - unterminated dollar-quoted string at or near "$ex$;"
LINE 2:     $ex$;
            ^


-----------
QUERY:

  exception when division_by_zero then
    raise notice 'caught division by zero';
RESULT:
	ERROR - syntax error at or near "exception"
LINE 2:   exception when division_by_zero then
          ^


-----------
QUERY:

  end;
RESULT:
	[]

-----------
QUERY:

  end loop;
RESULT:
	ERROR - syntax error at or near "loop"
LINE 2:   end loop;
              ^


-----------
QUERY:

end;
RESULT:
	[]

-----------
QUERY:

$outer$;
RESULT:
	ERROR - unterminated dollar-quoted string at or near "$outer$;"
LINE 2: $outer$;
        ^


-----------
QUERY:


-- Check variable scoping -- a var is not available in its own or prior
-- default expressions, but it is available in later ones.

do $$
declare x int := x + 1;  -- error
begin
  raise notice 'x = %', x;
end;
$$;
RESULT:
	ERROR - column "x" does not exist
LINE 1: x + 1
        ^
QUERY:  x + 1
CONTEXT:  PL/pgSQL function inline_code_block line 2 during statement block local variable initialization


-----------
QUERY:


do $$
declare y int := x + 1;  -- error
        x int := 42;
begin
  raise notice 'x = %, y = %', x, y;
end;
$$;
RESULT:
	ERROR - column "x" does not exist
LINE 1: x + 1
        ^
QUERY:  x + 1
CONTEXT:  PL/pgSQL function inline_code_block line 2 during statement block local variable initialization


-----------
QUERY:


do $$
declare x int := 42;
        y int := x + 1;
begin
  raise notice 'x = %, y = %', x, y;
end;
$$;
RESULT:
	[]

-----------
QUERY:


do $$
declare x int := 42;
begin
  declare y int := x + 1;
          x int := x + 2;
          z int := x * 10;
  begin
    raise notice 'x = %, y = %, z = %', x, y, z;
  end;
end;
$$;
RESULT:
	[]

-----------
QUERY:


-- Check handling of conflicts between plpgsql vars and table columns.

set plpgsql.variable_conflict = error;
RESULT:
	[]

-----------
QUERY:


create function conflict_test() returns setof int8_tbl as $$
declare r record;
  q1 bigint := 42;
begin
  for r in select q1,q2 from int8_tbl loop
    return next r;
  end loop;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from conflict_test();
RESULT:
	ERROR - column reference "q1" is ambiguous
LINE 1: select q1,q2 from int8_tbl
               ^
DETAIL:  It could refer to either a PL/pgSQL variable or a table column.
QUERY:  select q1,q2 from int8_tbl
CONTEXT:  PL/pgSQL function conflict_test() line 5 at FOR over SELECT rows


-----------
QUERY:


create or replace function conflict_test() returns setof int8_tbl as $$
#variable_conflict use_variable
declare r record;
  q1 bigint := 42;
begin
  for r in select q1,q2 from int8_tbl loop
    return next r;
  end loop;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from conflict_test();
RESULT:
	[(42, 456), (42, 4567890123456789), (42, 123), (42, 4567890123456789), (42, -4567890123456789)]

-----------
QUERY:


create or replace function conflict_test() returns setof int8_tbl as $$
#variable_conflict use_column
declare r record;
  q1 bigint := 42;
begin
  for r in select q1,q2 from int8_tbl loop
    return next r;
  end loop;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select * from conflict_test();
RESULT:
	[(123, 456), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789)]

-----------
QUERY:


drop function conflict_test();
RESULT:
	[]

-----------
QUERY:


-- Check that an unreserved keyword can be used as a variable name

create function unreserved_test() returns int as $$
declare
  forward int := 21;
begin
  forward := forward * 2;
  return forward;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select unreserved_test();
RESULT:
	[(42,)]

-----------
QUERY:


create or replace function unreserved_test() returns int as $$
declare
  return int := 42;
begin
  return := return + 1;
  return return;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select unreserved_test();
RESULT:
	[(43,)]

-----------
QUERY:


create or replace function unreserved_test() returns int as $$
declare
  comment int := 21;
begin
  comment := comment * 2;
  comment on function unreserved_test() is 'this is a test';
  return comment;
end
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select unreserved_test();
RESULT:
	[(42,)]

-----------
QUERY:


select obj_description('unreserved_test()'::regprocedure, 'pg_proc');
RESULT:
	[('this is a test',)]

-----------
QUERY:


drop function unreserved_test();
RESULT:
	[]

-----------
QUERY:


--
-- Test FOREACH over arrays
--

create function foreach_test(anyarray)
returns void as $$
declare x int;
begin
  foreach x in array $1
  loop
    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select foreach_test(ARRAY[1,2,3,4]);
RESULT:
	[('',)]

-----------
QUERY:

select foreach_test(ARRAY[[1,2],[3,4]]);
RESULT:
	[('',)]

-----------
QUERY:


create or replace function foreach_test(anyarray)
returns void as $$
declare x int;
begin
  foreach x slice 1 in array $1
  loop
    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


-- should fail
select foreach_test(ARRAY[1,2,3,4]);
RESULT:
	ERROR - FOREACH ... SLICE loop variable must be of an array type
CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array


-----------
QUERY:

select foreach_test(ARRAY[[1,2],[3,4]]);
RESULT:
	ERROR - FOREACH ... SLICE loop variable must be of an array type
CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array


-----------
QUERY:


create or replace function foreach_test(anyarray)
returns void as $$
declare x int[];
begin
  foreach x slice 1 in array $1
  loop
    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select foreach_test(ARRAY[1,2,3,4]);
RESULT:
	[('',)]

-----------
QUERY:

select foreach_test(ARRAY[[1,2],[3,4]]);
RESULT:
	[('',)]

-----------
QUERY:


-- higher level of slicing
create or replace function foreach_test(anyarray)
returns void as $$
declare x int[];
begin
  foreach x slice 2 in array $1
  loop
    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


-- should fail
select foreach_test(ARRAY[1,2,3,4]);
RESULT:
	ERROR - slice dimension (2) is out of the valid range 0..1
CONTEXT:  PL/pgSQL function foreach_test(anyarray) line 4 at FOREACH over array


-----------
QUERY:

-- ok
select foreach_test(ARRAY[[1,2],[3,4]]);
RESULT:
	[('',)]

-----------
QUERY:

select foreach_test(ARRAY[[[1,2]],[[3,4]]]);
RESULT:
	[('',)]

-----------
QUERY:


create type xy_tuple AS (x int, y int);
RESULT:
	[]

-----------
QUERY:


-- iteration over array of records
create or replace function foreach_test(anyarray)
returns void as $$
declare r record;
begin
  foreach r in array $1
  loop
    raise notice '%', r;
  end loop;
  end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
RESULT:
	[('',)]

-----------
QUERY:

select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
RESULT:
	[('',)]

-----------
QUERY:


create or replace function foreach_test(anyarray)
returns void as $$
declare x int; y int;
begin
  foreach x, y in array $1
  loop
    raise notice 'x = %, y = %', x, y;
  end loop;
  end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
RESULT:
	[('',)]

-----------
QUERY:

select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
RESULT:
	[('',)]

-----------
QUERY:


-- slicing over array of composite types
create or replace function foreach_test(anyarray)
returns void as $$
declare x xy_tuple[];
begin
  foreach x slice 1 in array $1
  loop
    raise notice '%', x;
  end loop;
  end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select foreach_test(ARRAY[(10,20),(40,69),(35,78)]::xy_tuple[]);
RESULT:
	[('',)]

-----------
QUERY:

select foreach_test(ARRAY[[(10,20),(40,69)],[(35,78),(88,76)]]::xy_tuple[]);
RESULT:
	[('',)]

-----------
QUERY:


drop function foreach_test(anyarray);
RESULT:
	[]

-----------
QUERY:

drop type xy_tuple;
RESULT:
	[]

-----------
QUERY:


--
-- Assorted tests for array subscript assignment
--

create temp table rtype (id int, ar text[]);
RESULT:
	[]

-----------
QUERY:


create function arrayassign1() returns text[] language plpgsql as $$
declare
 r record;
begin
  r := row(12, '{foo,bar,baz}')::rtype;
  r.ar[2] := 'replace';
  return r.ar;
end$$;
RESULT:
	[]

-----------
QUERY:


select arrayassign1();
RESULT:
	[(['foo', 'replace', 'baz'],)]

-----------
QUERY:

select arrayassign1();
RESULT:
	[(['foo', 'replace', 'baz'],)]

-----------
QUERY:
 -- try again to exercise internal caching

create domain orderedarray as int[2]
  constraint sorted check (value[1] < value[2]);
RESULT:
	[]

-----------
QUERY:


select '{1,2}'::orderedarray;
RESULT:
	[([1, 2],)]

-----------
QUERY:

select '{2,1}'::orderedarray;
RESULT:
	ERROR - value for domain orderedarray violates check constraint "sorted"


-----------
QUERY:
  -- fail

create function testoa(x1 int, x2 int, x3 int) returns orderedarray
language plpgsql as $$
declare res orderedarray;
begin
  res := array[x1, x2];
  res[2] := x3;
  return res;
end$$;
RESULT:
	[]

-----------
QUERY:


select testoa(1,2,3);
RESULT:
	[([1, 3],)]

-----------
QUERY:

select testoa(1,2,3);
RESULT:
	[([1, 3],)]

-----------
QUERY:
 -- try again to exercise internal caching
select testoa(2,1,3);
RESULT:
	ERROR - value for domain orderedarray violates check constraint "sorted"
CONTEXT:  PL/pgSQL function testoa(integer,integer,integer) line 4 at assignment


-----------
QUERY:
 -- fail at initial assign
select testoa(1,2,1);
RESULT:
	ERROR - value for domain orderedarray violates check constraint "sorted"
CONTEXT:  PL/pgSQL function testoa(integer,integer,integer) line 5 at assignment


-----------
QUERY:
 -- fail at update

drop function arrayassign1();
RESULT:
	[]

-----------
QUERY:

drop function testoa(x1 int, x2 int, x3 int);
RESULT:
	[]

-----------
QUERY:



--
-- Test handling of expanded arrays
--

create function returns_rw_array(int) returns int[]
language plpgsql as $$
  declare r int[];
  begin r := array[$1, $1]; return r; end;
$$ stable;
RESULT:
	[]

-----------
QUERY:


create function consumes_rw_array(int[]) returns int
language plpgsql as $$
  begin return $1[1]; end;
$$ stable;
RESULT:
	[]

-----------
QUERY:


select consumes_rw_array(returns_rw_array(42));
RESULT:
	[(42,)]

-----------
QUERY:


-- bug #14174
explain (verbose, costs off)
select i, a from
  (select returns_rw_array(1) as a offset 0) ss,
  lateral consumes_rw_array(a) i;
RESULT:
	[('Nested Loop',), ('  Output: i.i, (returns_rw_array(1))',), ('  ->  Result',), ('        Output: returns_rw_array(1)',), ('  ->  Function Scan on public.consumes_rw_array i',), ('        Output: i.i',), ('        Function Call: consumes_rw_array((returns_rw_array(1)))',)]

-----------
QUERY:


select i, a from
  (select returns_rw_array(1) as a offset 0) ss,
  lateral consumes_rw_array(a) i;
RESULT:
	[(1, [1, 1])]

-----------
QUERY:


explain (verbose, costs off)
select consumes_rw_array(a), a from returns_rw_array(1) a;
RESULT:
	[('Function Scan on public.returns_rw_array a',), ('  Output: consumes_rw_array(a), a',), ('  Function Call: returns_rw_array(1)',)]

-----------
QUERY:


select consumes_rw_array(a), a from returns_rw_array(1) a;
RESULT:
	[(1, [1, 1])]

-----------
QUERY:


explain (verbose, costs off)
select consumes_rw_array(a), a from
  (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);
RESULT:
	[('Values Scan on "*VALUES*"',), ('  Output: consumes_rw_array("*VALUES*".column1), "*VALUES*".column1',)]

-----------
QUERY:


select consumes_rw_array(a), a from
  (values (returns_rw_array(1)), (returns_rw_array(2))) v(a);
RESULT:
	[(1, [1, 1]), (2, [2, 2])]

-----------
QUERY:


do $$
declare a int[] := array[1,2];
begin
  a := a || 3;
  raise notice 'a = %', a;
end$$;
RESULT:
	[]

-----------
QUERY:



--
-- Test access to call stack
--

create function inner_func(int)
returns int as $$
declare _context text;
begin
  get diagnostics _context = pg_context;
  raise notice '***%***', _context;
  -- lets do it again, just for fun..
  get diagnostics _context = pg_context;
  raise notice '***%***', _context;
  raise notice 'lets make sure we didnt break anything';
  return 2 * $1;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


create or replace function outer_func(int)
returns int as $$
declare
  myresult int;
begin
  raise notice 'calling down into inner_func()';
  myresult := inner_func($1);
  raise notice 'inner_func() done';
  return myresult;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


create or replace function outer_outer_func(int)
returns int as $$
declare
  myresult int;
begin
  raise notice 'calling down into outer_func()';
  myresult := outer_func($1);
  raise notice 'outer_func() done';
  return myresult;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select outer_outer_func(10);
RESULT:
	[(20,)]

-----------
QUERY:

-- repeated call should work
select outer_outer_func(20);
RESULT:
	[(40,)]

-----------
QUERY:


drop function outer_outer_func(int);
RESULT:
	[]

-----------
QUERY:

drop function outer_func(int);
RESULT:
	[]

-----------
QUERY:

drop function inner_func(int);
RESULT:
	[]

-----------
QUERY:


-- access to call stack from exception
create function inner_func(int)
returns int as $$
declare
  _context text;
  sx int := 5;
begin
  begin
    perform sx / 0;
  exception
    when division_by_zero then
      get diagnostics _context = pg_context;
      raise notice '***%***', _context;
  end;

  -- lets do it again, just for fun..
  get diagnostics _context = pg_context;
  raise notice '***%***', _context;
  raise notice 'lets make sure we didnt break anything';
  return 2 * $1;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


create or replace function outer_func(int)
returns int as $$
declare
  myresult int;
begin
  raise notice 'calling down into inner_func()';
  myresult := inner_func($1);
  raise notice 'inner_func() done';
  return myresult;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


create or replace function outer_outer_func(int)
returns int as $$
declare
  myresult int;
begin
  raise notice 'calling down into outer_func()';
  myresult := outer_func($1);
  raise notice 'outer_func() done';
  return myresult;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select outer_outer_func(10);
RESULT:
	[(20,)]

-----------
QUERY:

-- repeated call should work
select outer_outer_func(20);
RESULT:
	[(40,)]

-----------
QUERY:


drop function outer_outer_func(int);
RESULT:
	[]

-----------
QUERY:

drop function outer_func(int);
RESULT:
	[]

-----------
QUERY:

drop function inner_func(int);
RESULT:
	[]

-----------
QUERY:


-- Test pg_routine_oid
create function current_function(text)
returns regprocedure as $$
declare
  fn_oid regprocedure;
begin
  get diagnostics fn_oid = pg_routine_oid;
  return fn_oid;
end;
$$ language plpgsql;
RESULT:
	[]

-----------
QUERY:


select current_function('foo');
RESULT:
	[('current_function(text)',)]

-----------
QUERY:


drop function current_function(text);
RESULT:
	[]

-----------
QUERY:


-- shouldn/* REPLACED */''t fail in DO, even though there/* REPLACED */''s no useful data
do $$
declare
  fn_oid oid;
begin
  get diagnostics fn_oid = pg_routine_oid;
  raise notice 'pg_routine_oid = %', fn_oid;
end;
$$;
RESULT:
	[]

-----------
QUERY:


--
-- Test ASSERT
--

do $$
begin
  assert 1=1;  -- should succeed
end;
$$;
RESULT:
	[]

-----------
QUERY:


do $$
begin
  assert 1=0;  -- should fail
end;
$$;
RESULT:
	ERROR - assertion failed
CONTEXT:  PL/pgSQL function inline_code_block line 3 at ASSERT


-----------
QUERY:


do $$
begin
  assert NULL;  -- should fail
end;
$$;
RESULT:
	ERROR - assertion failed
CONTEXT:  PL/pgSQL function inline_code_block line 3 at ASSERT


-----------
QUERY:


-- check controlling GUC
set plpgsql.check_asserts = off;
RESULT:
	[]

-----------
QUERY:

do $$
begin
  assert 1=0;  -- won/* REPLACED */''t be tested
end;
$$;
RESULT:
	[]

-----------
QUERY:

reset plpgsql.check_asserts;
RESULT:
	[]

-----------
QUERY:


-- test custom message
do $$
declare var text := 'some value';
begin
  assert 1=0, format('assertion failed, var = "%s"', var);
end;
$$;
RESULT:
	ERROR - assertion failed, var = "some value"
CONTEXT:  PL/pgSQL function inline_code_block line 4 at ASSERT


-----------
QUERY:


-- ensure assertions are not trapped by /* REPLACED */''others/* REPLACED */''
do $$
begin
  assert 1=0, 'unhandled assertion';
exception when others then
  null; -- do nothing
end;
$$;
RESULT:
	ERROR - unhandled assertion
CONTEXT:  PL/pgSQL function inline_code_block line 3 at ASSERT


-----------
QUERY:


-- Test use of plpgsql in a domain check constraint (cf. bug #14414)

create function plpgsql_domain_check(val int) returns boolean as $$
begin return val > 0; end
$$ language plpgsql immutable;
RESULT:
	[]

-----------
QUERY:


create domain plpgsql_domain as integer check(plpgsql_domain_check(value));
RESULT:
	[]

-----------
QUERY:


do $$
declare v_test plpgsql_domain;
begin
  v_test := 1;
end;
$$;
RESULT:
	[]

-----------
QUERY:


do $$
declare v_test plpgsql_domain := 1;
begin
  v_test := 0;  -- fail
end;
$$;
RESULT:
	ERROR - value for domain plpgsql_domain violates check constraint "plpgsql_domain_check"
CONTEXT:  PL/pgSQL function inline_code_block line 4 at assignment


-----------
QUERY:


-- Test handling of expanded array passed to a domain constraint (bug #14472)

create function plpgsql_arr_domain_check(val int[]) returns boolean as $$
begin return val[1] > 0; end
$$ language plpgsql immutable;
RESULT:
	[]

-----------
QUERY:


create domain plpgsql_arr_domain as int[] check(plpgsql_arr_domain_check(value));
RESULT:
	[]

-----------
QUERY:


do $$
declare v_test plpgsql_arr_domain;
begin
  v_test := array[1];
  v_test := v_test || 2;
end;
$$;
RESULT:
	[]

-----------
QUERY:


do $$
declare v_test plpgsql_arr_domain := array[1];
begin
  v_test := 0 || v_test;  -- fail
end;
$$;
RESULT:
	ERROR - value for domain plpgsql_arr_domain violates check constraint "plpgsql_arr_domain_check"
CONTEXT:  PL/pgSQL function inline_code_block line 4 at assignment


-----------
QUERY:


--
-- test usage of transition tables in AFTER triggers
--

CREATE TABLE transition_table_base (id int PRIMARY KEY, val text);
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION transition_table_base_ins_func()
  RETURNS trigger
  LANGUAGE plpgsql
AS $$
DECLARE
  t text;
  l text;
BEGIN
  t = '';
  FOR l IN EXECUTE
           $q$
             EXPLAIN (TIMING off, COSTS off, VERBOSE on)
             SELECT * FROM newtable
           $q$ LOOP
    t = t || l || E'\n';
  END LOOP;

  RAISE INFO '%', t;
  RETURN new;
END;
$$;
RESULT:
	[]

-----------
QUERY:


CREATE TRIGGER transition_table_base_ins_trig
  AFTER INSERT ON transition_table_base
  REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable
  FOR EACH STATEMENT
  EXECUTE PROCEDURE transition_table_base_ins_func();
RESULT:
	ERROR - OLD TABLE can only be specified for a DELETE or UPDATE trigger


-----------
QUERY:


CREATE TRIGGER transition_table_base_ins_trig
  AFTER INSERT ON transition_table_base
  REFERENCING NEW TABLE AS newtable
  FOR EACH STATEMENT
  EXECUTE PROCEDURE transition_table_base_ins_func();
RESULT:
	[]

-----------
QUERY:


INSERT INTO transition_table_base VALUES (1, 'One'), (2, 'Two');
RESULT:
	[]

-----------
QUERY:

INSERT INTO transition_table_base VALUES (3, 'Three'), (4, 'Four');
RESULT:
	[]

-----------
QUERY:


CREATE OR REPLACE FUNCTION transition_table_base_upd_func()
  RETURNS trigger
  LANGUAGE plpgsql
AS $$
DECLARE
  t text;
  l text;
BEGIN
  t = '';
  FOR l IN EXECUTE
           $q$
             EXPLAIN (TIMING off, COSTS off, VERBOSE on)
             SELECT * FROM oldtable ot FULL JOIN newtable nt USING (id)
           $q$ LOOP
    t = t || l || E'\n';
  END LOOP;

  RAISE INFO '%', t;
  RETURN new;
END;
$$;
RESULT:
	[]

-----------
QUERY:


CREATE TRIGGER transition_table_base_upd_trig
  AFTER UPDATE ON transition_table_base
  REFERENCING OLD TABLE AS oldtable NEW TABLE AS newtable
  FOR EACH STATEMENT
  EXECUTE PROCEDURE transition_table_base_upd_func();
RESULT:
	[]

-----------
QUERY:


UPDATE transition_table_base
  SET val = '*' || val || '*'
  WHERE id BETWEEN 2 AND 3;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE transition_table_level1
(
      level1_no serial NOT NULL ,
      level1_node_name varchar(255),
       PRIMARY KEY (level1_no)
) WITHOUT OIDS;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE transition_table_level2
(
      level2_no serial NOT NULL ,
      parent_no int NOT NULL,
      level1_node_name varchar(255),
       PRIMARY KEY (level2_no)
) WITHOUT OIDS;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE transition_table_status
(
      level int NOT NULL,
      node_no int NOT NULL,
      status int,
       PRIMARY KEY (level, node_no)
) WITHOUT OIDS;
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION transition_table_level1_ri_parent_del_func()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
  DECLARE n bigint;
  BEGIN
    PERFORM FROM p JOIN transition_table_level2 c ON c.parent_no = p.level1_no;
    IF FOUND THEN
      RAISE EXCEPTION 'RI error';
    END IF;
    RETURN NULL;
  END;
$$;
RESULT:
	[]

-----------
QUERY:


CREATE TRIGGER transition_table_level1_ri_parent_del_trigger
  AFTER DELETE ON transition_table_level1
  REFERENCING OLD TABLE AS p
  FOR EACH STATEMENT EXECUTE PROCEDURE
    transition_table_level1_ri_parent_del_func();
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION transition_table_level1_ri_parent_upd_func()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
  DECLARE
    x int;
  BEGIN
    WITH p AS (SELECT level1_no, sum(delta) cnt
                 FROM (SELECT level1_no, 1 AS delta FROM i
                       UNION ALL
                       SELECT level1_no, -1 AS delta FROM d) w
                 GROUP BY level1_no
                 HAVING sum(delta) < 0)
    SELECT level1_no
      FROM p JOIN transition_table_level2 c ON c.parent_no = p.level1_no
      INTO x;
    IF FOUND THEN
      RAISE EXCEPTION 'RI error';
    END IF;
    RETURN NULL;
  END;
$$;
RESULT:
	[]

-----------
QUERY:


CREATE TRIGGER transition_table_level1_ri_parent_upd_trigger
  AFTER UPDATE ON transition_table_level1
  REFERENCING OLD TABLE AS d NEW TABLE AS i
  FOR EACH STATEMENT EXECUTE PROCEDURE
    transition_table_level1_ri_parent_upd_func();
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION transition_table_level2_ri_child_insupd_func()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
  BEGIN
    PERFORM FROM i
      LEFT JOIN transition_table_level1 p
        ON p.level1_no IS NOT NULL AND p.level1_no = i.parent_no
      WHERE p.level1_no IS NULL;
    IF FOUND THEN
      RAISE EXCEPTION 'RI error';
    END IF;
    RETURN NULL;
  END;
$$;
RESULT:
	[]

-----------
QUERY:


CREATE TRIGGER transition_table_level2_ri_child_ins_trigger
  AFTER INSERT ON transition_table_level2
  REFERENCING NEW TABLE AS i
  FOR EACH STATEMENT EXECUTE PROCEDURE
    transition_table_level2_ri_child_insupd_func();
RESULT:
	[]

-----------
QUERY:


CREATE TRIGGER transition_table_level2_ri_child_upd_trigger
  AFTER UPDATE ON transition_table_level2
  REFERENCING NEW TABLE AS i
  FOR EACH STATEMENT EXECUTE PROCEDURE
    transition_table_level2_ri_child_insupd_func();
RESULT:
	[]

-----------
QUERY:


-- create initial test data
INSERT INTO transition_table_level1 (level1_no)
  SELECT generate_series(1,200);
RESULT:
	[]

-----------
QUERY:

ANALYZE transition_table_level1;
RESULT:
	[]

-----------
QUERY:


INSERT INTO transition_table_level2 (level2_no, parent_no)
  SELECT level2_no, level2_no / 50 + 1 AS parent_no
    FROM generate_series(1,9999) level2_no;
RESULT:
	[]

-----------
QUERY:

ANALYZE transition_table_level2;
RESULT:
	[]

-----------
QUERY:


INSERT INTO transition_table_status (level, node_no, status)
  SELECT 1, level1_no, 0 FROM transition_table_level1;
RESULT:
	[]

-----------
QUERY:


INSERT INTO transition_table_status (level, node_no, status)
  SELECT 2, level2_no, 0 FROM transition_table_level2;
RESULT:
	[]

-----------
QUERY:

ANALYZE transition_table_status;
RESULT:
	[]

-----------
QUERY:


INSERT INTO transition_table_level1(level1_no)
  SELECT generate_series(201,1000);
RESULT:
	[]

-----------
QUERY:

ANALYZE transition_table_level1;
RESULT:
	[]

-----------
QUERY:


-- behave reasonably if someone tries to modify a transition table
CREATE FUNCTION transition_table_level2_bad_usage_func()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
  BEGIN
    INSERT INTO dx VALUES (1000000, 1000000, 'x');
    RETURN NULL;
  END;
$$;
RESULT:
	[]

-----------
QUERY:


CREATE TRIGGER transition_table_level2_bad_usage_trigger
  AFTER DELETE ON transition_table_level2
  REFERENCING OLD TABLE AS dx
  FOR EACH STATEMENT EXECUTE PROCEDURE
    transition_table_level2_bad_usage_func();
RESULT:
	[]

-----------
QUERY:


DELETE FROM transition_table_level2
  WHERE level2_no BETWEEN 301 AND 305;
RESULT:
	ERROR - relation "dx" cannot be the target of a modifying statement
CONTEXT:  SQL statement "INSERT INTO dx VALUES (1000000, 1000000, 'x')"
PL/pgSQL function transition_table_level2_bad_usage_func() line 3 at SQL statement


-----------
QUERY:


DROP TRIGGER transition_table_level2_bad_usage_trigger
  ON transition_table_level2;
RESULT:
	[]

-----------
QUERY:


-- attempt modifications which would break RI (should all fail)
DELETE FROM transition_table_level1
  WHERE level1_no = 25;
RESULT:
	ERROR - RI error
CONTEXT:  PL/pgSQL function transition_table_level1_ri_parent_del_func() line 6 at RAISE


-----------
QUERY:


UPDATE transition_table_level1 SET level1_no = -1
  WHERE level1_no = 30;
RESULT:
	ERROR - RI error
CONTEXT:  PL/pgSQL function transition_table_level1_ri_parent_upd_func() line 15 at RAISE


-----------
QUERY:


INSERT INTO transition_table_level2 (level2_no, parent_no)
  VALUES (10000, 10000);
RESULT:
	ERROR - RI error
CONTEXT:  PL/pgSQL function transition_table_level2_ri_child_insupd_func() line 8 at RAISE


-----------
QUERY:


UPDATE transition_table_level2 SET parent_no = 2000
  WHERE level2_no = 40;
RESULT:
	ERROR - RI error
CONTEXT:  PL/pgSQL function transition_table_level2_ri_child_insupd_func() line 8 at RAISE


-----------
QUERY:



-- attempt modifications which would not break RI (should all succeed)
DELETE FROM transition_table_level1
  WHERE level1_no BETWEEN 201 AND 1000;
RESULT:
	[]

-----------
QUERY:


DELETE FROM transition_table_level1
  WHERE level1_no BETWEEN 100000000 AND 100000010;
RESULT:
	[]

-----------
QUERY:


SELECT count(*) FROM transition_table_level1;
RESULT:
	[(200,)]

-----------
QUERY:


DELETE FROM transition_table_level2
  WHERE level2_no BETWEEN 211 AND 220;
RESULT:
	[]

-----------
QUERY:


SELECT count(*) FROM transition_table_level2;
RESULT:
	[(9989,)]

-----------
QUERY:


CREATE TABLE alter_table_under_transition_tables
(
  id int PRIMARY KEY,
  name text
);
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION alter_table_under_transition_tables_upd_func()
  RETURNS TRIGGER
  LANGUAGE plpgsql
AS $$
BEGIN
  RAISE WARNING 'old table = %, new table = %',
                  (SELECT string_agg(id || '=' || name, ',') FROM d),
                  (SELECT string_agg(id || '=' || name, ',') FROM i);
  RAISE NOTICE 'one = %', (SELECT 1 FROM alter_table_under_transition_tables LIMIT 1);
  RETURN NULL;
END;
$$;
RESULT:
	[]

-----------
QUERY:


-- should fail, TRUNCATE is not compatible with transition tables
CREATE TRIGGER alter_table_under_transition_tables_upd_trigger
  AFTER TRUNCATE OR UPDATE ON alter_table_under_transition_tables
  REFERENCING OLD TABLE AS d NEW TABLE AS i
  FOR EACH STATEMENT EXECUTE PROCEDURE
    alter_table_under_transition_tables_upd_func();
RESULT:
	ERROR - TRUNCATE triggers with transition tables are not supported


-----------
QUERY:


-- should work
CREATE TRIGGER alter_table_under_transition_tables_upd_trigger
  AFTER UPDATE ON alter_table_under_transition_tables
  REFERENCING OLD TABLE AS d NEW TABLE AS i
  FOR EACH STATEMENT EXECUTE PROCEDURE
    alter_table_under_transition_tables_upd_func();
RESULT:
	[]

-----------
QUERY:


INSERT INTO alter_table_under_transition_tables
  VALUES (1, '1'), (2, '2'), (3, '3');
RESULT:
	[]

-----------
QUERY:

UPDATE alter_table_under_transition_tables
  SET name = name || name;
RESULT:
	[]

-----------
QUERY:


-- now change /* REPLACED */''name/* REPLACED */'' to an integer to see what happens...
ALTER TABLE alter_table_under_transition_tables
  ALTER COLUMN name TYPE int USING name::integer;
RESULT:
	[]

-----------
QUERY:

UPDATE alter_table_under_transition_tables
  SET name = (name::text || name::text)::integer;
RESULT:
	[]

-----------
QUERY:


-- now drop column /* REPLACED */''name/* REPLACED */''
ALTER TABLE alter_table_under_transition_tables
  DROP column name;
RESULT:
	[]

-----------
QUERY:

UPDATE alter_table_under_transition_tables
  SET id = id;
RESULT:
	ERROR - column "name" does not exist
LINE 1: (SELECT string_agg(id || '=' || name, ',') FROM d)
                                        ^
QUERY:  (SELECT string_agg(id || '=' || name, ',') FROM d)
CONTEXT:  PL/pgSQL function alter_table_under_transition_tables_upd_func() line 3 at RAISE


-----------
QUERY:


--
-- Test multiple reference to a transition table
--

CREATE TABLE multi_test (i int);
RESULT:
	[]

-----------
QUERY:

INSERT INTO multi_test VALUES (1);
RESULT:
	[]

-----------
QUERY:


CREATE OR REPLACE FUNCTION multi_test_trig() RETURNS trigger
LANGUAGE plpgsql AS $$
BEGIN
    RAISE NOTICE 'count = %', (SELECT COUNT(*) FROM new_test);
    RAISE NOTICE 'count union = %',
      (SELECT COUNT(*)
       FROM (SELECT * FROM new_test UNION ALL SELECT * FROM new_test) ss);
    RETURN NULL;
END$$;
RESULT:
	[]

-----------
QUERY:


CREATE TRIGGER my_trigger AFTER UPDATE ON multi_test
  REFERENCING NEW TABLE AS new_test OLD TABLE as old_test
  FOR EACH STATEMENT EXECUTE PROCEDURE multi_test_trig();
RESULT:
	[]

-----------
QUERY:


UPDATE multi_test SET i = i;
RESULT:
	[]

-----------
QUERY:


DROP TABLE multi_test;
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION multi_test_trig();
RESULT:
	[]

-----------
QUERY:


--
-- Check type parsing and record fetching from partitioned tables
--

CREATE TABLE partitioned_table (a int, b text) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE pt_part1 PARTITION OF partitioned_table FOR VALUES IN (1);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE pt_part2 PARTITION OF partitioned_table FOR VALUES IN (2);
RESULT:
	[]

-----------
QUERY:


INSERT INTO partitioned_table VALUES (1, 'Row 1');
RESULT:
	[]

-----------
QUERY:

INSERT INTO partitioned_table VALUES (2, 'Row 2');
RESULT:
	[]

-----------
QUERY:


CREATE OR REPLACE FUNCTION get_from_partitioned_table(partitioned_table.a%type)
RETURNS partitioned_table AS $$
DECLARE
    a_val partitioned_table.a%TYPE;
    result partitioned_table%ROWTYPE;
BEGIN
    a_val := $1;
    SELECT * INTO result FROM partitioned_table WHERE a = a_val;
    RETURN result;
END; $$ LANGUAGE plpgsql;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM get_from_partitioned_table(1) AS t;
RESULT:
	[(1, 'Row 1')]

-----------
QUERY:


CREATE OR REPLACE FUNCTION list_partitioned_table()
RETURNS SETOF public.partitioned_table.a%TYPE AS $$
DECLARE
    row public.partitioned_table%ROWTYPE;
    a_val public.partitioned_table.a%TYPE;
BEGIN
    FOR row IN SELECT * FROM public.partitioned_table ORDER BY a LOOP
        a_val := row.a;
        RETURN NEXT a_val;
    END LOOP;
    RETURN;
END; $$ LANGUAGE plpgsql;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM list_partitioned_table() AS t;
RESULT:
	[(1,), (2,)]

-----------
QUERY:


--
-- Check argument name is used instead of $n in error message
--
CREATE FUNCTION fx(x WSlot) RETURNS void AS $$
BEGIN
  GET DIAGNOSTICS x = ROW_COUNT;
  RETURN;
END; $$ LANGUAGE plpgsql;
RESULT:
	ERROR - "x" is not a scalar variable
LINE 8:   GET DIAGNOSTICS x = ROW_COUNT;
                          ^

