
-----------
QUERY:
--
-- Test access privileges
--

-- Clean up in case a prior regression run failed

-- Suppress NOTICE messages when users/groups don/* REPLACED */ ''t exist
SET client_min_messages TO 'warning';
RESULT:
	[]

-----------
QUERY:


DROP ROLE IF EXISTS regress_priv_group1;
RESULT:
	[]

-----------
QUERY:

DROP ROLE IF EXISTS regress_priv_group2;
RESULT:
	[]

-----------
QUERY:


DROP ROLE IF EXISTS regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

DROP ROLE IF EXISTS regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

DROP ROLE IF EXISTS regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

DROP ROLE IF EXISTS regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

DROP ROLE IF EXISTS regress_priv_user5;
RESULT:
	[]

-----------
QUERY:

DROP ROLE IF EXISTS regress_priv_user6;
RESULT:
	[]

-----------
QUERY:

DROP ROLE IF EXISTS regress_priv_user7;
RESULT:
	[]

-----------
QUERY:


SELECT lo_unlink(oid) FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
RESULT:
	[]

-----------
QUERY:


RESET client_min_messages;
RESULT:
	[]

-----------
QUERY:


-- test proper begins here

CREATE USER regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user5;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user5;
RESULT:
	ERROR - role "regress_priv_user5" already exists


-----------
QUERY:
	-- duplicate
CREATE USER regress_priv_user6;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user7;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user8;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user9;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user10;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_priv_role;
RESULT:
	[]

-----------
QUERY:


-- circular ADMIN OPTION grants should be disallowed
GRANT regress_priv_user1 TO regress_priv_user2 WITH ADMIN OPTION;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_user1 TO regress_priv_user3 WITH ADMIN OPTION GRANTED BY regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_user1 TO regress_priv_user2 WITH ADMIN OPTION GRANTED BY regress_priv_user3;
RESULT:
	ERROR - ADMIN option cannot be granted back to your own grantor


-----------
QUERY:


-- need CASCADE to revoke grant or admin option if dependent grants exist
REVOKE ADMIN OPTION FOR regress_priv_user1 FROM regress_priv_user2;
RESULT:
	ERROR - dependent privileges exist
HINT:  Use CASCADE to revoke them too.


-----------
QUERY:
 -- fail
REVOKE regress_priv_user1 FROM regress_priv_user2;
RESULT:
	ERROR - dependent privileges exist
HINT:  Use CASCADE to revoke them too.


-----------
QUERY:
 -- fail
SELECT member::regrole, admin_option FROM pg_auth_members WHERE roleid = 'regress_priv_user1'::regrole;
RESULT:
	[('regress_priv_user2', True), ('regress_priv_user3', True)]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

REVOKE ADMIN OPTION FOR regress_priv_user1 FROM regress_priv_user2 CASCADE;
RESULT:
	[]

-----------
QUERY:

SELECT member::regrole, admin_option FROM pg_auth_members WHERE roleid = 'regress_priv_user1'::regrole;
RESULT:
	[('regress_priv_user2', False)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:

REVOKE regress_priv_user1 FROM regress_priv_user2 CASCADE;
RESULT:
	[]

-----------
QUERY:

SELECT member::regrole, admin_option FROM pg_auth_members WHERE roleid = 'regress_priv_user1'::regrole;
RESULT:
	[]

-----------
QUERY:


-- inferred grantor must be a role with ADMIN OPTION
GRANT regress_priv_user1 TO regress_priv_user2 WITH ADMIN OPTION;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_user2 TO regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

SET ROLE regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_user1 TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT grantor::regrole FROM pg_auth_members WHERE roleid = 'regress_priv_user1'::regrole and member = 'regress_priv_user4'::regrole;
RESULT:
	[('regress_priv_user2',)]

-----------
QUERY:

RESET ROLE;
RESULT:
	[]

-----------
QUERY:

REVOKE regress_priv_user2 FROM regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

REVOKE regress_priv_user1 FROM regress_priv_user2 CASCADE;
RESULT:
	[]

-----------
QUERY:


-- test GRANTED BY with DROP OWNED and REASSIGN OWNED
GRANT regress_priv_user1 TO regress_priv_user2 WITH ADMIN OPTION;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_user1 TO regress_priv_user3 GRANTED BY regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_priv_user2;
RESULT:
	ERROR - role "regress_priv_user2" cannot be dropped because some objects depend on it
DETAIL:  privileges for membership of role regress_priv_user3 in role regress_priv_user1


-----------
QUERY:
 -- fail, dependency
REASSIGN OWNED BY regress_priv_user2 TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_priv_user2;
RESULT:
	ERROR - role "regress_priv_user2" cannot be dropped because some objects depend on it
DETAIL:  privileges for membership of role regress_priv_user3 in role regress_priv_user1


-----------
QUERY:
 -- still fail, REASSIGN OWNED doesn/* REPLACED */ ''t help
DROP OWNED BY regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_priv_user2;
RESULT:
	[]

-----------
QUERY:
 -- ok now, DROP OWNED does the job

-- test that removing granted role or grantee role removes dependency
GRANT regress_priv_user1 TO regress_priv_user3 WITH ADMIN OPTION;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_user1 TO regress_priv_user4 GRANTED BY regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_priv_user3;
RESULT:
	ERROR - role "regress_priv_user3" cannot be dropped because some objects depend on it
DETAIL:  privileges for membership of role regress_priv_user4 in role regress_priv_user1


-----------
QUERY:
 -- should fail, dependency
DROP ROLE regress_priv_user4;
RESULT:
	[]

-----------
QUERY:
 -- ok
DROP ROLE regress_priv_user3;
RESULT:
	[]

-----------
QUERY:
 -- ok now
GRANT regress_priv_user1 TO regress_priv_user5 WITH ADMIN OPTION;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_user1 TO regress_priv_user6 GRANTED BY regress_priv_user5;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_priv_user5;
RESULT:
	ERROR - role "regress_priv_user5" cannot be dropped because some objects depend on it
DETAIL:  privileges for membership of role regress_priv_user6 in role regress_priv_user1


-----------
QUERY:
 -- should fail, dependency
DROP ROLE regress_priv_user1, regress_priv_user5;
RESULT:
	[]

-----------
QUERY:
 -- ok, despite order

-- recreate the roles we just dropped
CREATE USER regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_priv_user5;
RESULT:
	[]

-----------
QUERY:


GRANT pg_read_all_data TO regress_priv_user6;
RESULT:
	[]

-----------
QUERY:

GRANT pg_write_all_data TO regress_priv_user7;
RESULT:
	[]

-----------
QUERY:

GRANT pg_read_all_settings TO regress_priv_user8 WITH ADMIN OPTION;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_user9 TO regress_priv_user8;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user8;
RESULT:
	[]

-----------
QUERY:

GRANT pg_read_all_settings TO regress_priv_user9 WITH ADMIN OPTION;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user9;
RESULT:
	[]

-----------
QUERY:

GRANT pg_read_all_settings TO regress_priv_user10;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user8;
RESULT:
	[]

-----------
QUERY:

REVOKE pg_read_all_settings FROM regress_priv_user10 GRANTED BY regress_priv_user9;
RESULT:
	[]

-----------
QUERY:

REVOKE ADMIN OPTION FOR pg_read_all_settings FROM regress_priv_user9;
RESULT:
	[]

-----------
QUERY:

REVOKE pg_read_all_settings FROM regress_priv_user9;
RESULT:
	[]

-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

REVOKE regress_priv_user9 FROM regress_priv_user8;
RESULT:
	[]

-----------
QUERY:

REVOKE ADMIN OPTION FOR pg_read_all_settings FROM regress_priv_user8;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user8;
RESULT:
	[]

-----------
QUERY:

SET ROLE pg_read_all_settings;
RESULT:
	[]

-----------
QUERY:

RESET ROLE;
RESULT:
	[]

-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

REVOKE SET OPTION FOR pg_read_all_settings FROM regress_priv_user8;
RESULT:
	[]

-----------
QUERY:

GRANT pg_read_all_stats TO regress_priv_user8 WITH SET FALSE;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user8;
RESULT:
	[]

-----------
QUERY:

SET ROLE pg_read_all_settings;
RESULT:
	ERROR - permission denied to set role "pg_read_all_settings"


-----------
QUERY:
  -- fail, no SET option any more
SET ROLE pg_read_all_stats;
RESULT:
	ERROR - permission denied to set role "pg_read_all_stats"


-----------
QUERY:
     -- fail, granted without SET option
RESET ROLE;
RESULT:
	[]

-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

REVOKE pg_read_all_settings FROM regress_priv_user8;
RESULT:
	[]

-----------
QUERY:


DROP USER regress_priv_user10;
RESULT:
	[]

-----------
QUERY:

DROP USER regress_priv_user9;
RESULT:
	[]

-----------
QUERY:

DROP USER regress_priv_user8;
RESULT:
	[]

-----------
QUERY:


CREATE GROUP regress_priv_group1;
RESULT:
	[]

-----------
QUERY:

CREATE GROUP regress_priv_group2 WITH ADMIN regress_priv_user1 USER regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


ALTER GROUP regress_priv_group1 ADD USER regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


GRANT regress_priv_group2 TO regress_priv_user2 GRANTED BY regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

ALTER GROUP regress_priv_group2 ADD USER regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

ALTER GROUP regress_priv_group2 ADD USER regress_priv_user2;
RESULT:
	[]

-----------
QUERY:
	-- duplicate
ALTER GROUP regress_priv_group2 DROP USER regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

ALTER USER regress_priv_user2 PASSWORD 'verysecret';
RESULT:
	ERROR - permission denied to alter role
DETAIL:  To change another role's password, the current user must have the CREATEROLE attribute and the ADMIN option on the role.


-----------
QUERY:
 -- not permitted
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

ALTER GROUP regress_priv_group2 DROP USER regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

REVOKE ADMIN OPTION FOR regress_priv_group2 FROM regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_group2 TO regress_priv_user4 WITH ADMIN OPTION;
RESULT:
	[]

-----------
QUERY:


-- prepare non-leakproof function for later
CREATE FUNCTION leak(integer,integer) RETURNS boolean
  AS 'int4lt'
  LANGUAGE internal IMMUTABLE STRICT;
RESULT:
	[]

-----------
QUERY:
  -- but deliberately not LEAKPROOF
ALTER FUNCTION leak(integer,integer) OWNER TO regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


-- test owner privileges

GRANT regress_priv_role TO regress_priv_user1 WITH ADMIN OPTION GRANTED BY regress_priv_role;
RESULT:
	ERROR - permission denied to grant privileges as role "regress_priv_role"
DETAIL:  The grantor must have the ADMIN option on role "regress_priv_role".


-----------
QUERY:
 -- error, doesn/* REPLACED */ ''t have ADMIN OPTION
GRANT regress_priv_role TO regress_priv_user1 WITH ADMIN OPTION GRANTED BY CURRENT_ROLE;
RESULT:
	[]

-----------
QUERY:

REVOKE ADMIN OPTION FOR regress_priv_role FROM regress_priv_user1 GRANTED BY foo;
RESULT:
	ERROR - role "foo" does not exist


-----------
QUERY:
 -- error
REVOKE ADMIN OPTION FOR regress_priv_role FROM regress_priv_user1 GRANTED BY regress_priv_user2;
RESULT:
	[]

-----------
QUERY:
 -- warning, noop
REVOKE ADMIN OPTION FOR regress_priv_role FROM regress_priv_user1 GRANTED BY CURRENT_USER;
RESULT:
	[]

-----------
QUERY:

REVOKE regress_priv_role FROM regress_priv_user1 GRANTED BY CURRENT_ROLE;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_priv_role;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

SELECT session_user, current_user;
RESULT:
	[('regress_priv_user1', 'regress_priv_user1')]

-----------
QUERY:


CREATE TABLE atest1 ( a int, b text );
RESULT:
	[]

-----------
QUERY:

SELECT * FROM atest1;
RESULT:
	[]

-----------
QUERY:

INSERT INTO atest1 VALUES (1, 'one');
RESULT:
	[]

-----------
QUERY:

DELETE FROM atest1;
RESULT:
	[]

-----------
QUERY:

UPDATE atest1 SET a = 1 WHERE b = 'blech';
RESULT:
	[]

-----------
QUERY:

TRUNCATE atest1;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK atest1 IN ACCESS EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:

COMMIT;
RESULT:
	[]

-----------
QUERY:


REVOKE ALL ON atest1 FROM PUBLIC;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM atest1;
RESULT:
	[]

-----------
QUERY:


GRANT ALL ON atest1 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON atest1 TO regress_priv_user3, regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM atest1;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE atest2 (col1 varchar(10), col2 boolean);
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON atest2 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT UPDATE ON atest2 TO regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

GRANT INSERT ON atest2 TO regress_priv_user4 GRANTED BY CURRENT_USER;
RESULT:
	[]

-----------
QUERY:

GRANT TRUNCATE ON atest2 TO regress_priv_user5 GRANTED BY CURRENT_ROLE;
RESULT:
	[]

-----------
QUERY:


GRANT TRUNCATE ON atest2 TO regress_priv_user4 GRANTED BY regress_priv_user5;
RESULT:
	ERROR - grantor must be current user


-----------
QUERY:
  -- error


SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

SELECT session_user, current_user;
RESULT:
	[('regress_priv_user2', 'regress_priv_user2')]

-----------
QUERY:


-- try various combinations of queries on atest1 and atest2

SELECT * FROM atest1;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT * FROM atest2;
RESULT:
	[]

-----------
QUERY:
 -- ok
INSERT INTO atest1 VALUES (2, 'two');
RESULT:
	[]

-----------
QUERY:
 -- ok
INSERT INTO atest2 VALUES ('foo', true);
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
INSERT INTO atest1 SELECT 1, b FROM atest1;
RESULT:
	[]

-----------
QUERY:
 -- ok
UPDATE atest1 SET a = 1 WHERE a = 2;
RESULT:
	[]

-----------
QUERY:
 -- ok
UPDATE atest2 SET col2 = NOT col2;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
SELECT * FROM atest1 FOR UPDATE;
RESULT:
	[(1, 'two'), (1, 'two')]

-----------
QUERY:
 -- ok
SELECT * FROM atest2 FOR UPDATE;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
DELETE FROM atest2;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
TRUNCATE atest2;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK atest2 IN ACCESS EXCLUSIVE MODE;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
COMMIT;
RESULT:
	[]

-----------
QUERY:

COPY atest2 FROM stdin;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 -- fail
GRANT ALL ON atest1 TO PUBLIC;
RESULT:
	[]

-----------
QUERY:
 -- fail

-- checks in subquery, both ok
SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
RESULT:
	[]

-----------
QUERY:

SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user6;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM atest1;
RESULT:
	[(1, 'two'), (1, 'two')]

-----------
QUERY:
 -- ok
SELECT * FROM atest2;
RESULT:
	[]

-----------
QUERY:
 -- ok
INSERT INTO atest2 VALUES ('foo', true);
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail

SET SESSION AUTHORIZATION regress_priv_user7;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM atest1;
RESULT:
	ERROR - permission denied for table atest1


-----------
QUERY:
 -- fail
SELECT * FROM atest2;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
INSERT INTO atest2 VALUES ('foo', true);
RESULT:
	[]

-----------
QUERY:
 -- ok
UPDATE atest2 SET col2 = true;
RESULT:
	[]

-----------
QUERY:
 -- ok
DELETE FROM atest2;
RESULT:
	[]

-----------
QUERY:
 -- ok

-- Make sure we are not able to modify system catalogs
UPDATE pg_catalog.pg_class SET relname = '123';
RESULT:
	ERROR - permission denied for table pg_class


-----------
QUERY:
 -- fail
DELETE FROM pg_catalog.pg_class;
RESULT:
	ERROR - permission denied for table pg_class


-----------
QUERY:
 -- fail
UPDATE pg_toast.pg_toast_1213 SET chunk_id = 1;
RESULT:
	ERROR - permission denied for table pg_toast_1213


-----------
QUERY:
 -- fail

SET SESSION AUTHORIZATION regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

SELECT session_user, current_user;
RESULT:
	[('regress_priv_user3', 'regress_priv_user3')]

-----------
QUERY:


SELECT * FROM atest1;
RESULT:
	[(1, 'two'), (1, 'two')]

-----------
QUERY:
 -- ok
SELECT * FROM atest2;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
INSERT INTO atest1 VALUES (2, 'two');
RESULT:
	ERROR - permission denied for table atest1


-----------
QUERY:
 -- fail
INSERT INTO atest2 VALUES ('foo', true);
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
INSERT INTO atest1 SELECT 1, b FROM atest1;
RESULT:
	ERROR - permission denied for table atest1


-----------
QUERY:
 -- fail
UPDATE atest1 SET a = 1 WHERE a = 2;
RESULT:
	ERROR - permission denied for table atest1


-----------
QUERY:
 -- fail
UPDATE atest2 SET col2 = NULL;
RESULT:
	[]

-----------
QUERY:
 -- ok
UPDATE atest2 SET col2 = NOT col2;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fails /* REPLACED */ , requires SELECT on atest2
UPDATE atest2 SET col2 = true FROM atest1 WHERE atest1.a = 5;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT * FROM atest1 FOR UPDATE;
RESULT:
	ERROR - permission denied for table atest1


-----------
QUERY:
 -- fail
SELECT * FROM atest2 FOR UPDATE;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
DELETE FROM atest2;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
TRUNCATE atest2;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK atest2 IN ACCESS EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- ok
COMMIT;
RESULT:
	[]

-----------
QUERY:

COPY atest2 FROM stdin;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 -- fail

-- checks in subquery, both fail
SELECT * FROM atest1 WHERE ( b IN ( SELECT col1 FROM atest2 ) );
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:

SELECT * FROM atest2 WHERE ( col1 IN ( SELECT b FROM atest1 ) );
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

COPY atest2 FROM stdin;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 -- ok
bar	true
-- \.
SELECT * FROM atest1;
RESULT:
	ERROR - syntax error at or near "bar"
LINE 2: bar true
        ^


-----------
QUERY:
 -- ok


-- test leaky-function protections in selfuncs

-- regress_priv_user1 will own a table and provide views for it.
SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE atest12 as
  SELECT x AS a, 10001 - x AS b FROM generate_series(1,10000) x;
RESULT:
	[]

-----------
QUERY:

CREATE INDEX ON atest12 (a);
RESULT:
	[]

-----------
QUERY:

CREATE INDEX ON atest12 (abs(a));
RESULT:
	[]

-----------
QUERY:

-- results below depend on having quite accurate stats for atest12, so...
ALTER TABLE atest12 SET (autovacuum_enabled = off);
RESULT:
	[]

-----------
QUERY:

SET default_statistics_target = 10000;
RESULT:
	[]

-----------
QUERY:

VACUUM ANALYZE atest12;
RESULT:
	[]

-----------
QUERY:

RESET default_statistics_target;
RESULT:
	[]

-----------
QUERY:


CREATE OPERATOR <<< (procedure = leak, leftarg = integer, rightarg = integer,
                     restrict = scalarltsel);
RESULT:
	[]

-----------
QUERY:


-- views with leaky operator
CREATE VIEW atest12v AS
  SELECT * FROM atest12 WHERE b <<< 5;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW atest12sbv WITH (security_barrier=true) AS
  SELECT * FROM atest12 WHERE b <<< 5;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON atest12v TO PUBLIC;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON atest12sbv TO PUBLIC;
RESULT:
	[]

-----------
QUERY:


-- This plan should use nestloop, knowing that few rows will be selected.
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
RESULT:
	[('Nested Loop',), ('  ->  Seq Scan on atest12 atest12_1',), ('        Filter: (b <<< 5)',), ('  ->  Index Scan using atest12_a_idx on atest12',), ('        Index Cond: (a = atest12_1.b)',), ('        Filter: (b <<< 5)',)]

-----------
QUERY:


-- And this one.
EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
  WHERE x.a = y.b and abs(y.a) <<< 5;
RESULT:
	[('Nested Loop',), ('  ->  Seq Scan on atest12 y',), ('        Filter: (abs(a) <<< 5)',), ('  ->  Index Scan using atest12_a_idx on atest12 x',), ('        Index Cond: (a = y.b)',)]

-----------
QUERY:


-- This should also be a nestloop, but the security barrier forces the inner
-- scan to be materialized
EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
RESULT:
	[('Nested Loop',), ('  Join Filter: (atest12.a = atest12_1.b)',), ('  ->  Seq Scan on atest12',), ('        Filter: (b <<< 5)',), ('  ->  Materialize',), ('        ->  Seq Scan on atest12 atest12_1',), ('              Filter: (b <<< 5)',)]

-----------
QUERY:


-- Check if regress_priv_user2 can break security.
SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION leak2(integer,integer) RETURNS boolean
  AS $$begin raise notice 'leak % %', $1, $2; return $1 > $2; end$$
  LANGUAGE plpgsql immutable;
RESULT:
	[]

-----------
QUERY:

CREATE OPERATOR >>> (procedure = leak2, leftarg = integer, rightarg = integer,
                     restrict = scalargtsel);
RESULT:
	[]

-----------
QUERY:


-- This should not show any /* REPLACED */ ''leak/* REPLACED */ '' notices before failing.
EXPLAIN (COSTS OFF) SELECT * FROM atest12 WHERE a >>> 0;
RESULT:
	ERROR - permission denied for table atest12


-----------
QUERY:


-- These plans should continue to use a nestloop, since they execute with the
-- privileges of the view owner.
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
RESULT:
	[('Nested Loop',), ('  ->  Seq Scan on atest12 atest12_1',), ('        Filter: (b <<< 5)',), ('  ->  Index Scan using atest12_a_idx on atest12',), ('        Index Cond: (a = atest12_1.b)',), ('        Filter: (b <<< 5)',)]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y WHERE x.a = y.b;
RESULT:
	[('Nested Loop',), ('  Join Filter: (atest12.a = atest12_1.b)',), ('  ->  Seq Scan on atest12',), ('        Filter: (b <<< 5)',), ('  ->  Materialize',), ('        ->  Seq Scan on atest12 atest12_1',), ('              Filter: (b <<< 5)',)]

-----------
QUERY:


-- A non-security barrier view does not guard against information leakage.
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y
  WHERE x.a = y.b and abs(y.a) <<< 5;
RESULT:
	[('Nested Loop',), ('  ->  Seq Scan on atest12 atest12_1',), ('        Filter: ((b <<< 5) AND (abs(a) <<< 5))',), ('  ->  Index Scan using atest12_a_idx on atest12',), ('        Index Cond: (a = atest12_1.b)',), ('        Filter: (b <<< 5)',)]

-----------
QUERY:


-- But a security barrier view isolates the leaky operator.
EXPLAIN (COSTS OFF) SELECT * FROM atest12sbv x, atest12sbv y
  WHERE x.a = y.b and abs(y.a) <<< 5;
RESULT:
	[('Nested Loop',), ('  Join Filter: (atest12_1.a = y.b)',), ('  ->  Subquery Scan on y',), ('        Filter: (abs(y.a) <<< 5)',), ('        ->  Seq Scan on atest12',), ('              Filter: (b <<< 5)',), ('  ->  Seq Scan on atest12 atest12_1',), ('        Filter: (b <<< 5)',)]

-----------
QUERY:


-- Now regress_priv_user1 grants sufficient access to regress_priv_user2.
SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (a, b) ON atest12 TO PUBLIC;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


-- regress_priv_user2 should continue to get a good row estimate.
EXPLAIN (COSTS OFF) SELECT * FROM atest12v x, atest12v y WHERE x.a = y.b;
RESULT:
	[('Nested Loop',), ('  ->  Seq Scan on atest12 atest12_1',), ('        Filter: (b <<< 5)',), ('  ->  Index Scan using atest12_a_idx on atest12',), ('        Index Cond: (a = atest12_1.b)',), ('        Filter: (b <<< 5)',)]

-----------
QUERY:


-- But not for this, due to lack of table-wide permissions needed
-- to make use of the expression index/* REPLACED */ ''s statistics.
EXPLAIN (COSTS OFF) SELECT * FROM atest12 x, atest12 y
  WHERE x.a = y.b and abs(y.a) <<< 5;
RESULT:
	[('Hash Join',), ('  Hash Cond: (x.a = y.b)',), ('  ->  Seq Scan on atest12 x',), ('  ->  Hash',), ('        ->  Seq Scan on atest12 y',), ('              Filter: (abs(a) <<< 5)',)]

-----------
QUERY:


-- clean up (regress_priv_user1/* REPLACED */ ''s objects are all dropped later)
DROP FUNCTION leak2(integer, integer) CASCADE;
RESULT:
	[]

-----------
QUERY:



-- groups

SET SESSION AUTHORIZATION regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE atest3 (one int, two int, three int);
RESULT:
	[]

-----------
QUERY:

GRANT DELETE ON atest3 TO GROUP regress_priv_group2;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM atest3;
RESULT:
	ERROR - permission denied for table atest3


-----------
QUERY:
 -- fail
DELETE FROM atest3;
RESULT:
	[]

-----------
QUERY:
 -- ok

BEGIN;
RESULT:
	[]

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

ALTER ROLE regress_priv_user1 NOINHERIT;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

SAVEPOINT s1;
RESULT:
	[]

-----------
QUERY:

DELETE FROM atest3;
RESULT:
	[]

-----------
QUERY:
 -- ok because grant-level option is unchanged
ROLLBACK TO s1;
RESULT:
	[]

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_group2 TO regress_priv_user1 WITH INHERIT FALSE;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

DELETE FROM atest3;
RESULT:
	ERROR - permission denied for table atest3


-----------
QUERY:
 -- fail
ROLLBACK TO s1;
RESULT:
	[]

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

REVOKE INHERIT OPTION FOR regress_priv_group2 FROM regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

DELETE FROM atest3;
RESULT:
	ERROR - permission denied for table atest3


-----------
QUERY:
 -- also fail
ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- views

SET SESSION AUTHORIZATION regress_priv_user3;
RESULT:
	[]

-----------
QUERY:


CREATE VIEW atestv1 AS SELECT * FROM atest1;
RESULT:
	[]

-----------
QUERY:
 -- ok
/* The next *should* fail, but it's not implemented that way yet. */
CREATE VIEW atestv2 AS SELECT * FROM atest2;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW atestv3 AS SELECT * FROM atest3;
RESULT:
	[]

-----------
QUERY:
 -- ok
/* Empty view is a corner case that failed in 9.2. */
CREATE VIEW atestv0 AS SELECT 0 as x WHERE false;
RESULT:
	[]

-----------
QUERY:
 -- ok

SELECT * FROM atestv1;
RESULT:
	[(1, 'two'), (1, 'two')]

-----------
QUERY:
 -- ok
SELECT * FROM atestv2;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
GRANT SELECT ON atestv1, atestv3 TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON atestv2 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM atestv1;
RESULT:
	[(1, 'two'), (1, 'two')]

-----------
QUERY:
 -- ok
SELECT * FROM atestv2;
RESULT:
	ERROR - permission denied for view atestv2


-----------
QUERY:
 -- fail
SELECT * FROM atestv3;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT * FROM atestv0;
RESULT:
	ERROR - permission denied for view atestv0


-----------
QUERY:
 -- fail

-- Appendrels excluded by constraints failed to check permissions in 8.4-9.2.
select * from
  ((select a.q1 as x from int8_tbl a offset 0)
   union all
   (select b.q2 as x from int8_tbl b offset 0)) ss
where false;
RESULT:
	ERROR - permission denied for table int8_tbl


-----------
QUERY:


set constraint_exclusion = on;
RESULT:
	[]

-----------
QUERY:

select * from
  ((select a.q1 as x, random() from int8_tbl a where q1 > 0)
   union all
   (select b.q2 as x, random() from int8_tbl b where q2 > 0)) ss
where x < 0;
RESULT:
	ERROR - permission denied for table int8_tbl


-----------
QUERY:

reset constraint_exclusion;
RESULT:
	[]

-----------
QUERY:


CREATE VIEW atestv4 AS SELECT * FROM atestv3;
RESULT:
	[]

-----------
QUERY:
 -- nested view
SELECT * FROM atestv4;
RESULT:
	[]

-----------
QUERY:
 -- ok
GRANT SELECT ON atestv4 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


-- Two complex cases:

SELECT * FROM atestv3;
RESULT:
	ERROR - permission denied for view atestv3


-----------
QUERY:
 -- fail
SELECT * FROM atestv4;
RESULT:
	[]

-----------
QUERY:
 -- ok (even though regress_priv_user2 cannot access underlying atestv3)

SELECT * FROM atest2;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT * FROM atestv2;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail (even though regress_priv_user2 can access underlying atest2)

-- Test column level permissions

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE atest5 (one int, two int unique, three int, four int unique);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE atest6 (one int, two int, blue int);
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (one), INSERT (two), UPDATE (three) ON atest5 TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

GRANT ALL (one) ON atest5 TO regress_priv_user3;
RESULT:
	[]

-----------
QUERY:


INSERT INTO atest5 VALUES (1,2,3);
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM atest5;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT one FROM atest5;
RESULT:
	[(1,)]

-----------
QUERY:
 -- ok
COPY atest5 (one) TO stdout;
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 -- ok
SELECT two FROM atest5;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
COPY atest5 (two) TO stdout;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT atest5 FROM atest5;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
COPY atest5 (one,two) TO stdout;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT 1 FROM atest5;
RESULT:
	[(1,)]

-----------
QUERY:
 -- ok
SELECT 1 FROM atest5 a JOIN atest5 b USING (one);
RESULT:
	[(1,)]

-----------
QUERY:
 -- ok
SELECT 1 FROM atest5 a JOIN atest5 b USING (two);
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT 1 FROM atest5 a NATURAL JOIN atest5 b;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT * FROM (atest5 a JOIN atest5 b USING (one)) j;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT j.* FROM (atest5 a JOIN atest5 b USING (one)) j;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT (j.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one)) j;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT one FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j;
RESULT:
	[(1,)]

-----------
QUERY:
 -- ok
SELECT j.one FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j;
RESULT:
	[(1,)]

-----------
QUERY:
 -- ok
SELECT two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT j.two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT j.y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one)) j;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT * FROM (atest5 a JOIN atest5 b USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT a.* FROM (atest5 a JOIN atest5 b USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT (a.*) IS NULL FROM (atest5 a JOIN atest5 b USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT a.two FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT b.y FROM (atest5 a JOIN atest5 b(one,x,y,z) USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT y FROM (atest5 a LEFT JOIN atest5 b(one,x,y,z) USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT b.y FROM (atest5 a LEFT JOIN atest5 b(one,x,y,z) USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT y FROM (atest5 a FULL JOIN atest5 b(one,x,y,z) USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT b.y FROM (atest5 a FULL JOIN atest5 b(one,x,y,z) USING (one));
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT 1 FROM atest5 WHERE two = 2;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT * FROM atest1, atest5;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT atest1.* FROM atest1, atest5;
RESULT:
	[(1, 'two'), (1, 'two')]

-----------
QUERY:
 -- ok
SELECT atest1.*,atest5.one FROM atest1, atest5;
RESULT:
	[(1, 'two', 1), (1, 'two', 1)]

-----------
QUERY:
 -- ok
SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.two);
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT atest1.*,atest5.one FROM atest1 JOIN atest5 ON (atest1.a = atest5.one);
RESULT:
	[(1, 'two', 1), (1, 'two', 1)]

-----------
QUERY:
 -- ok
SELECT one, two FROM atest5;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (one,two) ON atest6 TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT one, two FROM atest5 NATURAL JOIN atest6;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail still

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (two) ON atest5 TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT one, two FROM atest5 NATURAL JOIN atest6;
RESULT:
	[]

-----------
QUERY:
 -- ok now

-- test column-level privileges for INSERT and UPDATE
INSERT INTO atest5 (two) VALUES (3);
RESULT:
	[]

-----------
QUERY:
 -- ok
COPY atest5 FROM stdin;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 -- fail
COPY atest5 (two) FROM stdin;
RESULT:
	ERROR - can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:
 -- ok
1
-- \.
INSERT INTO atest5 (three) VALUES (4);
RESULT:
	ERROR - syntax error at or near "1"
LINE 2: 1
        ^


-----------
QUERY:
 -- fail
INSERT INTO atest5 VALUES (5,5,5);
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
UPDATE atest5 SET three = 10;
RESULT:
	[]

-----------
QUERY:
 -- ok
UPDATE atest5 SET one = 8;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
UPDATE atest5 SET three = 5, one = 2;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
-- Check that column level privs are enforced in RETURNING
-- Ok.
INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10;
RESULT:
	[]

-----------
QUERY:

-- Error. No SELECT on column three.
INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.three;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:

-- Ok.  May SELECT on column /* REPLACED */ ''one/* REPLACED */ '':
INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = 10 RETURNING atest5.one;
RESULT:
	[(None,)]

-----------
QUERY:

-- Check that column level privileges are enforced for EXCLUDED
-- Ok. we may select one
INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.one;
RESULT:
	[]

-----------
QUERY:

-- Error. No select rights on three
INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set three = EXCLUDED.three;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:

INSERT INTO atest5(two) VALUES (6) ON CONFLICT (two) DO UPDATE set one = 8;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fails (due to UPDATE)
INSERT INTO atest5(three) VALUES (4) ON CONFLICT (two) DO UPDATE set three = 10;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fails (due to INSERT)

-- Check that the columns in the inference require select privileges
INSERT INTO atest5(four) VALUES (4);
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT INSERT (four) ON atest5 TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fails (due to SELECT)
INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fails (due to SELECT)
INSERT INTO atest5(four) VALUES (4);
RESULT:
	[]

-----------
QUERY:
 -- ok

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (four) ON atest5 TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


INSERT INTO atest5(four) VALUES (4) ON CONFLICT (four) DO UPDATE set three = 3;
RESULT:
	[]

-----------
QUERY:
 -- ok
INSERT INTO atest5(four) VALUES (4) ON CONFLICT ON CONSTRAINT atest5_four_key DO UPDATE set three = 3;
RESULT:
	[]

-----------
QUERY:
 -- ok

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

REVOKE ALL (one) ON atest5 FROM regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (one,two,blue) ON atest6 TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT one FROM atest5;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
UPDATE atest5 SET one = 1;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
SELECT atest6 FROM atest6;
RESULT:
	[]

-----------
QUERY:
 -- ok
COPY atest6 TO stdout;
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 -- ok

-- test column privileges with MERGE
SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE mtarget (a int, b text);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE msource (a int, b text);
RESULT:
	[]

-----------
QUERY:

INSERT INTO mtarget VALUES (1, 'init1'), (2, 'init2');
RESULT:
	[]

-----------
QUERY:

INSERT INTO msource VALUES (1, 'source1'), (2, 'source2'), (3, 'source3');
RESULT:
	[]

-----------
QUERY:


GRANT SELECT (a) ON msource TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (a) ON mtarget TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

GRANT INSERT (a,b) ON mtarget TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

GRANT UPDATE (b) ON mtarget TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


--
-- test source privileges
--

-- fail (no SELECT priv on s.b)
MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED THEN
	UPDATE SET b = s.b
WHEN NOT MATCHED THEN
	INSERT VALUES (a, NULL);
RESULT:
	ERROR - permission denied for table msource


-----------
QUERY:


-- fail (s.b used in the INSERTed values)
MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED THEN
	UPDATE SET b = 'x'
WHEN NOT MATCHED THEN
	INSERT VALUES (a, b);
RESULT:
	ERROR - permission denied for table msource


-----------
QUERY:


-- fail (s.b used in the WHEN quals)
MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED AND s.b = 'x' THEN
	UPDATE SET b = 'x'
WHEN NOT MATCHED THEN
	INSERT VALUES (a, NULL);
RESULT:
	ERROR - permission denied for table msource


-----------
QUERY:


-- this should be ok since only s.a is accessed
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED THEN
	UPDATE SET b = 'ok'
WHEN NOT MATCHED THEN
	INSERT VALUES (a, NULL);
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (b) ON msource TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


-- should now be ok
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED THEN
	UPDATE SET b = s.b
WHEN NOT MATCHED THEN
	INSERT VALUES (a, b);
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


--
-- test target privileges
--

-- fail (no SELECT priv on t.b)
MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED THEN
	UPDATE SET b = t.b
WHEN NOT MATCHED THEN
	INSERT VALUES (a, NULL);
RESULT:
	ERROR - permission denied for table mtarget


-----------
QUERY:


-- fail (no UPDATE on t.a)
MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED THEN
	UPDATE SET b = s.b, a = t.a + 1
WHEN NOT MATCHED THEN
	INSERT VALUES (a, b);
RESULT:
	ERROR - permission denied for table mtarget


-----------
QUERY:


-- fail (no SELECT on t.b)
MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED AND t.b IS NOT NULL THEN
	UPDATE SET b = s.b
WHEN NOT MATCHED THEN
	INSERT VALUES (a, b);
RESULT:
	ERROR - permission denied for table mtarget


-----------
QUERY:


-- ok
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED THEN
	UPDATE SET b = s.b;
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- fail (no DELETE)
MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED AND t.b IS NOT NULL THEN
	DELETE;
RESULT:
	ERROR - permission denied for table mtarget


-----------
QUERY:


-- grant delete privileges
SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT DELETE ON mtarget TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

-- should be ok now
BEGIN;
RESULT:
	[]

-----------
QUERY:

MERGE INTO mtarget t USING msource s ON t.a = s.a
WHEN MATCHED AND t.b IS NOT NULL THEN
	DELETE;
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- check error reporting with column privs
SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE t1 (c1 int, c2 int, c3 int check (c3 < 5), primary key (c1, c2));
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (c1) ON t1 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT INSERT (c1, c2, c3) ON t1 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT UPDATE (c1, c2, c3) ON t1 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


-- seed data
INSERT INTO t1 VALUES (1, 1, 1);
RESULT:
	[]

-----------
QUERY:

INSERT INTO t1 VALUES (1, 2, 1);
RESULT:
	[]

-----------
QUERY:

INSERT INTO t1 VALUES (2, 1, 2);
RESULT:
	[]

-----------
QUERY:

INSERT INTO t1 VALUES (2, 2, 2);
RESULT:
	[]

-----------
QUERY:

INSERT INTO t1 VALUES (3, 1, 3);
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

INSERT INTO t1 (c1, c2) VALUES (1, 1);
RESULT:
	ERROR - duplicate key value violates unique constraint "t1_pkey"


-----------
QUERY:
 -- fail, but row not shown
UPDATE t1 SET c2 = 1;
RESULT:
	ERROR - duplicate key value violates unique constraint "t1_pkey"


-----------
QUERY:
 -- fail, but row not shown
INSERT INTO t1 (c1, c2) VALUES (null, null);
RESULT:
	ERROR - null value in column "c1" of relation "t1" violates not-null constraint
DETAIL:  Failing row contains (c1, c2) = (null, null).


-----------
QUERY:
 -- fail, but see columns being inserted
INSERT INTO t1 (c3) VALUES (null);
RESULT:
	ERROR - null value in column "c1" of relation "t1" violates not-null constraint
DETAIL:  Failing row contains (c1, c3) = (null, null).


-----------
QUERY:
 -- fail, but see columns being inserted or have SELECT
INSERT INTO t1 (c1) VALUES (5);
RESULT:
	ERROR - null value in column "c2" of relation "t1" violates not-null constraint
DETAIL:  Failing row contains (c1) = (5).


-----------
QUERY:
 -- fail, but see columns being inserted or have SELECT
UPDATE t1 SET c3 = 10;
RESULT:
	ERROR - new row for relation "t1" violates check constraint "t1_c3_check"
DETAIL:  Failing row contains (c1, c3) = (1, 10).


-----------
QUERY:
 -- fail, but see columns with SELECT rights, or being modified

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE t1;
RESULT:
	[]

-----------
QUERY:


-- check error reporting with column privs on a partitioned table
CREATE TABLE errtst(a text, b text NOT NULL, c text, secret1 text, secret2 text) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE errtst_part_1(secret2 text, c text, a text, b text NOT NULL, secret1 text);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE errtst_part_2(secret1 text, secret2 text, a text, c text, b text NOT NULL);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE errtst ATTACH PARTITION errtst_part_1 FOR VALUES IN ('aaa');
RESULT:
	[]

-----------
QUERY:

ALTER TABLE errtst ATTACH PARTITION errtst_part_2 FOR VALUES IN ('aaaa');
RESULT:
	[]

-----------
QUERY:


GRANT SELECT (a, b, c) ON TABLE errtst TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT UPDATE (a, b, c) ON TABLE errtst TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT INSERT (a, b, c) ON TABLE errtst TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


INSERT INTO errtst_part_1 (a, b, c, secret1, secret2)
VALUES ('aaa', 'bbb', 'ccc', 'the body', 'is in the attic');
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


-- Perform a few updates that violate the NOT NULL constraint. Make sure
-- the error messages don/* REPLACED */ ''t leak the secret fields.

-- simple insert.
INSERT INTO errtst (a, b) VALUES ('aaa', NULL);
RESULT:
	ERROR - null value in column "b" of relation "errtst_part_1" violates not-null constraint
DETAIL:  Failing row contains (a, b, c) = (aaa, null, null).


-----------
QUERY:

-- simple update.
UPDATE errtst SET b = NULL;
RESULT:
	ERROR - null value in column "b" of relation "errtst_part_1" violates not-null constraint
DETAIL:  Failing row contains (a, b, c) = (aaa, null, ccc).


-----------
QUERY:

-- partitioning key is updated, doesn/* REPLACED */ ''t move the row.
UPDATE errtst SET a = 'aaa', b = NULL;
RESULT:
	ERROR - null value in column "b" of relation "errtst_part_1" violates not-null constraint
DETAIL:  Failing row contains (a, b, c) = (aaa, null, ccc).


-----------
QUERY:

-- row is moved to another partition.
UPDATE errtst SET a = 'aaaa', b = NULL;
RESULT:
	ERROR - null value in column "b" of relation "errtst_part_2" violates not-null constraint
DETAIL:  Failing row contains (a, b, c) = (aaaa, null, ccc).


-----------
QUERY:


-- row is moved to another partition. This differs from the previous case in
-- that the new partition is excluded by constraint exclusion, so its
-- ResultRelInfo is not created at ExecInitModifyTable, but needs to be
-- constructed on the fly when the updated tuple is routed to it.
UPDATE errtst SET a = 'aaaa', b = NULL WHERE a = 'aaa';
RESULT:
	ERROR - null value in column "b" of relation "errtst_part_2" violates not-null constraint
DETAIL:  Failing row contains (a, b, c) = (aaaa, null, ccc).


-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE errtst;
RESULT:
	[]

-----------
QUERY:


-- test column-level privileges when involved with DELETE
SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE atest6 ADD COLUMN three integer;
RESULT:
	[]

-----------
QUERY:

GRANT DELETE ON atest5 TO regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (two) ON atest5 TO regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

REVOKE ALL (one) ON atest5 FROM regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT (one) ON atest5 TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT atest6 FROM atest6;
RESULT:
	ERROR - permission denied for table atest6


-----------
QUERY:
 -- fail
SELECT one FROM atest5 NATURAL JOIN atest6;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE atest6 DROP COLUMN three;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT atest6 FROM atest6;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT one FROM atest5 NATURAL JOIN atest6;
RESULT:
	[]

-----------
QUERY:
 -- ok

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE atest6 DROP COLUMN two;
RESULT:
	[]

-----------
QUERY:

REVOKE SELECT (one,blue) ON atest6 FROM regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM atest6;
RESULT:
	ERROR - permission denied for table atest6


-----------
QUERY:
 -- fail
SELECT 1 FROM atest6;
RESULT:
	ERROR - permission denied for table atest6


-----------
QUERY:
 -- fail

SET SESSION AUTHORIZATION regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

DELETE FROM atest5 WHERE one = 1;
RESULT:
	ERROR - permission denied for table atest5


-----------
QUERY:
 -- fail
DELETE FROM atest5 WHERE two = 2;
RESULT:
	[]

-----------
QUERY:
 -- ok

-- check inheritance cases
SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE atestp1 (f1 int, f2 int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE atestp2 (fx int, fy int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE atestc (fz int) INHERITS (atestp1, atestp2);
RESULT:
	[]

-----------
QUERY:

GRANT SELECT(fx,fy,tableoid) ON atestp2 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT(fx) ON atestc TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

SELECT fx FROM atestp2;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT fy FROM atestp2;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT atestp2 FROM atestp2;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT tableoid FROM atestp2;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT fy FROM atestc;
RESULT:
	ERROR - permission denied for table atestc


-----------
QUERY:
 -- fail

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT(fy,tableoid) ON atestc TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

SELECT fx FROM atestp2;
RESULT:
	[]

-----------
QUERY:
 -- still ok
SELECT fy FROM atestp2;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT atestp2 FROM atestp2;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT tableoid FROM atestp2;
RESULT:
	[]

-----------
QUERY:
 -- ok

-- child/* REPLACED */ ''s permissions do not apply when operating on parent
SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

REVOKE ALL ON atestc FROM regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON atestp1 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

SELECT f2 FROM atestp1;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT f2 FROM atestc;
RESULT:
	ERROR - permission denied for table atestc


-----------
QUERY:
 -- fail
DELETE FROM atestp1;
RESULT:
	[]

-----------
QUERY:
 -- ok
DELETE FROM atestc;
RESULT:
	ERROR - permission denied for table atestc


-----------
QUERY:
 -- fail
UPDATE atestp1 SET f1 = 1;
RESULT:
	[]

-----------
QUERY:
 -- ok
UPDATE atestc SET f1 = 1;
RESULT:
	ERROR - permission denied for table atestc


-----------
QUERY:
 -- fail
TRUNCATE atestp1;
RESULT:
	[]

-----------
QUERY:
 -- ok
TRUNCATE atestc;
RESULT:
	ERROR - permission denied for table atestc


-----------
QUERY:
 -- fail
BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK atestp1;
RESULT:
	[]

-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK atestc;
RESULT:
	ERROR - permission denied for table atestc


-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:


-- privileges on functions, languages

-- switch to superuser
-- \c -

REVOKE ALL PRIVILEGES ON LANGUAGE sql FROM PUBLIC;
RESULT:
	[]

-----------
QUERY:

GRANT USAGE ON LANGUAGE sql TO regress_priv_user1;
RESULT:
	[]

-----------
QUERY:
 -- ok
GRANT USAGE ON LANGUAGE c TO PUBLIC;
RESULT:
	ERROR - language "c" is not trusted
DETAIL:  GRANT and REVOKE are not allowed on untrusted languages, because only superusers can use untrusted languages.


-----------
QUERY:
 -- fail

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT USAGE ON LANGUAGE sql TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:
 -- fail
CREATE FUNCTION priv_testfunc1(int) RETURNS int AS 'select 2 * $1;
RESULT:
	ERROR - unterminated quoted string at or near "'select 2 * $1;"
LINE 2: ...REATE FUNCTION priv_testfunc1(int) RETURNS int AS 'select 2 ...
                                                             ^


-----------
QUERY:
' LANGUAGE sql;
RESULT:
	ERROR - unterminated quoted string at or near "' LANGUAGE sql;"
LINE 1: ' LANGUAGE sql;
        ^


-----------
QUERY:

CREATE FUNCTION priv_testfunc2(int) RETURNS int AS 'select 3 * $1;
RESULT:
	ERROR - unterminated quoted string at or near "'select 3 * $1;"
LINE 2: ...REATE FUNCTION priv_testfunc2(int) RETURNS int AS 'select 3 ...
                                                             ^


-----------
QUERY:
' LANGUAGE sql;
RESULT:
	ERROR - unterminated quoted string at or near "' LANGUAGE sql;"
LINE 1: ' LANGUAGE sql;
        ^


-----------
QUERY:

CREATE AGGREGATE priv_testagg1(int) (sfunc = int4pl, stype = int4);
RESULT:
	[]

-----------
QUERY:

CREATE PROCEDURE priv_testproc1(int) AS 'select $1;
RESULT:
	ERROR - unterminated quoted string at or near "'select $1;"
LINE 2: CREATE PROCEDURE priv_testproc1(int) AS 'select $1;
                                                ^


-----------
QUERY:
' LANGUAGE sql;
RESULT:
	ERROR - unterminated quoted string at or near "' LANGUAGE sql;"
LINE 1: ' LANGUAGE sql;
        ^


-----------
QUERY:


REVOKE ALL ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) FROM PUBLIC;
RESULT:
	ERROR - function priv_testfunc1(integer) does not exist


-----------
QUERY:

GRANT EXECUTE ON FUNCTION priv_testfunc1(int), priv_testfunc2(int), priv_testagg1(int) TO regress_priv_user2;
RESULT:
	ERROR - function priv_testfunc1(integer) does not exist


-----------
QUERY:

REVOKE ALL ON FUNCTION priv_testproc1(int) FROM PUBLIC;
RESULT:
	ERROR - function priv_testproc1(integer) does not exist


-----------
QUERY:
 -- fail, not a function
REVOKE ALL ON PROCEDURE priv_testproc1(int) FROM PUBLIC;
RESULT:
	ERROR - procedure priv_testproc1(integer) does not exist


-----------
QUERY:

GRANT EXECUTE ON PROCEDURE priv_testproc1(int) TO regress_priv_user2;
RESULT:
	ERROR - procedure priv_testproc1(integer) does not exist


-----------
QUERY:

GRANT USAGE ON FUNCTION priv_testfunc1(int) TO regress_priv_user3;
RESULT:
	ERROR - function priv_testfunc1(integer) does not exist


-----------
QUERY:
 -- semantic error
GRANT USAGE ON FUNCTION priv_testagg1(int) TO regress_priv_user3;
RESULT:
	ERROR - invalid privilege type USAGE for function


-----------
QUERY:
 -- semantic error
GRANT USAGE ON PROCEDURE priv_testproc1(int) TO regress_priv_user3;
RESULT:
	ERROR - procedure priv_testproc1(integer) does not exist


-----------
QUERY:
 -- semantic error
GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc1(int) TO regress_priv_user4;
RESULT:
	ERROR - function priv_testfunc1(integer) does not exist


-----------
QUERY:

GRANT ALL PRIVILEGES ON FUNCTION priv_testfunc_nosuch(int) TO regress_priv_user4;
RESULT:
	ERROR - function priv_testfunc_nosuch(integer) does not exist


-----------
QUERY:

GRANT ALL PRIVILEGES ON FUNCTION priv_testagg1(int) TO regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

GRANT ALL PRIVILEGES ON PROCEDURE priv_testproc1(int) TO regress_priv_user4;
RESULT:
	ERROR - procedure priv_testproc1(integer) does not exist


-----------
QUERY:


CREATE FUNCTION priv_testfunc4(boolean) RETURNS text
  AS 'select col1 from atest2 where col2 = $1;
RESULT:
	ERROR - unterminated quoted string at or near "'select col1 from atest2 where col2 = $1;"
LINE 4:   AS 'select col1 from atest2 where col2 = $1;
             ^


-----------
QUERY:
'
  LANGUAGE sql SECURITY DEFINER;
RESULT:
	ERROR - unterminated quoted string at or near "'
  LANGUAGE sql SECURITY DEFINER;"
LINE 1: '
        ^


-----------
QUERY:

GRANT EXECUTE ON FUNCTION priv_testfunc4(boolean) TO regress_priv_user3;
RESULT:
	ERROR - function priv_testfunc4(boolean) does not exist


-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

SELECT priv_testfunc1(5), priv_testfunc2(5);
RESULT:
	ERROR - function priv_testfunc1(integer) does not exist
LINE 2: SELECT priv_testfunc1(5), priv_testfunc2(5);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
 -- ok
CREATE FUNCTION priv_testfunc3(int) RETURNS int AS 'select 2 * $1;
RESULT:
	ERROR - unterminated quoted string at or near "'select 2 * $1;"
LINE 2: ...REATE FUNCTION priv_testfunc3(int) RETURNS int AS 'select 2 ...
                                                             ^


-----------
QUERY:
' LANGUAGE sql;
RESULT:
	ERROR - unterminated quoted string at or near "' LANGUAGE sql;"
LINE 1: ' LANGUAGE sql;
        ^


-----------
QUERY:
 -- fail
SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x);
RESULT:
	[(6,)]

-----------
QUERY:
 -- ok
CALL priv_testproc1(6);
RESULT:
	ERROR - procedure priv_testproc1(integer) does not exist
LINE 2: CALL priv_testproc1(6);
             ^
HINT:  No procedure matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
 -- ok

SET SESSION AUTHORIZATION regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

SELECT priv_testfunc1(5);
RESULT:
	ERROR - function priv_testfunc1(integer) does not exist
LINE 2: SELECT priv_testfunc1(5);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
 -- fail
SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x);
RESULT:
	[(6,)]

-----------
QUERY:
 -- fail
CALL priv_testproc1(6);
RESULT:
	ERROR - procedure priv_testproc1(integer) does not exist
LINE 2: CALL priv_testproc1(6);
             ^
HINT:  No procedure matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
 -- fail
SELECT col1 FROM atest2 WHERE col2 = true;
RESULT:
	ERROR - permission denied for table atest2


-----------
QUERY:
 -- fail
SELECT priv_testfunc4(true);
RESULT:
	ERROR - function priv_testfunc4(boolean) does not exist
LINE 2: SELECT priv_testfunc4(true);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
 -- ok

SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT priv_testfunc1(5);
RESULT:
	ERROR - function priv_testfunc1(integer) does not exist
LINE 2: SELECT priv_testfunc1(5);
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
 -- ok
SELECT priv_testagg1(x) FROM (VALUES (1), (2), (3)) _(x);
RESULT:
	[(6,)]

-----------
QUERY:
 -- ok
CALL priv_testproc1(6);
RESULT:
	ERROR - procedure priv_testproc1(integer) does not exist
LINE 2: CALL priv_testproc1(6);
             ^
HINT:  No procedure matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
 -- ok

DROP FUNCTION priv_testfunc1(int);
RESULT:
	ERROR - function priv_testfunc1(integer) does not exist


-----------
QUERY:
 -- fail
DROP AGGREGATE priv_testagg1(int);
RESULT:
	ERROR - must be owner of aggregate priv_testagg1


-----------
QUERY:
 -- fail
DROP PROCEDURE priv_testproc1(int);
RESULT:
	ERROR - procedure priv_testproc1(integer) does not exist


-----------
QUERY:
 -- fail

-- \c -

DROP FUNCTION priv_testfunc1(int);
RESULT:
	ERROR - function priv_testfunc1(integer) does not exist


-----------
QUERY:
 -- ok
-- restore to sanity
GRANT ALL PRIVILEGES ON LANGUAGE sql TO PUBLIC;
RESULT:
	[]

-----------
QUERY:


-- verify privilege checks on array-element coercions
BEGIN;
RESULT:
	[]

-----------
QUERY:

SELECT '{1}'::int4[]::int8[];
RESULT:
	[([1],)]

-----------
QUERY:

REVOKE ALL ON FUNCTION int8(integer) FROM PUBLIC;
RESULT:
	[]

-----------
QUERY:

SELECT '{1}'::int4[]::int8[];
RESULT:
	[([1],)]

-----------
QUERY:
 --superuser, succeed
SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

SELECT '{1}'::int4[]::int8[];
RESULT:
	[([1],)]

-----------
QUERY:
 --other user, fail
ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- privileges on types

-- switch to superuser
-- \c -

CREATE TYPE priv_testtype1 AS (a int, b text);
RESULT:
	[]

-----------
QUERY:

REVOKE USAGE ON TYPE priv_testtype1 FROM PUBLIC;
RESULT:
	[]

-----------
QUERY:

GRANT USAGE ON TYPE priv_testtype1 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT USAGE ON TYPE _priv_testtype1 TO regress_priv_user2;
RESULT:
	ERROR - cannot set privileges of array types
HINT:  Set the privileges of the element type instead.


-----------
QUERY:
 -- fail
GRANT USAGE ON DOMAIN priv_testtype1 TO regress_priv_user2;
RESULT:
	ERROR - "priv_testtype1" is not a domain


-----------
QUERY:
 -- fail

CREATE DOMAIN priv_testdomain1 AS int;
RESULT:
	[]

-----------
QUERY:

REVOKE USAGE on DOMAIN priv_testdomain1 FROM PUBLIC;
RESULT:
	[]

-----------
QUERY:

GRANT USAGE ON DOMAIN priv_testdomain1 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT USAGE ON TYPE priv_testdomain1 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:
 -- ok

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


-- commands that should fail

CREATE AGGREGATE priv_testagg1a(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:


CREATE DOMAIN priv_testdomain2a AS priv_testdomain1;
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:


CREATE DOMAIN priv_testdomain3a AS int;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3a AS $$ SELECT $1::priv_testdomain3a $$ LANGUAGE SQL;
RESULT:
	[]

-----------
QUERY:

CREATE CAST (priv_testdomain1 AS priv_testdomain3a) WITH FUNCTION castfunc(int);
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:

DROP FUNCTION castfunc(int) CASCADE;
RESULT:
	[]

-----------
QUERY:

DROP DOMAIN priv_testdomain3a;
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION priv_testfunc5a(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:

CREATE FUNCTION priv_testfunc6a(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:


CREATE OPERATOR !+! (PROCEDURE = int4pl, LEFTARG = priv_testdomain1, RIGHTARG = priv_testdomain1);
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:


CREATE TABLE test5a (a int, b priv_testdomain1);
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:

CREATE TABLE test6a OF priv_testtype1;
RESULT:
	ERROR - permission denied for type priv_testtype1


-----------
QUERY:

CREATE TABLE test10a (a int[], b priv_testtype1[]);
RESULT:
	ERROR - permission denied for type priv_testtype1


-----------
QUERY:


CREATE TABLE test9a (a int, b int);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE test9a ADD COLUMN c priv_testdomain1;
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:

ALTER TABLE test9a ALTER COLUMN b TYPE priv_testdomain1;
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:


CREATE TYPE test7a AS (a int, b priv_testdomain1);
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:


CREATE TYPE test8a AS (a int, b int);
RESULT:
	[]

-----------
QUERY:

ALTER TYPE test8a ADD ATTRIBUTE c priv_testdomain1;
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:

ALTER TYPE test8a ALTER ATTRIBUTE b TYPE priv_testdomain1;
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:


CREATE TABLE test11a AS (SELECT 1::priv_testdomain1 AS a);
RESULT:
	ERROR - permission denied for type priv_testdomain1


-----------
QUERY:


REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
RESULT:
	ERROR - permission denied for type priv_testtype1


-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


-- commands that should succeed

CREATE AGGREGATE priv_testagg1b(priv_testdomain1) (sfunc = int4_sum, stype = bigint);
RESULT:
	[]

-----------
QUERY:


CREATE DOMAIN priv_testdomain2b AS priv_testdomain1;
RESULT:
	[]

-----------
QUERY:


CREATE DOMAIN priv_testdomain3b AS int;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION castfunc(int) RETURNS priv_testdomain3b AS $$ SELECT $1::priv_testdomain3b $$ LANGUAGE SQL;
RESULT:
	[]

-----------
QUERY:

CREATE CAST (priv_testdomain1 AS priv_testdomain3b) WITH FUNCTION castfunc(int);
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION priv_testfunc5b(a priv_testdomain1) RETURNS int LANGUAGE SQL AS $$ SELECT $1 $$;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION priv_testfunc6b(b int) RETURNS priv_testdomain1 LANGUAGE SQL AS $$ SELECT $1::priv_testdomain1 $$;
RESULT:
	[]

-----------
QUERY:


CREATE OPERATOR !! (PROCEDURE = priv_testfunc5b, RIGHTARG = priv_testdomain1);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE test5b (a int, b priv_testdomain1);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE test6b OF priv_testtype1;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE test10b (a int[], b priv_testtype1[]);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE test9b (a int, b int);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE test9b ADD COLUMN c priv_testdomain1;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE test9b ALTER COLUMN b TYPE priv_testdomain1;
RESULT:
	[]

-----------
QUERY:


CREATE TYPE test7b AS (a int, b priv_testdomain1);
RESULT:
	[]

-----------
QUERY:


CREATE TYPE test8b AS (a int, b int);
RESULT:
	[]

-----------
QUERY:

ALTER TYPE test8b ADD ATTRIBUTE c priv_testdomain1;
RESULT:
	[]

-----------
QUERY:

ALTER TYPE test8b ALTER ATTRIBUTE b TYPE priv_testdomain1;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE test11b AS (SELECT 1::priv_testdomain1 AS a);
RESULT:
	[]

-----------
QUERY:


REVOKE ALL ON TYPE priv_testtype1 FROM PUBLIC;
RESULT:
	[]

-----------
QUERY:


-- \c -
DROP AGGREGATE priv_testagg1b(priv_testdomain1);
RESULT:
	[]

-----------
QUERY:

DROP DOMAIN priv_testdomain2b;
RESULT:
	[]

-----------
QUERY:

DROP OPERATOR !! (NONE, priv_testdomain1);
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION priv_testfunc5b(a priv_testdomain1);
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION priv_testfunc6b(b int);
RESULT:
	[]

-----------
QUERY:

DROP TABLE test5b;
RESULT:
	[]

-----------
QUERY:

DROP TABLE test6b;
RESULT:
	[]

-----------
QUERY:

DROP TABLE test9b;
RESULT:
	[]

-----------
QUERY:

DROP TABLE test10b;
RESULT:
	[]

-----------
QUERY:

DROP TYPE test7b;
RESULT:
	[]

-----------
QUERY:

DROP TYPE test8b;
RESULT:
	[]

-----------
QUERY:

DROP CAST (priv_testdomain1 AS priv_testdomain3b);
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION castfunc(int) CASCADE;
RESULT:
	[]

-----------
QUERY:

DROP DOMAIN priv_testdomain3b;
RESULT:
	[]

-----------
QUERY:

DROP TABLE test11b;
RESULT:
	[]

-----------
QUERY:


DROP TYPE priv_testtype1;
RESULT:
	ERROR - must be owner of type priv_testtype1


-----------
QUERY:
 -- ok
DROP DOMAIN priv_testdomain1;
RESULT:
	ERROR - must be owner of type priv_testdomain1


-----------
QUERY:
 -- ok


-- truncate
SET SESSION AUTHORIZATION regress_priv_user5;
RESULT:
	[]

-----------
QUERY:

TRUNCATE atest2;
RESULT:
	[]

-----------
QUERY:
 -- ok
TRUNCATE atest3;
RESULT:
	ERROR - permission denied for table atest3


-----------
QUERY:
 -- fail

-- has_table_privilege function

-- bad-input checks
select has_table_privilege(NULL,'pg_authid','select');
RESULT:
	[(None,)]

-----------
QUERY:

select has_table_privilege('pg_shad','select');
RESULT:
	ERROR - relation "pg_shad" does not exist


-----------
QUERY:

select has_table_privilege('nosuchuser','pg_authid','select');
RESULT:
	ERROR - role "nosuchuser" does not exist


-----------
QUERY:

select has_table_privilege('pg_authid','sel');
RESULT:
	ERROR - unrecognized privilege type: "sel"


-----------
QUERY:

select has_table_privilege(-999999,'pg_authid','update');
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege(1,'select');
RESULT:
	[(None,)]

-----------
QUERY:


-- superuser
-- \c -

select has_table_privilege(current_user,'pg_authid','select');
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege(current_user,'pg_authid','insert');
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(t2.oid,'pg_authid','update')
from (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege(t2.oid,'pg_authid','delete')
from (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(False,)]

-----------
QUERY:


-- /* REPLACED */ ''rule/* REPLACED */ '' privilege no longer exists, but for backwards compatibility
-- has_table_privilege still recognizes the keyword and says FALSE
select has_table_privilege(current_user,t1.oid,'rule')
from (select oid from pg_class where relname = 'pg_authid') as t1;
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege(current_user,t1.oid,'references')
from (select oid from pg_class where relname = 'pg_authid') as t1;
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(t2.oid,t1.oid,'select')
from (select oid from pg_class where relname = 'pg_authid') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege(t2.oid,t1.oid,'insert')
from (select oid from pg_class where relname = 'pg_authid') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege('pg_authid','update');
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege('pg_authid','delete');
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege('pg_authid','truncate');
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(t1.oid,'select')
from (select oid from pg_class where relname = 'pg_authid') as t1;
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege(t1.oid,'trigger')
from (select oid from pg_class where relname = 'pg_authid') as t1;
RESULT:
	[(False,)]

-----------
QUERY:


-- non-superuser
SET SESSION AUTHORIZATION regress_priv_user3;
RESULT:
	[]

-----------
QUERY:


select has_table_privilege(current_user,'pg_class','select');
RESULT:
	[(True,)]

-----------
QUERY:

select has_table_privilege(current_user,'pg_class','insert');
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(t2.oid,'pg_class','update')
from (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege(t2.oid,'pg_class','delete')
from (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(current_user,t1.oid,'references')
from (select oid from pg_class where relname = 'pg_class') as t1;
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(t2.oid,t1.oid,'select')
from (select oid from pg_class where relname = 'pg_class') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(True,)]

-----------
QUERY:

select has_table_privilege(t2.oid,t1.oid,'insert')
from (select oid from pg_class where relname = 'pg_class') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege('pg_class','update');
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege('pg_class','delete');
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege('pg_class','truncate');
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(t1.oid,'select')
from (select oid from pg_class where relname = 'pg_class') as t1;
RESULT:
	[(True,)]

-----------
QUERY:

select has_table_privilege(t1.oid,'trigger')
from (select oid from pg_class where relname = 'pg_class') as t1;
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(current_user,'atest1','select');
RESULT:
	[(True,)]

-----------
QUERY:

select has_table_privilege(current_user,'atest1','insert');
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(t2.oid,'atest1','update')
from (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege(t2.oid,'atest1','delete')
from (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(current_user,t1.oid,'references')
from (select oid from pg_class where relname = 'atest1') as t1;
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(t2.oid,t1.oid,'select')
from (select oid from pg_class where relname = 'atest1') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(True,)]

-----------
QUERY:

select has_table_privilege(t2.oid,t1.oid,'insert')
from (select oid from pg_class where relname = 'atest1') as t1,
  (select oid from pg_roles where rolname = current_user) as t2;
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege('atest1','update');
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege('atest1','delete');
RESULT:
	[(False,)]

-----------
QUERY:

select has_table_privilege('atest1','truncate');
RESULT:
	[(False,)]

-----------
QUERY:


select has_table_privilege(t1.oid,'select')
from (select oid from pg_class where relname = 'atest1') as t1;
RESULT:
	[(True,)]

-----------
QUERY:

select has_table_privilege(t1.oid,'trigger')
from (select oid from pg_class where relname = 'atest1') as t1;
RESULT:
	[(False,)]

-----------
QUERY:


-- has_column_privilege function

-- bad-input checks (as non-super-user)
select has_column_privilege('pg_authid',NULL,'select');
RESULT:
	[(None,)]

-----------
QUERY:

select has_column_privilege('pg_authid','nosuchcol','select');
RESULT:
	ERROR - column "nosuchcol" of relation "pg_authid" does not exist


-----------
QUERY:

select has_column_privilege(9999,'nosuchcol','select');
RESULT:
	[(None,)]

-----------
QUERY:

select has_column_privilege(9999,99::int2,'select');
RESULT:
	[(None,)]

-----------
QUERY:

select has_column_privilege('pg_authid',99::int2,'select');
RESULT:
	[(None,)]

-----------
QUERY:

select has_column_privilege(9999,99::int2,'select');
RESULT:
	[(None,)]

-----------
QUERY:


create temp table mytable(f1 int, f2 int, f3 int);
RESULT:
	[]

-----------
QUERY:

alter table mytable drop column f2;
RESULT:
	[]

-----------
QUERY:

select has_column_privilege('mytable','f2','select');
RESULT:
	ERROR - column "f2" of relation "mytable" does not exist


-----------
QUERY:

select has_column_privilege('mytable','........pg.dropped.2........','select');
RESULT:
	[(None,)]

-----------
QUERY:

select has_column_privilege('mytable',2::int2,'select');
RESULT:
	[(None,)]

-----------
QUERY:

select has_column_privilege('mytable',99::int2,'select');
RESULT:
	[(None,)]

-----------
QUERY:

revoke select on table mytable from regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

select has_column_privilege('mytable',2::int2,'select');
RESULT:
	[(None,)]

-----------
QUERY:

select has_column_privilege('mytable',99::int2,'select');
RESULT:
	[(None,)]

-----------
QUERY:

drop table mytable;
RESULT:
	[]

-----------
QUERY:


-- Grant options

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE atest4 (a int);
RESULT:
	[]

-----------
QUERY:


GRANT SELECT ON atest4 TO regress_priv_user2 WITH GRANT OPTION;
RESULT:
	[]

-----------
QUERY:

GRANT UPDATE ON atest4 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON atest4 TO GROUP regress_priv_group1 WITH GRANT OPTION;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


GRANT SELECT ON atest4 TO regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

GRANT UPDATE ON atest4 TO regress_priv_user3;
RESULT:
	[]

-----------
QUERY:
 -- fail

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


REVOKE SELECT ON atest4 FROM regress_priv_user3;
RESULT:
	[]

-----------
QUERY:
 -- does nothing
SELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT');
RESULT:
	[(True,)]

-----------
QUERY:
 -- true
REVOKE SELECT ON atest4 FROM regress_priv_user2;
RESULT:
	ERROR - dependent privileges exist
HINT:  Use CASCADE to revoke them too.


-----------
QUERY:
 -- fail
REVOKE GRANT OPTION FOR SELECT ON atest4 FROM regress_priv_user2 CASCADE;
RESULT:
	[]

-----------
QUERY:
 -- ok
SELECT has_table_privilege('regress_priv_user2', 'atest4', 'SELECT');
RESULT:
	[(True,)]

-----------
QUERY:
 -- true
SELECT has_table_privilege('regress_priv_user3', 'atest4', 'SELECT');
RESULT:
	[(False,)]

-----------
QUERY:
 -- false

SELECT has_table_privilege('regress_priv_user1', 'atest4', 'SELECT WITH GRANT OPTION');
RESULT:
	[(True,)]

-----------
QUERY:
 -- true


-- security-restricted operations
-- \c -
CREATE ROLE regress_sro_user;
RESULT:
	ERROR - permission denied to create role
DETAIL:  Only roles with the CREATEROLE attribute may create roles.


-----------
QUERY:


-- Check that index expressions and predicates are run as the table/* REPLACED */ ''s owner

-- A dummy index function checking current_user
CREATE FUNCTION sro_ifun(int) RETURNS int AS $$
BEGIN
	-- Below we set the table/* REPLACED */ ''s owner to regress_sro_user
	ASSERT current_user = 'regress_sro_user',
		format('sro_ifun(%s) called by %s', $1, current_user);
	RETURN $1;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
RESULT:
	[]

-----------
QUERY:

-- Create a table owned by regress_sro_user
CREATE TABLE sro_tab (a int);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE sro_tab OWNER TO regress_sro_user;
RESULT:
	ERROR - role "regress_sro_user" does not exist


-----------
QUERY:

INSERT INTO sro_tab VALUES (1), (2), (3);
RESULT:
	[]

-----------
QUERY:

-- Create an expression index with a predicate
CREATE INDEX sro_idx ON sro_tab ((sro_ifun(a) + sro_ifun(0)))
	WHERE sro_ifun(a + 10) > sro_ifun(10);
RESULT:
	ERROR - sro_ifun(10) called by regress_priv_user1
CONTEXT:  PL/pgSQL function sro_ifun(integer) line 4 at ASSERT


-----------
QUERY:

DROP INDEX sro_idx;
RESULT:
	ERROR - index "sro_idx" does not exist


-----------
QUERY:

-- Do the same concurrently
CREATE INDEX CONCURRENTLY sro_idx ON sro_tab ((sro_ifun(a) + sro_ifun(0)))
	WHERE sro_ifun(a + 10) > sro_ifun(10);
RESULT:
	ERROR - sro_ifun(10) called by regress_priv_user1
CONTEXT:  PL/pgSQL function sro_ifun(integer) line 4 at ASSERT


-----------
QUERY:

-- REINDEX
REINDEX TABLE sro_tab;
RESULT:
	[]

-----------
QUERY:

REINDEX INDEX sro_idx;
RESULT:
	ERROR - relation "sro_idx" does not exist


-----------
QUERY:

REINDEX TABLE CONCURRENTLY sro_tab;
RESULT:
	[]

-----------
QUERY:

DROP INDEX sro_idx;
RESULT:
	ERROR - index "sro_idx" does not exist


-----------
QUERY:

-- CLUSTER
CREATE INDEX sro_cluster_idx ON sro_tab ((sro_ifun(a) + sro_ifun(0)));
RESULT:
	ERROR - sro_ifun(0) called by regress_priv_user1
CONTEXT:  PL/pgSQL function sro_ifun(integer) line 4 at ASSERT


-----------
QUERY:

CLUSTER sro_tab USING sro_cluster_idx;
RESULT:
	ERROR - index "sro_cluster_idx" for table "sro_tab" does not exist


-----------
QUERY:

DROP INDEX sro_cluster_idx;
RESULT:
	ERROR - index "sro_cluster_idx" does not exist


-----------
QUERY:

-- BRIN index
CREATE INDEX sro_brin ON sro_tab USING brin ((sro_ifun(a) + sro_ifun(0)));
RESULT:
	ERROR - sro_ifun(0) called by regress_priv_user1
CONTEXT:  PL/pgSQL function sro_ifun(integer) line 4 at ASSERT


-----------
QUERY:

SELECT brin_desummarize_range('sro_brin', 0);
RESULT:
	ERROR - relation "sro_brin" does not exist
LINE 2: SELECT brin_desummarize_range('sro_brin', 0);
                                      ^


-----------
QUERY:

SELECT brin_summarize_range('sro_brin', 0);
RESULT:
	ERROR - relation "sro_brin" does not exist
LINE 2: SELECT brin_summarize_range('sro_brin', 0);
                                    ^


-----------
QUERY:

DROP TABLE sro_tab;
RESULT:
	[]

-----------
QUERY:

-- Check with a partitioned table
CREATE TABLE sro_ptab (a int) PARTITION BY RANGE (a);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE sro_ptab OWNER TO regress_sro_user;
RESULT:
	ERROR - role "regress_sro_user" does not exist


-----------
QUERY:

CREATE TABLE sro_part PARTITION OF sro_ptab FOR VALUES FROM (1) TO (10);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE sro_part OWNER TO regress_sro_user;
RESULT:
	ERROR - role "regress_sro_user" does not exist


-----------
QUERY:

INSERT INTO sro_ptab VALUES (1), (2), (3);
RESULT:
	[]

-----------
QUERY:

CREATE INDEX sro_pidx ON sro_ptab ((sro_ifun(a) + sro_ifun(0)))
	WHERE sro_ifun(a + 10) > sro_ifun(10);
RESULT:
	ERROR - sro_ifun(10) called by regress_priv_user1
CONTEXT:  PL/pgSQL function sro_ifun(integer) line 4 at ASSERT


-----------
QUERY:

REINDEX TABLE sro_ptab;
RESULT:
	[]

-----------
QUERY:

REINDEX INDEX CONCURRENTLY sro_pidx;
RESULT:
	ERROR - relation "sro_pidx" does not exist


-----------
QUERY:


SET SESSION AUTHORIZATION regress_sro_user;
RESULT:
	ERROR - role "regress_sro_user" does not exist


-----------
QUERY:

CREATE FUNCTION unwanted_grant() RETURNS void LANGUAGE sql AS
	'GRANT regress_priv_group2 TO regress_sro_user';
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION mv_action() RETURNS bool LANGUAGE sql AS
	'DECLARE c CURSOR WITH HOLD FOR SELECT public.unwanted_grant();
RESULT:
	ERROR - unterminated quoted string at or near "'DECLARE c CURSOR WITH HOLD FOR SELECT public.unwanted_grant();"
LINE 3:  'DECLARE c CURSOR WITH HOLD FOR SELECT public.unwanted_gran...
         ^


-----------
QUERY:
 SELECT true';
RESULT:
	ERROR - unterminated quoted string at or near "';"
LINE 1:  SELECT true';
                    ^


-----------
QUERY:

-- REFRESH of this MV will queue a GRANT at end of transaction
CREATE MATERIALIZED VIEW sro_mv AS SELECT mv_action() WITH NO DATA;
RESULT:
	ERROR - function mv_action() does not exist
LINE 3: CREATE MATERIALIZED VIEW sro_mv AS SELECT mv_action() WITH N...
                                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

REFRESH MATERIALIZED VIEW sro_mv;
RESULT:
	ERROR - relation "sro_mv" does not exist


-----------
QUERY:

-- \c -
REFRESH MATERIALIZED VIEW sro_mv;
RESULT:
	ERROR - relation "sro_mv" does not exist


-----------
QUERY:


SET SESSION AUTHORIZATION regress_sro_user;
RESULT:
	ERROR - role "regress_sro_user" does not exist


-----------
QUERY:

-- INSERT to this table will queue a GRANT at end of transaction
CREATE TABLE sro_trojan_table ();
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION sro_trojan() RETURNS trigger LANGUAGE plpgsql AS
	'BEGIN PERFORM public.unwanted_grant();
RESULT:
	ERROR - unterminated quoted string at or near "'BEGIN PERFORM public.unwanted_grant();"
LINE 3:  'BEGIN PERFORM public.unwanted_grant();
         ^


-----------
QUERY:
 RETURN NULL;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 1:  RETURN NULL;
         ^


-----------
QUERY:
 END';
RESULT:
	ERROR - unterminated quoted string at or near "';"
LINE 1:  END';
            ^


-----------
QUERY:

CREATE CONSTRAINT TRIGGER t AFTER INSERT ON sro_trojan_table
    INITIALLY DEFERRED FOR EACH ROW EXECUTE PROCEDURE sro_trojan();
RESULT:
	ERROR - function sro_trojan() does not exist


-----------
QUERY:

-- Now, REFRESH will issue such an INSERT, queueing the GRANT
CREATE OR REPLACE FUNCTION mv_action() RETURNS bool LANGUAGE sql AS
	'INSERT INTO public.sro_trojan_table DEFAULT VALUES;
RESULT:
	ERROR - unterminated quoted string at or near "'INSERT INTO public.sro_trojan_table DEFAULT VALUES;"
LINE 4:  'INSERT INTO public.sro_trojan_table DEFAULT VALUES;
         ^


-----------
QUERY:
 SELECT true';
RESULT:
	ERROR - unterminated quoted string at or near "';"
LINE 1:  SELECT true';
                    ^


-----------
QUERY:

REFRESH MATERIALIZED VIEW sro_mv;
RESULT:
	ERROR - relation "sro_mv" does not exist


-----------
QUERY:

-- \c -
REFRESH MATERIALIZED VIEW sro_mv;
RESULT:
	ERROR - relation "sro_mv" does not exist


-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:
 SET CONSTRAINTS ALL IMMEDIATE;
RESULT:
	[]

-----------
QUERY:
 REFRESH MATERIALIZED VIEW sro_mv;
RESULT:
	ERROR - relation "sro_mv" does not exist


-----------
QUERY:
 COMMIT;
RESULT:
	[]

-----------
QUERY:


-- REFRESH MATERIALIZED VIEW CONCURRENTLY use of eval_const_expressions()
SET SESSION AUTHORIZATION regress_sro_user;
RESULT:
	ERROR - role "regress_sro_user" does not exist


-----------
QUERY:

CREATE FUNCTION unwanted_grant_nofail(int) RETURNS int
	IMMUTABLE LANGUAGE plpgsql AS $$
BEGIN
	PERFORM public.unwanted_grant();
	RAISE WARNING 'owned';
	RETURN 1;
EXCEPTION WHEN OTHERS THEN
	RETURN 2;
END$$;
RESULT:
	[]

-----------
QUERY:

CREATE MATERIALIZED VIEW sro_index_mv AS SELECT 1 AS c;
RESULT:
	[]

-----------
QUERY:

CREATE UNIQUE INDEX ON sro_index_mv (c) WHERE unwanted_grant_nofail(1) > 0;
RESULT:
	[]

-----------
QUERY:

-- \c -
REFRESH MATERIALIZED VIEW CONCURRENTLY sro_index_mv;
RESULT:
	[]

-----------
QUERY:

REFRESH MATERIALIZED VIEW sro_index_mv;
RESULT:
	[]

-----------
QUERY:


DROP OWNED BY regress_sro_user;
RESULT:
	ERROR - role "regress_sro_user" does not exist


-----------
QUERY:

DROP ROLE regress_sro_user;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:



-- Admin options

SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION dogrant_ok() RETURNS void LANGUAGE sql SECURITY DEFINER AS
	'GRANT regress_priv_group2 TO regress_priv_user5';
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_group2 TO regress_priv_user5;
RESULT:
	[]

-----------
QUERY:
 -- ok: had ADMIN OPTION
SET ROLE regress_priv_group2;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_group2 TO regress_priv_user5;
RESULT:
	ERROR - permission denied to grant role "regress_priv_group2"
DETAIL:  Only roles with the ADMIN option on role "regress_priv_group2" may grant this role.


-----------
QUERY:
 -- fails: SET ROLE suspended privilege

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_group2 TO regress_priv_user5;
RESULT:
	ERROR - permission denied to grant role "regress_priv_group2"
DETAIL:  Only roles with the ADMIN option on role "regress_priv_group2" may grant this role.


-----------
QUERY:
 -- fails: no ADMIN OPTION
SELECT dogrant_ok();
RESULT:
	[(None,)]

-----------
QUERY:
			-- ok: SECURITY DEFINER conveys ADMIN
SET ROLE regress_priv_group2;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_group2 TO regress_priv_user5;
RESULT:
	ERROR - permission denied to grant role "regress_priv_group2"
DETAIL:  Only roles with the ADMIN option on role "regress_priv_group2" may grant this role.


-----------
QUERY:
 -- fails: SET ROLE did not help

SET SESSION AUTHORIZATION regress_priv_group2;
RESULT:
	[]

-----------
QUERY:

GRANT regress_priv_group2 TO regress_priv_user5;
RESULT:
	ERROR - permission denied to grant role "regress_priv_group2"
DETAIL:  Only roles with the ADMIN option on role "regress_priv_group2" may grant this role.


-----------
QUERY:
 -- fails: no self-admin

SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION dogrant_ok();
RESULT:
	[]

-----------
QUERY:

REVOKE regress_priv_group2 FROM regress_priv_user5;
RESULT:
	[]

-----------
QUERY:



-- has_sequence_privilege tests
-- \c -

CREATE SEQUENCE x_seq;
RESULT:
	[]

-----------
QUERY:


GRANT USAGE on x_seq to regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


SELECT has_sequence_privilege('regress_priv_user1', 'atest1', 'SELECT');
RESULT:
	ERROR - "atest1" is not a sequence


-----------
QUERY:

SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'INSERT');
RESULT:
	ERROR - unrecognized privilege type: "INSERT"


-----------
QUERY:

SELECT has_sequence_privilege('regress_priv_user1', 'x_seq', 'SELECT');
RESULT:
	[(False,)]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


SELECT has_sequence_privilege('x_seq', 'USAGE');
RESULT:
	[(True,)]

-----------
QUERY:


-- largeobject privilege tests
-- \c -
SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


SELECT lo_create(1001);
RESULT:
	[(1001,)]

-----------
QUERY:

SELECT lo_create(1002);
RESULT:
	[(1002,)]

-----------
QUERY:

SELECT lo_create(1003);
RESULT:
	[(1003,)]

-----------
QUERY:

SELECT lo_create(1004);
RESULT:
	[(1004,)]

-----------
QUERY:

SELECT lo_create(1005);
RESULT:
	[(1005,)]

-----------
QUERY:


GRANT ALL ON LARGE OBJECT 1001 TO PUBLIC;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON LARGE OBJECT 1003 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT,UPDATE ON LARGE OBJECT 1004 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON LARGE OBJECT 1005 TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON LARGE OBJECT 1005 TO regress_priv_user2 WITH GRANT OPTION;
RESULT:
	[]

-----------
QUERY:


GRANT SELECT, INSERT ON LARGE OBJECT 1001 TO PUBLIC;
RESULT:
	ERROR - invalid privilege type INSERT for large object


-----------
QUERY:
	-- to be failed
GRANT SELECT, UPDATE ON LARGE OBJECT 1001 TO nosuchuser;
RESULT:
	ERROR - role "nosuchuser" does not exist


-----------
QUERY:
	-- to be failed
GRANT SELECT, UPDATE ON LARGE OBJECT  999 TO PUBLIC;
RESULT:
	ERROR - large object 999 does not exist


-----------
QUERY:
	-- to be failed

-- \c -
SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


SELECT lo_create(2001);
RESULT:
	[(2001,)]

-----------
QUERY:

SELECT lo_create(2002);
RESULT:
	[(2002,)]

-----------
QUERY:
	-- allowed, for now
SELECT lowrite(lo_open(1001, x'40000'::int), 'abcd');
RESULT:
	ERROR - large object descriptor 0 was not opened for writing


-----------
QUERY:

SELECT loread(lo_open(1002, x'40000'::int), 32);
RESULT:
	ERROR - permission denied for large object 1002


-----------
QUERY:


SELECT lowrite(lo_open(1001, x'20000'::int), 'abcd');
RESULT:
	[(4,)]

-----------
QUERY:

SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');
RESULT:
	ERROR - permission denied for large object 1002


-----------
QUERY:
	-- to be denied
SELECT lowrite(lo_open(1003, x'20000'::int), 'abcd');
RESULT:
	ERROR - permission denied for large object 1003


-----------
QUERY:
	-- to be denied
SELECT lowrite(lo_open(1004, x'20000'::int), 'abcd');
RESULT:
	[(4,)]

-----------
QUERY:


GRANT SELECT ON LARGE OBJECT 1005 TO regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

GRANT UPDATE ON LARGE OBJECT 1006 TO regress_priv_user3;
RESULT:
	ERROR - large object 1006 does not exist


-----------
QUERY:
	-- to be denied
REVOKE ALL ON LARGE OBJECT 2001, 2002 FROM PUBLIC;
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON LARGE OBJECT 2001 TO regress_priv_user3;
RESULT:
	[]

-----------
QUERY:


SELECT lo_unlink(1001);
RESULT:
	ERROR - must be owner of large object 1001


-----------
QUERY:
		-- to be denied
SELECT lo_unlink(2002);
RESULT:
	[(1,)]

-----------
QUERY:


-- \c -
-- confirm ACL setting
SELECT oid, pg_get_userbyid(lomowner) ownername, lomacl FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
RESULT:
	[(1001, 'regress_priv_user1', '{regress_priv_user1=rw/regress_priv_user1,=rw/regress_priv_user1}'), (1002, 'regress_priv_user1', None), (1003, 'regress_priv_user1', '{regress_priv_user1=rw/regress_priv_user1,regress_priv_user2=r/regress_priv_user1}'), (1004, 'regress_priv_user1', '{regress_priv_user1=rw/regress_priv_user1,regress_priv_user2=rw/regress_priv_user1}'), (1005, 'regress_priv_user1', '{regress_priv_user1=rw/regress_priv_user1,regress_priv_user2=r*w/regress_priv_user1,regress_priv_user3=r/regress_priv_user2}'), (2001, 'regress_priv_user2', '{regress_priv_user2=rw/regress_priv_user2,regress_priv_user3=rw/regress_priv_user2}')]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

SELECT loread(lo_open(1003, x'40000'::int), 32);
RESULT:
	ERROR - permission denied for large object 1003


-----------
QUERY:


SELECT lo_truncate(lo_open(1005, x'20000'::int), 10);
RESULT:
	ERROR - permission denied for large object 1005


-----------
QUERY:
	-- to be denied
SELECT lo_truncate(lo_open(2001, x'20000'::int), 10);
RESULT:
	[(0,)]

-----------
QUERY:


-- compatibility mode in largeobject permission
-- \c -
SET lo_compat_privileges = false;
RESULT:
	ERROR - permission denied to set parameter "lo_compat_privileges"


-----------
QUERY:
	-- default setting
SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


SELECT loread(lo_open(1002, x'40000'::int), 32);
RESULT:
	ERROR - permission denied for large object 1002


-----------
QUERY:
	-- to be denied
SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');
RESULT:
	ERROR - permission denied for large object 1002


-----------
QUERY:
	-- to be denied
SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);
RESULT:
	ERROR - permission denied for large object 1002


-----------
QUERY:
	-- to be denied
SELECT lo_put(1002, 1, 'abcd');
RESULT:
	ERROR - permission denied for large object 1002


-----------
QUERY:
				-- to be denied
SELECT lo_unlink(1002);
RESULT:
	ERROR - must be owner of large object 1002


-----------
QUERY:
					-- to be denied
SELECT lo_export(1001, '/dev/null');
RESULT:
	ERROR - permission denied for function lo_export


-----------
QUERY:
			-- to be denied
SELECT lo_import('/dev/null');
RESULT:
	ERROR - permission denied for function lo_import


-----------
QUERY:
				-- to be denied
SELECT lo_import('/dev/null', 2003);
RESULT:
	ERROR - permission denied for function lo_import


-----------
QUERY:
			-- to be denied

-- \c -
SET lo_compat_privileges = true;
RESULT:
	ERROR - permission denied to set parameter "lo_compat_privileges"


-----------
QUERY:
	-- compatibility mode
SET SESSION AUTHORIZATION regress_priv_user4;
RESULT:
	[]

-----------
QUERY:


SELECT loread(lo_open(1002, x'40000'::int), 32);
RESULT:
	ERROR - permission denied for large object 1002


-----------
QUERY:

SELECT lowrite(lo_open(1002, x'20000'::int), 'abcd');
RESULT:
	ERROR - permission denied for large object 1002


-----------
QUERY:

SELECT lo_truncate(lo_open(1002, x'20000'::int), 10);
RESULT:
	ERROR - permission denied for large object 1002


-----------
QUERY:

SELECT lo_unlink(1002);
RESULT:
	ERROR - must be owner of large object 1002


-----------
QUERY:

SELECT lo_export(1001, '/dev/null');
RESULT:
	ERROR - permission denied for function lo_export


-----------
QUERY:
			-- to be denied

-- don/* REPLACED */ ''t allow unpriv users to access pg_largeobject contents
-- \c -
SELECT * FROM pg_largeobject LIMIT 0;
RESULT:
	ERROR - permission denied for table pg_largeobject


-----------
QUERY:


SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM pg_largeobject LIMIT 0;
RESULT:
	ERROR - permission denied for table pg_largeobject


-----------
QUERY:
			-- to be denied

-- pg_signal_backend can/* REPLACED */ ''t signal superusers
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE OR REPLACE FUNCTION terminate_nothrow(pid int) RETURNS bool
	LANGUAGE plpgsql SECURITY DEFINER SET client_min_messages = error AS $$
BEGIN
	RETURN pg_terminate_backend($1);
EXCEPTION WHEN OTHERS THEN
	RETURN false;
END$$;
RESULT:
	[]

-----------
QUERY:

ALTER FUNCTION terminate_nothrow OWNER TO pg_signal_backend;
RESULT:
	[]

-----------
QUERY:

SELECT backend_type FROM pg_stat_activity
WHERE CASE WHEN COALESCE(usesysid, 10) = 10 THEN terminate_nothrow(pid) END;
RESULT:
	[]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- test pg_database_owner
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

GRANT pg_database_owner TO regress_priv_user1;
RESULT:
	ERROR - role "pg_database_owner" cannot have explicit members


-----------
QUERY:

GRANT regress_priv_user1 TO pg_database_owner;
RESULT:
	ERROR - role "pg_database_owner" cannot be a member of any role


-----------
QUERY:

CREATE TABLE datdba_only ();
RESULT:
	[]

-----------
QUERY:

ALTER TABLE datdba_only OWNER TO pg_database_owner;
RESULT:
	[]

-----------
QUERY:

REVOKE DELETE ON datdba_only FROM pg_database_owner;
RESULT:
	[]

-----------
QUERY:

SELECT
	pg_has_role('regress_priv_user1', 'pg_database_owner', 'USAGE') as priv,
	pg_has_role('regress_priv_user1', 'pg_database_owner', 'MEMBER') as mem,
	pg_has_role('regress_priv_user1', 'pg_database_owner',
				'MEMBER WITH ADMIN OPTION') as admin;
RESULT:
	[(False, False, False)]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:

DO $$BEGIN EXECUTE format(
	'ALTER DATABASE %I OWNER TO regress_priv_group2', current_catalog); END$$;
RESULT:
	[]

-----------
QUERY:

SELECT
	pg_has_role('regress_priv_user1', 'pg_database_owner', 'USAGE') as priv,
	pg_has_role('regress_priv_user1', 'pg_database_owner', 'MEMBER') as mem,
	pg_has_role('regress_priv_user1', 'pg_database_owner',
				'MEMBER WITH ADMIN OPTION') as admin;
RESULT:
	[(True, True, False)]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

TABLE information_schema.enabled_roles ORDER BY role_name COLLATE "C";
RESULT:
	[('pg_database_owner',), ('regress_priv_group2',), ('regress_priv_user1',)]

-----------
QUERY:

TABLE information_schema.applicable_roles ORDER BY role_name COLLATE "C";
RESULT:
	[('regress_priv_group2', 'pg_database_owner', 'NO'), ('regress_priv_user1', 'regress_priv_group2', 'NO')]

-----------
QUERY:

INSERT INTO datdba_only DEFAULT VALUES;
RESULT:
	[]

-----------
QUERY:

SAVEPOINT q;
RESULT:
	[]

-----------
QUERY:
 DELETE FROM datdba_only;
RESULT:
	ERROR - permission denied for table datdba_only


-----------
QUERY:
 ROLLBACK TO q;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

TABLE information_schema.enabled_roles;
RESULT:
	[('regress_priv_user2',)]

-----------
QUERY:

INSERT INTO datdba_only DEFAULT VALUES;
RESULT:
	ERROR - permission denied for table datdba_only


-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


-- test default ACLs
-- \c -

CREATE SCHEMA testns;
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON SCHEMA testns TO regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE testns.acltest1 (x int);
RESULT:
	[]

-----------
QUERY:

SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no

-- placeholder for test with duplicated schema and role names
ALTER DEFAULT PRIVILEGES IN SCHEMA testns,testns GRANT SELECT ON TABLES TO public,public;
RESULT:
	[]

-----------
QUERY:


SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no

DROP TABLE testns.acltest1;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE testns.acltest1 (x int);
RESULT:
	[]

-----------
QUERY:


SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no

ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT INSERT ON TABLES TO regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


DROP TABLE testns.acltest1;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE testns.acltest1 (x int);
RESULT:
	[]

-----------
QUERY:


SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes

ALTER DEFAULT PRIVILEGES IN SCHEMA testns REVOKE INSERT ON TABLES FROM regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


DROP TABLE testns.acltest1;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE testns.acltest1 (x int);
RESULT:
	[]

-----------
QUERY:


SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'SELECT');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes
SELECT has_table_privilege('regress_priv_user1', 'testns.acltest1', 'INSERT');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no

ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE EXECUTE ON FUNCTIONS FROM public;
RESULT:
	[]

-----------
QUERY:


ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON SCHEMAS TO regress_priv_user2;
RESULT:
	ERROR - cannot use IN SCHEMA clause when using GRANT/REVOKE ON SCHEMAS


-----------
QUERY:
 -- error

-- Test makeaclitem()
SELECT makeaclitem('regress_priv_user1'::regrole, 'regress_priv_user2'::regrole,
	'SELECT', TRUE);
RESULT:
	[('regress_priv_user1=r*/regress_priv_user2',)]

-----------
QUERY:
  -- single privilege
SELECT makeaclitem('regress_priv_user1'::regrole, 'regress_priv_user2'::regrole,
	'SELECT, INSERT,  UPDATE , DELETE  ', FALSE);
RESULT:
	[('regress_priv_user1=arwd/regress_priv_user2',)]

-----------
QUERY:
  -- multiple privileges
SELECT makeaclitem('regress_priv_user1'::regrole, 'regress_priv_user2'::regrole,
	'SELECT, fake_privilege', FALSE);
RESULT:
	ERROR - unrecognized privilege type: "fake_privilege"


-----------
QUERY:
  -- error

-- Test non-throwing aclitem I/O
SELECT pg_input_is_valid('regress_priv_user1=r/regress_priv_user2', 'aclitem');
RESULT:
	[(True,)]

-----------
QUERY:

SELECT pg_input_is_valid('regress_priv_user1=r/', 'aclitem');
RESULT:
	[(False,)]

-----------
QUERY:

SELECT * FROM pg_input_error_info('regress_priv_user1=r/', 'aclitem');
RESULT:
	[('a name must follow the "/" sign', None, None, '22P02')]

-----------
QUERY:

SELECT pg_input_is_valid('regress_priv_user1=r/regress_no_such_user', 'aclitem');
RESULT:
	[(False,)]

-----------
QUERY:

SELECT * FROM pg_input_error_info('regress_priv_user1=r/regress_no_such_user', 'aclitem');
RESULT:
	[('role "regress_no_such_user" does not exist', None, None, '42704')]

-----------
QUERY:

SELECT pg_input_is_valid('regress_priv_user1=rY', 'aclitem');
RESULT:
	[(False,)]

-----------
QUERY:

SELECT * FROM pg_input_error_info('regress_priv_user1=rY', 'aclitem');
RESULT:
	[('invalid mode character: must be one of "arwdDxtXUCTcsAm"', None, None, '22P02')]

-----------
QUERY:


--
-- Testing blanket default grants is very hazardous since it might change
-- the privileges attached to objects created by concurrent regression tests.
-- To avoid that, be sure to revoke the privileges again before committing.
--
BEGIN;
RESULT:
	[]

-----------
QUERY:


ALTER DEFAULT PRIVILEGES GRANT USAGE ON SCHEMAS TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


CREATE SCHEMA testns2;
RESULT:
	[]

-----------
QUERY:


SELECT has_schema_privilege('regress_priv_user2', 'testns2', 'USAGE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes
SELECT has_schema_privilege('regress_priv_user6', 'testns2', 'USAGE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes
SELECT has_schema_privilege('regress_priv_user2', 'testns2', 'CREATE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no

ALTER DEFAULT PRIVILEGES REVOKE USAGE ON SCHEMAS FROM regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


CREATE SCHEMA testns3;
RESULT:
	[]

-----------
QUERY:


SELECT has_schema_privilege('regress_priv_user2', 'testns3', 'USAGE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no
SELECT has_schema_privilege('regress_priv_user2', 'testns3', 'CREATE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no

ALTER DEFAULT PRIVILEGES GRANT ALL ON SCHEMAS TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


CREATE SCHEMA testns4;
RESULT:
	[]

-----------
QUERY:


SELECT has_schema_privilege('regress_priv_user2', 'testns4', 'USAGE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes
SELECT has_schema_privilege('regress_priv_user2', 'testns4', 'CREATE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes

ALTER DEFAULT PRIVILEGES REVOKE ALL ON SCHEMAS FROM regress_priv_user2;
RESULT:
	[]

-----------
QUERY:


COMMIT;
RESULT:
	[]

-----------
QUERY:


-- Test for DROP OWNED BY with shared dependencies.  This is done in a
-- separate, rollbacked, transaction to avoid any trouble with other
-- regression sessions.
BEGIN;
RESULT:
	[]

-----------
QUERY:

ALTER DEFAULT PRIVILEGES GRANT ALL ON FUNCTIONS TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

ALTER DEFAULT PRIVILEGES GRANT ALL ON SCHEMAS TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

ALTER DEFAULT PRIVILEGES GRANT ALL ON SEQUENCES TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

ALTER DEFAULT PRIVILEGES GRANT ALL ON TABLES TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

ALTER DEFAULT PRIVILEGES GRANT ALL ON TYPES TO regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

SELECT count(*) FROM pg_shdepend
  WHERE deptype = 'a' AND
        refobjid = 'regress_priv_user2'::regrole AND
	classid = 'pg_default_acl'::regclass;
RESULT:
	[(5,)]

-----------
QUERY:

DROP OWNED BY regress_priv_user2, regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

SELECT count(*) FROM pg_shdepend
  WHERE deptype = 'a' AND
        refobjid = 'regress_priv_user2'::regrole AND
	classid = 'pg_default_acl'::regclass;
RESULT:
	[(0,)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


CREATE SCHEMA testns5;
RESULT:
	[]

-----------
QUERY:


SELECT has_schema_privilege('regress_priv_user2', 'testns5', 'USAGE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no
SELECT has_schema_privilege('regress_priv_user2', 'testns5', 'CREATE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no

SET ROLE regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
RESULT:
	[]

-----------
QUERY:

CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
RESULT:
	[]

-----------
QUERY:

CREATE PROCEDURE testns.bar() AS 'select 1' LANGUAGE sql;
RESULT:
	[]

-----------
QUERY:


SELECT has_function_privilege('regress_priv_user2', 'testns.foo()', 'EXECUTE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no
SELECT has_function_privilege('regress_priv_user2', 'testns.agg1(int)', 'EXECUTE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no
SELECT has_function_privilege('regress_priv_user2', 'testns.bar()', 'EXECUTE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no

ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT EXECUTE ON ROUTINES to public;
RESULT:
	[]

-----------
QUERY:


DROP FUNCTION testns.foo();
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION testns.foo() RETURNS int AS 'select 1' LANGUAGE sql;
RESULT:
	[]

-----------
QUERY:

DROP AGGREGATE testns.agg1(int);
RESULT:
	[]

-----------
QUERY:

CREATE AGGREGATE testns.agg1(int) (sfunc = int4pl, stype = int4);
RESULT:
	[]

-----------
QUERY:

DROP PROCEDURE testns.bar();
RESULT:
	[]

-----------
QUERY:

CREATE PROCEDURE testns.bar() AS 'select 1' LANGUAGE sql;
RESULT:
	[]

-----------
QUERY:


SELECT has_function_privilege('regress_priv_user2', 'testns.foo()', 'EXECUTE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes
SELECT has_function_privilege('regress_priv_user2', 'testns.agg1(int)', 'EXECUTE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes
SELECT has_function_privilege('regress_priv_user2', 'testns.bar()', 'EXECUTE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes (counts as function here)

DROP FUNCTION testns.foo();
RESULT:
	[]

-----------
QUERY:

DROP AGGREGATE testns.agg1(int);
RESULT:
	[]

-----------
QUERY:

DROP PROCEDURE testns.bar();
RESULT:
	[]

-----------
QUERY:


ALTER DEFAULT PRIVILEGES FOR ROLE regress_priv_user1 REVOKE USAGE ON TYPES FROM public;
RESULT:
	[]

-----------
QUERY:


CREATE DOMAIN testns.priv_testdomain1 AS int;
RESULT:
	[]

-----------
QUERY:


SELECT has_type_privilege('regress_priv_user2', 'testns.priv_testdomain1', 'USAGE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- no

ALTER DEFAULT PRIVILEGES IN SCHEMA testns GRANT USAGE ON TYPES to public;
RESULT:
	[]

-----------
QUERY:


DROP DOMAIN testns.priv_testdomain1;
RESULT:
	[]

-----------
QUERY:

CREATE DOMAIN testns.priv_testdomain1 AS int;
RESULT:
	[]

-----------
QUERY:


SELECT has_type_privilege('regress_priv_user2', 'testns.priv_testdomain1', 'USAGE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- yes

DROP DOMAIN testns.priv_testdomain1;
RESULT:
	[]

-----------
QUERY:


RESET ROLE;
RESULT:
	[]

-----------
QUERY:


SELECT count(*)
  FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid
  WHERE nspname = 'testns';
RESULT:
	[(3,)]

-----------
QUERY:


DROP SCHEMA testns CASCADE;
RESULT:
	[]

-----------
QUERY:

DROP SCHEMA testns2 CASCADE;
RESULT:
	[]

-----------
QUERY:

DROP SCHEMA testns3 CASCADE;
RESULT:
	[]

-----------
QUERY:

DROP SCHEMA testns4 CASCADE;
RESULT:
	[]

-----------
QUERY:

DROP SCHEMA testns5 CASCADE;
RESULT:
	[]

-----------
QUERY:


SELECT d.*     -- check that entries went away
  FROM pg_default_acl d LEFT JOIN pg_namespace n ON defaclnamespace = n.oid
  WHERE nspname IS NULL AND defaclnamespace != 0;
RESULT:
	[]

-----------
QUERY:



-- Grant on all objects of given type in a schema
-- \c -

CREATE SCHEMA testns;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE testns.t1 (f1 int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE testns.t2 (f1 int);
RESULT:
	[]

-----------
QUERY:


SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT');
RESULT:
	[(False,)]

-----------
QUERY:
 -- false

GRANT ALL ON ALL TABLES IN SCHEMA testns TO regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT');
RESULT:
	[(True,)]

-----------
QUERY:
 -- true
SELECT has_table_privilege('regress_priv_user1', 'testns.t2', 'SELECT');
RESULT:
	[(True,)]

-----------
QUERY:
 -- true

REVOKE ALL ON ALL TABLES IN SCHEMA testns FROM regress_priv_user1;
RESULT:
	[]

-----------
QUERY:


SELECT has_table_privilege('regress_priv_user1', 'testns.t1', 'SELECT');
RESULT:
	[(False,)]

-----------
QUERY:
 -- false
SELECT has_table_privilege('regress_priv_user1', 'testns.t2', 'SELECT');
RESULT:
	[(False,)]

-----------
QUERY:
 -- false

CREATE FUNCTION testns.priv_testfunc(int) RETURNS int AS 'select 3 * $1;
RESULT:
	ERROR - unterminated quoted string at or near "'select 3 * $1;"
LINE 3: ...FUNCTION testns.priv_testfunc(int) RETURNS int AS 'select 3 ...
                                                             ^


-----------
QUERY:
' LANGUAGE sql;
RESULT:
	ERROR - unterminated quoted string at or near "' LANGUAGE sql;"
LINE 1: ' LANGUAGE sql;
        ^


-----------
QUERY:

CREATE AGGREGATE testns.priv_testagg(int) (sfunc = int4pl, stype = int4);
RESULT:
	[]

-----------
QUERY:

CREATE PROCEDURE testns.priv_testproc(int) AS 'select 3' LANGUAGE sql;
RESULT:
	[]

-----------
QUERY:


SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE');
RESULT:
	ERROR - function "testns.priv_testfunc(int)" does not exist


-----------
QUERY:
 -- true by default
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- true by default
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- true by default

REVOKE ALL ON ALL FUNCTIONS IN SCHEMA testns FROM PUBLIC;
RESULT:
	[]

-----------
QUERY:


SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE');
RESULT:
	ERROR - function "testns.priv_testfunc(int)" does not exist


-----------
QUERY:
 -- false
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- false
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- still true, not a function

REVOKE ALL ON ALL PROCEDURES IN SCHEMA testns FROM PUBLIC;
RESULT:
	[]

-----------
QUERY:


SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE');
RESULT:
	[(False,)]

-----------
QUERY:
 -- now false

GRANT ALL ON ALL ROUTINES IN SCHEMA testns TO PUBLIC;
RESULT:
	[]

-----------
QUERY:


SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testfunc(int)', 'EXECUTE');
RESULT:
	ERROR - function "testns.priv_testfunc(int)" does not exist


-----------
QUERY:
 -- true
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testagg(int)', 'EXECUTE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- true
SELECT has_function_privilege('regress_priv_user1', 'testns.priv_testproc(int)', 'EXECUTE');
RESULT:
	[(True,)]

-----------
QUERY:
 -- true

DROP SCHEMA testns CASCADE;
RESULT:
	[]

-----------
QUERY:



-- Change owner of the schema & and rename of new schema owner
-- \c -

CREATE ROLE regress_schemauser1 superuser login;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_schemauser2 superuser login;
RESULT:
	ERROR - role "regress_schemauser2" already exists


-----------
QUERY:


SET SESSION ROLE regress_schemauser1;
RESULT:
	[]

-----------
QUERY:

CREATE SCHEMA testns;
RESULT:
	[]

-----------
QUERY:


SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
RESULT:
	[('testns', 'regress_schemauser1')]

-----------
QUERY:


ALTER SCHEMA testns OWNER TO regress_schemauser2;
RESULT:
	[]

-----------
QUERY:

ALTER ROLE regress_schemauser2 RENAME TO regress_schemauser_renamed;
RESULT:
	ERROR - role "regress_schemauser_renamed" already exists


-----------
QUERY:

SELECT nspname, rolname FROM pg_namespace, pg_roles WHERE pg_namespace.nspname = 'testns' AND pg_namespace.nspowner = pg_roles.oid;
RESULT:
	[('testns', 'regress_schemauser2')]

-----------
QUERY:


set session role regress_schemauser_renamed;
RESULT:
	[]

-----------
QUERY:

DROP SCHEMA testns CASCADE;
RESULT:
	[]

-----------
QUERY:


-- clean up
-- \c -

DROP ROLE regress_schemauser1;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_schemauser_renamed;
RESULT:
	ERROR - current user cannot be dropped


-----------
QUERY:



-- test that dependent privileges are revoked (or not) properly
-- \c -

set session role regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

create table dep_priv_test (a int);
RESULT:
	[]

-----------
QUERY:

grant select on dep_priv_test to regress_priv_user2 with grant option;
RESULT:
	[]

-----------
QUERY:

grant select on dep_priv_test to regress_priv_user3 with grant option;
RESULT:
	[]

-----------
QUERY:

set session role regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

grant select on dep_priv_test to regress_priv_user4 with grant option;
RESULT:
	[]

-----------
QUERY:

set session role regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

grant select on dep_priv_test to regress_priv_user4 with grant option;
RESULT:
	[]

-----------
QUERY:

set session role regress_priv_user4;
RESULT:
	[]

-----------
QUERY:

grant select on dep_priv_test to regress_priv_user5;
RESULT:
	[]

-----------
QUERY:

-- \dp dep_priv_test
set session role regress_priv_user2;
RESULT:
	[]

-----------
QUERY:

revoke select on dep_priv_test from regress_priv_user4 cascade;
RESULT:
	[]

-----------
QUERY:

-- \dp dep_priv_test
set session role regress_priv_user3;
RESULT:
	[]

-----------
QUERY:

revoke select on dep_priv_test from regress_priv_user4 cascade;
RESULT:
	[]

-----------
QUERY:

-- \dp dep_priv_test
set session role regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

drop table dep_priv_test;
RESULT:
	[]

-----------
QUERY:



-- clean up

-- \c

drop sequence x_seq;
RESULT:
	ERROR - must be owner of sequence x_seq


-----------
QUERY:


DROP AGGREGATE priv_testagg1(int);
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION priv_testfunc2(int);
RESULT:
	ERROR - function priv_testfunc2(integer) does not exist


-----------
QUERY:

DROP FUNCTION priv_testfunc4(boolean);
RESULT:
	ERROR - function priv_testfunc4(boolean) does not exist


-----------
QUERY:

DROP PROCEDURE priv_testproc1(int);
RESULT:
	ERROR - procedure priv_testproc1(integer) does not exist


-----------
QUERY:


DROP VIEW atestv0;
RESULT:
	ERROR - must be owner of view atestv0


-----------
QUERY:

DROP VIEW atestv1;
RESULT:
	ERROR - must be owner of view atestv1


-----------
QUERY:

DROP VIEW atestv2;
RESULT:
	ERROR - must be owner of view atestv2


-----------
QUERY:

-- this should cascade to drop atestv4
DROP VIEW atestv3 CASCADE;
RESULT:
	ERROR - must be owner of view atestv3


-----------
QUERY:

-- this should complain /* REPLACED */ ''does not exist/* REPLACED */ ''
DROP VIEW atestv4;
RESULT:
	ERROR - must be owner of view atestv4


-----------
QUERY:


DROP TABLE atest1;
RESULT:
	ERROR - cannot drop table atest1 because other objects depend on it
DETAIL:  view atestv1 depends on table atest1
HINT:  Use DROP ... CASCADE to drop the dependent objects too.


-----------
QUERY:

DROP TABLE atest2;
RESULT:
	ERROR - cannot drop table atest2 because other objects depend on it
DETAIL:  view atestv2 depends on table atest2
HINT:  Use DROP ... CASCADE to drop the dependent objects too.


-----------
QUERY:

DROP TABLE atest3;
RESULT:
	ERROR - must be owner of table atest3


-----------
QUERY:

DROP TABLE atest4;
RESULT:
	[]

-----------
QUERY:

DROP TABLE atest5;
RESULT:
	[]

-----------
QUERY:

DROP TABLE atest6;
RESULT:
	[]

-----------
QUERY:

DROP TABLE atestc;
RESULT:
	[]

-----------
QUERY:

DROP TABLE atestp1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE atestp2;
RESULT:
	[]

-----------
QUERY:


SELECT lo_unlink(oid) FROM pg_largeobject_metadata WHERE oid >= 1000 AND oid < 3000 ORDER BY oid;
RESULT:
	ERROR - must be owner of large object 2001


-----------
QUERY:


DROP GROUP regress_priv_group1;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:

DROP GROUP regress_priv_group2;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:


-- these are needed to clean up permissions
REVOKE USAGE ON LANGUAGE sql FROM regress_priv_user1;
RESULT:
	[]

-----------
QUERY:

DROP OWNED BY regress_priv_user1;
RESULT:
	ERROR - cannot drop desired object(s) because other objects depend on them
DETAIL:  view atestv1 depends on table atest1
view atestv2 depends on table atest2
HINT:  Use DROP ... CASCADE to drop the dependent objects too.


-----------
QUERY:


DROP USER regress_priv_user1;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:

DROP USER regress_priv_user2;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:

DROP USER regress_priv_user3;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:

DROP USER regress_priv_user4;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:

DROP USER regress_priv_user5;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:

DROP USER regress_priv_user6;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:

DROP USER regress_priv_user7;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:

DROP USER regress_priv_user8;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:
 -- does not exist


-- permissions with LOCK TABLE
CREATE USER regress_locktable_user;
RESULT:
	ERROR - permission denied to create role
DETAIL:  Only roles with the CREATEROLE attribute may create roles.


-----------
QUERY:

CREATE TABLE lock_table (a int);
RESULT:
	[]

-----------
QUERY:


-- LOCK TABLE and SELECT permission
GRANT SELECT ON lock_table TO regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

SET SESSION AUTHORIZATION regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS SHARE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
COMMIT;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ROW EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should fail
ROLLBACK;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should fail
ROLLBACK;
RESULT:
	[]

-----------
QUERY:

-- \c
REVOKE SELECT ON lock_table FROM regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:


-- LOCK TABLE and INSERT permission
GRANT INSERT ON lock_table TO regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

SET SESSION AUTHORIZATION regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS SHARE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
ROLLBACK;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ROW EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
COMMIT;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should fail
ROLLBACK;
RESULT:
	[]

-----------
QUERY:

-- \c
REVOKE INSERT ON lock_table FROM regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:


-- LOCK TABLE and UPDATE permission
GRANT UPDATE ON lock_table TO regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

SET SESSION AUTHORIZATION regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS SHARE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
ROLLBACK;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ROW EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
COMMIT;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
COMMIT;
RESULT:
	[]

-----------
QUERY:

-- \c
REVOKE UPDATE ON lock_table FROM regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:


-- LOCK TABLE and DELETE permission
GRANT DELETE ON lock_table TO regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

SET SESSION AUTHORIZATION regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS SHARE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
ROLLBACK;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ROW EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
COMMIT;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
COMMIT;
RESULT:
	[]

-----------
QUERY:

-- \c
REVOKE DELETE ON lock_table FROM regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:


-- LOCK TABLE and TRUNCATE permission
GRANT TRUNCATE ON lock_table TO regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

SET SESSION AUTHORIZATION regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS SHARE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
ROLLBACK;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ROW EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
COMMIT;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
COMMIT;
RESULT:
	[]

-----------
QUERY:

-- \c
REVOKE TRUNCATE ON lock_table FROM regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:


-- LOCK TABLE and MAINTAIN permission
GRANT MAINTAIN ON lock_table TO regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

SET SESSION AUTHORIZATION regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS SHARE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
ROLLBACK;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ROW EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
COMMIT;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

LOCK TABLE lock_table IN ACCESS EXCLUSIVE MODE;
RESULT:
	[]

-----------
QUERY:
 -- should pass
COMMIT;
RESULT:
	[]

-----------
QUERY:

-- \c
REVOKE MAINTAIN ON lock_table FROM regress_locktable_user;
RESULT:
	ERROR - role "regress_locktable_user" does not exist


-----------
QUERY:


-- clean up
DROP TABLE lock_table;
RESULT:
	[]

-----------
QUERY:

DROP USER regress_locktable_user;
RESULT:
	ERROR - permission denied to drop role
DETAIL:  Only roles with the CREATEROLE attribute and the ADMIN option on the target roles may drop roles.


-----------
QUERY:


-- test to check privileges of system views pg_shmem_allocations and
-- pg_backend_memory_contexts.

-- switch to superuser
-- \c -

CREATE ROLE regress_readallstats;
RESULT:
	ERROR - permission denied to create role
DETAIL:  Only roles with the CREATEROLE attribute may create roles.


-----------
QUERY:


SELECT has_table_privilege('regress_readallstats','pg_backend_memory_contexts','SELECT');
RESULT:
	ERROR - role "regress_readallstats" does not exist


-----------
QUERY:
 -- no
SELECT has_table_privilege('regress_readallstats','pg_shmem_allocations','SELECT');
RESULT:
	ERROR - role "regress_readallstats" does not exist


-----------
QUERY:
 -- no

GRANT pg_read_all_stats TO regress_readallstats;
RESULT:
	ERROR - role "regress_readallstats" does not exist


-----------
QUERY:


SELECT has_table_privilege('regress_readallstats','pg_backend_memory_contexts','SELECT');
RESULT:
	ERROR - role "regress_readallstats" does not exist


-----------
QUERY:
 -- yes
SELECT has_table_privilege('regress_readallstats','pg_shmem_allocations','SELECT');
RESULT:
	ERROR - role "regress_readallstats" does not exist


-----------
QUERY:
 -- yes

-- run query to ensure that functions within views can be executed
SET ROLE regress_readallstats;
RESULT:
	ERROR - role "regress_readallstats" does not exist


-----------
QUERY:

SELECT COUNT(*) >= 0 AS ok FROM pg_backend_memory_contexts;
RESULT:
	ERROR - permission denied for view pg_backend_memory_contexts


-----------
QUERY:

SELECT COUNT(*) >= 0 AS ok FROM pg_shmem_allocations;
RESULT:
	ERROR - permission denied for view pg_shmem_allocations


-----------
QUERY:

RESET ROLE;
RESULT:
	[]

-----------
QUERY:


-- clean up
DROP ROLE regress_readallstats;
RESULT:
	ERROR - role "regress_readallstats" does not exist


-----------
QUERY:


-- test role grantor machinery
CREATE ROLE regress_group;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_group_direct_manager;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_group_indirect_manager;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_group_member;
RESULT:
	[]

-----------
QUERY:


GRANT regress_group TO regress_group_direct_manager WITH INHERIT FALSE, ADMIN TRUE;
RESULT:
	[]

-----------
QUERY:

GRANT regress_group_direct_manager TO regress_group_indirect_manager;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_group_direct_manager;
RESULT:
	[]

-----------
QUERY:

GRANT regress_group TO regress_group_member;
RESULT:
	[]

-----------
QUERY:

SELECT member::regrole::text, CASE WHEN grantor = 10 THEN 'BOOTSTRAP SUPERUSER' ELSE grantor::regrole::text END FROM pg_auth_members WHERE roleid = 'regress_group'::regrole ORDER BY 1, 2;
RESULT:
	[('regress_group_direct_manager', 'BOOTSTRAP SUPERUSER'), ('regress_group_member', 'regress_group_direct_manager')]

-----------
QUERY:

REVOKE regress_group FROM regress_group_member;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_group_indirect_manager;
RESULT:
	[]

-----------
QUERY:

GRANT regress_group TO regress_group_member;
RESULT:
	[]

-----------
QUERY:

SELECT member::regrole::text, CASE WHEN grantor = 10 THEN 'BOOTSTRAP SUPERUSER' ELSE grantor::regrole::text END FROM pg_auth_members WHERE roleid = 'regress_group'::regrole ORDER BY 1, 2;
RESULT:
	[('regress_group_direct_manager', 'BOOTSTRAP SUPERUSER'), ('regress_group_member', 'regress_group_direct_manager')]

-----------
QUERY:

REVOKE regress_group FROM regress_group_member;
RESULT:
	[]

-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_group;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_group_direct_manager;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_group_indirect_manager;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_group_member;
RESULT:
	[]

-----------
QUERY:


-- test SET and INHERIT options with object ownership changes
CREATE ROLE regress_roleoption_protagonist;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_roleoption_donor;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_roleoption_recipient;
RESULT:
	[]

-----------
QUERY:

CREATE SCHEMA regress_roleoption;
RESULT:
	[]

-----------
QUERY:

GRANT CREATE, USAGE ON SCHEMA regress_roleoption TO PUBLIC;
RESULT:
	[]

-----------
QUERY:

GRANT regress_roleoption_donor TO regress_roleoption_protagonist WITH INHERIT TRUE, SET FALSE;
RESULT:
	[]

-----------
QUERY:

GRANT regress_roleoption_recipient TO regress_roleoption_protagonist WITH INHERIT FALSE, SET TRUE;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_roleoption_protagonist;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE regress_roleoption.t1 (a int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE regress_roleoption.t2 (a int);
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_roleoption_donor;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE regress_roleoption.t3 (a int);
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_roleoption_recipient;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE regress_roleoption.t4 (a int);
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_roleoption_protagonist;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE regress_roleoption.t1 OWNER TO regress_roleoption_donor;
RESULT:
	ERROR - must be able to SET ROLE "regress_roleoption_donor"


-----------
QUERY:
 -- fails, can/* REPLACED */ ''t be come donor
ALTER TABLE regress_roleoption.t2 OWNER TO regress_roleoption_recipient;
RESULT:
	[]

-----------
QUERY:
 -- works
ALTER TABLE regress_roleoption.t3 OWNER TO regress_roleoption_protagonist;
RESULT:
	[]

-----------
QUERY:
 -- works
ALTER TABLE regress_roleoption.t4 OWNER TO regress_roleoption_protagonist;
RESULT:
	ERROR - must be owner of table t4


-----------
QUERY:
 -- fails, we don/* REPLACED */ ''t inherit from recipient
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

DROP TABLE regress_roleoption.t1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE regress_roleoption.t2;
RESULT:
	[]

-----------
QUERY:

DROP TABLE regress_roleoption.t3;
RESULT:
	[]

-----------
QUERY:

DROP TABLE regress_roleoption.t4;
RESULT:
	[]

-----------
QUERY:

DROP SCHEMA regress_roleoption;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_roleoption_protagonist;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_roleoption_donor;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_roleoption_recipient;
RESULT:
	[]

-----------
QUERY:


-- MAINTAIN
CREATE ROLE regress_no_maintain;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_maintain;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_maintain_all IN ROLE pg_maintain;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE maintain_test (a INT);
RESULT:
	[]

-----------
QUERY:

CREATE INDEX ON maintain_test (a);
RESULT:
	[]

-----------
QUERY:

GRANT MAINTAIN ON maintain_test TO regress_maintain;
RESULT:
	[]

-----------
QUERY:

CREATE MATERIALIZED VIEW refresh_test AS SELECT 1;
RESULT:
	[]

-----------
QUERY:

GRANT MAINTAIN ON refresh_test TO regress_maintain;
RESULT:
	[]

-----------
QUERY:

CREATE SCHEMA reindex_test;
RESULT:
	[]

-----------
QUERY:


-- negative tests /* REPLACED */ , should fail
SET ROLE regress_no_maintain;
RESULT:
	[]

-----------
QUERY:

VACUUM maintain_test;
RESULT:
	[]

-----------
QUERY:

ANALYZE maintain_test;
RESULT:
	[]

-----------
QUERY:

VACUUM (ANALYZE) maintain_test;
RESULT:
	[]

-----------
QUERY:

CLUSTER maintain_test USING maintain_test_a_idx;
RESULT:
	ERROR - permission denied for table maintain_test


-----------
QUERY:

REFRESH MATERIALIZED VIEW refresh_test;
RESULT:
	ERROR - permission denied for materialized view refresh_test


-----------
QUERY:

REINDEX TABLE maintain_test;
RESULT:
	ERROR - permission denied for table maintain_test


-----------
QUERY:

REINDEX INDEX maintain_test_a_idx;
RESULT:
	ERROR - permission denied for index maintain_test_a_idx


-----------
QUERY:

REINDEX SCHEMA reindex_test;
RESULT:
	ERROR - must be owner of schema reindex_test


-----------
QUERY:

RESET ROLE;
RESULT:
	[]

-----------
QUERY:


SET ROLE regress_maintain;
RESULT:
	[]

-----------
QUERY:

VACUUM maintain_test;
RESULT:
	[]

-----------
QUERY:

ANALYZE maintain_test;
RESULT:
	[]

-----------
QUERY:

VACUUM (ANALYZE) maintain_test;
RESULT:
	[]

-----------
QUERY:

CLUSTER maintain_test USING maintain_test_a_idx;
RESULT:
	[]

-----------
QUERY:

REFRESH MATERIALIZED VIEW refresh_test;
RESULT:
	[]

-----------
QUERY:

REINDEX TABLE maintain_test;
RESULT:
	[]

-----------
QUERY:

REINDEX INDEX maintain_test_a_idx;
RESULT:
	[]

-----------
QUERY:

REINDEX SCHEMA reindex_test;
RESULT:
	ERROR - must be owner of schema reindex_test


-----------
QUERY:

RESET ROLE;
RESULT:
	[]

-----------
QUERY:


SET ROLE regress_maintain_all;
RESULT:
	[]

-----------
QUERY:

VACUUM maintain_test;
RESULT:
	[]

-----------
QUERY:

ANALYZE maintain_test;
RESULT:
	[]

-----------
QUERY:

VACUUM (ANALYZE) maintain_test;
RESULT:
	[]

-----------
QUERY:

CLUSTER maintain_test USING maintain_test_a_idx;
RESULT:
	[]

-----------
QUERY:

REFRESH MATERIALIZED VIEW refresh_test;
RESULT:
	[]

-----------
QUERY:

REINDEX TABLE maintain_test;
RESULT:
	[]

-----------
QUERY:

REINDEX INDEX maintain_test_a_idx;
RESULT:
	[]

-----------
QUERY:

REINDEX SCHEMA reindex_test;
RESULT:
	[]

-----------
QUERY:

RESET ROLE;
RESULT:
	[]

-----------
QUERY:


DROP TABLE maintain_test;
RESULT:
	[]

-----------
QUERY:

DROP MATERIALIZED VIEW refresh_test;
RESULT:
	[]

-----------
QUERY:

DROP SCHEMA reindex_test;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_no_maintain;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_maintain;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_maintain_all;
RESULT:
	[]
