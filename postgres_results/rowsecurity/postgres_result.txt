--
-- Test of Row-level security feature
--

-- Clean up in case a prior regression run failed

-- Suppress NOTICE messages when users/groups don''t exist
SET client_min_messages TO 'warning'


DROP USER IF EXISTS regress_rls_alice

DROP USER IF EXISTS regress_rls_bob

DROP USER IF EXISTS regress_rls_carol

DROP USER IF EXISTS regress_rls_dave

DROP USER IF EXISTS regress_rls_exempt_user

DROP ROLE IF EXISTS regress_rls_group1

DROP ROLE IF EXISTS regress_rls_group2


DROP SCHEMA IF EXISTS regress_rls_schema CASCADE


RESET client_min_messages


-- initial setup
CREATE USER regress_rls_alice NOLOGIN

CREATE USER regress_rls_bob NOLOGIN

CREATE USER regress_rls_carol NOLOGIN

CREATE USER regress_rls_dave NOLOGIN

CREATE USER regress_rls_exempt_user BYPASSRLS NOLOGIN

CREATE ROLE regress_rls_group1 NOLOGIN

CREATE ROLE regress_rls_group2 NOLOGIN


GRANT regress_rls_group1 TO regress_rls_bob

GRANT regress_rls_group2 TO regress_rls_carol


CREATE SCHEMA regress_rls_schema

GRANT ALL ON SCHEMA regress_rls_schema to public

SET search_path = regress_rls_schema


-- setup of malicious function
CREATE OR REPLACE FUNCTION f_leak(text) RETURNS bool
    COST 0.0000001 LANGUAGE plpgsql
    AS 'BEGIN RAISE NOTICE ''f_leak => %'', $1; RETURN true; END'

GRANT EXECUTE ON FUNCTION f_leak(text) TO public


-- BASIC Row-Level Security Scenario

SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE uaccount (
    pguser      name primary key,
    seclv       int
)

GRANT SELECT ON uaccount TO public

INSERT INTO uaccount VALUES
    ('regress_rls_alice', 99),
    ('regress_rls_bob', 1),
    ('regress_rls_carol', 2),
    ('regress_rls_dave', 3)


CREATE TABLE category (
    cid        int primary key,
    cname      text
)

GRANT ALL ON category TO public

INSERT INTO category VALUES
    (11, 'novel'),
    (22, 'science fiction'),
    (33, 'technology'),
    (44, 'manga')


CREATE TABLE document (
    did         int primary key,
    cid         int references category(cid),
    dlevel      int not null,
    dauthor     name,
    dtitle      text
)

GRANT ALL ON document TO public

INSERT INTO document VALUES
    ( 1, 11, 1, 'regress_rls_bob', 'my first novel'),
    ( 2, 11, 2, 'regress_rls_bob', 'my second novel'),
    ( 3, 22, 2, 'regress_rls_bob', 'my science fiction'),
    ( 4, 44, 1, 'regress_rls_bob', 'my first manga'),
    ( 5, 44, 2, 'regress_rls_bob', 'my second manga'),
    ( 6, 22, 1, 'regress_rls_carol', 'great science fiction'),
    ( 7, 33, 2, 'regress_rls_carol', 'great technology book'),
    ( 8, 44, 1, 'regress_rls_carol', 'great manga'),
    ( 9, 22, 1, 'regress_rls_dave', 'awesome science fiction'),
    (10, 33, 2, 'regress_rls_dave', 'awesome technology book')


ALTER TABLE document ENABLE ROW LEVEL SECURITY


-- user''s security level must be higher than or equal to document''s
CREATE POLICY p1 ON document AS PERMISSIVE
    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user))


-- try to create a policy of bogus type
CREATE POLICY p1 ON document AS UGLY
    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user))
ProgrammingError: 

-- try to create a policy of bogus type
CREATE POLICY p1 ON document AS UGLY
    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user))

unrecognized row security option "ugly"
LINE 4: CREATE POLICY p1 ON document AS UGLY
                                        ^
HINT:  Only PERMISSIVE or RESTRICTIVE policies are supported currently.



-- but Dave isn''t allowed to anything at cid 50 or above
-- this is to make sure that we sort the policies by name first
-- when applying WITH CHECK, a later INSERT by Dave should fail due
-- to p1r first
CREATE POLICY p2r ON document AS RESTRICTIVE TO regress_rls_dave
    USING (cid <> 44 AND cid < 50)


-- and Dave isn''t allowed to see manga documents
CREATE POLICY p1r ON document AS RESTRICTIVE TO regress_rls_dave
    USING (cid <> 44)


-- \dp
-- \d document
SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename = 'document' ORDER BY policyname
RESULT: 
	[('regress_rls_schema', 'document', 'p1', 'PERMISSIVE', ['public'], 'ALL', '(dlevel <= ( SELECT uaccount.seclv\n   FROM uaccount\n  WHERE (uaccount.pguser = CURRENT_USER)))', None), ('regress_rls_schema', 'document', 'p1r', 'RESTRICTIVE', ['regress_rls_dave'], 'ALL', '(cid <> 44)', None), ('regress_rls_schema', 'document', 'p2r', 'RESTRICTIVE', ['regress_rls_dave'], 'ALL', '((cid <> 44) AND (cid < 50))', None)]


-- viewpoint from regress_rls_bob
SET SESSION AUTHORIZATION regress_rls_bob

SET row_security TO ON

SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction')]

SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(11, 1, 1, 'regress_rls_bob', 'my first novel', 'novel'), (44, 4, 1, 'regress_rls_bob', 'my first manga', 'manga'), (22, 6, 1, 'regress_rls_carol', 'great science fiction', 'science fiction'), (44, 8, 1, 'regress_rls_carol', 'great manga', 'manga'), (22, 9, 1, 'regress_rls_dave', 'awesome science fiction', 'science fiction')]


-- try a sampled version
SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)
  WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(4, 44, 1, 'regress_rls_bob', 'my first manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction')]


-- viewpoint from regress_rls_carol
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book')]

SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(11, 1, 1, 'regress_rls_bob', 'my first novel', 'novel'), (11, 2, 2, 'regress_rls_bob', 'my second novel', 'novel'), (22, 3, 2, 'regress_rls_bob', 'my science fiction', 'science fiction'), (44, 4, 1, 'regress_rls_bob', 'my first manga', 'manga'), (44, 5, 2, 'regress_rls_bob', 'my second manga', 'manga'), (22, 6, 1, 'regress_rls_carol', 'great science fiction', 'science fiction'), (33, 7, 2, 'regress_rls_carol', 'great technology book', 'technology'), (44, 8, 1, 'regress_rls_carol', 'great manga', 'manga'), (22, 9, 1, 'regress_rls_dave', 'awesome science fiction', 'science fiction'), (33, 10, 2, 'regress_rls_dave', 'awesome technology book', 'technology')]


-- try a sampled version
SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)
  WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction')]


EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle)
RESULT: 
	[('Seq Scan on document',), ('  Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',), ('  InitPlan 1',), ('    ->  Index Scan using uaccount_pkey on uaccount',), ('          Index Cond: (pguser = CURRENT_USER)',)]

EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle)
RESULT: 
	[('Hash Join',), ('  Hash Cond: (category.cid = document.cid)',), ('  InitPlan 1',), ('    ->  Index Scan using uaccount_pkey on uaccount',), ('          Index Cond: (pguser = CURRENT_USER)',), ('  ->  Seq Scan on category',), ('  ->  Hash',), ('        ->  Seq Scan on document',), ('              Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',)]


-- viewpoint from regress_rls_dave
SET SESSION AUTHORIZATION regress_rls_dave

SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book')]

SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(11, 1, 1, 'regress_rls_bob', 'my first novel', 'novel'), (11, 2, 2, 'regress_rls_bob', 'my second novel', 'novel'), (22, 3, 2, 'regress_rls_bob', 'my science fiction', 'science fiction'), (22, 6, 1, 'regress_rls_carol', 'great science fiction', 'science fiction'), (33, 7, 2, 'regress_rls_carol', 'great technology book', 'technology'), (22, 9, 1, 'regress_rls_dave', 'awesome science fiction', 'science fiction'), (33, 10, 2, 'regress_rls_dave', 'awesome technology book', 'technology')]


EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle)
RESULT: 
	[('Seq Scan on document',), ('  Filter: ((cid <> 44) AND (cid <> 44) AND (cid < 50) AND (dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',), ('  InitPlan 1',), ('    ->  Index Scan using uaccount_pkey on uaccount',), ('          Index Cond: (pguser = CURRENT_USER)',)]

EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle)
RESULT: 
	[('Hash Join',), ('  Hash Cond: (category.cid = document.cid)',), ('  InitPlan 1',), ('    ->  Index Scan using uaccount_pkey on uaccount',), ('          Index Cond: (pguser = CURRENT_USER)',), ('  ->  Seq Scan on category',), ('  ->  Hash',), ('        ->  Seq Scan on document',), ('              Filter: ((cid <> 44) AND (cid <> 44) AND (cid < 50) AND (dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',)]


-- 44 would technically fail for both p2r and p1r, but we should get an error
-- back from p1r for this because it sorts first
INSERT INTO document VALUES (100, 44, 1, 'regress_rls_dave', 'testing sorting of policies')
ProgrammingError: 

-- 44 would technically fail for both p2r and p1r, but we should get an error
-- back from p1r for this because it sorts first
INSERT INTO document VALUES (100, 44, 1, 'regress_rls_dave', 'testing sorting of policies')

new row violates row-level security policy "p1r" for table "document"

 -- fail
-- Just to see a p2r error
INSERT INTO document VALUES (100, 55, 1, 'regress_rls_dave', 'testing sorting of policies')
ProgrammingError:  -- fail
-- Just to see a p2r error
INSERT INTO document VALUES (100, 55, 1, 'regress_rls_dave', 'testing sorting of policies')

new row violates row-level security policy "p2r" for table "document"

 -- fail

-- only owner can change policies
ALTER POLICY p1 ON document USING (true)
ProgrammingError:  -- fail

-- only owner can change policies
ALTER POLICY p1 ON document USING (true)

must be owner of table document

    --fail
DROP POLICY p1 ON document
ProgrammingError:     --fail
DROP POLICY p1 ON document

must be owner of relation document

                  --fail

SET SESSION AUTHORIZATION regress_rls_alice

ALTER POLICY p1 ON document USING (dauthor = current_user)


-- viewpoint from regress_rls_bob again
SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga')]

SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did
RESULT: 
	[(11, 1, 1, 'regress_rls_bob', 'my first novel', 'novel'), (11, 2, 2, 'regress_rls_bob', 'my second novel', 'novel'), (22, 3, 2, 'regress_rls_bob', 'my science fiction', 'science fiction'), (44, 4, 1, 'regress_rls_bob', 'my first manga', 'manga'), (44, 5, 2, 'regress_rls_bob', 'my second manga', 'manga')]


-- viewpoint from rls_regres_carol again
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga')]

SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did
RESULT: 
	[(22, 6, 1, 'regress_rls_carol', 'great science fiction', 'science fiction'), (33, 7, 2, 'regress_rls_carol', 'great technology book', 'technology'), (44, 8, 1, 'regress_rls_carol', 'great manga', 'manga')]


EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle)
RESULT: 
	[('Seq Scan on document',), ('  Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))',)]

EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle)
RESULT: 
	[('Nested Loop',), ('  ->  Seq Scan on document',), ('        Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))',), ('  ->  Index Scan using category_pkey on category',), ('        Index Cond: (cid = document.cid)',)]


-- interaction of FK/PK constraints
SET SESSION AUTHORIZATION regress_rls_alice

CREATE POLICY p2 ON category
    USING (CASE WHEN current_user = 'regress_rls_bob' THEN cid IN (11, 33)
           WHEN current_user = 'regress_rls_carol' THEN cid IN (22, 44)
           ELSE false END)


ALTER TABLE category ENABLE ROW LEVEL SECURITY


-- cannot delete PK referenced by invisible FK
SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel', 11, 'novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel', 11, 'novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction', None, None), (4, 44, 1, 'regress_rls_bob', 'my first manga', None, None), (5, 44, 2, 'regress_rls_bob', 'my second manga', None, None), (None, None, None, None, None, 33, 'technology')]

DELETE FROM category WHERE cid = 33
ERROR: 
DELETE FROM category WHERE cid = 33

update or delete on table "category" violates foreign key constraint "document_cid_fkey" on table "document"
DETAIL:  Key is still referenced from table "document".

    -- fails with FK violation

-- can insert FK referencing invisible PK
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid
RESULT: 
	[(6, 22, 1, 'regress_rls_carol', 'great science fiction', 22, 'science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book', None, None), (8, 44, 1, 'regress_rls_carol', 'great manga', 44, 'manga')]

INSERT INTO document VALUES (11, 33, 1, current_user, 'hoge')


-- UNIQUE or PRIMARY KEY constraint violation DOES reveal presence of row
SET SESSION AUTHORIZATION regress_rls_bob

INSERT INTO document VALUES (8, 44, 1, 'regress_rls_bob', 'my third manga')
ERROR: 
INSERT INTO document VALUES (8, 44, 1, 'regress_rls_bob', 'my third manga')

duplicate key value violates unique constraint "document_pkey"

 -- Must fail with unique violation, revealing presence of did we can''t see
SELECT * FROM document WHERE did = 8
RESULT: 
	[]
 -- and confirm we can''t see it

-- RLS policies are checked before constraints
INSERT INTO document VALUES (8, 44, 1, 'regress_rls_carol', 'my third manga')
ProgrammingError:  -- and confirm we can''t see it

-- RLS policies are checked before constraints
INSERT INTO document VALUES (8, 44, 1, 'regress_rls_carol', 'my third manga')

new row violates row-level security policy for table "document"

 -- Should fail with RLS check violation, not duplicate key violation
UPDATE document SET did = 8, dauthor = 'regress_rls_carol' WHERE did = 5
ProgrammingError:  -- Should fail with RLS check violation, not duplicate key violation
UPDATE document SET did = 8, dauthor = 'regress_rls_carol' WHERE did = 5

new row violates row-level security policy for table "document"

 -- Should fail with RLS check violation, not duplicate key violation

-- database superuser does bypass RLS policy when enabled
RESET SESSION AUTHORIZATION

SET row_security TO ON

SELECT * FROM document
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book'), (11, 33, 1, 'regress_rls_carol', 'hoge')]

SELECT * FROM category
RESULT: 
	[(11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga')]


-- database superuser does bypass RLS policy when disabled
RESET SESSION AUTHORIZATION

SET row_security TO OFF

SELECT * FROM document
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book'), (11, 33, 1, 'regress_rls_carol', 'hoge')]

SELECT * FROM category
RESULT: 
	[(11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga')]


-- database non-superuser with bypass privilege can bypass RLS policy when disabled
SET SESSION AUTHORIZATION regress_rls_exempt_user

SET row_security TO OFF

SELECT * FROM document
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book'), (11, 33, 1, 'regress_rls_carol', 'hoge')]

SELECT * FROM category
RESULT: 
	[(11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga')]


-- RLS policy does not apply to table owner when RLS enabled.
SET SESSION AUTHORIZATION regress_rls_alice

SET row_security TO ON

SELECT * FROM document
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book'), (11, 33, 1, 'regress_rls_carol', 'hoge')]

SELECT * FROM category
RESULT: 
	[(11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga')]


-- RLS policy does not apply to table owner when RLS disabled.
SET SESSION AUTHORIZATION regress_rls_alice

SET row_security TO OFF

SELECT * FROM document
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book'), (11, 33, 1, 'regress_rls_carol', 'hoge')]

SELECT * FROM category
RESULT: 
	[(11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga')]


--
-- Table inheritance and RLS policy
--
SET SESSION AUTHORIZATION regress_rls_alice


SET row_security TO ON


CREATE TABLE t1 (id int not null primary key, a int, junk1 text, b text)

ALTER TABLE t1 DROP COLUMN junk1
    -- just a disturbing factor
GRANT ALL ON t1 TO public


COPY t1 FROM stdin WITH 
ProgrammingError: 

COPY t1 FROM stdin WITH 

can't execute COPY FROM: use the copy_from() method instead

101	1	aba
102	2	bbb
103	3	ccc
104	4	dad
\.

CREATE TABLE t2 (c float) INHERITS (t1)
ProgrammingError: 
101	1	aba
102	2	bbb
103	3	ccc
104	4	dad
\.

CREATE TABLE t2 (c float) INHERITS (t1)

syntax error at or near "101"
LINE 2: 101 1 aba
        ^


GRANT ALL ON t2 TO public
ProgrammingError: 
GRANT ALL ON t2 TO public

relation "t2" does not exist



COPY t2 FROM stdin
ProgrammingError: 

COPY t2 FROM stdin

relation "t2" does not exist


201	1	abc	1.1
202	2	bcd	2.2
203	3	cde	3.3
204	4	def	4.4
\.

CREATE TABLE t3 (id int not null primary key, c text, b text, a int)
ProgrammingError: 
201	1	abc	1.1
202	2	bcd	2.2
203	3	cde	3.3
204	4	def	4.4
\.

CREATE TABLE t3 (id int not null primary key, c text, b text, a int)

syntax error at or near "201"
LINE 2: 201 1 abc 1.1
        ^


ALTER TABLE t3 INHERIT t1
ProgrammingError: 
ALTER TABLE t3 INHERIT t1

relation "t3" does not exist


GRANT ALL ON t3 TO public
ProgrammingError: 
GRANT ALL ON t3 TO public

relation "t3" does not exist



COPY t3(id, a,b,c) FROM stdin
ProgrammingError: 

COPY t3(id, a,b,c) FROM stdin

relation "t3" does not exist


301	1	xxx	X
302	2	yyy	Y
303	3	zzz	Z
\.

CREATE POLICY p1 ON t1 FOR ALL TO PUBLIC USING (a % 2 = 0)
ProgrammingError: 
301	1	xxx	X
302	2	yyy	Y
303	3	zzz	Z
\.

CREATE POLICY p1 ON t1 FOR ALL TO PUBLIC USING (a % 2 = 0)

syntax error at or near "301"
LINE 2: 301 1 xxx X
        ^

 -- be even number
CREATE POLICY p2 ON t2 FOR ALL TO PUBLIC USING (a % 2 = 1)
ProgrammingError:  -- be even number
CREATE POLICY p2 ON t2 FOR ALL TO PUBLIC USING (a % 2 = 1)

relation "t2" does not exist

 -- be odd number

ALTER TABLE t1 ENABLE ROW LEVEL SECURITY

ALTER TABLE t2 ENABLE ROW LEVEL SECURITY
ProgrammingError: 
ALTER TABLE t2 ENABLE ROW LEVEL SECURITY

relation "t2" does not exist



SET SESSION AUTHORIZATION regress_rls_bob


SELECT * FROM t1
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM t1
RESULT: 
	[('Result',), ('  One-Time Filter: false',)]


SELECT * FROM t1 WHERE f_leak(b)
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b)
RESULT: 
	[('Result',), ('  One-Time Filter: false',)]


-- reference to system column
SELECT tableoid::regclass, * FROM t1
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1
RESULT: 
	[('Result',), ('  One-Time Filter: false',)]


-- reference to whole-row reference
SELECT *, t1 FROM t1
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1
RESULT: 
	[('Result',), ('  One-Time Filter: false',)]


-- for share/update lock
SELECT * FROM t1 FOR SHARE
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM t1 FOR SHARE
RESULT: 
	[('LockRows',), ('  ->  Result',), ('        One-Time Filter: false',)]


SELECT * FROM t1 WHERE f_leak(b) FOR SHARE
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b) FOR SHARE
RESULT: 
	[('LockRows',), ('  ->  Result',), ('        One-Time Filter: false',)]


-- union all query
SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3
ProgrammingError: 

-- union all query
SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3

relation "t2" does not exist
LINE 4: SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, ...
                                             ^


EXPLAIN (COSTS OFF) SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3
ProgrammingError: 
EXPLAIN (COSTS OFF) SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3

relation "t2" does not exist
LINE 2: ... (COSTS OFF) SELECT a, b, tableoid::regclass FROM t2 UNION A...
                                                             ^



-- superuser is allowed to bypass RLS checks
RESET SESSION AUTHORIZATION

SET row_security TO OFF

SELECT * FROM t1 WHERE f_leak(b)
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b)
RESULT: 
	[('Seq Scan on t1',), ('  Filter: f_leak(b)',)]


-- non-superuser with bypass privilege can bypass RLS policy when disabled
SET SESSION AUTHORIZATION regress_rls_exempt_user

SET row_security TO OFF

SELECT * FROM t1 WHERE f_leak(b)
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b)
RESULT: 
	[('Seq Scan on t1',), ('  Filter: f_leak(b)',)]


--
-- Partitioned Tables
--

SET SESSION AUTHORIZATION regress_rls_alice


CREATE TABLE part_document (
    did         int,
    cid         int,
    dlevel      int not null,
    dauthor     name,
    dtitle      text
) PARTITION BY RANGE (cid)

GRANT ALL ON part_document TO public


-- Create partitions for document categories
CREATE TABLE part_document_fiction PARTITION OF part_document FOR VALUES FROM (11) to (12)

CREATE TABLE part_document_satire PARTITION OF part_document FOR VALUES FROM (55) to (56)

CREATE TABLE part_document_nonfiction PARTITION OF part_document FOR VALUES FROM (99) to (100)


GRANT ALL ON part_document_fiction TO public

GRANT ALL ON part_document_satire TO public

GRANT ALL ON part_document_nonfiction TO public


INSERT INTO part_document VALUES
    ( 1, 11, 1, 'regress_rls_bob', 'my first novel'),
    ( 2, 11, 2, 'regress_rls_bob', 'my second novel'),
    ( 3, 99, 2, 'regress_rls_bob', 'my science textbook'),
    ( 4, 55, 1, 'regress_rls_bob', 'my first satire'),
    ( 5, 99, 2, 'regress_rls_bob', 'my history book'),
    ( 6, 11, 1, 'regress_rls_carol', 'great science fiction'),
    ( 7, 99, 2, 'regress_rls_carol', 'great technology book'),
    ( 8, 55, 2, 'regress_rls_carol', 'great satire'),
    ( 9, 11, 1, 'regress_rls_dave', 'awesome science fiction'),
    (10, 99, 2, 'regress_rls_dave', 'awesome technology book')


ALTER TABLE part_document ENABLE ROW LEVEL SECURITY


-- Create policy on parent
-- user''s security level must be higher than or equal to document''s
CREATE POLICY pp1 ON part_document AS PERMISSIVE
    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user))


-- Dave is only allowed to see cid < 55
CREATE POLICY pp1r ON part_document AS RESTRICTIVE TO regress_rls_dave
    USING (cid < 55)


-- \d+ part_document
SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename like '%part_document%' ORDER BY policyname
RESULT: 
	[('regress_rls_schema', 'part_document', 'pp1', 'PERMISSIVE', ['public'], 'ALL', '(dlevel <= ( SELECT uaccount.seclv\n   FROM uaccount\n  WHERE (uaccount.pguser = CURRENT_USER)))', None), ('regress_rls_schema', 'part_document', 'pp1r', 'RESTRICTIVE', ['regress_rls_dave'], 'ALL', '(cid < 55)', None)]


-- viewpoint from regress_rls_bob
SET SESSION AUTHORIZATION regress_rls_bob

SET row_security TO ON

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction')]

EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle)
RESULT: 
	[('Append',), ('  InitPlan 1',), ('    ->  Index Scan using uaccount_pkey on uaccount',), ('          Index Cond: (pguser = CURRENT_USER)',), ('  ->  Seq Scan on part_document_fiction part_document_1',), ('        Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',), ('  ->  Seq Scan on part_document_satire part_document_2',), ('        Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',), ('  ->  Seq Scan on part_document_nonfiction part_document_3',), ('        Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',)]


-- viewpoint from regress_rls_carol
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 99, 2, 'regress_rls_bob', 'my science textbook'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (5, 99, 2, 'regress_rls_bob', 'my history book'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (7, 99, 2, 'regress_rls_carol', 'great technology book'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 99, 2, 'regress_rls_dave', 'awesome technology book')]

EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle)
RESULT: 
	[('Append',), ('  InitPlan 1',), ('    ->  Index Scan using uaccount_pkey on uaccount',), ('          Index Cond: (pguser = CURRENT_USER)',), ('  ->  Seq Scan on part_document_fiction part_document_1',), ('        Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',), ('  ->  Seq Scan on part_document_satire part_document_2',), ('        Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',), ('  ->  Seq Scan on part_document_nonfiction part_document_3',), ('        Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',)]


-- viewpoint from regress_rls_dave
SET SESSION AUTHORIZATION regress_rls_dave

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction')]

EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle)
RESULT: 
	[('Seq Scan on part_document_fiction part_document',), ('  Filter: ((cid < 55) AND (dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',), ('  InitPlan 1',), ('    ->  Index Scan using uaccount_pkey on uaccount',), ('          Index Cond: (pguser = CURRENT_USER)',)]


-- pp1 ERROR
INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_dave', 'testing pp1')
ProgrammingError: 

-- pp1 ERROR
INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_dave', 'testing pp1')

new row violates row-level security policy for table "part_document"

 -- fail
-- pp1r ERROR
INSERT INTO part_document VALUES (100, 99, 1, 'regress_rls_dave', 'testing pp1r')
ProgrammingError:  -- fail
-- pp1r ERROR
INSERT INTO part_document VALUES (100, 99, 1, 'regress_rls_dave', 'testing pp1r')

new row violates row-level security policy "pp1r" for table "part_document"

 -- fail

-- Show that RLS policy does not apply for direct inserts to children
-- This should fail with RLS POLICY pp1r violation.
INSERT INTO part_document VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')
ProgrammingError:  -- fail

-- Show that RLS policy does not apply for direct inserts to children
-- This should fail with RLS POLICY pp1r violation.
INSERT INTO part_document VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')

new row violates row-level security policy "pp1r" for table "part_document"

 -- fail
-- But this should succeed.
INSERT INTO part_document_satire VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')
 -- success
-- We still cannot see the row using the parent
SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction')]

-- But we can if we look directly
SELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(4, 55, 1, 'regress_rls_bob', 'my first satire'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]


-- Turn on RLS and create policy on child to show RLS is checked before constraints
SET SESSION AUTHORIZATION regress_rls_alice

ALTER TABLE part_document_satire ENABLE ROW LEVEL SECURITY

CREATE POLICY pp3 ON part_document_satire AS RESTRICTIVE
    USING (cid < 55)

-- This should fail with RLS violation now.
SET SESSION AUTHORIZATION regress_rls_dave

INSERT INTO part_document_satire VALUES (101, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')
ProgrammingError: 
INSERT INTO part_document_satire VALUES (101, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')

new row violates row-level security policy for table "part_document_satire"

 -- fail
-- And now we cannot see directly into the partition either, due to RLS
SELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[]

-- The parent looks same as before
-- viewpoint from regress_rls_dave
SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction')]

EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle)
RESULT: 
	[('Seq Scan on part_document_fiction part_document',), ('  Filter: ((cid < 55) AND (dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',), ('  InitPlan 1',), ('    ->  Index Scan using uaccount_pkey on uaccount',), ('          Index Cond: (pguser = CURRENT_USER)',)]


-- viewpoint from regress_rls_carol
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 99, 2, 'regress_rls_bob', 'my science textbook'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (5, 99, 2, 'regress_rls_bob', 'my history book'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (7, 99, 2, 'regress_rls_carol', 'great technology book'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 99, 2, 'regress_rls_dave', 'awesome technology book'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]

EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle)
RESULT: 
	[('Append',), ('  InitPlan 1',), ('    ->  Index Scan using uaccount_pkey on uaccount',), ('          Index Cond: (pguser = CURRENT_USER)',), ('  ->  Seq Scan on part_document_fiction part_document_1',), ('        Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',), ('  ->  Seq Scan on part_document_satire part_document_2',), ('        Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',), ('  ->  Seq Scan on part_document_nonfiction part_document_3',), ('        Filter: ((dlevel <= (InitPlan 1).col1) AND f_leak(dtitle))',)]


-- only owner can change policies
ALTER POLICY pp1 ON part_document USING (true)
ProgrammingError: 

-- only owner can change policies
ALTER POLICY pp1 ON part_document USING (true)

must be owner of table part_document

    --fail
DROP POLICY pp1 ON part_document
ProgrammingError:     --fail
DROP POLICY pp1 ON part_document

must be owner of relation part_document

                  --fail

SET SESSION AUTHORIZATION regress_rls_alice

ALTER POLICY pp1 ON part_document USING (dauthor = current_user)


-- viewpoint from regress_rls_bob again
SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 99, 2, 'regress_rls_bob', 'my science textbook'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (5, 99, 2, 'regress_rls_bob', 'my history book')]


-- viewpoint from rls_regres_carol again
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did
RESULT: 
	[(6, 11, 1, 'regress_rls_carol', 'great science fiction'), (7, 99, 2, 'regress_rls_carol', 'great technology book'), (8, 55, 2, 'regress_rls_carol', 'great satire')]


EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle)
RESULT: 
	[('Append',), ('  ->  Seq Scan on part_document_fiction part_document_1',), ('        Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))',), ('  ->  Seq Scan on part_document_satire part_document_2',), ('        Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))',), ('  ->  Seq Scan on part_document_nonfiction part_document_3',), ('        Filter: ((dauthor = CURRENT_USER) AND f_leak(dtitle))',)]


-- database superuser does bypass RLS policy when enabled
RESET SESSION AUTHORIZATION

SET row_security TO ON

SELECT * FROM part_document ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 99, 2, 'regress_rls_bob', 'my science textbook'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (5, 99, 2, 'regress_rls_bob', 'my history book'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (7, 99, 2, 'regress_rls_carol', 'great technology book'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 99, 2, 'regress_rls_dave', 'awesome technology book'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]

SELECT * FROM part_document_satire ORDER by did
RESULT: 
	[(4, 55, 1, 'regress_rls_bob', 'my first satire'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]


-- database non-superuser with bypass privilege can bypass RLS policy when disabled
SET SESSION AUTHORIZATION regress_rls_exempt_user

SET row_security TO OFF

SELECT * FROM part_document ORDER BY did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 99, 2, 'regress_rls_bob', 'my science textbook'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (5, 99, 2, 'regress_rls_bob', 'my history book'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (7, 99, 2, 'regress_rls_carol', 'great technology book'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 99, 2, 'regress_rls_dave', 'awesome technology book'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]

SELECT * FROM part_document_satire ORDER by did
RESULT: 
	[(4, 55, 1, 'regress_rls_bob', 'my first satire'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]


-- RLS policy does not apply to table owner when RLS enabled.
SET SESSION AUTHORIZATION regress_rls_alice

SET row_security TO ON

SELECT * FROM part_document ORDER by did
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 99, 2, 'regress_rls_bob', 'my science textbook'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (5, 99, 2, 'regress_rls_bob', 'my history book'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (7, 99, 2, 'regress_rls_carol', 'great technology book'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 99, 2, 'regress_rls_dave', 'awesome technology book'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]

SELECT * FROM part_document_satire ORDER by did
RESULT: 
	[(4, 55, 1, 'regress_rls_bob', 'my first satire'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]


-- When RLS disabled, other users get ERROR.
SET SESSION AUTHORIZATION regress_rls_dave

SET row_security TO OFF

SELECT * FROM part_document ORDER by did
ProgrammingError: 
SELECT * FROM part_document ORDER by did

query would be affected by row-level security policy for table "part_document"


SELECT * FROM part_document_satire ORDER by did
ProgrammingError: 
SELECT * FROM part_document_satire ORDER by did

query would be affected by row-level security policy for table "part_document_satire"



-- Check behavior with a policy that uses a SubPlan not an InitPlan.
SET SESSION AUTHORIZATION regress_rls_alice

SET row_security TO ON

CREATE POLICY pp3 ON part_document AS RESTRICTIVE
    USING ((SELECT dlevel <= seclv FROM uaccount WHERE pguser = current_user))


SET SESSION AUTHORIZATION regress_rls_carol

INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_carol', 'testing pp3')
ProgrammingError: 
INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_carol', 'testing pp3')

new row violates row-level security policy "pp3" for table "part_document"

 -- fail

----- Dependencies -----
SET SESSION AUTHORIZATION regress_rls_alice

SET row_security TO ON


CREATE TABLE dependee (x integer, y integer)


CREATE TABLE dependent (x integer, y integer)

CREATE POLICY d1 ON dependent FOR ALL
    TO PUBLIC
    USING (x = (SELECT d.x FROM dependee d WHERE d.y = y))


DROP TABLE dependee
ERROR: 

DROP TABLE dependee

cannot drop table dependee because other objects depend on it
DETAIL:  policy d1 on table dependent depends on table dependee
HINT:  Use DROP ... CASCADE to drop the dependent objects too.

 -- Should fail without CASCADE due to dependency on row security qual?

DROP TABLE dependee CASCADE


EXPLAIN (COSTS OFF) SELECT * FROM dependent
RESULT: 
	[('Seq Scan on dependent',)]
 -- After drop, should be unqualified

-----   RECURSION    ----

--
-- Simple recursion
--
SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE rec1 (x integer, y integer)

CREATE POLICY r1 ON rec1 USING (x = (SELECT r.x FROM rec1 r WHERE y = r.y))

ALTER TABLE rec1 ENABLE ROW LEVEL SECURITY

SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rec1
ProgrammingError: 
SELECT * FROM rec1

infinite recursion detected in policy for relation "rec1"

 -- fail, direct recursion

--
-- Mutual recursion
--
SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE rec2 (a integer, b integer)

ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2 WHERE b = y))

CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1 WHERE y = b))

ALTER TABLE rec2 ENABLE ROW LEVEL SECURITY


SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rec1
ProgrammingError: 
SELECT * FROM rec1

infinite recursion detected in policy for relation "rec1"

    -- fail, mutual recursion

--
-- Mutual recursion via views
--
SET SESSION AUTHORIZATION regress_rls_bob

CREATE VIEW rec1v AS SELECT * FROM rec1

CREATE VIEW rec2v AS SELECT * FROM rec2

SET SESSION AUTHORIZATION regress_rls_alice

ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y))

ALTER POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b))


SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rec1
ProgrammingError: 
SELECT * FROM rec1

infinite recursion detected in policy for relation "rec1"

    -- fail, mutual recursion via views

--
-- Mutual recursion via .s.b views
--
SET SESSION AUTHORIZATION regress_rls_bob


DROP VIEW rec1v, rec2v CASCADE


CREATE VIEW rec1v WITH (security_barrier) AS SELECT * FROM rec1

CREATE VIEW rec2v WITH (security_barrier) AS SELECT * FROM rec2

SET SESSION AUTHORIZATION regress_rls_alice

CREATE POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y))

CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b))


SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rec1
ProgrammingError: 
SELECT * FROM rec1

infinite recursion detected in policy for relation "rec1"

    -- fail, mutual recursion via s.b. views

--
-- recursive RLS and VIEWs in policy
--
SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE s1 (a int, b text)

INSERT INTO s1 (SELECT x, public.fipshash(x::text) FROM generate_series(-10,10) x)


CREATE TABLE s2 (x int, y text)

INSERT INTO s2 (SELECT x, public.fipshash(x::text) FROM generate_series(-6,6) x)


GRANT SELECT ON s1, s2 TO regress_rls_bob


CREATE POLICY p1 ON s1 USING (a in (select x from s2 where y like '%2f%'))

CREATE POLICY p2 ON s2 USING (x in (select a from s1 where b like '%22%'))

CREATE POLICY p3 ON s1 FOR INSERT WITH CHECK (a = (SELECT a FROM s1))


ALTER TABLE s1 ENABLE ROW LEVEL SECURITY

ALTER TABLE s2 ENABLE ROW LEVEL SECURITY


SET SESSION AUTHORIZATION regress_rls_bob

CREATE VIEW v2 AS SELECT * FROM s2 WHERE y like '%af%'

SELECT * FROM s1 WHERE f_leak(b)
ProgrammingError: 
SELECT * FROM s1 WHERE f_leak(b)

infinite recursion detected in policy for relation "s1"

 -- fail (infinite recursion)

INSERT INTO s1 VALUES (1, 'foo')
ProgrammingError:  -- fail (infinite recursion)

INSERT INTO s1 VALUES (1, 'foo')

infinite recursion detected in policy for relation "s1"

 -- fail (infinite recursion)

SET SESSION AUTHORIZATION regress_rls_alice

DROP POLICY p3 on s1

ALTER POLICY p2 ON s2 USING (x % 2 = 0)


SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM s1 WHERE f_leak(b)
RESULT: 
	[(-6, '03b26944890929ff751653acb2f2af79')]
	-- OK
EXPLAIN (COSTS OFF) SELECT * FROM only s1 WHERE f_leak(b)
RESULT: 
	[('Seq Scan on s1',), ('  Filter: ((ANY (a = (hashed SubPlan 1).col1)) AND f_leak(b))',), ('  SubPlan 1',), ('    ->  Seq Scan on s2',), ("          Filter: (((x % 2) = 0) AND (y ~~ '%2f%'::text))",)]


SET SESSION AUTHORIZATION regress_rls_alice

ALTER POLICY p1 ON s1 USING (a in (select x from v2))
 -- using VIEW in RLS policy
SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM s1 WHERE f_leak(b)
RESULT: 
	[(-6, '03b26944890929ff751653acb2f2af79')]
	-- OK
EXPLAIN (COSTS OFF) SELECT * FROM s1 WHERE f_leak(b)
RESULT: 
	[('Seq Scan on s1',), ('  Filter: ((ANY (a = (hashed SubPlan 1).col1)) AND f_leak(b))',), ('  SubPlan 1',), ('    ->  Seq Scan on s2',), ("          Filter: (((x % 2) = 0) AND (y ~~ '%af%'::text))",)]


SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%'
RESULT: 
	[(-4, -4, 'e5e0093f285a4fb94c3fcc2ad7fd04ed')]

EXPLAIN (COSTS OFF) SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%'
RESULT: 
	[('Seq Scan on s2',), ("  Filter: (((x % 2) = 0) AND (y ~~ '%28%'::text))",), ('  SubPlan 2',), ('    ->  Limit',), ('          ->  Seq Scan on s1',), ('                Filter: (ANY (a = (hashed SubPlan 1).col1))',), ('                SubPlan 1',), ('                  ->  Seq Scan on s2 s2_1',), ("                        Filter: (((x % 2) = 0) AND (y ~~ '%af%'::text))",)]


SET SESSION AUTHORIZATION regress_rls_alice

ALTER POLICY p2 ON s2 USING (x in (select a from s1 where b like '%d2%'))

SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM s1 WHERE f_leak(b)
ProgrammingError: 
SELECT * FROM s1 WHERE f_leak(b)

infinite recursion detected in policy for relation "s1"

	-- fail (infinite recursion via view)

-- prepared statement with regress_rls_alice privilege
PREPARE p1(int) AS SELECT * FROM t1 WHERE a <= $1

EXECUTE p1(2)
RESULT: 
	[]

EXPLAIN (COSTS OFF) EXECUTE p1(2)
RESULT: 
	[('Result',), ('  One-Time Filter: false',)]


-- superuser is allowed to bypass RLS checks
RESET SESSION AUTHORIZATION

SET row_security TO OFF

SELECT * FROM t1 WHERE f_leak(b)
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b)
RESULT: 
	[('Seq Scan on t1',), ('  Filter: f_leak(b)',)]


-- plan cache should be invalidated
EXECUTE p1(2)
RESULT: 
	[]

EXPLAIN (COSTS OFF) EXECUTE p1(2)
RESULT: 
	[('Seq Scan on t1',), ('  Filter: (a <= 2)',)]


PREPARE p2(int) AS SELECT * FROM t1 WHERE a = $1

EXECUTE p2(2)
RESULT: 
	[]

EXPLAIN (COSTS OFF) EXECUTE p2(2)
RESULT: 
	[('Seq Scan on t1',), ('  Filter: (a = 2)',)]


-- also, case when privilege switch from superuser
SET SESSION AUTHORIZATION regress_rls_bob

SET row_security TO ON

EXECUTE p2(2)
RESULT: 
	[]

EXPLAIN (COSTS OFF) EXECUTE p2(2)
RESULT: 
	[('Result',), ('  One-Time Filter: false',)]


--
-- UPDATE / DELETE and Row-level security
--
SET SESSION AUTHORIZATION regress_rls_bob

EXPLAIN (COSTS OFF) UPDATE t1 SET b = b || b WHERE f_leak(b)
RESULT: 
	[('Update on t1',), ('  ->  Result',), ('        One-Time Filter: false',)]

UPDATE t1 SET b = b || b WHERE f_leak(b)


EXPLAIN (COSTS OFF) UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b)
RESULT: 
	[('Update on t1',), ('  ->  Result',), ('        One-Time Filter: false',)]

UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b)


-- returning clause with system column
UPDATE only t1 SET b = b WHERE f_leak(b) RETURNING tableoid::regclass, *, t1
RESULT: 
	[]

UPDATE t1 SET b = b WHERE f_leak(b) RETURNING *
RESULT: 
	[]

UPDATE t1 SET b = b WHERE f_leak(b) RETURNING tableoid::regclass, *, t1
RESULT: 
	[]


-- updates with from clause
EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t3
WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b)
ProgrammingError: 

-- updates with from clause
EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t3
WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b)

relation "t2" does not exist
LINE 4: EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t3
                                   ^



UPDATE t2 SET b=t2.b FROM t3
WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b)
ProgrammingError: 

UPDATE t2 SET b=t2.b FROM t3
WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b)

relation "t2" does not exist
LINE 3: UPDATE t2 SET b=t2.b FROM t3
               ^



EXPLAIN (COSTS OFF) UPDATE t1 SET b=t1.b FROM t2
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b)
ProgrammingError: 

EXPLAIN (COSTS OFF) UPDATE t1 SET b=t1.b FROM t2
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b)

relation "t2" does not exist
LINE 3: EXPLAIN (COSTS OFF) UPDATE t1 SET b=t1.b FROM t2
                                                      ^



UPDATE t1 SET b=t1.b FROM t2
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b)
ProgrammingError: 

UPDATE t1 SET b=t1.b FROM t2
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b)

relation "t2" does not exist
LINE 3: UPDATE t1 SET b=t1.b FROM t2
                                  ^



EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t1
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b)
ProgrammingError: 

EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t1
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b)

relation "t2" does not exist
LINE 3: EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t1
                                   ^



UPDATE t2 SET b=t2.b FROM t1
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b)
ProgrammingError: 

UPDATE t2 SET b=t2.b FROM t1
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b)

relation "t2" does not exist
LINE 3: UPDATE t2 SET b=t2.b FROM t1
               ^



-- updates with from clause self join
EXPLAIN (COSTS OFF) UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2
ProgrammingError: 

-- updates with from clause self join
EXPLAIN (COSTS OFF) UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2

relation "t2" does not exist
LINE 4: EXPLAIN (COSTS OFF) UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2...
                                   ^



UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2
ProgrammingError: 

UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2

relation "t2" does not exist
LINE 3: UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
               ^



EXPLAIN (COSTS OFF) UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2
WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b
AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2
RESULT: 
	[('Update on t1 t1_1',), ('  ->  Result',), ('        One-Time Filter: false',)]


UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2
WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b
AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2
RESULT: 
	[]


RESET SESSION AUTHORIZATION

SET row_security TO OFF

SELECT * FROM t1 ORDER BY a,b
RESULT: 
	[]


SET SESSION AUTHORIZATION regress_rls_bob

SET row_security TO ON

EXPLAIN (COSTS OFF) DELETE FROM only t1 WHERE f_leak(b)
RESULT: 
	[('Delete on t1',), ('  ->  Result',), ('        One-Time Filter: false',)]

EXPLAIN (COSTS OFF) DELETE FROM t1 WHERE f_leak(b)
RESULT: 
	[('Delete on t1',), ('  ->  Result',), ('        One-Time Filter: false',)]


DELETE FROM only t1 WHERE f_leak(b) RETURNING tableoid::regclass, *, t1
RESULT: 
	[]

DELETE FROM t1 WHERE f_leak(b) RETURNING tableoid::regclass, *, t1
RESULT: 
	[]


--
-- S.b. view on top of Row-level security
--
SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE b1 (a int, b text)

INSERT INTO b1 (SELECT x, public.fipshash(x::text) FROM generate_series(-10,10) x)


CREATE POLICY p1 ON b1 USING (a % 2 = 0)

ALTER TABLE b1 ENABLE ROW LEVEL SECURITY

GRANT ALL ON b1 TO regress_rls_bob


SET SESSION AUTHORIZATION regress_rls_bob

CREATE VIEW bv1 WITH (security_barrier) AS SELECT * FROM b1 WHERE a > 0 WITH CHECK OPTION

GRANT ALL ON bv1 TO regress_rls_carol


SET SESSION AUTHORIZATION regress_rls_carol


EXPLAIN (COSTS OFF) SELECT * FROM bv1 WHERE f_leak(b)
RESULT: 
	[('Subquery Scan on bv1',), ('  Filter: f_leak(bv1.b)',), ('  ->  Seq Scan on b1',), ('        Filter: ((a > 0) AND ((a % 2) = 0))',)]

SELECT * FROM bv1 WHERE f_leak(b)
RESULT: 
	[(2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1')]


INSERT INTO bv1 VALUES (-1, 'xxx')
ProgrammingError: 

INSERT INTO bv1 VALUES (-1, 'xxx')

new row violates row-level security policy for table "b1"

 -- should fail view WCO
INSERT INTO bv1 VALUES (11, 'xxx')
ProgrammingError:  -- should fail view WCO
INSERT INTO bv1 VALUES (11, 'xxx')

new row violates row-level security policy for table "b1"

 -- should fail RLS check
INSERT INTO bv1 VALUES (12, 'xxx')
 -- ok

EXPLAIN (COSTS OFF) UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b)
RESULT: 
	[('Update on b1',), ('  ->  Seq Scan on b1',), ('        Filter: ((a > 0) AND (a = 4) AND ((a % 2) = 0) AND f_leak(b))',)]

UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b)


EXPLAIN (COSTS OFF) DELETE FROM bv1 WHERE a = 6 AND f_leak(b)
RESULT: 
	[('Delete on b1',), ('  ->  Seq Scan on b1',), ('        Filter: ((a > 0) AND (a = 6) AND ((a % 2) = 0) AND f_leak(b))',)]

DELETE FROM bv1 WHERE a = 6 AND f_leak(b)


SET SESSION AUTHORIZATION regress_rls_alice

SELECT * FROM b1
RESULT: 
	[(-10, 'c171d4ec282b23db89a99880cd624e9b'), (-9, 'd5c534fde62beb89c745a59952c8efed'), (-8, 'e91592205d3881e3ea35d66973bb4898'), (-7, 'a770d3270c9dcdedf12ed9fd70444f7c'), (-6, '03b26944890929ff751653acb2f2af79'), (-5, '37aa1ccf80e481832b2db282d4d4f895'), (-4, 'e5e0093f285a4fb94c3fcc2ad7fd04ed'), (-3, '615bdd17c2556f82f384392ea8557f8c'), (-2, 'cf3bae39dd692048a8bf961182e6a34d'), (-1, '1bad6b8cf97131fceab8543e81f77571'), (0, '5feceb66ffc86f38d952786c6d696c79'), (1, '6b86b273ff34fce19d6b804eff5a3f57'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (3, '4e07408562bedb8b60ce05c1decfe3ad'), (5, 'ef2d127de37b942baad06145e54b0c61'), (7, '7902699be42c8a8e46fbbb4501726517'), (8, '2c624232cdd221771294dfbb310aca00'), (9, '19581e27de7ced00ff1ce50b2047e7a5'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, 'xxx'), (4, 'yyy')]

--
-- INSERT ... ON CONFLICT DO UPDATE and Row-level security
--

SET SESSION AUTHORIZATION regress_rls_alice

DROP POLICY p1 ON document

DROP POLICY p1r ON document


CREATE POLICY p1 ON document FOR SELECT USING (true)

CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user)

CREATE POLICY p3 ON document FOR UPDATE
  USING (cid = (SELECT cid from category WHERE cname = 'novel'))
  WITH CHECK (dauthor = current_user)


SET SESSION AUTHORIZATION regress_rls_bob


-- Exists...
SELECT * FROM document WHERE did = 2
RESULT: 
	[(2, 11, 2, 'regress_rls_bob', 'my second novel')]


-- ...so violates actual WITH CHECK OPTION within UPDATE (not INSERT, since
-- alternative UPDATE path happens to be taken):
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, dauthor = EXCLUDED.dauthor
ProgrammingError: 

-- ...so violates actual WITH CHECK OPTION within UPDATE (not INSERT, since
-- alternative UPDATE path happens to be taken):
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, dauthor = EXCLUDED.dauthor

new row violates row-level security policy for table "document"



-- Violates USING qual for UPDATE policy p3.
--
-- UPDATE path is taken, but UPDATE fails purely because *existing* row to be
-- updated is not a ''novel''/cid 11 (row is not leaked, even though we have
-- SELECT privileges sufficient to see the row in this instance):
INSERT INTO document VALUES (33, 22, 1, 'regress_rls_bob', 'okay science fiction')
 -- preparation for next statement
INSERT INTO document VALUES (33, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'Some novel, replaces sci-fi') -- takes UPDATE path
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle
ProgrammingError:  -- preparation for next statement
INSERT INTO document VALUES (33, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'Some novel, replaces sci-fi') -- takes UPDATE path
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle

new row violates row-level security policy (USING expression) for table "document"


-- Fine (we UPDATE, since INSERT WCOs and UPDATE security barrier quals + WCOs
-- not violated):
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *
RESULT: 
	[(2, 11, 2, 'regress_rls_bob', 'my first novel')]

-- Fine (we INSERT, so ''cid = 33'' (''technology'') isn''t evaluated):
INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *
RESULT: 
	[(78, 11, 1, 'regress_rls_bob', 'some technology novel')]

-- Fine (same query, but we UPDATE, so ''cid = 33'', (''technology'') is not the
-- case in respect of *existing* tuple):
INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *
RESULT: 
	[(78, 33, 1, 'regress_rls_bob', 'some technology novel')]

-- Same query a third time, but now fails due to existing tuple finally not
-- passing quals:
INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *
ProgrammingError: 
-- Same query a third time, but now fails due to existing tuple finally not
-- passing quals:
INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *

new row violates row-level security policy (USING expression) for table "document"


-- Don''t fail just because INSERT doesn''t satisfy WITH CHECK option that
-- originated as a barrier/USING() qual from the UPDATE.  Note that the UPDATE
-- path *isn''t* taken, and so UPDATE-related policy does not apply:
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *
RESULT: 
	[(79, 33, 1, 'regress_rls_bob', 'technology book, can only insert')]

-- But this time, the same statement fails, because the UPDATE path is taken,
-- and updating the row just inserted falls afoul of security barrier qual
-- (enforced as WCO) -- what we might have updated target tuple to is
-- irrelevant, in fact.
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *
ProgrammingError: 
-- But this time, the same statement fails, because the UPDATE path is taken,
-- and updating the row just inserted falls afoul of security barrier qual
-- (enforced as WCO) -- what we might have updated target tuple to is
-- irrelevant, in fact.
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *

new row violates row-level security policy (USING expression) for table "document"



-- Test default USING qual enforced as WCO
SET SESSION AUTHORIZATION regress_rls_alice

DROP POLICY p1 ON document

DROP POLICY p2 ON document

DROP POLICY p3 ON document


CREATE POLICY p3_with_default ON document FOR UPDATE
  USING (cid = (SELECT cid from category WHERE cname = 'novel'))


SET SESSION AUTHORIZATION regress_rls_bob

-- Just because WCO-style enforcement of USING quals occurs with
-- existing/target tuple does not mean that the implementation can be allowed
-- to fail to also enforce this qual against the final tuple appended to
-- relation (since in the absence of an explicit WCO, this is also interpreted
-- as an UPDATE/ALL WCO in general).
--
-- UPDATE path is taken here (fails due to existing tuple).  Note that this is
-- not reported as a ''USING expression'', because it''s an RLS UPDATE check that originated as
-- a USING qual for the purposes of RLS in general, as opposed to an explicit
-- USING qual that is ordinarily a security barrier.  We leave it up to the
-- UPDATE to make this fail:
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *
ProgrammingError: 
-- Just because WCO-style enforcement of USING quals occurs with
-- existing/target tuple does not mean that the implementation can be allowed
-- to fail to also enforce this qual against the final tuple appended to
-- relation (since in the absence of an explicit WCO, this is also interpreted
-- as an UPDATE/ALL WCO in general).
--
-- UPDATE path is taken here (fails due to existing tuple).  Note that this is
-- not reported as a ''USING expression'', because it''s an RLS UPDATE check that originated as
-- a USING qual for the purposes of RLS in general, as opposed to an explicit
-- USING qual that is ordinarily a security barrier.  We leave it up to the
-- UPDATE to make this fail:
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *

new row violates row-level security policy for table "document"



-- UPDATE path is taken here.  Existing tuple passes, since its cid
-- corresponds to ''novel'', but default USING qual is enforced against
-- post-UPDATE tuple too (as always when updating with a policy that lacks an
-- explicit WCO), and so this fails:
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET cid = EXCLUDED.cid, dtitle = EXCLUDED.dtitle RETURNING *
ProgrammingError: 

-- UPDATE path is taken here.  Existing tuple passes, since its cid
-- corresponds to ''novel'', but default USING qual is enforced against
-- post-UPDATE tuple too (as always when updating with a policy that lacks an
-- explicit WCO), and so this fails:
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET cid = EXCLUDED.cid, dtitle = EXCLUDED.dtitle RETURNING *

new row violates row-level security policy for table "document"



SET SESSION AUTHORIZATION regress_rls_alice

DROP POLICY p3_with_default ON document


--
-- Test ALL policies with ON CONFLICT DO UPDATE (much the same as existing UPDATE
-- tests)
--
CREATE POLICY p3_with_all ON document FOR ALL
  USING (cid = (SELECT cid from category WHERE cname = 'novel'))
  WITH CHECK (dauthor = current_user)


SET SESSION AUTHORIZATION regress_rls_bob


-- Fails, since ALL WCO is enforced in insert path:
INSERT INTO document VALUES (80, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33
ProgrammingError: 

-- Fails, since ALL WCO is enforced in insert path:
INSERT INTO document VALUES (80, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33

new row violates row-level security policy for table "document"


-- Fails, since ALL policy USING qual is enforced (existing, target tuple is in
-- violation, since it has the ''manga'' cid):
INSERT INTO document VALUES (4, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle
ProgrammingError: 
-- Fails, since ALL policy USING qual is enforced (existing, target tuple is in
-- violation, since it has the ''manga'' cid):
INSERT INTO document VALUES (4, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle

new row violates row-level security policy (USING expression) for table "document"


-- Fails, since ALL WCO are enforced:
INSERT INTO document VALUES (1, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dauthor = 'regress_rls_carol'
ProgrammingError: 
-- Fails, since ALL WCO are enforced:
INSERT INTO document VALUES (1, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dauthor = 'regress_rls_carol'

new row violates row-level security policy for table "document"



--
-- MERGE
--
RESET SESSION AUTHORIZATION

DROP POLICY p3_with_all ON document


ALTER TABLE document ADD COLUMN dnotes text DEFAULT ''

-- all documents are readable
CREATE POLICY p1 ON document FOR SELECT USING (true)

-- one may insert documents only authored by them
CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user)

-- one may only update documents in ''novel'' category and new dlevel must be > 0
CREATE POLICY p3 ON document FOR UPDATE
  USING (cid = (SELECT cid from category WHERE cname = 'novel'))
  WITH CHECK (dlevel > 0)

-- one may only delete documents in ''manga'' category
CREATE POLICY p4 ON document FOR DELETE
  USING (cid = (SELECT cid from category WHERE cname = 'manga'))


SELECT * FROM document
RESULT: 
	[(1, 11, 1, 'regress_rls_bob', 'my first novel', ''), (3, 22, 2, 'regress_rls_bob', 'my science fiction', ''), (4, 44, 1, 'regress_rls_bob', 'my first manga', ''), (5, 44, 2, 'regress_rls_bob', 'my second manga', ''), (6, 22, 1, 'regress_rls_carol', 'great science fiction', ''), (7, 33, 2, 'regress_rls_carol', 'great technology book', ''), (8, 44, 1, 'regress_rls_carol', 'great manga', ''), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction', ''), (10, 33, 2, 'regress_rls_dave', 'awesome technology book', ''), (11, 33, 1, 'regress_rls_carol', 'hoge', ''), (33, 22, 1, 'regress_rls_bob', 'okay science fiction', ''), (2, 11, 2, 'regress_rls_bob', 'my first novel', ''), (78, 33, 1, 'regress_rls_bob', 'some technology novel', ''), (79, 33, 1, 'regress_rls_bob', 'technology book, can only insert', '')]


SET SESSION AUTHORIZATION regress_rls_bob


-- Fails, since update violates WITH CHECK qual on dlevel
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge1 ', dlevel = 0
ProgrammingError: 

-- Fails, since update violates WITH CHECK qual on dlevel
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge1 ', dlevel = 0

new row violates row-level security policy for table "document"



-- Should be OK since USING and WITH CHECK quals pass
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge2 '


-- Even when dlevel is updated explicitly, but to the existing value
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge3 ', dlevel = 1


-- There is a MATCH for did = 3, but UPDATE''s USING qual does not allow
-- updating an item in category ''science fiction''
MERGE INTO document d
USING (SELECT 3 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
ProgrammingError: 

-- There is a MATCH for did = 3, but UPDATE''s USING qual does not allow
-- updating an item in category ''science fiction''
MERGE INTO document d
USING (SELECT 3 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '

target row violates row-level security policy (USING expression) for table "document"



-- The same thing with DELETE action, but fails again because no permissions
-- to delete items in ''science fiction'' category that did 3 belongs to.
MERGE INTO document d
USING (SELECT 3 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	DELETE
ProgrammingError: 

-- The same thing with DELETE action, but fails again because no permissions
-- to delete items in ''science fiction'' category that did 3 belongs to.
MERGE INTO document d
USING (SELECT 3 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	DELETE

target row violates row-level security policy (USING expression) for table "document"



-- Document with did 4 belongs to ''manga'' category which is allowed for
-- deletion. But this fails because the UPDATE action is matched first and
-- UPDATE policy does not allow updation in the category.
MERGE INTO document d
USING (SELECT 4 as sdid) s
ON did = s.sdid
WHEN MATCHED AND dnotes = '' THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
WHEN MATCHED THEN
	DELETE
ProgrammingError: 

-- Document with did 4 belongs to ''manga'' category which is allowed for
-- deletion. But this fails because the UPDATE action is matched first and
-- UPDATE policy does not allow updation in the category.
MERGE INTO document d
USING (SELECT 4 as sdid) s
ON did = s.sdid
WHEN MATCHED AND dnotes = '' THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
WHEN MATCHED THEN
	DELETE

target row violates row-level security policy (USING expression) for table "document"



-- UPDATE action is not matched this time because of the WHEN qual.
-- DELETE still fails because role regress_rls_bob does not have SELECT
-- privileges on ''manga'' category row in the category table.
MERGE INTO document d
USING (SELECT 4 as sdid) s
ON did = s.sdid
WHEN MATCHED AND dnotes <> '' THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
WHEN MATCHED THEN
	DELETE
ProgrammingError: 

-- UPDATE action is not matched this time because of the WHEN qual.
-- DELETE still fails because role regress_rls_bob does not have SELECT
-- privileges on ''manga'' category row in the category table.
MERGE INTO document d
USING (SELECT 4 as sdid) s
ON did = s.sdid
WHEN MATCHED AND dnotes <> '' THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
WHEN MATCHED THEN
	DELETE

target row violates row-level security policy (USING expression) for table "document"



-- OK if DELETE is replaced with DO NOTHING
MERGE INTO document d
USING (SELECT 4 as sdid) s
ON did = s.sdid
WHEN MATCHED AND dnotes <> '' THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
WHEN MATCHED THEN
	DO NOTHING


SELECT * FROM document WHERE did = 4
RESULT: 
	[(4, 44, 1, 'regress_rls_bob', 'my first manga', '')]


-- Switch to regress_rls_carol role and try the DELETE again. It should succeed
-- this time
RESET SESSION AUTHORIZATION

SET SESSION AUTHORIZATION regress_rls_carol


MERGE INTO document d
USING (SELECT 4 as sdid) s
ON did = s.sdid
WHEN MATCHED AND dnotes <> '' THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
WHEN MATCHED THEN
	DELETE


-- Switch back to regress_rls_bob role
RESET SESSION AUTHORIZATION

SET SESSION AUTHORIZATION regress_rls_bob


-- Try INSERT action. This fails because we are trying to insert
-- dauthor = regress_rls_dave and INSERT''s WITH CHECK does not allow
-- that
MERGE INTO document d
USING (SELECT 12 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	DELETE
WHEN NOT MATCHED THEN
	INSERT VALUES (12, 11, 1, 'regress_rls_dave', 'another novel')
ProgrammingError: 

-- Try INSERT action. This fails because we are trying to insert
-- dauthor = regress_rls_dave and INSERT''s WITH CHECK does not allow
-- that
MERGE INTO document d
USING (SELECT 12 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	DELETE
WHEN NOT MATCHED THEN
	INSERT VALUES (12, 11, 1, 'regress_rls_dave', 'another novel')

new row violates row-level security policy for table "document"



-- This should be fine
MERGE INTO document d
USING (SELECT 12 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	DELETE
WHEN NOT MATCHED THEN
	INSERT VALUES (12, 11, 1, 'regress_rls_bob', 'another novel')


-- ok
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge4 '
WHEN NOT MATCHED THEN
	INSERT VALUES (12, 11, 1, 'regress_rls_bob', 'another novel')


-- drop and create a new SELECT policy which prevents us from reading
-- any document except with category ''novel''
RESET SESSION AUTHORIZATION

DROP POLICY p1 ON document

CREATE POLICY p1 ON document FOR SELECT
  USING (cid = (SELECT cid from category WHERE cname = 'novel'))


SET SESSION AUTHORIZATION regress_rls_bob


-- MERGE can no longer see the matching row and hence attempts the
-- NOT MATCHED action, which results in unique key violation
MERGE INTO document d
USING (SELECT 7 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge5 '
WHEN NOT MATCHED THEN
	INSERT VALUES (12, 11, 1, 'regress_rls_bob', 'another novel')
ERROR: 

-- MERGE can no longer see the matching row and hence attempts the
-- NOT MATCHED action, which results in unique key violation
MERGE INTO document d
USING (SELECT 7 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge5 '
WHEN NOT MATCHED THEN
	INSERT VALUES (12, 11, 1, 'regress_rls_bob', 'another novel')

duplicate key value violates unique constraint "document_pkey"



-- UPDATE action fails if new row is not visible
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge6 ',
			   cid = (SELECT cid from category WHERE cname = 'technology')
ProgrammingError: 

-- UPDATE action fails if new row is not visible
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge6 ',
			   cid = (SELECT cid from category WHERE cname = 'technology')

new row violates row-level security policy for table "document"



-- but OK if new row is visible
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge7 ',
			   cid = (SELECT cid from category WHERE cname = 'novel')


-- OK to insert a new row that is not visible
MERGE INTO document d
USING (SELECT 13 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge8 '
WHEN NOT MATCHED THEN
	INSERT VALUES (13, 44, 1, 'regress_rls_bob', 'new manga')

SELECT * FROM document WHERE did = 13
RESULT: 
	[]


-- but not OK if RETURNING is used
MERGE INTO document d
USING (SELECT 14 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge9 '
WHEN NOT MATCHED THEN
	INSERT VALUES (14, 44, 1, 'regress_rls_bob', 'new manga')
RETURNING *
ProgrammingError: 

-- but not OK if RETURNING is used
MERGE INTO document d
USING (SELECT 14 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge9 '
WHEN NOT MATCHED THEN
	INSERT VALUES (14, 44, 1, 'regress_rls_bob', 'new manga')
RETURNING *

new row violates row-level security policy for table "document"



-- but OK if new row is visible
MERGE INTO document d
USING (SELECT 14 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge10 '
WHEN NOT MATCHED THEN
	INSERT VALUES (14, 11, 1, 'regress_rls_bob', 'new novel')
RETURNING *
RESULT: 
	[(14, 14, 11, 1, 'regress_rls_bob', 'new novel', '')]


RESET SESSION AUTHORIZATION

-- drop the restrictive SELECT policy so that we can look at the
-- final state of the table
DROP POLICY p1 ON document

-- Just check everything went per plan
SELECT * FROM document
RESULT: 
	[(3, 22, 2, 'regress_rls_bob', 'my science fiction', ''), (5, 44, 2, 'regress_rls_bob', 'my second manga', ''), (6, 22, 1, 'regress_rls_carol', 'great science fiction', ''), (7, 33, 2, 'regress_rls_carol', 'great technology book', ''), (8, 44, 1, 'regress_rls_carol', 'great manga', ''), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction', ''), (10, 33, 2, 'regress_rls_dave', 'awesome technology book', ''), (11, 33, 1, 'regress_rls_carol', 'hoge', ''), (33, 22, 1, 'regress_rls_bob', 'okay science fiction', ''), (2, 11, 2, 'regress_rls_bob', 'my first novel', ''), (78, 33, 1, 'regress_rls_bob', 'some technology novel', ''), (79, 33, 1, 'regress_rls_bob', 'technology book, can only insert', ''), (12, 11, 1, 'regress_rls_bob', 'another novel', ''), (1, 11, 1, 'regress_rls_bob', 'my first novel', ' notes added by merge2  notes added by merge3  notes added by merge4  notes added by merge7 '), (13, 44, 1, 'regress_rls_bob', 'new manga', ''), (14, 11, 1, 'regress_rls_bob', 'new novel', '')]


--
-- ROLE/GROUP
--
SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE z1 (a int, b text)

CREATE TABLE z2 (a int, b text)


GRANT SELECT ON z1,z2 TO regress_rls_group1, regress_rls_group2,
    regress_rls_bob, regress_rls_carol


INSERT INTO z1 VALUES
    (1, 'aba'),
    (2, 'bbb'),
    (3, 'ccc'),
    (4, 'dad')


CREATE POLICY p1 ON z1 TO regress_rls_group1 USING (a % 2 = 0)

CREATE POLICY p2 ON z1 TO regress_rls_group2 USING (a % 2 = 1)


ALTER TABLE z1 ENABLE ROW LEVEL SECURITY


SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM z1 WHERE f_leak(b)
RESULT: 
	[(2, 'bbb'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b)
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 0) AND f_leak(b))',)]


PREPARE plancache_test AS SELECT * FROM z1 WHERE f_leak(b)

EXPLAIN (COSTS OFF) EXECUTE plancache_test
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 0) AND f_leak(b))',)]


PREPARE plancache_test2 AS WITH q AS MATERIALIZED (SELECT * FROM z1 WHERE f_leak(b)) SELECT * FROM q,z2

EXPLAIN (COSTS OFF) EXECUTE plancache_test2
RESULT: 
	[('Nested Loop',), ('  CTE q',), ('    ->  Seq Scan on z1',), ('          Filter: (((a % 2) = 0) AND f_leak(b))',), ('  ->  CTE Scan on q',), ('  ->  Materialize',), ('        ->  Seq Scan on z2',)]


PREPARE plancache_test3 AS WITH q AS MATERIALIZED (SELECT * FROM z2) SELECT * FROM q,z1 WHERE f_leak(z1.b)

EXPLAIN (COSTS OFF) EXECUTE plancache_test3
RESULT: 
	[('Nested Loop',), ('  CTE q',), ('    ->  Seq Scan on z2',), ('  ->  CTE Scan on q',), ('  ->  Materialize',), ('        ->  Seq Scan on z1',), ('              Filter: (((a % 2) = 0) AND f_leak(b))',)]


SET ROLE regress_rls_group1

SELECT * FROM z1 WHERE f_leak(b)
RESULT: 
	[(2, 'bbb'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b)
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 0) AND f_leak(b))',)]


EXPLAIN (COSTS OFF) EXECUTE plancache_test
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 0) AND f_leak(b))',)]

EXPLAIN (COSTS OFF) EXECUTE plancache_test2
RESULT: 
	[('Nested Loop',), ('  CTE q',), ('    ->  Seq Scan on z1',), ('          Filter: (((a % 2) = 0) AND f_leak(b))',), ('  ->  CTE Scan on q',), ('  ->  Materialize',), ('        ->  Seq Scan on z2',)]

EXPLAIN (COSTS OFF) EXECUTE plancache_test3
RESULT: 
	[('Nested Loop',), ('  CTE q',), ('    ->  Seq Scan on z2',), ('  ->  CTE Scan on q',), ('  ->  Materialize',), ('        ->  Seq Scan on z1',), ('              Filter: (((a % 2) = 0) AND f_leak(b))',)]


SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM z1 WHERE f_leak(b)
RESULT: 
	[(1, 'aba'), (3, 'ccc')]

EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b)
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 1) AND f_leak(b))',)]


EXPLAIN (COSTS OFF) EXECUTE plancache_test
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 1) AND f_leak(b))',)]

EXPLAIN (COSTS OFF) EXECUTE plancache_test2
RESULT: 
	[('Nested Loop',), ('  CTE q',), ('    ->  Seq Scan on z1',), ('          Filter: (((a % 2) = 1) AND f_leak(b))',), ('  ->  CTE Scan on q',), ('  ->  Materialize',), ('        ->  Seq Scan on z2',)]

EXPLAIN (COSTS OFF) EXECUTE plancache_test3
RESULT: 
	[('Nested Loop',), ('  CTE q',), ('    ->  Seq Scan on z2',), ('  ->  CTE Scan on q',), ('  ->  Materialize',), ('        ->  Seq Scan on z1',), ('              Filter: (((a % 2) = 1) AND f_leak(b))',)]


SET ROLE regress_rls_group2

SELECT * FROM z1 WHERE f_leak(b)
RESULT: 
	[(1, 'aba'), (3, 'ccc')]

EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b)
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 1) AND f_leak(b))',)]


EXPLAIN (COSTS OFF) EXECUTE plancache_test
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 1) AND f_leak(b))',)]

EXPLAIN (COSTS OFF) EXECUTE plancache_test2
RESULT: 
	[('Nested Loop',), ('  CTE q',), ('    ->  Seq Scan on z1',), ('          Filter: (((a % 2) = 1) AND f_leak(b))',), ('  ->  CTE Scan on q',), ('  ->  Materialize',), ('        ->  Seq Scan on z2',)]

EXPLAIN (COSTS OFF) EXECUTE plancache_test3
RESULT: 
	[('Nested Loop',), ('  CTE q',), ('    ->  Seq Scan on z2',), ('  ->  CTE Scan on q',), ('  ->  Materialize',), ('        ->  Seq Scan on z1',), ('              Filter: (((a % 2) = 1) AND f_leak(b))',)]


--
-- Views should follow policy for view owner.
--
-- View and Table owner are the same.
SET SESSION AUTHORIZATION regress_rls_alice

CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b)

GRANT SELECT ON rls_view TO regress_rls_bob


-- Query as role that is not owner of view or table.  Should return all records.
SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rls_view
RESULT: 
	[(1, 'aba'), (2, 'bbb'), (3, 'ccc'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: f_leak(b)',)]


-- Query as view/table owner.  Should return all records.
SET SESSION AUTHORIZATION regress_rls_alice

SELECT * FROM rls_view
RESULT: 
	[(1, 'aba'), (2, 'bbb'), (3, 'ccc'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: f_leak(b)',)]

DROP VIEW rls_view


-- View and Table owners are different.
SET SESSION AUTHORIZATION regress_rls_bob

CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b)

GRANT SELECT ON rls_view TO regress_rls_alice


-- Query as role that is not owner of view but is owner of table.
-- Should return records based on view owner policies.
SET SESSION AUTHORIZATION regress_rls_alice

SELECT * FROM rls_view
RESULT: 
	[(2, 'bbb'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 0) AND f_leak(b))',)]


-- Query as role that is not owner of table but is owner of view.
-- Should return records based on view owner policies.
SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rls_view
RESULT: 
	[(2, 'bbb'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 0) AND f_leak(b))',)]


-- Query as role that is not the owner of the table or view without permissions.
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM rls_view
ProgrammingError: 
SELECT * FROM rls_view

permission denied for view rls_view

 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view
ProgrammingError:  --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view

permission denied for view rls_view

 --fail - permission denied.

-- Query as role that is not the owner of the table or view with permissions.
SET SESSION AUTHORIZATION regress_rls_bob

GRANT SELECT ON rls_view TO regress_rls_carol


SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM rls_view
RESULT: 
	[(2, 'bbb'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 0) AND f_leak(b))',)]


-- Policy requiring access to another table.
SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE z1_blacklist (a int)

INSERT INTO z1_blacklist VALUES (3), (4)

CREATE POLICY p3 ON z1 AS RESTRICTIVE USING (a NOT IN (SELECT a FROM z1_blacklist))


-- Query as role that is not owner of table but is owner of view without permissions.
SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rls_view
ProgrammingError: 
SELECT * FROM rls_view

permission denied for table z1_blacklist

 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view
ProgrammingError:  --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view

permission denied for table z1_blacklist

 --fail - permission denied.

-- Query as role that is not the owner of the table or view without permissions.
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM rls_view
ProgrammingError: 
SELECT * FROM rls_view

permission denied for table z1_blacklist

 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view
ProgrammingError:  --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view

permission denied for table z1_blacklist

 --fail - permission denied.

-- Query as role that is not owner of table but is owner of view with permissions.
SET SESSION AUTHORIZATION regress_rls_alice

GRANT SELECT ON z1_blacklist TO regress_rls_bob


SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rls_view
RESULT: 
	[(2, 'bbb')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: ((NOT (ANY (a = (hashed SubPlan 1).col1))) AND ((a % 2) = 0) AND f_leak(b))',), ('  SubPlan 1',), ('    ->  Seq Scan on z1_blacklist',)]


-- Query as role that is not the owner of the table or view with permissions.
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM rls_view
RESULT: 
	[(2, 'bbb')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: ((NOT (ANY (a = (hashed SubPlan 1).col1))) AND ((a % 2) = 0) AND f_leak(b))',), ('  SubPlan 1',), ('    ->  Seq Scan on z1_blacklist',)]


SET SESSION AUTHORIZATION regress_rls_alice

REVOKE SELECT ON z1_blacklist FROM regress_rls_bob

DROP POLICY p3 ON z1


SET SESSION AUTHORIZATION regress_rls_bob

DROP VIEW rls_view


--
-- Security invoker views should follow policy for current user.
--
-- View and table owner are the same.
SET SESSION AUTHORIZATION regress_rls_alice

CREATE VIEW rls_view WITH (security_invoker) AS
    SELECT * FROM z1 WHERE f_leak(b)

GRANT SELECT ON rls_view TO regress_rls_bob

GRANT SELECT ON rls_view TO regress_rls_carol


-- Query as table owner.  Should return all records.
SELECT * FROM rls_view
RESULT: 
	[(1, 'aba'), (2, 'bbb'), (3, 'ccc'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: f_leak(b)',)]


-- Queries as other users.
-- Should return records based on current user''s policies.
SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rls_view
RESULT: 
	[(2, 'bbb'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 0) AND f_leak(b))',)]


SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM rls_view
RESULT: 
	[(1, 'aba'), (3, 'ccc')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 1) AND f_leak(b))',)]


-- View and table owners are different.
SET SESSION AUTHORIZATION regress_rls_alice

DROP VIEW rls_view


SET SESSION AUTHORIZATION regress_rls_bob

CREATE VIEW rls_view WITH (security_invoker) AS
    SELECT * FROM z1 WHERE f_leak(b)

GRANT SELECT ON rls_view TO regress_rls_alice

GRANT SELECT ON rls_view TO regress_rls_carol


-- Query as table owner.  Should return all records.
SET SESSION AUTHORIZATION regress_rls_alice

SELECT * FROM rls_view
RESULT: 
	[(1, 'aba'), (2, 'bbb'), (3, 'ccc'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: f_leak(b)',)]


-- Queries as other users.
-- Should return records based on current user''s policies.
SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rls_view
RESULT: 
	[(2, 'bbb'), (4, 'dad')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 0) AND f_leak(b))',)]


SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM rls_view
RESULT: 
	[(1, 'aba'), (3, 'ccc')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: (((a % 2) = 1) AND f_leak(b))',)]


-- Policy requiring access to another table.
SET SESSION AUTHORIZATION regress_rls_alice

CREATE POLICY p3 ON z1 AS RESTRICTIVE USING (a NOT IN (SELECT a FROM z1_blacklist))


-- Query as role that is not owner of table but is owner of view without permissions.
SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rls_view
ProgrammingError: 
SELECT * FROM rls_view

permission denied for table z1_blacklist

 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view
ProgrammingError:  --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view

permission denied for table z1_blacklist

 --fail - permission denied.

-- Query as role that is not the owner of the table or view without permissions.
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM rls_view
ProgrammingError: 
SELECT * FROM rls_view

permission denied for table z1_blacklist

 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view
ProgrammingError:  --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view

permission denied for table z1_blacklist

 --fail - permission denied.

-- Query as role that is not owner of table but is owner of view with permissions.
SET SESSION AUTHORIZATION regress_rls_alice

GRANT SELECT ON z1_blacklist TO regress_rls_bob


SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM rls_view
RESULT: 
	[(2, 'bbb')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: ((NOT (ANY (a = (hashed SubPlan 1).col1))) AND ((a % 2) = 0) AND f_leak(b))',), ('  SubPlan 1',), ('    ->  Seq Scan on z1_blacklist',)]


-- Query as role that is not the owner of the table or view without permissions.
SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM rls_view
ProgrammingError: 
SELECT * FROM rls_view

permission denied for table z1_blacklist

 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view
ProgrammingError:  --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view

permission denied for table z1_blacklist

 --fail - permission denied.

-- Query as role that is not the owner of the table or view with permissions.
SET SESSION AUTHORIZATION regress_rls_alice

GRANT SELECT ON z1_blacklist TO regress_rls_carol


SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM rls_view
RESULT: 
	[(1, 'aba')]

EXPLAIN (COSTS OFF) SELECT * FROM rls_view
RESULT: 
	[('Seq Scan on z1',), ('  Filter: ((NOT (ANY (a = (hashed SubPlan 1).col1))) AND ((a % 2) = 1) AND f_leak(b))',), ('  SubPlan 1',), ('    ->  Seq Scan on z1_blacklist',)]


SET SESSION AUTHORIZATION regress_rls_bob

DROP VIEW rls_view


--
-- Command specific
--
SET SESSION AUTHORIZATION regress_rls_alice


CREATE TABLE x1 (a int, b text, c text)

GRANT ALL ON x1 TO PUBLIC


INSERT INTO x1 VALUES
    (1, 'abc', 'regress_rls_bob'),
    (2, 'bcd', 'regress_rls_bob'),
    (3, 'cde', 'regress_rls_carol'),
    (4, 'def', 'regress_rls_carol'),
    (5, 'efg', 'regress_rls_bob'),
    (6, 'fgh', 'regress_rls_bob'),
    (7, 'fgh', 'regress_rls_carol'),
    (8, 'fgh', 'regress_rls_carol')


CREATE POLICY p0 ON x1 FOR ALL USING (c = current_user)

CREATE POLICY p1 ON x1 FOR SELECT USING (a % 2 = 0)

CREATE POLICY p2 ON x1 FOR INSERT WITH CHECK (a % 2 = 1)

CREATE POLICY p3 ON x1 FOR UPDATE USING (a % 2 = 0)

CREATE POLICY p4 ON x1 FOR DELETE USING (a < 8)


ALTER TABLE x1 ENABLE ROW LEVEL SECURITY


SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC
RESULT: 
	[(1, 'abc', 'regress_rls_bob'), (2, 'bcd', 'regress_rls_bob'), (4, 'def', 'regress_rls_carol'), (5, 'efg', 'regress_rls_bob'), (6, 'fgh', 'regress_rls_bob'), (8, 'fgh', 'regress_rls_carol')]

UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *
RESULT: 
	[(1, 'abc_updt', 'regress_rls_bob'), (2, 'bcd_updt', 'regress_rls_bob'), (4, 'def_updt', 'regress_rls_carol'), (5, 'efg_updt', 'regress_rls_bob'), (6, 'fgh_updt', 'regress_rls_bob'), (8, 'fgh_updt', 'regress_rls_carol')]


SET SESSION AUTHORIZATION regress_rls_carol

SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC
RESULT: 
	[(2, 'bcd_updt', 'regress_rls_bob'), (3, 'cde', 'regress_rls_carol'), (4, 'def_updt', 'regress_rls_carol'), (6, 'fgh_updt', 'regress_rls_bob'), (7, 'fgh', 'regress_rls_carol'), (8, 'fgh_updt', 'regress_rls_carol')]

UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *
RESULT: 
	[(3, 'cde_updt', 'regress_rls_carol'), (7, 'fgh_updt', 'regress_rls_carol'), (2, 'bcd_updt_updt', 'regress_rls_bob'), (4, 'def_updt_updt', 'regress_rls_carol'), (6, 'fgh_updt_updt', 'regress_rls_bob'), (8, 'fgh_updt_updt', 'regress_rls_carol')]

DELETE FROM x1 WHERE f_leak(b) RETURNING *
RESULT: 
	[(3, 'cde_updt', 'regress_rls_carol'), (7, 'fgh_updt', 'regress_rls_carol'), (2, 'bcd_updt_updt', 'regress_rls_bob'), (4, 'def_updt_updt', 'regress_rls_carol'), (6, 'fgh_updt_updt', 'regress_rls_bob'), (8, 'fgh_updt_updt', 'regress_rls_carol')]


--
-- Duplicate Policy Names
--
SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE y1 (a int, b text)

CREATE TABLE y2 (a int, b text)


GRANT ALL ON y1, y2 TO regress_rls_bob


CREATE POLICY p1 ON y1 FOR ALL USING (a % 2 = 0)

CREATE POLICY p2 ON y1 FOR SELECT USING (a > 2)

CREATE POLICY p1 ON y1 FOR SELECT USING (a % 2 = 1)
ProgrammingError: 
CREATE POLICY p1 ON y1 FOR SELECT USING (a % 2 = 1)

policy "p1" for table "y1" already exists

  --fail
CREATE POLICY p1 ON y2 FOR ALL USING (a % 2 = 0)
  --OK

ALTER TABLE y1 ENABLE ROW LEVEL SECURITY

ALTER TABLE y2 ENABLE ROW LEVEL SECURITY


--
-- Expression structure with SBV
--
-- Create view as table owner.  RLS should NOT be applied.
SET SESSION AUTHORIZATION regress_rls_alice

CREATE VIEW rls_sbv WITH (security_barrier) AS
    SELECT * FROM y1 WHERE f_leak(b)

EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1)
RESULT: 
	[('Seq Scan on y1',), ('  Filter: (f_leak(b) AND (a = 1))',)]

DROP VIEW rls_sbv


-- Create view as role that does not own table.  RLS should be applied.
SET SESSION AUTHORIZATION regress_rls_bob

CREATE VIEW rls_sbv WITH (security_barrier) AS
    SELECT * FROM y1 WHERE f_leak(b)

EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1)
RESULT: 
	[('Seq Scan on y1',), ('  Filter: ((a = 1) AND ((a > 2) OR ((a % 2) = 0)) AND f_leak(b))',)]

DROP VIEW rls_sbv


--
-- Expression structure
--
SET SESSION AUTHORIZATION regress_rls_alice

INSERT INTO y2 (SELECT x, public.fipshash(x::text) FROM generate_series(0,20) x)

CREATE POLICY p2 ON y2 USING (a % 3 = 0)

CREATE POLICY p3 ON y2 USING (a % 4 = 0)


SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM y2 WHERE f_leak(b)
RESULT: 
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (3, '4e07408562bedb8b60ce05c1decfe3ad'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (9, '19581e27de7ced00ff1ce50b2047e7a5'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (15, 'e629fa6598d732768f7c726b4b621285'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3')]

EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak(b)
RESULT: 
	[('Seq Scan on y2',), ('  Filter: ((((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0)) AND f_leak(b))',)]


--
-- Qual push-down of leaky functions, when not referring to table
--
SELECT * FROM y2 WHERE f_leak('abc')
RESULT: 
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (3, '4e07408562bedb8b60ce05c1decfe3ad'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (9, '19581e27de7ced00ff1ce50b2047e7a5'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (15, 'e629fa6598d732768f7c726b4b621285'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3')]

EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak('abc')
RESULT: 
	[('Seq Scan on y2',), ("  Filter: (f_leak('abc'::text) AND (((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0)))",)]


CREATE TABLE test_qual_pushdown (
    abc text
)


INSERT INTO test_qual_pushdown VALUES ('abc'),('def')


SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(abc)
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(abc)
RESULT: 
	[('Hash Join',), ('  Hash Cond: (test_qual_pushdown.abc = y2.b)',), ('  ->  Seq Scan on test_qual_pushdown',), ('        Filter: f_leak(abc)',), ('  ->  Hash',), ('        ->  Seq Scan on y2',), ('              Filter: (((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0))',)]


SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(b)
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(b)
RESULT: 
	[('Hash Join',), ('  Hash Cond: (test_qual_pushdown.abc = y2.b)',), ('  ->  Seq Scan on test_qual_pushdown',), ('  ->  Hash',), ('        ->  Seq Scan on y2',), ('              Filter: ((((a % 4) = 0) OR ((a % 3) = 0) OR ((a % 2) = 0)) AND f_leak(b))',)]


DROP TABLE test_qual_pushdown


--
-- Plancache invalidate on user change.
--
RESET SESSION AUTHORIZATION


DROP TABLE t1 CASCADE


CREATE TABLE t1 (a integer)


GRANT SELECT ON t1 TO regress_rls_bob, regress_rls_carol


CREATE POLICY p1 ON t1 TO regress_rls_bob USING ((a % 2) = 0)

CREATE POLICY p2 ON t1 TO regress_rls_carol USING ((a % 4) = 0)


ALTER TABLE t1 ENABLE ROW LEVEL SECURITY


-- Prepare as regress_rls_bob
SET ROLE regress_rls_bob

PREPARE role_inval AS SELECT * FROM t1

-- Check plan
EXPLAIN (COSTS OFF) EXECUTE role_inval
RESULT: 
	[('Seq Scan on t1',), ('  Filter: ((a % 2) = 0)',)]


-- Change to regress_rls_carol
SET ROLE regress_rls_carol

-- Check plan- should be different
EXPLAIN (COSTS OFF) EXECUTE role_inval
RESULT: 
	[('Seq Scan on t1',), ('  Filter: ((a % 4) = 0)',)]


-- Change back to regress_rls_bob
SET ROLE regress_rls_bob

-- Check plan- should be back to original
EXPLAIN (COSTS OFF) EXECUTE role_inval
RESULT: 
	[('Seq Scan on t1',), ('  Filter: ((a % 2) = 0)',)]


--
-- CTE and RLS
--
RESET SESSION AUTHORIZATION

DROP TABLE t1 CASCADE

CREATE TABLE t1 (a integer, b text)

CREATE POLICY p1 ON t1 USING (a % 2 = 0)


ALTER TABLE t1 ENABLE ROW LEVEL SECURITY


GRANT ALL ON t1 TO regress_rls_bob


INSERT INTO t1 (SELECT x, public.fipshash(x::text) FROM generate_series(0,20) x)


SET SESSION AUTHORIZATION regress_rls_bob


WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1
RESULT: 
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3')]

EXPLAIN (COSTS OFF)
WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1
RESULT: 
	[('CTE Scan on cte1',), ('  CTE cte1',), ('    ->  Seq Scan on t1',), ('          Filter: (((a % 2) = 0) AND f_leak(b))',)]


WITH cte1 AS (UPDATE t1 SET a = a + 1 RETURNING *) SELECT * FROM cte1
ProgrammingError: 

WITH cte1 AS (UPDATE t1 SET a = a + 1 RETURNING *) SELECT * FROM cte1

new row violates row-level security policy for table "t1"

 --fail
WITH cte1 AS (UPDATE t1 SET a = a RETURNING *) SELECT * FROM cte1
RESULT: 
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3')]
 --ok

WITH cte1 AS (INSERT INTO t1 VALUES (21, 'Fail') RETURNING *) SELECT * FROM cte1
ProgrammingError:  --ok

WITH cte1 AS (INSERT INTO t1 VALUES (21, 'Fail') RETURNING *) SELECT * FROM cte1

new row violates row-level security policy for table "t1"

 --fail
WITH cte1 AS (INSERT INTO t1 VALUES (20, 'Success') RETURNING *) SELECT * FROM cte1
RESULT: 
	[(20, 'Success')]
 --ok

--
-- Rename Policy
--
RESET SESSION AUTHORIZATION

ALTER POLICY p1 ON t1 RENAME TO p1
ProgrammingError: 
ALTER POLICY p1 ON t1 RENAME TO p1

policy "p1" for table "t1" already exists

 --fail

SELECT polname, relname
    FROM pg_policy pol
    JOIN pg_class pc ON (pc.oid = pol.polrelid)
    WHERE relname = 't1'
RESULT: 
	[('p1', 't1')]


ALTER POLICY p1 ON t1 RENAME TO p2
 --ok

SELECT polname, relname
    FROM pg_policy pol
    JOIN pg_class pc ON (pc.oid = pol.polrelid)
    WHERE relname = 't1'
RESULT: 
	[('p2', 't1')]


--
-- Check INSERT SELECT
--
SET SESSION AUTHORIZATION regress_rls_bob

CREATE TABLE t2 (a integer, b text)

INSERT INTO t2 (SELECT * FROM t1)

EXPLAIN (COSTS OFF) INSERT INTO t2 (SELECT * FROM t1)
RESULT: 
	[('Insert on t2',), ('  ->  Seq Scan on t1',), ('        Filter: ((a % 2) = 0)',)]

SELECT * FROM t2
RESULT: 
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3'), (20, 'Success')]

EXPLAIN (COSTS OFF) SELECT * FROM t2
RESULT: 
	[('Seq Scan on t2',)]

CREATE TABLE t3 AS SELECT * FROM t1

SELECT * FROM t3
RESULT: 
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3'), (20, 'Success')]

SELECT * INTO t4 FROM t1

SELECT * FROM t4
RESULT: 
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3'), (20, 'Success')]


--
-- RLS with JOIN
--
SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE blog (id integer, author text, post text)

CREATE TABLE comment (blog_id integer, message text)


GRANT ALL ON blog, comment TO regress_rls_bob


CREATE POLICY blog_1 ON blog USING (id % 2 = 0)


ALTER TABLE blog ENABLE ROW LEVEL SECURITY


INSERT INTO blog VALUES
    (1, 'alice', 'blog #1'),
    (2, 'bob', 'blog #1'),
    (3, 'alice', 'blog #2'),
    (4, 'alice', 'blog #3'),
    (5, 'john', 'blog #1')


INSERT INTO comment VALUES
    (1, 'cool blog'),
    (1, 'fun blog'),
    (3, 'crazy blog'),
    (5, 'what?'),
    (4, 'insane!'),
    (2, 'who did it?')


SET SESSION AUTHORIZATION regress_rls_bob

-- Check RLS JOIN with Non-RLS.
SELECT id, author, message FROM blog JOIN comment ON id = blog_id
RESULT: 
	[(4, 'alice', 'insane!'), (2, 'bob', 'who did it?')]

-- Check Non-RLS JOIN with RLS.
SELECT id, author, message FROM comment JOIN blog ON id = blog_id
RESULT: 
	[(4, 'alice', 'insane!'), (2, 'bob', 'who did it?')]


SET SESSION AUTHORIZATION regress_rls_alice

CREATE POLICY comment_1 ON comment USING (blog_id < 4)


ALTER TABLE comment ENABLE ROW LEVEL SECURITY


SET SESSION AUTHORIZATION regress_rls_bob

-- Check RLS JOIN RLS
SELECT id, author, message FROM blog JOIN comment ON id = blog_id
RESULT: 
	[(2, 'bob', 'who did it?')]

SELECT id, author, message FROM comment JOIN blog ON id = blog_id
RESULT: 
	[(2, 'bob', 'who did it?')]


SET SESSION AUTHORIZATION regress_rls_alice

DROP TABLE blog, comment


--
-- Default Deny Policy
--
RESET SESSION AUTHORIZATION

DROP POLICY p2 ON t1

ALTER TABLE t1 OWNER TO regress_rls_alice


-- Check that default deny does not apply to superuser.
RESET SESSION AUTHORIZATION

SELECT * FROM t1
RESULT: 
	[(1, '6b86b273ff34fce19d6b804eff5a3f57'), (3, '4e07408562bedb8b60ce05c1decfe3ad'), (5, 'ef2d127de37b942baad06145e54b0c61'), (7, '7902699be42c8a8e46fbbb4501726517'), (9, '19581e27de7ced00ff1ce50b2047e7a5'), (11, '4fc82b26aecb47d2868c4efbe3581732'), (13, '3fdba35f04dc8c462986c992bcf87554'), (15, 'e629fa6598d732768f7c726b4b621285'), (17, '4523540f1504cd17100c4835e85b7eef'), (19, '9400f1b21cb527d7fa3d3eabba93557a'), (0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3'), (20, 'Success')]

EXPLAIN (COSTS OFF) SELECT * FROM t1
RESULT: 
	[('Seq Scan on t1',)]


-- Check that default deny does not apply to table owner.
SET SESSION AUTHORIZATION regress_rls_alice

SELECT * FROM t1
RESULT: 
	[(1, '6b86b273ff34fce19d6b804eff5a3f57'), (3, '4e07408562bedb8b60ce05c1decfe3ad'), (5, 'ef2d127de37b942baad06145e54b0c61'), (7, '7902699be42c8a8e46fbbb4501726517'), (9, '19581e27de7ced00ff1ce50b2047e7a5'), (11, '4fc82b26aecb47d2868c4efbe3581732'), (13, '3fdba35f04dc8c462986c992bcf87554'), (15, 'e629fa6598d732768f7c726b4b621285'), (17, '4523540f1504cd17100c4835e85b7eef'), (19, '9400f1b21cb527d7fa3d3eabba93557a'), (0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3'), (20, 'Success')]

EXPLAIN (COSTS OFF) SELECT * FROM t1
RESULT: 
	[('Seq Scan on t1',)]


-- Check that default deny applies to non-owner/non-superuser when RLS on.
SET SESSION AUTHORIZATION regress_rls_bob

SET row_security TO ON

SELECT * FROM t1
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM t1
RESULT: 
	[('Result',), ('  One-Time Filter: false',)]

SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM t1
RESULT: 
	[]

EXPLAIN (COSTS OFF) SELECT * FROM t1
RESULT: 
	[('Result',), ('  One-Time Filter: false',)]


--
-- COPY TO/FROM
--

RESET SESSION AUTHORIZATION

DROP TABLE copy_t CASCADE
ProgrammingError: 
DROP TABLE copy_t CASCADE

table "copy_t" does not exist


CREATE TABLE copy_t (a integer, b text)

CREATE POLICY p1 ON copy_t USING (a % 2 = 0)


ALTER TABLE copy_t ENABLE ROW LEVEL SECURITY


GRANT ALL ON copy_t TO regress_rls_bob, regress_rls_exempt_user


INSERT INTO copy_t (SELECT x, public.fipshash(x::text) FROM generate_series(0,10) x)


-- Check COPY TO as Superuser/owner.
RESET SESSION AUTHORIZATION

SET row_security TO OFF

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead

SET row_security TO ON

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead


-- Check COPY TO as user with permissions.
SET SESSION AUTHORIZATION regress_rls_bob

SET row_security TO OFF

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','

query would be affected by row-level security policy for table "copy_t"

 --fail - would be affected by RLS
SET row_security TO ON

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead
 --ok

-- Check COPY TO as user with permissions and BYPASSRLS
SET SESSION AUTHORIZATION regress_rls_exempt_user

SET row_security TO OFF

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead
 --ok
SET row_security TO ON

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead
 --ok

-- Check COPY TO as user without permissions. SET row_security TO OFF /* REPLACED */,
SET SESSION AUTHORIZATION regress_rls_carol

SET row_security TO OFF

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','

query would be affected by row-level security policy for table "copy_t"

 --fail - would be affected by RLS
SET row_security TO ON

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ','

permission denied for table copy_t

 --fail - permission denied

-- Check COPY relation TO /* REPLACED */, keep it just one row to avoid reordering issues
RESET SESSION AUTHORIZATION

SET row_security TO ON

CREATE TABLE copy_rel_to (a integer, b text)

CREATE POLICY p1 ON copy_rel_to USING (a % 2 = 0)


ALTER TABLE copy_rel_to ENABLE ROW LEVEL SECURITY


GRANT ALL ON copy_rel_to TO regress_rls_bob, regress_rls_exempt_user


INSERT INTO copy_rel_to VALUES (1, public.fipshash('1'))


-- Check COPY TO as Superuser/owner.
RESET SESSION AUTHORIZATION

SET row_security TO OFF

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead

SET row_security TO ON

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead


-- Check COPY TO as user with permissions.
SET SESSION AUTHORIZATION regress_rls_bob

SET row_security TO OFF

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

query would be affected by row-level security policy for table "copy_rel_to"

 --fail - would be affected by RLS
SET row_security TO ON

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead
 --ok

-- Check COPY TO as user with permissions and BYPASSRLS
SET SESSION AUTHORIZATION regress_rls_exempt_user

SET row_security TO OFF

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead
 --ok
SET row_security TO ON

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead
 --ok

-- Check COPY TO as user without permissions. SET row_security TO OFF /* REPLACED */,
SET SESSION AUTHORIZATION regress_rls_carol

SET row_security TO OFF

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

permission denied for table copy_rel_to

 --fail - permission denied
SET row_security TO ON

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

permission denied for table copy_rel_to

 --fail - permission denied

-- Check behavior with a child table.
RESET SESSION AUTHORIZATION

SET row_security TO ON

CREATE TABLE copy_rel_to_child () INHERITS (copy_rel_to)

INSERT INTO copy_rel_to_child VALUES (1, 'one'), (2, 'two')


-- Check COPY TO as Superuser/owner.
RESET SESSION AUTHORIZATION

SET row_security TO OFF

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead

SET row_security TO ON

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead


-- Check COPY TO as user with permissions.
SET SESSION AUTHORIZATION regress_rls_bob

SET row_security TO OFF

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

query would be affected by row-level security policy for table "copy_rel_to"

 --fail - would be affected by RLS
SET row_security TO ON

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead
 --ok

-- Check COPY TO as user with permissions and BYPASSRLS
SET SESSION AUTHORIZATION regress_rls_exempt_user

SET row_security TO OFF

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead
 --ok
SET row_security TO ON

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

can't execute COPY TO: use the copy_to() method instead
 --ok

-- Check COPY TO as user without permissions. SET row_security TO OFF /* REPLACED */,
SET SESSION AUTHORIZATION regress_rls_carol

SET row_security TO OFF

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

permission denied for table copy_rel_to

 --fail - permission denied
SET row_security TO ON

COPY copy_rel_to TO STDOUT WITH DELIMITER ','
ProgrammingError: 
COPY copy_rel_to TO STDOUT WITH DELIMITER ','

permission denied for table copy_rel_to

 --fail - permission denied

-- Check COPY FROM as Superuser/owner.
RESET SESSION AUTHORIZATION

SET row_security TO OFF

COPY copy_t FROM STDIN
ProgrammingError: 
COPY copy_t FROM STDIN

can't execute COPY FROM: use the copy_from() method instead
 --ok
1	abc
2	bcd
3	cde
4	def
\.
SET row_security TO ON
ProgrammingError:  --ok
1	abc
2	bcd
3	cde
4	def
\.
SET row_security TO ON

syntax error at or near "1"
LINE 2: 1 abc
        ^


COPY copy_t FROM STDIN
ProgrammingError: 
COPY copy_t FROM STDIN

can't execute COPY FROM: use the copy_from() method instead
 --ok
1	abc
2	bcd
3	cde
4	def
\.

-- Check COPY FROM as user with permissions.
SET SESSION AUTHORIZATION regress_rls_bob
ProgrammingError:  --ok
1	abc
2	bcd
3	cde
4	def
\.

-- Check COPY FROM as user with permissions.
SET SESSION AUTHORIZATION regress_rls_bob

syntax error at or near "1"
LINE 2: 1 abc
        ^


SET row_security TO OFF

COPY copy_t FROM STDIN
ProgrammingError: 
COPY copy_t FROM STDIN

can't execute COPY FROM: use the copy_from() method instead
 --fail - would be affected by RLS.
SET row_security TO ON

COPY copy_t FROM STDIN
ProgrammingError: 
COPY copy_t FROM STDIN

can't execute COPY FROM: use the copy_from() method instead
 --fail - COPY FROM not supported by RLS.

-- Check COPY FROM as user with permissions and BYPASSRLS
SET SESSION AUTHORIZATION regress_rls_exempt_user

SET row_security TO ON

COPY copy_t FROM STDIN
ProgrammingError: 
COPY copy_t FROM STDIN

can't execute COPY FROM: use the copy_from() method instead
 --ok
1	abc
2	bcd
3	cde
4	def
\.

-- Check COPY FROM as user without permissions.
SET SESSION AUTHORIZATION regress_rls_carol
ProgrammingError:  --ok
1	abc
2	bcd
3	cde
4	def
\.

-- Check COPY FROM as user without permissions.
SET SESSION AUTHORIZATION regress_rls_carol

syntax error at or near "1"
LINE 2: 1 abc
        ^


SET row_security TO OFF

COPY copy_t FROM STDIN
ProgrammingError: 
COPY copy_t FROM STDIN

can't execute COPY FROM: use the copy_from() method instead
 --fail - permission denied.
SET row_security TO ON

COPY copy_t FROM STDIN
ProgrammingError: 
COPY copy_t FROM STDIN

can't execute COPY FROM: use the copy_from() method instead
 --fail - permission denied.

RESET SESSION AUTHORIZATION

DROP TABLE copy_t

DROP TABLE copy_rel_to CASCADE


-- Check WHERE CURRENT OF
SET SESSION AUTHORIZATION regress_rls_alice


CREATE TABLE current_check (currentid int, payload text, rlsuser text)

GRANT ALL ON current_check TO PUBLIC


INSERT INTO current_check VALUES
    (1, 'abc', 'regress_rls_bob'),
    (2, 'bcd', 'regress_rls_bob'),
    (3, 'cde', 'regress_rls_bob'),
    (4, 'def', 'regress_rls_bob')


CREATE POLICY p1 ON current_check FOR SELECT USING (currentid % 2 = 0)

CREATE POLICY p2 ON current_check FOR DELETE USING (currentid = 4 AND rlsuser = current_user)

CREATE POLICY p3 ON current_check FOR UPDATE USING (currentid = 4) WITH CHECK (rlsuser = current_user)


ALTER TABLE current_check ENABLE ROW LEVEL SECURITY


SET SESSION AUTHORIZATION regress_rls_bob


-- Can SELECT even rows
SELECT * FROM current_check
RESULT: 
	[(2, 'bcd', 'regress_rls_bob'), (4, 'def', 'regress_rls_bob')]


-- Cannot UPDATE row 2
UPDATE current_check SET payload = payload || '_new' WHERE currentid = 2 RETURNING *
RESULT: 
	[]


BEGIN


DECLARE current_check_cursor SCROLL CURSOR FOR SELECT * FROM current_check

-- Returns rows that can be seen according to SELECT policy, like plain SELECT
-- above (even rows)
FETCH ABSOLUTE 1 FROM current_check_cursor
RESULT: 
	[(2, 'bcd', 'regress_rls_bob')]

-- Still cannot UPDATE row 2 through cursor
UPDATE current_check SET payload = payload || '_new' WHERE CURRENT OF current_check_cursor RETURNING *
RESULT: 
	[]

-- Can update row 4 through cursor, which is the next visible row
FETCH RELATIVE 1 FROM current_check_cursor
RESULT: 
	[(4, 'def', 'regress_rls_bob')]

UPDATE current_check SET payload = payload || '_new' WHERE CURRENT OF current_check_cursor RETURNING *
RESULT: 
	[(4, 'def_new', 'regress_rls_bob')]

SELECT * FROM current_check
RESULT: 
	[(2, 'bcd', 'regress_rls_bob'), (4, 'def_new', 'regress_rls_bob')]

-- Plan should be a subquery TID scan
EXPLAIN (COSTS OFF) UPDATE current_check SET payload = payload WHERE CURRENT OF current_check_cursor
RESULT: 
	[('Update on current_check',), ('  ->  Tid Scan on current_check',), ('        TID Cond: CURRENT OF current_check_cursor',), ('        Filter: ((currentid = 4) AND ((currentid % 2) = 0))',)]

-- Similarly can only delete row 4
FETCH ABSOLUTE 1 FROM current_check_cursor
RESULT: 
	[(2, 'bcd', 'regress_rls_bob')]

DELETE FROM current_check WHERE CURRENT OF current_check_cursor RETURNING *
RESULT: 
	[]

FETCH RELATIVE 1 FROM current_check_cursor
RESULT: 
	[(4, 'def', 'regress_rls_bob')]

DELETE FROM current_check WHERE CURRENT OF current_check_cursor RETURNING *
RESULT: 
	[(4, 'def_new', 'regress_rls_bob')]

SELECT * FROM current_check
RESULT: 
	[(2, 'bcd', 'regress_rls_bob')]


COMMIT


--
-- check pg_stats view filtering
--
SET row_security TO ON

SET SESSION AUTHORIZATION regress_rls_alice

ANALYZE current_check

-- Stats visible
SELECT row_security_active('current_check')
RESULT: 
	[(False,)]

SELECT attname, most_common_vals FROM pg_stats
  WHERE tablename = 'current_check'
  ORDER BY 1
RESULT: 
	[('currentid', None), ('payload', None), ('rlsuser', '{regress_rls_bob}')]


SET SESSION AUTHORIZATION regress_rls_bob

-- Stats not visible
SELECT row_security_active('current_check')
RESULT: 
	[(True,)]

SELECT attname, most_common_vals FROM pg_stats
  WHERE tablename = 'current_check'
  ORDER BY 1
RESULT: 
	[]


--
-- Collation support
--
BEGIN

CREATE TABLE coll_t (c) AS VALUES ('bar'::text)

CREATE POLICY coll_p ON coll_t USING (c < ('foo'::text COLLATE "C"))

ALTER TABLE coll_t ENABLE ROW LEVEL SECURITY

GRANT SELECT ON coll_t TO regress_rls_alice

SELECT (string_to_array(polqual, ':'))[7] AS inputcollid FROM pg_policy WHERE polrelid = 'coll_t'::regclass
RESULT: 
	[('inputcollid 950 ',)]

SET SESSION AUTHORIZATION regress_rls_alice

SELECT * FROM coll_t
RESULT: 
	[('bar',)]

ROLLBACK


--
-- Shared Object Dependencies
--
RESET SESSION AUTHORIZATION

BEGIN

CREATE ROLE regress_rls_eve

CREATE ROLE regress_rls_frank

CREATE TABLE tbl1 (c) AS VALUES ('bar'::text)

GRANT SELECT ON TABLE tbl1 TO regress_rls_eve

CREATE POLICY P ON tbl1 TO regress_rls_eve, regress_rls_frank USING (true)

SELECT refclassid::regclass, deptype
  FROM pg_depend
  WHERE classid = 'pg_policy'::regclass
  AND refobjid = 'tbl1'::regclass
RESULT: 
	[('pg_class', 'a')]

SELECT refclassid::regclass, deptype
  FROM pg_shdepend
  WHERE classid = 'pg_policy'::regclass
  AND refobjid IN ('regress_rls_eve'::regrole, 'regress_rls_frank'::regrole)
RESULT: 
	[('pg_authid', 'r'), ('pg_authid', 'r')]


SAVEPOINT q

DROP ROLE regress_rls_eve
ERROR: 
DROP ROLE regress_rls_eve

role "regress_rls_eve" cannot be dropped because some objects depend on it
DETAIL:  privileges for table tbl1
target of policy p on table tbl1

 --fails due to dependency on POLICY p
ROLLBACK TO q


ALTER POLICY p ON tbl1 TO regress_rls_frank USING (true)

SAVEPOINT q

DROP ROLE regress_rls_eve
ERROR: 
DROP ROLE regress_rls_eve

role "regress_rls_eve" cannot be dropped because some objects depend on it
DETAIL:  privileges for table tbl1

 --fails due to dependency on GRANT SELECT
ROLLBACK TO q


REVOKE ALL ON TABLE tbl1 FROM regress_rls_eve

SAVEPOINT q

DROP ROLE regress_rls_eve
 --succeeds
ROLLBACK TO q


SAVEPOINT q

DROP ROLE regress_rls_frank
ERROR: 
DROP ROLE regress_rls_frank

role "regress_rls_frank" cannot be dropped because some objects depend on it
DETAIL:  target of policy p on table tbl1

 --fails due to dependency on POLICY p
ROLLBACK TO q


DROP POLICY p ON tbl1

SAVEPOINT q

DROP ROLE regress_rls_frank
 -- succeeds
ROLLBACK TO q


ROLLBACK
 -- cleanup

--
-- Policy expression handling
--
BEGIN

CREATE TABLE t (c) AS VALUES ('bar'::text)

CREATE POLICY p ON t USING (max(c))
ProgrammingError: 
CREATE POLICY p ON t USING (max(c))

aggregate functions are not allowed in policy expressions

 -- fails: aggregate functions are not allowed in policy expressions
ROLLBACK


--
-- Non-target relations are only subject to SELECT policies
--
SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE r1 (a int)

CREATE TABLE r2 (a int)

INSERT INTO r1 VALUES (10), (20)

INSERT INTO r2 VALUES (10), (20)


GRANT ALL ON r1, r2 TO regress_rls_bob


CREATE POLICY p1 ON r1 USING (true)

ALTER TABLE r1 ENABLE ROW LEVEL SECURITY


CREATE POLICY p1 ON r2 FOR SELECT USING (true)

CREATE POLICY p2 ON r2 FOR INSERT WITH CHECK (false)

CREATE POLICY p3 ON r2 FOR UPDATE USING (false)

CREATE POLICY p4 ON r2 FOR DELETE USING (false)

ALTER TABLE r2 ENABLE ROW LEVEL SECURITY


SET SESSION AUTHORIZATION regress_rls_bob

SELECT * FROM r1
RESULT: 
	[(10,), (20,)]

SELECT * FROM r2
RESULT: 
	[(10,), (20,)]


-- r2 is read-only
INSERT INTO r2 VALUES (2)
ProgrammingError: 

-- r2 is read-only
INSERT INTO r2 VALUES (2)

new row violates row-level security policy for table "r2"

 -- Not allowed
UPDATE r2 SET a = 2 RETURNING *
RESULT: 
	[]
 -- Updates nothing
DELETE FROM r2 RETURNING *
RESULT: 
	[]
 -- Deletes nothing

-- r2 can be used as a non-target relation in DML
INSERT INTO r1 SELECT a + 1 FROM r2 RETURNING *
RESULT: 
	[(11,), (21,)]
 -- OK
UPDATE r1 SET a = r2.a + 2 FROM r2 WHERE r1.a = r2.a RETURNING *
RESULT: 
	[(12, 10), (22, 20)]
 -- OK
DELETE FROM r1 USING r2 WHERE r1.a = r2.a + 2 RETURNING *
RESULT: 
	[(12, 10), (22, 20)]
 -- OK
SELECT * FROM r1
RESULT: 
	[(11,), (21,)]

SELECT * FROM r2
RESULT: 
	[(10,), (20,)]


SET SESSION AUTHORIZATION regress_rls_alice

DROP TABLE r1

DROP TABLE r2


--
-- FORCE ROW LEVEL SECURITY applies RLS to owners too
--
SET SESSION AUTHORIZATION regress_rls_alice

SET row_security = on

CREATE TABLE r1 (a int)

INSERT INTO r1 VALUES (10), (20)


CREATE POLICY p1 ON r1 USING (false)

ALTER TABLE r1 ENABLE ROW LEVEL SECURITY

ALTER TABLE r1 FORCE ROW LEVEL SECURITY


-- No error, but no rows
TABLE r1
RESULT: 
	[]


-- RLS error
INSERT INTO r1 VALUES (1)
ProgrammingError: 

-- RLS error
INSERT INTO r1 VALUES (1)

new row violates row-level security policy for table "r1"



-- No error (unable to see any rows to update)
UPDATE r1 SET a = 1

TABLE r1
RESULT: 
	[]


-- No error (unable to see any rows to delete)
DELETE FROM r1

TABLE r1
RESULT: 
	[]


SET row_security = off

-- these all fail, would be affected by RLS
TABLE r1
ProgrammingError: 
-- these all fail, would be affected by RLS
TABLE r1

query would be affected by row-level security policy for table "r1"
HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.


UPDATE r1 SET a = 1
ProgrammingError: 
UPDATE r1 SET a = 1

query would be affected by row-level security policy for table "r1"
HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.


DELETE FROM r1
ProgrammingError: 
DELETE FROM r1

query would be affected by row-level security policy for table "r1"
HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.



DROP TABLE r1


--
-- FORCE ROW LEVEL SECURITY does not break RI
--
SET SESSION AUTHORIZATION regress_rls_alice

SET row_security = on

CREATE TABLE r1 (a int PRIMARY KEY)

CREATE TABLE r2 (a int REFERENCES r1)

INSERT INTO r1 VALUES (10), (20)

INSERT INTO r2 VALUES (10), (20)


-- Create policies on r2 which prevent the
-- owner from seeing any rows, but RI should
-- still see them.
CREATE POLICY p1 ON r2 USING (false)

ALTER TABLE r2 ENABLE ROW LEVEL SECURITY

ALTER TABLE r2 FORCE ROW LEVEL SECURITY


-- Errors due to rows in r2
DELETE FROM r1
ERROR: 

-- Errors due to rows in r2
DELETE FROM r1

update or delete on table "r1" violates foreign key constraint "r2_a_fkey" on table "r2"
DETAIL:  Key (a)=(10) is still referenced from table "r2".



-- Reset r2 to no-RLS
DROP POLICY p1 ON r2

ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY

ALTER TABLE r2 DISABLE ROW LEVEL SECURITY


-- clean out r2 for INSERT test below
DELETE FROM r2


-- Change r1 to not allow rows to be seen
CREATE POLICY p1 ON r1 USING (false)

ALTER TABLE r1 ENABLE ROW LEVEL SECURITY

ALTER TABLE r1 FORCE ROW LEVEL SECURITY


-- No rows seen
TABLE r1
RESULT: 
	[]


-- No error, RI still sees that row exists in r1
INSERT INTO r2 VALUES (10)


DROP TABLE r2

DROP TABLE r1


-- Ensure cascaded DELETE works
CREATE TABLE r1 (a int PRIMARY KEY)

CREATE TABLE r2 (a int REFERENCES r1 ON DELETE CASCADE)

INSERT INTO r1 VALUES (10), (20)

INSERT INTO r2 VALUES (10), (20)


-- Create policies on r2 which prevent the
-- owner from seeing any rows, but RI should
-- still see them.
CREATE POLICY p1 ON r2 USING (false)

ALTER TABLE r2 ENABLE ROW LEVEL SECURITY

ALTER TABLE r2 FORCE ROW LEVEL SECURITY


-- Deletes all records from both
DELETE FROM r1


-- Remove FORCE from r2
ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY


-- As owner, we now bypass RLS
-- verify no rows in r2 now
TABLE r2
RESULT: 
	[]


DROP TABLE r2

DROP TABLE r1


-- Ensure cascaded UPDATE works
CREATE TABLE r1 (a int PRIMARY KEY)

CREATE TABLE r2 (a int REFERENCES r1 ON UPDATE CASCADE)

INSERT INTO r1 VALUES (10), (20)

INSERT INTO r2 VALUES (10), (20)


-- Create policies on r2 which prevent the
-- owner from seeing any rows, but RI should
-- still see them.
CREATE POLICY p1 ON r2 USING (false)

ALTER TABLE r2 ENABLE ROW LEVEL SECURITY

ALTER TABLE r2 FORCE ROW LEVEL SECURITY


-- Updates records in both
UPDATE r1 SET a = a+5


-- Remove FORCE from r2
ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY


-- As owner, we now bypass RLS
-- verify records in r2 updated
TABLE r2
RESULT: 
	[(15,), (25,)]


DROP TABLE r2

DROP TABLE r1


--
-- Test INSERT+RETURNING applies SELECT policies as
-- WithCheckOptions (meaning an error is thrown)
--
SET SESSION AUTHORIZATION regress_rls_alice

SET row_security = on

CREATE TABLE r1 (a int)


CREATE POLICY p1 ON r1 FOR SELECT USING (false)

CREATE POLICY p2 ON r1 FOR INSERT WITH CHECK (true)

ALTER TABLE r1 ENABLE ROW LEVEL SECURITY

ALTER TABLE r1 FORCE ROW LEVEL SECURITY


-- Works fine
INSERT INTO r1 VALUES (10), (20)


-- No error, but no rows
TABLE r1
RESULT: 
	[]


SET row_security = off

-- fail, would be affected by RLS
TABLE r1
ProgrammingError: 
-- fail, would be affected by RLS
TABLE r1

query would be affected by row-level security policy for table "r1"
HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.



SET row_security = on


-- Error
INSERT INTO r1 VALUES (10), (20) RETURNING *
ProgrammingError: 

-- Error
INSERT INTO r1 VALUES (10), (20) RETURNING *

new row violates row-level security policy for table "r1"



DROP TABLE r1


--
-- Test UPDATE+RETURNING applies SELECT policies as
-- WithCheckOptions (meaning an error is thrown)
--
SET SESSION AUTHORIZATION regress_rls_alice

SET row_security = on

CREATE TABLE r1 (a int PRIMARY KEY)


CREATE POLICY p1 ON r1 FOR SELECT USING (a < 20)

CREATE POLICY p2 ON r1 FOR UPDATE USING (a < 20) WITH CHECK (true)

CREATE POLICY p3 ON r1 FOR INSERT WITH CHECK (true)

INSERT INTO r1 VALUES (10)

ALTER TABLE r1 ENABLE ROW LEVEL SECURITY

ALTER TABLE r1 FORCE ROW LEVEL SECURITY


-- Works fine
UPDATE r1 SET a = 30


-- Show updated rows
ALTER TABLE r1 NO FORCE ROW LEVEL SECURITY

TABLE r1
RESULT: 
	[(30,)]

-- reset value in r1 for test with RETURNING
UPDATE r1 SET a = 10


-- Verify row reset
TABLE r1
RESULT: 
	[(10,)]


ALTER TABLE r1 FORCE ROW LEVEL SECURITY


-- Error
UPDATE r1 SET a = 30 RETURNING *
ProgrammingError: 

-- Error
UPDATE r1 SET a = 30 RETURNING *

new row violates row-level security policy for table "r1"



-- UPDATE path of INSERT ... ON CONFLICT DO UPDATE should also error out
INSERT INTO r1 VALUES (10)
    ON CONFLICT (a) DO UPDATE SET a = 30 RETURNING *
ProgrammingError: 

-- UPDATE path of INSERT ... ON CONFLICT DO UPDATE should also error out
INSERT INTO r1 VALUES (10)
    ON CONFLICT (a) DO UPDATE SET a = 30 RETURNING *

new row violates row-level security policy for table "r1"



-- Should still error out without RETURNING (use of arbiter always requires
-- SELECT permissions)
INSERT INTO r1 VALUES (10)
    ON CONFLICT (a) DO UPDATE SET a = 30
ProgrammingError: 

-- Should still error out without RETURNING (use of arbiter always requires
-- SELECT permissions)
INSERT INTO r1 VALUES (10)
    ON CONFLICT (a) DO UPDATE SET a = 30

new row violates row-level security policy for table "r1"


INSERT INTO r1 VALUES (10)
    ON CONFLICT ON CONSTRAINT r1_pkey DO UPDATE SET a = 30
ProgrammingError: 
INSERT INTO r1 VALUES (10)
    ON CONFLICT ON CONSTRAINT r1_pkey DO UPDATE SET a = 30

new row violates row-level security policy for table "r1"



DROP TABLE r1


-- Check dependency handling
RESET SESSION AUTHORIZATION

CREATE TABLE dep1 (c1 int)

CREATE TABLE dep2 (c1 int)


CREATE POLICY dep_p1 ON dep1 TO regress_rls_bob USING (c1 > (select max(dep2.c1) from dep2))

ALTER POLICY dep_p1 ON dep1 TO regress_rls_bob,regress_rls_carol


-- Should return one
SELECT count(*) = 1 FROM pg_depend
				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
					 AND refobjid = (SELECT oid FROM pg_class WHERE relname = 'dep2')
RESULT: 
	[(True,)]


ALTER POLICY dep_p1 ON dep1 USING (true)


-- Should return one
SELECT count(*) = 1 FROM pg_shdepend
				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
					 AND refobjid = (SELECT oid FROM pg_authid WHERE rolname = 'regress_rls_bob')
RESULT: 
	[(True,)]


-- Should return one
SELECT count(*) = 1 FROM pg_shdepend
				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
					 AND refobjid = (SELECT oid FROM pg_authid WHERE rolname = 'regress_rls_carol')
RESULT: 
	[(True,)]


-- Should return zero
SELECT count(*) = 0 FROM pg_depend
				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
					 AND refobjid = (SELECT oid FROM pg_class WHERE relname = 'dep2')
RESULT: 
	[(True,)]


-- DROP OWNED BY testing
RESET SESSION AUTHORIZATION


CREATE ROLE regress_rls_dob_role1

CREATE ROLE regress_rls_dob_role2


CREATE TABLE dob_t1 (c1 int)

CREATE TABLE dob_t2 (c1 int) PARTITION BY RANGE (c1)


CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1 USING (true)

DROP OWNED BY regress_rls_dob_role1

DROP POLICY p1 ON dob_t1
ProgrammingError: 
DROP POLICY p1 ON dob_t1

policy "p1" for table "dob_t1" does not exist

 -- should fail, already gone

CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true)

DROP OWNED BY regress_rls_dob_role1

DROP POLICY p1 ON dob_t1
 -- should succeed

-- same cases with duplicate polroles entries
CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role1 USING (true)

DROP OWNED BY regress_rls_dob_role1

DROP POLICY p1 ON dob_t1
ProgrammingError: 
DROP POLICY p1 ON dob_t1

policy "p1" for table "dob_t1" does not exist

 -- should fail, already gone

CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role1,regress_rls_dob_role2 USING (true)

DROP OWNED BY regress_rls_dob_role1

DROP POLICY p1 ON dob_t1
 -- should succeed

-- partitioned target
CREATE POLICY p1 ON dob_t2 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true)

DROP OWNED BY regress_rls_dob_role1

DROP POLICY p1 ON dob_t2
 -- should succeed

DROP USER regress_rls_dob_role1

DROP USER regress_rls_dob_role2


-- Bug #15708: view + table with RLS should check policies as view owner
CREATE TABLE ref_tbl (a int)

INSERT INTO ref_tbl VALUES (1)


CREATE TABLE rls_tbl (a int)

INSERT INTO rls_tbl VALUES (10)

ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY

CREATE POLICY p1 ON rls_tbl USING (EXISTS (SELECT 1 FROM ref_tbl))


GRANT SELECT ON ref_tbl TO regress_rls_bob

GRANT SELECT ON rls_tbl TO regress_rls_bob


CREATE VIEW rls_view AS SELECT * FROM rls_tbl

ALTER VIEW rls_view OWNER TO regress_rls_bob

GRANT SELECT ON rls_view TO regress_rls_alice


SET SESSION AUTHORIZATION regress_rls_alice

SELECT * FROM ref_tbl
ProgrammingError: 
SELECT * FROM ref_tbl

permission denied for table ref_tbl

 -- Permission denied
SELECT * FROM rls_tbl
ProgrammingError:  -- Permission denied
SELECT * FROM rls_tbl

permission denied for table rls_tbl

 -- Permission denied
SELECT * FROM rls_view
RESULT: 
	[(10,)]
 -- OK
RESET SESSION AUTHORIZATION


DROP VIEW rls_view

DROP TABLE rls_tbl

DROP TABLE ref_tbl


-- Leaky operator test
CREATE TABLE rls_tbl (a int)

INSERT INTO rls_tbl SELECT x/10 FROM generate_series(1, 100) x

ANALYZE rls_tbl


ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY

GRANT SELECT ON rls_tbl TO regress_rls_alice


SET SESSION AUTHORIZATION regress_rls_alice

CREATE FUNCTION op_leak(int, int) RETURNS bool
    AS 'BEGIN RAISE NOTICE ''op_leak => %, %'', $1, $2; RETURN $1 < $2; END'
    LANGUAGE plpgsql

CREATE OPERATOR <<< (procedure = op_leak, leftarg = int, rightarg = int,
                     restrict = scalarltsel)

SELECT * FROM rls_tbl WHERE a <<< 1000
RESULT: 
	[]

DROP OPERATOR <<< (int, int)

DROP FUNCTION op_leak(int, int)

RESET SESSION AUTHORIZATION

DROP TABLE rls_tbl


-- Bug #16006: whole-row Vars in a policy don''t play nice with sub-selects
SET SESSION AUTHORIZATION regress_rls_alice

CREATE TABLE rls_tbl (a int, b int, c int)

CREATE POLICY p1 ON rls_tbl USING (rls_tbl >= ROW(1,1,1))


ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY

ALTER TABLE rls_tbl FORCE ROW LEVEL SECURITY


INSERT INTO rls_tbl SELECT 10, 20, 30

EXPLAIN (VERBOSE, COSTS OFF)
INSERT INTO rls_tbl
  SELECT * FROM (SELECT b, c FROM rls_tbl ORDER BY a) ss
RESULT: 
	[('Insert on regress_rls_schema.rls_tbl',), ('  ->  Subquery Scan on ss',), ('        Output: ss.b, ss.c, NULL::integer',), ('        ->  Sort',), ('              Output: rls_tbl_1.b, rls_tbl_1.c, rls_tbl_1.a',), ('              Sort Key: rls_tbl_1.a',), ('              ->  Seq Scan on regress_rls_schema.rls_tbl rls_tbl_1',), ('                    Output: rls_tbl_1.b, rls_tbl_1.c, rls_tbl_1.a',), ("                    Filter: (rls_tbl_1.* >= '(1,1,1)'::record)",)]

INSERT INTO rls_tbl
  SELECT * FROM (SELECT b, c FROM rls_tbl ORDER BY a) ss

SELECT * FROM rls_tbl
RESULT: 
	[(10, 20, 30), (20, 30, None)]


DROP TABLE rls_tbl

RESET SESSION AUTHORIZATION


-- CVE-2023-2455: inlining an SRF may introduce an RLS dependency
create table rls_t (c text)

insert into rls_t values ('invisible to bob')

alter table rls_t enable row level security

grant select on rls_t to regress_rls_alice, regress_rls_bob

create policy p1 on rls_t for select to regress_rls_alice using (true)

create policy p2 on rls_t for select to regress_rls_bob using (false)

create function rls_f () returns setof rls_t
  stable language sql
  as $$ select * from rls_t $$

prepare q as select current_user, * from rls_f()

set role regress_rls_alice

execute q
RESULT: 
	[('regress_rls_alice', 'invisible to bob')]

set role regress_rls_bob

execute q
RESULT: 
	[]


RESET ROLE

DROP FUNCTION rls_f()

DROP TABLE rls_t


--
-- Clean up objects
--
RESET SESSION AUTHORIZATION


DROP SCHEMA regress_rls_schema CASCADE


DROP USER regress_rls_alice

DROP USER regress_rls_bob

DROP USER regress_rls_carol

DROP USER regress_rls_dave

DROP USER regress_rls_exempt_user

DROP ROLE regress_rls_group1

DROP ROLE regress_rls_group2


-- Arrange to have a few policies left over, for testing
-- pg_dump/pg_restore
CREATE SCHEMA regress_rls_schema

CREATE TABLE rls_tbl (c1 int)

ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY

CREATE POLICY p1 ON rls_tbl USING (c1 > 5)

CREATE POLICY p2 ON rls_tbl FOR SELECT USING (c1 <= 3)

CREATE POLICY p3 ON rls_tbl FOR UPDATE USING (c1 <= 3) WITH CHECK (c1 > 5)

CREATE POLICY p4 ON rls_tbl FOR DELETE USING (c1 <= 3)


CREATE TABLE rls_tbl_force (c1 int)

ALTER TABLE rls_tbl_force ENABLE ROW LEVEL SECURITY

ALTER TABLE rls_tbl_force FORCE ROW LEVEL SECURITY

CREATE POLICY p1 ON rls_tbl_force USING (c1 = 5) WITH CHECK (c1 < 5)

CREATE POLICY p2 ON rls_tbl_force FOR SELECT USING (c1 = 8)

CREATE POLICY p3 ON rls_tbl_force FOR UPDATE USING (c1 = 8) WITH CHECK (c1 >= 5)

CREATE POLICY p4 ON rls_tbl_force FOR DELETE USING (c1 = 8)


