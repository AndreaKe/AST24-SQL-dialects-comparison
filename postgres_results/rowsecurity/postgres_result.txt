
-----------
QUERY:
--
-- Test of Row-level security feature
--

-- Clean up in case a prior regression run failed

-- Suppress NOTICE messages when users/groups don/* REPLACED */ ''t exist
SET client_min_messages TO 'warning';
RESULT:
	[]

-----------
QUERY:


DROP USER IF EXISTS regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

DROP USER IF EXISTS regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

DROP USER IF EXISTS regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

DROP USER IF EXISTS regress_rls_dave;
RESULT:
	[]

-----------
QUERY:

DROP USER IF EXISTS regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:

DROP ROLE IF EXISTS regress_rls_group1;
RESULT:
	[]

-----------
QUERY:

DROP ROLE IF EXISTS regress_rls_group2;
RESULT:
	[]

-----------
QUERY:


DROP SCHEMA IF EXISTS regress_rls_schema CASCADE;
RESULT:
	[]

-----------
QUERY:


RESET client_min_messages;
RESULT:
	[]

-----------
QUERY:


-- initial setup
CREATE USER regress_rls_alice NOLOGIN;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_rls_bob NOLOGIN;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_rls_carol NOLOGIN;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_rls_dave NOLOGIN;
RESULT:
	[]

-----------
QUERY:

CREATE USER regress_rls_exempt_user BYPASSRLS NOLOGIN;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_rls_group1 NOLOGIN;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_rls_group2 NOLOGIN;
RESULT:
	[]

-----------
QUERY:


GRANT regress_rls_group1 TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

GRANT regress_rls_group2 TO regress_rls_carol;
RESULT:
	[]

-----------
QUERY:


CREATE SCHEMA regress_rls_schema;
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON SCHEMA regress_rls_schema to public;
RESULT:
	[]

-----------
QUERY:

SET search_path = regress_rls_schema;
RESULT:
	[]

-----------
QUERY:


-- setup of malicious function
CREATE OR REPLACE FUNCTION f_leak(text) RETURNS bool
    COST 0.0000001 LANGUAGE plpgsql
    AS 'BEGIN RAISE NOTICE ''f_leak => %'', $1;
RESULT:
	ERROR - unterminated quoted string at or near "'BEGIN RAISE NOTICE ''f_leak => %'', $1;"
LINE 6:     AS 'BEGIN RAISE NOTICE ''f_leak => %'', $1;
               ^


-----------
QUERY:
 RETURN true;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 1:  RETURN true;
         ^


-----------
QUERY:
 END';
RESULT:
	ERROR - unterminated quoted string at or near "';"
LINE 1:  END';
            ^


-----------
QUERY:

GRANT EXECUTE ON FUNCTION f_leak(text) TO public;
RESULT:
	ERROR - function f_leak(text) does not exist


-----------
QUERY:


-- BASIC Row-Level Security Scenario

SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE uaccount (
    pguser      name primary key,
    seclv       int
);
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON uaccount TO public;
RESULT:
	[]

-----------
QUERY:

INSERT INTO uaccount VALUES
    ('regress_rls_alice', 99),
    ('regress_rls_bob', 1),
    ('regress_rls_carol', 2),
    ('regress_rls_dave', 3);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE category (
    cid        int primary key,
    cname      text
);
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON category TO public;
RESULT:
	[]

-----------
QUERY:

INSERT INTO category VALUES
    (11, 'novel'),
    (22, 'science fiction'),
    (33, 'technology'),
    (44, 'manga');
RESULT:
	[]

-----------
QUERY:


CREATE TABLE document (
    did         int primary key,
    cid         int references category(cid),
    dlevel      int not null,
    dauthor     name,
    dtitle      text
);
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON document TO public;
RESULT:
	[]

-----------
QUERY:

INSERT INTO document VALUES
    ( 1, 11, 1, 'regress_rls_bob', 'my first novel'),
    ( 2, 11, 2, 'regress_rls_bob', 'my second novel'),
    ( 3, 22, 2, 'regress_rls_bob', 'my science fiction'),
    ( 4, 44, 1, 'regress_rls_bob', 'my first manga'),
    ( 5, 44, 2, 'regress_rls_bob', 'my second manga'),
    ( 6, 22, 1, 'regress_rls_carol', 'great science fiction'),
    ( 7, 33, 2, 'regress_rls_carol', 'great technology book'),
    ( 8, 44, 1, 'regress_rls_carol', 'great manga'),
    ( 9, 22, 1, 'regress_rls_dave', 'awesome science fiction'),
    (10, 33, 2, 'regress_rls_dave', 'awesome technology book');
RESULT:
	[]

-----------
QUERY:


ALTER TABLE document ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- user/* REPLACED */ ''s security level must be higher than or equal to document/* REPLACED */ ''s
CREATE POLICY p1 ON document AS PERMISSIVE
    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
RESULT:
	[]

-----------
QUERY:


-- try to create a policy of bogus type
CREATE POLICY p1 ON document AS UGLY
    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
RESULT:
	ERROR - unrecognized row security option "ugly"
LINE 4: CREATE POLICY p1 ON document AS UGLY
                                        ^
HINT:  Only PERMISSIVE or RESTRICTIVE policies are supported currently.


-----------
QUERY:


-- but Dave isn/* REPLACED */ ''t allowed to anything at cid 50 or above
-- this is to make sure that we sort the policies by name first
-- when applying WITH CHECK, a later INSERT by Dave should fail due
-- to p1r first
CREATE POLICY p2r ON document AS RESTRICTIVE TO regress_rls_dave
    USING (cid <> 44 AND cid < 50);
RESULT:
	[]

-----------
QUERY:


-- and Dave isn/* REPLACED */ ''t allowed to see manga documents
CREATE POLICY p1r ON document AS RESTRICTIVE TO regress_rls_dave
    USING (cid <> 44);
RESULT:
	[]

-----------
QUERY:


-- \dp
-- \d document
SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename = 'document' ORDER BY policyname;
RESULT:
	[('regress_rls_schema', 'document', 'p1', 'PERMISSIVE', ['public'], 'ALL', '(dlevel <= ( SELECT uaccount.seclv\n   FROM uaccount\n  WHERE (uaccount.pguser = CURRENT_USER)))', None), ('regress_rls_schema', 'document', 'p1r', 'RESTRICTIVE', ['regress_rls_dave'], 'ALL', '(cid <> 44)', None), ('regress_rls_schema', 'document', 'p2r', 'RESTRICTIVE', ['regress_rls_dave'], 'ALL', '((cid <> 44) AND (cid < 50))', None)]

-----------
QUERY:


-- viewpoint from regress_rls_bob
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
                                     ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...ELECT * FROM document NATURAL JOIN category WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- try a sampled version
SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)
  WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 5:   WHERE f_leak(dtitle) ORDER BY did;
                ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- viewpoint from regress_rls_carol
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
                                     ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...ELECT * FROM document NATURAL JOIN category WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- try a sampled version
SELECT * FROM document TABLESAMPLE BERNOULLI(50) REPEATABLE(0)
  WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 5:   WHERE f_leak(dtitle) ORDER BY did;
                ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtit...
                                                         ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...ELECT * FROM document NATURAL JOIN category WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- viewpoint from regress_rls_dave
SET SESSION AUTHORIZATION regress_rls_dave;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
                                     ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...ELECT * FROM document NATURAL JOIN category WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtit...
                                                         ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...ELECT * FROM document NATURAL JOIN category WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- 44 would technically fail for both p2r and p1r, but we should get an error
-- back from p1r for this because it sorts first
INSERT INTO document VALUES (100, 44, 1, 'regress_rls_dave', 'testing sorting of policies');
RESULT:
	ERROR - new row violates row-level security policy "p1r" for table "document"


-----------
QUERY:
 -- fail
-- Just to see a p2r error
INSERT INTO document VALUES (100, 55, 1, 'regress_rls_dave', 'testing sorting of policies');
RESULT:
	ERROR - new row violates row-level security policy "p2r" for table "document"


-----------
QUERY:
 -- fail

-- only owner can change policies
ALTER POLICY p1 ON document USING (true);
RESULT:
	ERROR - must be owner of table document


-----------
QUERY:
    --fail
DROP POLICY p1 ON document;
RESULT:
	ERROR - must be owner of relation document


-----------
QUERY:
                  --fail

SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

ALTER POLICY p1 ON document USING (dauthor = current_user);
RESULT:
	[]

-----------
QUERY:


-- viewpoint from regress_rls_bob again
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
                                     ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...ELECT * FROM document NATURAL JOIN category WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- viewpoint from rls_regres_carol again
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM document WHERE f_leak(dtitle) ORDER BY did;
                                     ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle) ORDER by did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...ELECT * FROM document NATURAL JOIN category WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: EXPLAIN (COSTS OFF) SELECT * FROM document WHERE f_leak(dtit...
                                                         ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM document NATURAL JOIN category WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...ELECT * FROM document NATURAL JOIN category WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- interaction of FK/PK constraints
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON category
    USING (CASE WHEN current_user = 'regress_rls_bob' THEN cid IN (11, 33)
           WHEN current_user = 'regress_rls_carol' THEN cid IN (22, 44)
           ELSE false END);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE category ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- cannot delete PK referenced by invisible FK
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid;
RESULT:
	[(1, 11, 1, 'regress_rls_bob', 'my first novel', 11, 'novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel', 11, 'novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction', None, None), (4, 44, 1, 'regress_rls_bob', 'my first manga', None, None), (5, 44, 2, 'regress_rls_bob', 'my second manga', None, None), (None, None, None, None, None, 33, 'technology')]

-----------
QUERY:

DELETE FROM category WHERE cid = 33;
RESULT:
	ERROR - update or delete on table "category" violates foreign key constraint "document_cid_fkey" on table "document"
DETAIL:  Key is still referenced from table "document".


-----------
QUERY:
    -- fails with FK violation

-- can insert FK referencing invisible PK
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document d FULL OUTER JOIN category c on d.cid = c.cid ORDER BY d.did, c.cid;
RESULT:
	[(6, 22, 1, 'regress_rls_carol', 'great science fiction', 22, 'science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book', None, None), (8, 44, 1, 'regress_rls_carol', 'great manga', 44, 'manga')]

-----------
QUERY:

INSERT INTO document VALUES (11, 33, 1, current_user, 'hoge');
RESULT:
	[]

-----------
QUERY:


-- UNIQUE or PRIMARY KEY constraint violation DOES reveal presence of row
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

INSERT INTO document VALUES (8, 44, 1, 'regress_rls_bob', 'my third manga');
RESULT:
	ERROR - duplicate key value violates unique constraint "document_pkey"


-----------
QUERY:
 -- Must fail with unique violation, revealing presence of did we can/* REPLACED */ ''t see
SELECT * FROM document WHERE did = 8;
RESULT:
	[]

-----------
QUERY:
 -- and confirm we can/* REPLACED */ ''t see it

-- RLS policies are checked before constraints
INSERT INTO document VALUES (8, 44, 1, 'regress_rls_carol', 'my third manga');
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:
 -- Should fail with RLS check violation, not duplicate key violation
UPDATE document SET did = 8, dauthor = 'regress_rls_carol' WHERE did = 5;
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:
 -- Should fail with RLS check violation, not duplicate key violation

-- database superuser does bypass RLS policy when enabled
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document;
RESULT:
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book'), (11, 33, 1, 'regress_rls_carol', 'hoge')]

-----------
QUERY:

SELECT * FROM category;
RESULT:
	[(11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga')]

-----------
QUERY:


-- database superuser does bypass RLS policy when disabled
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document;
RESULT:
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book'), (11, 33, 1, 'regress_rls_carol', 'hoge')]

-----------
QUERY:

SELECT * FROM category;
RESULT:
	[(11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga')]

-----------
QUERY:


-- database non-superuser with bypass privilege can bypass RLS policy when disabled
SET SESSION AUTHORIZATION regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document;
RESULT:
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book'), (11, 33, 1, 'regress_rls_carol', 'hoge')]

-----------
QUERY:

SELECT * FROM category;
RESULT:
	[(11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga')]

-----------
QUERY:


-- RLS policy does not apply to table owner when RLS enabled.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document;
RESULT:
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book'), (11, 33, 1, 'regress_rls_carol', 'hoge')]

-----------
QUERY:

SELECT * FROM category;
RESULT:
	[(11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga')]

-----------
QUERY:


-- RLS policy does not apply to table owner when RLS disabled.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document;
RESULT:
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 22, 2, 'regress_rls_bob', 'my science fiction'), (4, 44, 1, 'regress_rls_bob', 'my first manga'), (5, 44, 2, 'regress_rls_bob', 'my second manga'), (6, 22, 1, 'regress_rls_carol', 'great science fiction'), (7, 33, 2, 'regress_rls_carol', 'great technology book'), (8, 44, 1, 'regress_rls_carol', 'great manga'), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 33, 2, 'regress_rls_dave', 'awesome technology book'), (11, 33, 1, 'regress_rls_carol', 'hoge')]

-----------
QUERY:

SELECT * FROM category;
RESULT:
	[(11, 'novel'), (22, 'science fiction'), (33, 'technology'), (44, 'manga')]

-----------
QUERY:


--
-- Table inheritance and RLS policy
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:


SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE t1 (id int not null primary key, a int, junk1 text, b text);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE t1 DROP COLUMN junk1;
RESULT:
	[]

-----------
QUERY:
    -- just a disturbing factor
GRANT ALL ON t1 TO public;
RESULT:
	[]

-----------
QUERY:


COPY t1 FROM stdin WITH ;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:

101	1	aba
102	2	bbb
103	3	ccc
104	4	dad
-- \.

CREATE TABLE t2 (c float) INHERITS (t1);
RESULT:
	ERROR - syntax error at or near "101"
LINE 2: 101 1 aba
        ^


-----------
QUERY:

GRANT ALL ON t2 TO public;
RESULT:
	ERROR - relation "t2" does not exist


-----------
QUERY:


COPY t2 FROM stdin;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:

201	1	abc	1.1
202	2	bcd	2.2
203	3	cde	3.3
204	4	def	4.4
-- \.

CREATE TABLE t3 (id int not null primary key, c text, b text, a int);
RESULT:
	ERROR - syntax error at or near "201"
LINE 2: 201 1 abc 1.1
        ^


-----------
QUERY:

ALTER TABLE t3 INHERIT t1;
RESULT:
	ERROR - relation "t3" does not exist


-----------
QUERY:

GRANT ALL ON t3 TO public;
RESULT:
	ERROR - relation "t3" does not exist


-----------
QUERY:


COPY t3(id, a,b,c) FROM stdin;
RESULT:
	ERROR - relation "t3" does not exist


-----------
QUERY:

301	1	xxx	X
302	2	yyy	Y
303	3	zzz	Z
-- \.

CREATE POLICY p1 ON t1 FOR ALL TO PUBLIC USING (a % 2 = 0);
RESULT:
	ERROR - syntax error at or near "301"
LINE 2: 301 1 xxx X
        ^


-----------
QUERY:
 -- be even number
CREATE POLICY p2 ON t2 FOR ALL TO PUBLIC USING (a % 2 = 1);
RESULT:
	ERROR - relation "t2" does not exist


-----------
QUERY:
 -- be odd number

ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE t2 ENABLE ROW LEVEL SECURITY;
RESULT:
	ERROR - relation "t2" does not exist


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM t1;
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1;
RESULT:
	[('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


SELECT * FROM t1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: SELECT * FROM t1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- reference to system column
SELECT tableoid::regclass, * FROM t1;
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
RESULT:
	[('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


-- reference to whole-row reference
SELECT *, t1 FROM t1;
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT *, t1 FROM t1;
RESULT:
	[('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


-- for share/update lock
SELECT * FROM t1 FOR SHARE;
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1 FOR SHARE;
RESULT:
	[('LockRows',), ('  ->  Result',), ('        One-Time Filter: false',)]

-----------
QUERY:


SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b) FOR SHARE;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b) FOR SHA...
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- union all query
SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3;
RESULT:
	ERROR - relation "t2" does not exist
LINE 4: SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, ...
                                             ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT a, b, tableoid::regclass FROM t2 UNION ALL SELECT a, b, tableoid::regclass FROM t3;
RESULT:
	ERROR - relation "t2" does not exist
LINE 2: ... (COSTS OFF) SELECT a, b, tableoid::regclass FROM t2 UNION A...
                                                             ^


-----------
QUERY:


-- superuser is allowed to bypass RLS checks
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM t1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM t1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- non-superuser with bypass privilege can bypass RLS policy when disabled
SET SESSION AUTHORIZATION regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM t1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM t1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


--
-- Partitioned Tables
--

SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE part_document (
    did         int,
    cid         int,
    dlevel      int not null,
    dauthor     name,
    dtitle      text
) PARTITION BY RANGE (cid);
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON part_document TO public;
RESULT:
	[]

-----------
QUERY:


-- Create partitions for document categories
CREATE TABLE part_document_fiction PARTITION OF part_document FOR VALUES FROM (11) to (12);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_document_satire PARTITION OF part_document FOR VALUES FROM (55) to (56);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_document_nonfiction PARTITION OF part_document FOR VALUES FROM (99) to (100);
RESULT:
	[]

-----------
QUERY:


GRANT ALL ON part_document_fiction TO public;
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON part_document_satire TO public;
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON part_document_nonfiction TO public;
RESULT:
	[]

-----------
QUERY:


INSERT INTO part_document VALUES
    ( 1, 11, 1, 'regress_rls_bob', 'my first novel'),
    ( 2, 11, 2, 'regress_rls_bob', 'my second novel'),
    ( 3, 99, 2, 'regress_rls_bob', 'my science textbook'),
    ( 4, 55, 1, 'regress_rls_bob', 'my first satire'),
    ( 5, 99, 2, 'regress_rls_bob', 'my history book'),
    ( 6, 11, 1, 'regress_rls_carol', 'great science fiction'),
    ( 7, 99, 2, 'regress_rls_carol', 'great technology book'),
    ( 8, 55, 2, 'regress_rls_carol', 'great satire'),
    ( 9, 11, 1, 'regress_rls_dave', 'awesome science fiction'),
    (10, 99, 2, 'regress_rls_dave', 'awesome technology book');
RESULT:
	[]

-----------
QUERY:


ALTER TABLE part_document ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- Create policy on parent
-- user/* REPLACED */ ''s security level must be higher than or equal to document/* REPLACED */ ''s
CREATE POLICY pp1 ON part_document AS PERMISSIVE
    USING (dlevel <= (SELECT seclv FROM uaccount WHERE pguser = current_user));
RESULT:
	[]

-----------
QUERY:


-- Dave is only allowed to see cid < 55
CREATE POLICY pp1r ON part_document AS RESTRICTIVE TO regress_rls_dave
    USING (cid < 55);
RESULT:
	[]

-----------
QUERY:


-- \d+ part_document
SELECT * FROM pg_policies WHERE schemaname = 'regress_rls_schema' AND tablename like '%part_document%' ORDER BY policyname;
RESULT:
	[('regress_rls_schema', 'part_document', 'pp1', 'PERMISSIVE', ['public'], 'ALL', '(dlevel <= ( SELECT uaccount.seclv\n   FROM uaccount\n  WHERE (uaccount.pguser = CURRENT_USER)))', None), ('regress_rls_schema', 'part_document', 'pp1r', 'RESTRICTIVE', ['regress_rls_dave'], 'ALL', '(cid < 55)', None)]

-----------
QUERY:


-- viewpoint from regress_rls_bob
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY di...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...AIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- viewpoint from regress_rls_carol
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY di...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...AIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- viewpoint from regress_rls_dave
SET SESSION AUTHORIZATION regress_rls_dave;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY di...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...AIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- pp1 ERROR
INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_dave', 'testing pp1');
RESULT:
	ERROR - new row violates row-level security policy for table "part_document"


-----------
QUERY:
 -- fail
-- pp1r ERROR
INSERT INTO part_document VALUES (100, 99, 1, 'regress_rls_dave', 'testing pp1r');
RESULT:
	ERROR - new row violates row-level security policy "pp1r" for table "part_document"


-----------
QUERY:
 -- fail

-- Show that RLS policy does not apply for direct inserts to children
-- This should fail with RLS POLICY pp1r violation.
INSERT INTO part_document VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions');
RESULT:
	ERROR - new row violates row-level security policy "pp1r" for table "part_document"


-----------
QUERY:
 -- fail
-- But this should succeed.
INSERT INTO part_document_satire VALUES (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions');
RESULT:
	[]

-----------
QUERY:
 -- success
-- We still cannot see the row using the parent
SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY di...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

-- But we can if we look directly
SELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: SELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDE...
                                                 ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- Turn on RLS and create policy on child to show RLS is checked before constraints
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE part_document_satire ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY pp3 ON part_document_satire AS RESTRICTIVE
    USING (cid < 55);
RESULT:
	[]

-----------
QUERY:

-- This should fail with RLS violation now.
SET SESSION AUTHORIZATION regress_rls_dave;
RESULT:
	[]

-----------
QUERY:

INSERT INTO part_document_satire VALUES (101, 55, 1, 'regress_rls_dave', 'testing RLS with partitions');
RESULT:
	ERROR - new row violates row-level security policy for table "part_document_satire"


-----------
QUERY:
 -- fail
-- And now we cannot see directly into the partition either, due to RLS
SELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: SELECT * FROM part_document_satire WHERE f_leak(dtitle) ORDE...
                                                 ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

-- The parent looks same as before
-- viewpoint from regress_rls_dave
SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 4: SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY di...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...AIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- viewpoint from regress_rls_carol
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY di...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...AIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- only owner can change policies
ALTER POLICY pp1 ON part_document USING (true);
RESULT:
	ERROR - must be owner of table part_document


-----------
QUERY:
    --fail
DROP POLICY pp1 ON part_document;
RESULT:
	ERROR - must be owner of relation part_document


-----------
QUERY:
                  --fail

SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

ALTER POLICY pp1 ON part_document USING (dauthor = current_user);
RESULT:
	[]

-----------
QUERY:


-- viewpoint from regress_rls_bob again
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY di...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- viewpoint from rls_regres_carol again
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY did;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM part_document WHERE f_leak(dtitle) ORDER BY di...
                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


EXPLAIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dtitle);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: ...AIN (COSTS OFF) SELECT * FROM part_document WHERE f_leak(dti...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- database superuser does bypass RLS policy when enabled
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM part_document ORDER BY did;
RESULT:
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 99, 2, 'regress_rls_bob', 'my science textbook'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (5, 99, 2, 'regress_rls_bob', 'my history book'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (7, 99, 2, 'regress_rls_carol', 'great technology book'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 99, 2, 'regress_rls_dave', 'awesome technology book'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]

-----------
QUERY:

SELECT * FROM part_document_satire ORDER by did;
RESULT:
	[(4, 55, 1, 'regress_rls_bob', 'my first satire'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]

-----------
QUERY:


-- database non-superuser with bypass privilege can bypass RLS policy when disabled
SET SESSION AUTHORIZATION regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM part_document ORDER BY did;
RESULT:
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 99, 2, 'regress_rls_bob', 'my science textbook'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (5, 99, 2, 'regress_rls_bob', 'my history book'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (7, 99, 2, 'regress_rls_carol', 'great technology book'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 99, 2, 'regress_rls_dave', 'awesome technology book'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]

-----------
QUERY:

SELECT * FROM part_document_satire ORDER by did;
RESULT:
	[(4, 55, 1, 'regress_rls_bob', 'my first satire'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]

-----------
QUERY:


-- RLS policy does not apply to table owner when RLS enabled.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM part_document ORDER by did;
RESULT:
	[(1, 11, 1, 'regress_rls_bob', 'my first novel'), (2, 11, 2, 'regress_rls_bob', 'my second novel'), (3, 99, 2, 'regress_rls_bob', 'my science textbook'), (4, 55, 1, 'regress_rls_bob', 'my first satire'), (5, 99, 2, 'regress_rls_bob', 'my history book'), (6, 11, 1, 'regress_rls_carol', 'great science fiction'), (7, 99, 2, 'regress_rls_carol', 'great technology book'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (9, 11, 1, 'regress_rls_dave', 'awesome science fiction'), (10, 99, 2, 'regress_rls_dave', 'awesome technology book'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]

-----------
QUERY:

SELECT * FROM part_document_satire ORDER by did;
RESULT:
	[(4, 55, 1, 'regress_rls_bob', 'my first satire'), (8, 55, 2, 'regress_rls_carol', 'great satire'), (100, 55, 1, 'regress_rls_dave', 'testing RLS with partitions')]

-----------
QUERY:


-- When RLS disabled, other users get ERROR.
SET SESSION AUTHORIZATION regress_rls_dave;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM part_document ORDER by did;
RESULT:
	ERROR - query would be affected by row-level security policy for table "part_document"


-----------
QUERY:

SELECT * FROM part_document_satire ORDER by did;
RESULT:
	ERROR - query would be affected by row-level security policy for table "part_document_satire"


-----------
QUERY:


-- Check behavior with a policy that uses a SubPlan not an InitPlan.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY pp3 ON part_document AS RESTRICTIVE
    USING ((SELECT dlevel <= seclv FROM uaccount WHERE pguser = current_user));
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

INSERT INTO part_document VALUES (100, 11, 5, 'regress_rls_carol', 'testing pp3');
RESULT:
	ERROR - new row violates row-level security policy "pp3" for table "part_document"


-----------
QUERY:
 -- fail

----- Dependencies -----
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE dependee (x integer, y integer);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE dependent (x integer, y integer);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY d1 ON dependent FOR ALL
    TO PUBLIC
    USING (x = (SELECT d.x FROM dependee d WHERE d.y = y));
RESULT:
	[]

-----------
QUERY:


DROP TABLE dependee;
RESULT:
	ERROR - cannot drop table dependee because other objects depend on it
DETAIL:  policy d1 on table dependent depends on table dependee
HINT:  Use DROP ... CASCADE to drop the dependent objects too.


-----------
QUERY:
 -- Should fail without CASCADE due to dependency on row security qual?

DROP TABLE dependee CASCADE;
RESULT:
	[]

-----------
QUERY:


EXPLAIN (COSTS OFF) SELECT * FROM dependent;
RESULT:
	[('Seq Scan on dependent',)]

-----------
QUERY:
 -- After drop, should be unqualified

-----   RECURSION    ----

--
-- Simple recursion
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE rec1 (x integer, y integer);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY r1 ON rec1 USING (x = (SELECT r.x FROM rec1 r WHERE y = r.y));
RESULT:
	[]

-----------
QUERY:

ALTER TABLE rec1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rec1;
RESULT:
	ERROR - infinite recursion detected in policy for relation "rec1"


-----------
QUERY:
 -- fail, direct recursion

--
-- Mutual recursion
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE rec2 (a integer, b integer);
RESULT:
	[]

-----------
QUERY:

ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2 WHERE b = y));
RESULT:
	[]

-----------
QUERY:

CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1 WHERE y = b));
RESULT:
	[]

-----------
QUERY:

ALTER TABLE rec2 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rec1;
RESULT:
	ERROR - infinite recursion detected in policy for relation "rec1"


-----------
QUERY:
    -- fail, mutual recursion

--
-- Mutual recursion via views
--
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rec1v AS SELECT * FROM rec1;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rec2v AS SELECT * FROM rec2;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

ALTER POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
RESULT:
	[]

-----------
QUERY:

ALTER POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rec1;
RESULT:
	ERROR - infinite recursion detected in policy for relation "rec1"


-----------
QUERY:
    -- fail, mutual recursion via views

--
-- Mutual recursion via .s.b views
--
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


DROP VIEW rec1v, rec2v CASCADE;
RESULT:
	[]

-----------
QUERY:


CREATE VIEW rec1v WITH (security_barrier) AS SELECT * FROM rec1;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rec2v WITH (security_barrier) AS SELECT * FROM rec2;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY r1 ON rec1 USING (x = (SELECT a FROM rec2v WHERE b = y));
RESULT:
	[]

-----------
QUERY:

CREATE POLICY r2 ON rec2 USING (a = (SELECT x FROM rec1v WHERE y = b));
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rec1;
RESULT:
	ERROR - infinite recursion detected in policy for relation "rec1"


-----------
QUERY:
    -- fail, mutual recursion via s.b. views

--
-- recursive RLS and VIEWs in policy
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE s1 (a int, b text);
RESULT:
	[]

-----------
QUERY:

INSERT INTO s1 (SELECT x, public.fipshash(x::text) FROM generate_series(-10,10) x);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE s2 (x int, y text);
RESULT:
	[]

-----------
QUERY:

INSERT INTO s2 (SELECT x, public.fipshash(x::text) FROM generate_series(-6,6) x);
RESULT:
	[]

-----------
QUERY:


GRANT SELECT ON s1, s2 TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON s1 USING (a in (select x from s2 where y like '%2f%'));
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON s2 USING (x in (select a from s1 where b like '%22%'));
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON s1 FOR INSERT WITH CHECK (a = (SELECT a FROM s1));
RESULT:
	[]

-----------
QUERY:


ALTER TABLE s1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE s2 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v2 AS SELECT * FROM s2 WHERE y like '%af%';
RESULT:
	[]

-----------
QUERY:

SELECT * FROM s1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM s1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
 -- fail (infinite recursion)

INSERT INTO s1 VALUES (1, 'foo');
RESULT:
	ERROR - infinite recursion detected in policy for relation "s1"


-----------
QUERY:
 -- fail (infinite recursion)

SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p3 on s1;
RESULT:
	[]

-----------
QUERY:

ALTER POLICY p2 ON s2 USING (x % 2 = 0);
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM s1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM s1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
	-- OK
EXPLAIN (COSTS OFF) SELECT * FROM only s1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM only s1 WHERE f_leak(b);
                                                        ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

ALTER POLICY p1 ON s1 USING (a in (select x from v2));
RESULT:
	[]

-----------
QUERY:
 -- using VIEW in RLS policy
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM s1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM s1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
	-- OK
EXPLAIN (COSTS OFF) SELECT * FROM s1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM s1 WHERE f_leak(b);
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%';
RESULT:
	[(-4, -4, 'e5e0093f285a4fb94c3fcc2ad7fd04ed')]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT (SELECT x FROM s1 LIMIT 1) xx, * FROM s2 WHERE y like '%28%';
RESULT:
	[('Seq Scan on s2',), ("  Filter: (((x % 2) = 0) AND (y ~~ '%28%'::text))",), ('  SubPlan 2',), ('    ->  Limit',), ('          ->  Seq Scan on s1',), ('                Filter: (ANY (a = (hashed SubPlan 1).col1))',), ('                SubPlan 1',), ('                  ->  Seq Scan on s2 s2_1',), ("                        Filter: (((x % 2) = 0) AND (y ~~ '%af%'::text))",)]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

ALTER POLICY p2 ON s2 USING (x in (select a from s1 where b like '%d2%'));
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM s1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM s1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
	-- fail (infinite recursion via view)

-- prepared statement with regress_rls_alice privilege
PREPARE p1(int) AS SELECT * FROM t1 WHERE a <= $1;
RESULT:
	[]

-----------
QUERY:

EXECUTE p1(2);
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE p1(2);
RESULT:
	[('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


-- superuser is allowed to bypass RLS checks
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM t1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM t1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM t1 WHERE f_leak(b);
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- plan cache should be invalidated
EXECUTE p1(2);
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE p1(2);
RESULT:
	[('Seq Scan on t1',), ('  Filter: (a <= 2)',)]

-----------
QUERY:


PREPARE p2(int) AS SELECT * FROM t1 WHERE a = $1;
RESULT:
	[]

-----------
QUERY:

EXECUTE p2(2);
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE p2(2);
RESULT:
	[('Seq Scan on t1',), ('  Filter: (a = 2)',)]

-----------
QUERY:


-- also, case when privilege switch from superuser
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

EXECUTE p2(2);
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE p2(2);
RESULT:
	[('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


--
-- UPDATE / DELETE and Row-level security
--
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) UPDATE t1 SET b = b || b WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...XPLAIN (COSTS OFF) UPDATE t1 SET b = b || b WHERE f_leak(b);
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

UPDATE t1 SET b = b || b WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: UPDATE t1 SET b = b || b WHERE f_leak(b);
                                       ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


EXPLAIN (COSTS OFF) UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: ...TS OFF) UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: UPDATE only t1 SET b = b || '_updt' WHERE f_leak(b);
                                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- returning clause with system column
UPDATE only t1 SET b = b WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 4: UPDATE only t1 SET b = b WHERE f_leak(b) RETURNING tableoid:...
                                       ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

UPDATE t1 SET b = b WHERE f_leak(b) RETURNING *;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: UPDATE t1 SET b = b WHERE f_leak(b) RETURNING *;
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

UPDATE t1 SET b = b WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: UPDATE t1 SET b = b WHERE f_leak(b) RETURNING tableoid::regc...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


-- updates with from clause
EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t3
WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b);
RESULT:
	ERROR - relation "t2" does not exist
LINE 4: EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t3
                                   ^


-----------
QUERY:


UPDATE t2 SET b=t2.b FROM t3
WHERE t2.a = 3 and t3.a = 2 AND f_leak(t2.b) AND f_leak(t3.b);
RESULT:
	ERROR - relation "t2" does not exist
LINE 3: UPDATE t2 SET b=t2.b FROM t3
               ^


-----------
QUERY:


EXPLAIN (COSTS OFF) UPDATE t1 SET b=t1.b FROM t2
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
RESULT:
	ERROR - relation "t2" does not exist
LINE 3: EXPLAIN (COSTS OFF) UPDATE t1 SET b=t1.b FROM t2
                                                      ^


-----------
QUERY:


UPDATE t1 SET b=t1.b FROM t2
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
RESULT:
	ERROR - relation "t2" does not exist
LINE 3: UPDATE t1 SET b=t1.b FROM t2
                                  ^


-----------
QUERY:


EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t1
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
RESULT:
	ERROR - relation "t2" does not exist
LINE 3: EXPLAIN (COSTS OFF) UPDATE t2 SET b=t2.b FROM t1
                                   ^


-----------
QUERY:


UPDATE t2 SET b=t2.b FROM t1
WHERE t1.a = 3 and t2.a = 3 AND f_leak(t1.b) AND f_leak(t2.b);
RESULT:
	ERROR - relation "t2" does not exist
LINE 3: UPDATE t2 SET b=t2.b FROM t1
               ^


-----------
QUERY:


-- updates with from clause self join
EXPLAIN (COSTS OFF) UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2;
RESULT:
	ERROR - relation "t2" does not exist
LINE 4: EXPLAIN (COSTS OFF) UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2...
                                   ^


-----------
QUERY:


UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
WHERE t2_1.a = 3 AND t2_2.a = t2_1.a AND t2_2.b = t2_1.b
AND f_leak(t2_1.b) AND f_leak(t2_2.b) RETURNING *, t2_1, t2_2;
RESULT:
	ERROR - relation "t2" does not exist
LINE 3: UPDATE t2 t2_1 SET b = t2_2.b FROM t2 t2_2
               ^


-----------
QUERY:


EXPLAIN (COSTS OFF) UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2
WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b
AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 5: AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_...
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


UPDATE t1 t1_1 SET b = t1_2.b FROM t1 t1_2
WHERE t1_1.a = 4 AND t1_2.a = t1_1.a AND t1_2.b = t1_1.b
AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_2;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 5: AND f_leak(t1_1.b) AND f_leak(t1_2.b) RETURNING *, t1_1, t1_...
            ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM t1 ORDER BY a,b;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) DELETE FROM only t1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) DELETE FROM only t1 WHERE f_leak(b);
                                                      ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) DELETE FROM t1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) DELETE FROM t1 WHERE f_leak(b);
                                                 ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


DELETE FROM only t1 WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: DELETE FROM only t1 WHERE f_leak(b) RETURNING tableoid::regc...
                                  ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

DELETE FROM t1 WHERE f_leak(b) RETURNING tableoid::regclass, *, t1;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: DELETE FROM t1 WHERE f_leak(b) RETURNING tableoid::regclass,...
                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


--
-- S.b. view on top of Row-level security
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE b1 (a int, b text);
RESULT:
	[]

-----------
QUERY:

INSERT INTO b1 (SELECT x, public.fipshash(x::text) FROM generate_series(-10,10) x);
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON b1 USING (a % 2 = 0);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE b1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON b1 TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW bv1 WITH (security_barrier) AS SELECT * FROM b1 WHERE a > 0 WITH CHECK OPTION;
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON bv1 TO regress_rls_carol;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:


EXPLAIN (COSTS OFF) SELECT * FROM bv1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: EXPLAIN (COSTS OFF) SELECT * FROM bv1 WHERE f_leak(b);
                                                    ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SELECT * FROM bv1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM bv1 WHERE f_leak(b);
                                ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


INSERT INTO bv1 VALUES (-1, 'xxx');
RESULT:
	ERROR - new row violates row-level security policy for table "b1"


-----------
QUERY:
 -- should fail view WCO
INSERT INTO bv1 VALUES (11, 'xxx');
RESULT:
	ERROR - new row violates row-level security policy for table "b1"


-----------
QUERY:
 -- should fail RLS check
INSERT INTO bv1 VALUES (12, 'xxx');
RESULT:
	[]

-----------
QUERY:
 -- ok

EXPLAIN (COSTS OFF) UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: ...STS OFF) UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b);
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: UPDATE bv1 SET b = 'yyy' WHERE a = 4 AND f_leak(b);
                                                 ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


EXPLAIN (COSTS OFF) DELETE FROM bv1 WHERE a = 6 AND f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: ...PLAIN (COSTS OFF) DELETE FROM bv1 WHERE a = 6 AND f_leak(b);
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

DELETE FROM bv1 WHERE a = 6 AND f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: DELETE FROM bv1 WHERE a = 6 AND f_leak(b);
                                        ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM b1;
RESULT:
	[(-10, 'c171d4ec282b23db89a99880cd624e9b'), (-9, 'd5c534fde62beb89c745a59952c8efed'), (-8, 'e91592205d3881e3ea35d66973bb4898'), (-7, 'a770d3270c9dcdedf12ed9fd70444f7c'), (-6, '03b26944890929ff751653acb2f2af79'), (-5, '37aa1ccf80e481832b2db282d4d4f895'), (-4, 'e5e0093f285a4fb94c3fcc2ad7fd04ed'), (-3, '615bdd17c2556f82f384392ea8557f8c'), (-2, 'cf3bae39dd692048a8bf961182e6a34d'), (-1, '1bad6b8cf97131fceab8543e81f77571'), (0, '5feceb66ffc86f38d952786c6d696c79'), (1, '6b86b273ff34fce19d6b804eff5a3f57'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (3, '4e07408562bedb8b60ce05c1decfe3ad'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (5, 'ef2d127de37b942baad06145e54b0c61'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (7, '7902699be42c8a8e46fbbb4501726517'), (8, '2c624232cdd221771294dfbb310aca00'), (9, '19581e27de7ced00ff1ce50b2047e7a5'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, 'xxx')]

-----------
QUERY:

--
-- INSERT ... ON CONFLICT DO UPDATE and Row-level security
--

SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p1 ON document;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p1r ON document;
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON document FOR SELECT USING (true);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON document FOR UPDATE
  USING (cid = (SELECT cid from category WHERE cname = 'novel'))
  WITH CHECK (dauthor = current_user);
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


-- Exists...
SELECT * FROM document WHERE did = 2;
RESULT:
	[(2, 11, 2, 'regress_rls_bob', 'my second novel')]

-----------
QUERY:


-- ...so violates actual WITH CHECK OPTION within UPDATE (not INSERT, since
-- alternative UPDATE path happens to be taken):
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, dauthor = EXCLUDED.dauthor;
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:


-- Violates USING qual for UPDATE policy p3.
--
-- UPDATE path is taken, but UPDATE fails purely because *existing* row to be
-- updated is not a /* REPLACED */ ''novel/* REPLACED */ ''/cid 11 (row is not leaked, even though we have
-- SELECT privileges sufficient to see the row in this instance):
INSERT INTO document VALUES (33, 22, 1, 'regress_rls_bob', 'okay science fiction');
RESULT:
	[]

-----------
QUERY:
 -- preparation for next statement
INSERT INTO document VALUES (33, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'Some novel, replaces sci-fi') -- takes UPDATE path
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
RESULT:
	ERROR - new row violates row-level security policy (USING expression) for table "document"


-----------
QUERY:

-- Fine (we UPDATE, since INSERT WCOs and UPDATE security barrier quals + WCOs
-- not violated):
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
RESULT:
	[(2, 11, 2, 'regress_rls_bob', 'my first novel')]

-----------
QUERY:

-- Fine (we INSERT, so /* REPLACED */ ''cid = 33/* REPLACED */ '' (/* REPLACED */ ''technology/* REPLACED */ '') isn/* REPLACED */ ''t evaluated):
INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
RESULT:
	[(78, 11, 1, 'regress_rls_bob', 'some technology novel')]

-----------
QUERY:

-- Fine (same query, but we UPDATE, so /* REPLACED */ ''cid = 33/* REPLACED */ '', (/* REPLACED */ ''technology/* REPLACED */ '') is not the
-- case in respect of *existing* tuple):
INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
RESULT:
	[(78, 33, 1, 'regress_rls_bob', 'some technology novel')]

-----------
QUERY:

-- Same query a third time, but now fails due to existing tuple finally not
-- passing quals:
INSERT INTO document VALUES (78, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'some technology novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33 RETURNING *;
RESULT:
	ERROR - new row violates row-level security policy (USING expression) for table "document"


-----------
QUERY:

-- Don/* REPLACED */ ''t fail just because INSERT doesn/* REPLACED */ ''t satisfy WITH CHECK option that
-- originated as a barrier/USING() qual from the UPDATE.  Note that the UPDATE
-- path *isn/* REPLACED */ ''t* taken, and so UPDATE-related policy does not apply:
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
RESULT:
	[(79, 33, 1, 'regress_rls_bob', 'technology book, can only insert')]

-----------
QUERY:

-- But this time, the same statement fails, because the UPDATE path is taken,
-- and updating the row just inserted falls afoul of security barrier qual
-- (enforced as WCO) -- what we might have updated target tuple to is
-- irrelevant, in fact.
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
RESULT:
	ERROR - new row violates row-level security policy (USING expression) for table "document"


-----------
QUERY:


-- Test default USING qual enforced as WCO
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p1 ON document;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p2 ON document;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p3 ON document;
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p3_with_default ON document FOR UPDATE
  USING (cid = (SELECT cid from category WHERE cname = 'novel'));
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

-- Just because WCO-style enforcement of USING quals occurs with
-- existing/target tuple does not mean that the implementation can be allowed
-- to fail to also enforce this qual against the final tuple appended to
-- relation (since in the absence of an explicit WCO, this is also interpreted
-- as an UPDATE/ALL WCO in general).
--
-- UPDATE path is taken here (fails due to existing tuple).  Note that this is
-- not reported as a /* REPLACED */ ''USING expression/* REPLACED */ '', because it/* REPLACED */ ''s an RLS UPDATE check that originated as
-- a USING qual for the purposes of RLS in general, as opposed to an explicit
-- USING qual that is ordinarily a security barrier.  We leave it up to the
-- UPDATE to make this fail:
INSERT INTO document VALUES (79, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'technology book, can only insert')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle RETURNING *;
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:


-- UPDATE path is taken here.  Existing tuple passes, since its cid
-- corresponds to /* REPLACED */ ''novel/* REPLACED */ '', but default USING qual is enforced against
-- post-UPDATE tuple too (as always when updating with a policy that lacks an
-- explicit WCO), and so this fails:
INSERT INTO document VALUES (2, (SELECT cid from category WHERE cname = 'technology'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET cid = EXCLUDED.cid, dtitle = EXCLUDED.dtitle RETURNING *;
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p3_with_default ON document;
RESULT:
	[]

-----------
QUERY:


--
-- Test ALL policies with ON CONFLICT DO UPDATE (much the same as existing UPDATE
-- tests)
--
CREATE POLICY p3_with_all ON document FOR ALL
  USING (cid = (SELECT cid from category WHERE cname = 'novel'))
  WITH CHECK (dauthor = current_user);
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


-- Fails, since ALL WCO is enforced in insert path:
INSERT INTO document VALUES (80, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_carol', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle, cid = 33;
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:

-- Fails, since ALL policy USING qual is enforced (existing, target tuple is in
-- violation, since it has the /* REPLACED */ ''manga/* REPLACED */ '' cid):
INSERT INTO document VALUES (4, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dtitle = EXCLUDED.dtitle;
RESULT:
	ERROR - new row violates row-level security policy (USING expression) for table "document"


-----------
QUERY:

-- Fails, since ALL WCO are enforced:
INSERT INTO document VALUES (1, (SELECT cid from category WHERE cname = 'novel'), 1, 'regress_rls_bob', 'my first novel')
    ON CONFLICT (did) DO UPDATE SET dauthor = 'regress_rls_carol';
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:


--
-- MERGE
--
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p3_with_all ON document;
RESULT:
	[]

-----------
QUERY:


ALTER TABLE document ADD COLUMN dnotes text DEFAULT '';
RESULT:
	[]

-----------
QUERY:

-- all documents are readable
CREATE POLICY p1 ON document FOR SELECT USING (true);
RESULT:
	[]

-----------
QUERY:

-- one may insert documents only authored by them
CREATE POLICY p2 ON document FOR INSERT WITH CHECK (dauthor = current_user);
RESULT:
	[]

-----------
QUERY:

-- one may only update documents in /* REPLACED */ ''novel/* REPLACED */ '' category and new dlevel must be > 0
CREATE POLICY p3 ON document FOR UPDATE
  USING (cid = (SELECT cid from category WHERE cname = 'novel'))
  WITH CHECK (dlevel > 0);
RESULT:
	[]

-----------
QUERY:

-- one may only delete documents in /* REPLACED */ ''manga/* REPLACED */ '' category
CREATE POLICY p4 ON document FOR DELETE
  USING (cid = (SELECT cid from category WHERE cname = 'manga'));
RESULT:
	[]

-----------
QUERY:


SELECT * FROM document;
RESULT:
	[(1, 11, 1, 'regress_rls_bob', 'my first novel', ''), (3, 22, 2, 'regress_rls_bob', 'my science fiction', ''), (4, 44, 1, 'regress_rls_bob', 'my first manga', ''), (5, 44, 2, 'regress_rls_bob', 'my second manga', ''), (6, 22, 1, 'regress_rls_carol', 'great science fiction', ''), (7, 33, 2, 'regress_rls_carol', 'great technology book', ''), (8, 44, 1, 'regress_rls_carol', 'great manga', ''), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction', ''), (10, 33, 2, 'regress_rls_dave', 'awesome technology book', ''), (11, 33, 1, 'regress_rls_carol', 'hoge', ''), (33, 22, 1, 'regress_rls_bob', 'okay science fiction', ''), (2, 11, 2, 'regress_rls_bob', 'my first novel', ''), (78, 33, 1, 'regress_rls_bob', 'some technology novel', ''), (79, 33, 1, 'regress_rls_bob', 'technology book, can only insert', '')]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


-- Fails, since update violates WITH CHECK qual on dlevel
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge1 ', dlevel = 0;
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:


-- Should be OK since USING and WITH CHECK quals pass
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge2 ';
RESULT:
	[]

-----------
QUERY:


-- Even when dlevel is updated explicitly, but to the existing value
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge3 ', dlevel = 1;
RESULT:
	[]

-----------
QUERY:


-- There is a MATCH for did = 3, but UPDATE/* REPLACED */ ''s USING qual does not allow
-- updating an item in category /* REPLACED */ ''science fiction/* REPLACED */ ''
MERGE INTO document d
USING (SELECT 3 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge ';
RESULT:
	ERROR - target row violates row-level security policy (USING expression) for table "document"


-----------
QUERY:


-- The same thing with DELETE action, but fails again because no permissions
-- to delete items in /* REPLACED */ ''science fiction/* REPLACED */ '' category that did 3 belongs to.
MERGE INTO document d
USING (SELECT 3 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	DELETE;
RESULT:
	ERROR - target row violates row-level security policy (USING expression) for table "document"


-----------
QUERY:


-- Document with did 4 belongs to /* REPLACED */ ''manga/* REPLACED */ '' category which is allowed for
-- deletion. But this fails because the UPDATE action is matched first and
-- UPDATE policy does not allow updation in the category.
MERGE INTO document d
USING (SELECT 4 as sdid) s
ON did = s.sdid
WHEN MATCHED AND dnotes = '' THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
WHEN MATCHED THEN
	DELETE;
RESULT:
	ERROR - target row violates row-level security policy (USING expression) for table "document"


-----------
QUERY:


-- UPDATE action is not matched this time because of the WHEN qual.
-- DELETE still fails because role regress_rls_bob does not have SELECT
-- privileges on /* REPLACED */ ''manga/* REPLACED */ '' category row in the category table.
MERGE INTO document d
USING (SELECT 4 as sdid) s
ON did = s.sdid
WHEN MATCHED AND dnotes <> '' THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
WHEN MATCHED THEN
	DELETE;
RESULT:
	ERROR - target row violates row-level security policy (USING expression) for table "document"


-----------
QUERY:


-- OK if DELETE is replaced with DO NOTHING
MERGE INTO document d
USING (SELECT 4 as sdid) s
ON did = s.sdid
WHEN MATCHED AND dnotes <> '' THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
WHEN MATCHED THEN
	DO NOTHING;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM document WHERE did = 4;
RESULT:
	[(4, 44, 1, 'regress_rls_bob', 'my first manga', '')]

-----------
QUERY:


-- Switch to regress_rls_carol role and try the DELETE again. It should succeed
-- this time
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:


MERGE INTO document d
USING (SELECT 4 as sdid) s
ON did = s.sdid
WHEN MATCHED AND dnotes <> '' THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge '
WHEN MATCHED THEN
	DELETE;
RESULT:
	[]

-----------
QUERY:


-- Switch back to regress_rls_bob role
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


-- Try INSERT action. This fails because we are trying to insert
-- dauthor = regress_rls_dave and INSERT/* REPLACED */ ''s WITH CHECK does not allow
-- that
MERGE INTO document d
USING (SELECT 12 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	DELETE
WHEN NOT MATCHED THEN
	INSERT VALUES (12, 11, 1, 'regress_rls_dave', 'another novel');
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:


-- This should be fine
MERGE INTO document d
USING (SELECT 12 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	DELETE
WHEN NOT MATCHED THEN
	INSERT VALUES (12, 11, 1, 'regress_rls_bob', 'another novel');
RESULT:
	[]

-----------
QUERY:


-- ok
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge4 '
WHEN NOT MATCHED THEN
	INSERT VALUES (12, 11, 1, 'regress_rls_bob', 'another novel');
RESULT:
	[]

-----------
QUERY:


-- drop and create a new SELECT policy which prevents us from reading
-- any document except with category /* REPLACED */ ''novel/* REPLACED */ ''
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p1 ON document;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p1 ON document FOR SELECT
  USING (cid = (SELECT cid from category WHERE cname = 'novel'));
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


-- MERGE can no longer see the matching row and hence attempts the
-- NOT MATCHED action, which results in unique key violation
MERGE INTO document d
USING (SELECT 7 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge5 '
WHEN NOT MATCHED THEN
	INSERT VALUES (12, 11, 1, 'regress_rls_bob', 'another novel');
RESULT:
	ERROR - duplicate key value violates unique constraint "document_pkey"


-----------
QUERY:


-- UPDATE action fails if new row is not visible
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge6 ',
			   cid = (SELECT cid from category WHERE cname = 'technology');
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:


-- but OK if new row is visible
MERGE INTO document d
USING (SELECT 1 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge7 ',
			   cid = (SELECT cid from category WHERE cname = 'novel');
RESULT:
	[]

-----------
QUERY:


-- OK to insert a new row that is not visible
MERGE INTO document d
USING (SELECT 13 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge8 '
WHEN NOT MATCHED THEN
	INSERT VALUES (13, 44, 1, 'regress_rls_bob', 'new manga');
RESULT:
	[]

-----------
QUERY:

SELECT * FROM document WHERE did = 13;
RESULT:
	[]

-----------
QUERY:


-- but not OK if RETURNING is used
MERGE INTO document d
USING (SELECT 14 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge9 '
WHEN NOT MATCHED THEN
	INSERT VALUES (14, 44, 1, 'regress_rls_bob', 'new manga')
RETURNING *;
RESULT:
	ERROR - new row violates row-level security policy for table "document"


-----------
QUERY:


-- but OK if new row is visible
MERGE INTO document d
USING (SELECT 14 as sdid) s
ON did = s.sdid
WHEN MATCHED THEN
	UPDATE SET dnotes = dnotes || ' notes added by merge10 '
WHEN NOT MATCHED THEN
	INSERT VALUES (14, 11, 1, 'regress_rls_bob', 'new novel')
RETURNING *;
RESULT:
	[(14, 14, 11, 1, 'regress_rls_bob', 'new novel', '')]

-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

-- drop the restrictive SELECT policy so that we can look at the
-- final state of the table
DROP POLICY p1 ON document;
RESULT:
	[]

-----------
QUERY:

-- Just check everything went per plan
SELECT * FROM document;
RESULT:
	[(3, 22, 2, 'regress_rls_bob', 'my science fiction', ''), (5, 44, 2, 'regress_rls_bob', 'my second manga', ''), (6, 22, 1, 'regress_rls_carol', 'great science fiction', ''), (7, 33, 2, 'regress_rls_carol', 'great technology book', ''), (8, 44, 1, 'regress_rls_carol', 'great manga', ''), (9, 22, 1, 'regress_rls_dave', 'awesome science fiction', ''), (10, 33, 2, 'regress_rls_dave', 'awesome technology book', ''), (11, 33, 1, 'regress_rls_carol', 'hoge', ''), (33, 22, 1, 'regress_rls_bob', 'okay science fiction', ''), (2, 11, 2, 'regress_rls_bob', 'my first novel', ''), (78, 33, 1, 'regress_rls_bob', 'some technology novel', ''), (79, 33, 1, 'regress_rls_bob', 'technology book, can only insert', ''), (12, 11, 1, 'regress_rls_bob', 'another novel', ''), (1, 11, 1, 'regress_rls_bob', 'my first novel', ' notes added by merge2  notes added by merge3  notes added by merge4  notes added by merge7 '), (13, 44, 1, 'regress_rls_bob', 'new manga', ''), (14, 11, 1, 'regress_rls_bob', 'new novel', '')]

-----------
QUERY:


--
-- ROLE/GROUP
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE z1 (a int, b text);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE z2 (a int, b text);
RESULT:
	[]

-----------
QUERY:


GRANT SELECT ON z1,z2 TO regress_rls_group1, regress_rls_group2,
    regress_rls_bob, regress_rls_carol;
RESULT:
	[]

-----------
QUERY:


INSERT INTO z1 VALUES
    (1, 'aba'),
    (2, 'bbb'),
    (3, 'ccc'),
    (4, 'dad');
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON z1 TO regress_rls_group1 USING (a % 2 = 0);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON z1 TO regress_rls_group2 USING (a % 2 = 1);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE z1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM z1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


PREPARE plancache_test AS SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: PREPARE plancache_test AS SELECT * FROM z1 WHERE f_leak(b);
                                                         ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE plancache_test;
RESULT:
	ERROR - prepared statement "plancache_test" does not exist


-----------
QUERY:


PREPARE plancache_test2 AS WITH q AS MATERIALIZED (SELECT * FROM z1 WHERE f_leak(b)) SELECT * FROM q,z2;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: ...AS WITH q AS MATERIALIZED (SELECT * FROM z1 WHERE f_leak(b))...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
RESULT:
	ERROR - prepared statement "plancache_test2" does not exist


-----------
QUERY:


PREPARE plancache_test3 AS WITH q AS MATERIALIZED (SELECT * FROM z2) SELECT * FROM q,z1 WHERE f_leak(z1.b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: ...LIZED (SELECT * FROM z2) SELECT * FROM q,z1 WHERE f_leak(z1....
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
RESULT:
	ERROR - prepared statement "plancache_test3" does not exist


-----------
QUERY:


SET ROLE regress_rls_group1;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM z1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


EXPLAIN (COSTS OFF) EXECUTE plancache_test;
RESULT:
	ERROR - prepared statement "plancache_test" does not exist


-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
RESULT:
	ERROR - prepared statement "plancache_test2" does not exist


-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
RESULT:
	ERROR - prepared statement "plancache_test3" does not exist


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM z1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


EXPLAIN (COSTS OFF) EXECUTE plancache_test;
RESULT:
	ERROR - prepared statement "plancache_test" does not exist


-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
RESULT:
	ERROR - prepared statement "plancache_test2" does not exist


-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
RESULT:
	ERROR - prepared statement "plancache_test3" does not exist


-----------
QUERY:


SET ROLE regress_rls_group2;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM z1 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM z1 WHERE f_leak(b);
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


EXPLAIN (COSTS OFF) EXECUTE plancache_test;
RESULT:
	ERROR - prepared statement "plancache_test" does not exist


-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE plancache_test2;
RESULT:
	ERROR - prepared statement "plancache_test2" does not exist


-----------
QUERY:

EXPLAIN (COSTS OFF) EXECUTE plancache_test3;
RESULT:
	ERROR - prepared statement "plancache_test3" does not exist


-----------
QUERY:


--
-- Views should follow policy for view owner.
--
-- View and Table owner are the same.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b);
                                                       ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

GRANT SELECT ON rls_view TO regress_rls_bob;
RESULT:
	ERROR - relation "rls_view" does not exist


-----------
QUERY:


-- Query as role that is not owner of view or table.  Should return all records.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


-- Query as view/table owner.  Should return all records.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:

DROP VIEW rls_view;
RESULT:
	ERROR - view "rls_view" does not exist


-----------
QUERY:


-- View and Table owners are different.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: CREATE VIEW rls_view AS SELECT * FROM z1 WHERE f_leak(b);
                                                       ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

GRANT SELECT ON rls_view TO regress_rls_alice;
RESULT:
	ERROR - relation "rls_view" does not exist


-----------
QUERY:


-- Query as role that is not owner of view but is owner of table.
-- Should return records based on view owner policies.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


-- Query as role that is not owner of table but is owner of view.
-- Should return records based on view owner policies.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


-- Query as role that is not the owner of the table or view without permissions.
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:
 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:
 --fail - permission denied.

-- Query as role that is not the owner of the table or view with permissions.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON rls_view TO regress_rls_carol;
RESULT:
	ERROR - relation "rls_view" does not exist


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


-- Policy requiring access to another table.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE z1_blacklist (a int);
RESULT:
	[]

-----------
QUERY:

INSERT INTO z1_blacklist VALUES (3), (4);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON z1 AS RESTRICTIVE USING (a NOT IN (SELECT a FROM z1_blacklist));
RESULT:
	[]

-----------
QUERY:


-- Query as role that is not owner of table but is owner of view without permissions.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:
 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:
 --fail - permission denied.

-- Query as role that is not the owner of the table or view without permissions.
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:
 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:
 --fail - permission denied.

-- Query as role that is not owner of table but is owner of view with permissions.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON z1_blacklist TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


-- Query as role that is not the owner of the table or view with permissions.
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

REVOKE SELECT ON z1_blacklist FROM regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p3 ON z1;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

DROP VIEW rls_view;
RESULT:
	ERROR - view "rls_view" does not exist


-----------
QUERY:


--
-- Security invoker views should follow policy for current user.
--
-- View and table owner are the same.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rls_view WITH (security_invoker) AS
    SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3:     SELECT * FROM z1 WHERE f_leak(b);
                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

GRANT SELECT ON rls_view TO regress_rls_bob;
RESULT:
	ERROR - relation "rls_view" does not exist


-----------
QUERY:

GRANT SELECT ON rls_view TO regress_rls_carol;
RESULT:
	ERROR - relation "rls_view" does not exist


-----------
QUERY:


-- Query as table owner.  Should return all records.
SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 4: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


-- Queries as other users.
-- Should return records based on current user/* REPLACED */ ''s policies.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


-- View and table owners are different.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

DROP VIEW rls_view;
RESULT:
	ERROR - view "rls_view" does not exist


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rls_view WITH (security_invoker) AS
    SELECT * FROM z1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3:     SELECT * FROM z1 WHERE f_leak(b);
                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

GRANT SELECT ON rls_view TO regress_rls_alice;
RESULT:
	ERROR - relation "rls_view" does not exist


-----------
QUERY:

GRANT SELECT ON rls_view TO regress_rls_carol;
RESULT:
	ERROR - relation "rls_view" does not exist


-----------
QUERY:


-- Query as table owner.  Should return all records.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


-- Queries as other users.
-- Should return records based on current user/* REPLACED */ ''s policies.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


-- Policy requiring access to another table.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON z1 AS RESTRICTIVE USING (a NOT IN (SELECT a FROM z1_blacklist));
RESULT:
	[]

-----------
QUERY:


-- Query as role that is not owner of table but is owner of view without permissions.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:
 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:
 --fail - permission denied.

-- Query as role that is not the owner of the table or view without permissions.
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:
 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:
 --fail - permission denied.

-- Query as role that is not owner of table but is owner of view with permissions.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON z1_blacklist TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


-- Query as role that is not the owner of the table or view without permissions.
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:
 --fail - permission denied.
EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:
 --fail - permission denied.

-- Query as role that is not the owner of the table or view with permissions.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON z1_blacklist TO regress_rls_carol;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: SELECT * FROM rls_view;
                      ^


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
RESULT:
	ERROR - relation "rls_view" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_view;
                                          ^


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

DROP VIEW rls_view;
RESULT:
	ERROR - view "rls_view" does not exist


-----------
QUERY:


--
-- Command specific
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE x1 (a int, b text, c text);
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON x1 TO PUBLIC;
RESULT:
	[]

-----------
QUERY:


INSERT INTO x1 VALUES
    (1, 'abc', 'regress_rls_bob'),
    (2, 'bcd', 'regress_rls_bob'),
    (3, 'cde', 'regress_rls_carol'),
    (4, 'def', 'regress_rls_carol'),
    (5, 'efg', 'regress_rls_bob'),
    (6, 'fgh', 'regress_rls_bob'),
    (7, 'fgh', 'regress_rls_carol'),
    (8, 'fgh', 'regress_rls_carol');
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p0 ON x1 FOR ALL USING (c = current_user);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p1 ON x1 FOR SELECT USING (a % 2 = 0);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON x1 FOR INSERT WITH CHECK (a % 2 = 1);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON x1 FOR UPDATE USING (a % 2 = 0);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p4 ON x1 FOR DELETE USING (a < 8);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE x1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC;
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM x1 WHERE f_leak(b) ORDER BY a ASC;
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: UPDATE x1 SET b = b || '_updt' WHERE f_leak(b) RETURNING *;
                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

DELETE FROM x1 WHERE f_leak(b) RETURNING *;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: DELETE FROM x1 WHERE f_leak(b) RETURNING *;
                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


--
-- Duplicate Policy Names
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE y1 (a int, b text);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE y2 (a int, b text);
RESULT:
	[]

-----------
QUERY:


GRANT ALL ON y1, y2 TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON y1 FOR ALL USING (a % 2 = 0);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON y1 FOR SELECT USING (a > 2);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p1 ON y1 FOR SELECT USING (a % 2 = 1);
RESULT:
	ERROR - policy "p1" for table "y1" already exists


-----------
QUERY:
  --fail
CREATE POLICY p1 ON y2 FOR ALL USING (a % 2 = 0);
RESULT:
	[]

-----------
QUERY:
  --OK

ALTER TABLE y1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE y2 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


--
-- Expression structure with SBV
--
-- Create view as table owner.  RLS should NOT be applied.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rls_sbv WITH (security_barrier) AS
    SELECT * FROM y1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3:     SELECT * FROM y1 WHERE f_leak(b);
                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
RESULT:
	ERROR - relation "rls_sbv" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
                                          ^


-----------
QUERY:

DROP VIEW rls_sbv;
RESULT:
	ERROR - view "rls_sbv" does not exist


-----------
QUERY:


-- Create view as role that does not own table.  RLS should be applied.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rls_sbv WITH (security_barrier) AS
    SELECT * FROM y1 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3:     SELECT * FROM y1 WHERE f_leak(b);
                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
RESULT:
	ERROR - relation "rls_sbv" does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM rls_sbv WHERE (a = 1);
                                          ^


-----------
QUERY:

DROP VIEW rls_sbv;
RESULT:
	ERROR - view "rls_sbv" does not exist


-----------
QUERY:


--
-- Expression structure
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

INSERT INTO y2 (SELECT x, public.fipshash(x::text) FROM generate_series(0,20) x);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON y2 USING (a % 3 = 0);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON y2 USING (a % 4 = 0);
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM y2 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: SELECT * FROM y2 WHERE f_leak(b);
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak(b);
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


--
-- Qual push-down of leaky functions, when not referring to table
--
SELECT * FROM y2 WHERE f_leak('abc');
RESULT:
	ERROR - function f_leak(unknown) does not exist
LINE 6: SELECT * FROM y2 WHERE f_leak('abc');
                               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak('abc');
RESULT:
	ERROR - function f_leak(unknown) does not exist
LINE 2: EXPLAIN (COSTS OFF) SELECT * FROM y2 WHERE f_leak('abc');
                                                   ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


CREATE TABLE test_qual_pushdown (
    abc text
);
RESULT:
	[]

-----------
QUERY:


INSERT INTO test_qual_pushdown VALUES ('abc'),('def');
RESULT:
	[]

-----------
QUERY:


SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(abc);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: ...ROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(abc...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(abc);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...ROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(abc...
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: ...ROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(b);
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(b);
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 2: ...ROM y2 JOIN test_qual_pushdown ON (b = abc) WHERE f_leak(b);
                                                             ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


DROP TABLE test_qual_pushdown;
RESULT:
	[]

-----------
QUERY:


--
-- Plancache invalidate on user change.
--
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:


DROP TABLE t1 CASCADE;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE t1 (a integer);
RESULT:
	[]

-----------
QUERY:


GRANT SELECT ON t1 TO regress_rls_bob, regress_rls_carol;
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON t1 TO regress_rls_bob USING ((a % 2) = 0);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON t1 TO regress_rls_carol USING ((a % 4) = 0);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- Prepare as regress_rls_bob
SET ROLE regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

PREPARE role_inval AS SELECT * FROM t1;
RESULT:
	[]

-----------
QUERY:

-- Check plan
EXPLAIN (COSTS OFF) EXECUTE role_inval;
RESULT:
	[('Seq Scan on t1',), ('  Filter: ((a % 2) = 0)',)]

-----------
QUERY:


-- Change to regress_rls_carol
SET ROLE regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

-- Check plan- should be different
EXPLAIN (COSTS OFF) EXECUTE role_inval;
RESULT:
	[('Seq Scan on t1',), ('  Filter: ((a % 4) = 0)',)]

-----------
QUERY:


-- Change back to regress_rls_bob
SET ROLE regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

-- Check plan- should be back to original
EXPLAIN (COSTS OFF) EXECUTE role_inval;
RESULT:
	[('Seq Scan on t1',), ('  Filter: ((a % 2) = 0)',)]

-----------
QUERY:


--
-- CTE and RLS
--
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

DROP TABLE t1 CASCADE;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE t1 (a integer, b text);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p1 ON t1 USING (a % 2 = 0);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE t1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


GRANT ALL ON t1 TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


INSERT INTO t1 (SELECT x, public.fipshash(x::text) FROM generate_series(0,20) x);
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b))...
                                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

EXPLAIN (COSTS OFF)
WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b)) SELECT * FROM cte1;
RESULT:
	ERROR - function f_leak(text) does not exist
LINE 3: WITH cte1 AS MATERIALIZED (SELECT * FROM t1 WHERE f_leak(b))...
                                                          ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:


WITH cte1 AS (UPDATE t1 SET a = a + 1 RETURNING *) SELECT * FROM cte1;
RESULT:
	ERROR - new row violates row-level security policy for table "t1"


-----------
QUERY:
 --fail
WITH cte1 AS (UPDATE t1 SET a = a RETURNING *) SELECT * FROM cte1;
RESULT:
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3')]

-----------
QUERY:
 --ok

WITH cte1 AS (INSERT INTO t1 VALUES (21, 'Fail') RETURNING *) SELECT * FROM cte1;
RESULT:
	ERROR - new row violates row-level security policy for table "t1"


-----------
QUERY:
 --fail
WITH cte1 AS (INSERT INTO t1 VALUES (20, 'Success') RETURNING *) SELECT * FROM cte1;
RESULT:
	[(20, 'Success')]

-----------
QUERY:
 --ok

--
-- Rename Policy
--
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

ALTER POLICY p1 ON t1 RENAME TO p1;
RESULT:
	ERROR - policy "p1" for table "t1" already exists


-----------
QUERY:
 --fail

SELECT polname, relname
    FROM pg_policy pol
    JOIN pg_class pc ON (pc.oid = pol.polrelid)
    WHERE relname = 't1';
RESULT:
	[('p1', 't1')]

-----------
QUERY:


ALTER POLICY p1 ON t1 RENAME TO p2;
RESULT:
	[]

-----------
QUERY:
 --ok

SELECT polname, relname
    FROM pg_policy pol
    JOIN pg_class pc ON (pc.oid = pol.polrelid)
    WHERE relname = 't1';
RESULT:
	[('p2', 't1')]

-----------
QUERY:


--
-- Check INSERT SELECT
--
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE t2 (a integer, b text);
RESULT:
	[]

-----------
QUERY:

INSERT INTO t2 (SELECT * FROM t1);
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) INSERT INTO t2 (SELECT * FROM t1);
RESULT:
	[('Insert on t2',), ('  ->  Seq Scan on t1',), ('        Filter: ((a % 2) = 0)',)]

-----------
QUERY:

SELECT * FROM t2;
RESULT:
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3'), (20, 'Success')]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t2;
RESULT:
	[('Seq Scan on t2',)]

-----------
QUERY:

CREATE TABLE t3 AS SELECT * FROM t1;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM t3;
RESULT:
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3'), (20, 'Success')]

-----------
QUERY:

SELECT * INTO t4 FROM t1;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM t4;
RESULT:
	[(0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3'), (20, 'Success')]

-----------
QUERY:


--
-- RLS with JOIN
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE blog (id integer, author text, post text);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE comment (blog_id integer, message text);
RESULT:
	[]

-----------
QUERY:


GRANT ALL ON blog, comment TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


CREATE POLICY blog_1 ON blog USING (id % 2 = 0);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE blog ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


INSERT INTO blog VALUES
    (1, 'alice', 'blog #1'),
    (2, 'bob', 'blog #1'),
    (3, 'alice', 'blog #2'),
    (4, 'alice', 'blog #3'),
    (5, 'john', 'blog #1');
RESULT:
	[]

-----------
QUERY:


INSERT INTO comment VALUES
    (1, 'cool blog'),
    (1, 'fun blog'),
    (3, 'crazy blog'),
    (5, 'what?'),
    (4, 'insane!'),
    (2, 'who did it?');
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

-- Check RLS JOIN with Non-RLS.
SELECT id, author, message FROM blog JOIN comment ON id = blog_id;
RESULT:
	[(4, 'alice', 'insane!'), (2, 'bob', 'who did it?')]

-----------
QUERY:

-- Check Non-RLS JOIN with RLS.
SELECT id, author, message FROM comment JOIN blog ON id = blog_id;
RESULT:
	[(4, 'alice', 'insane!'), (2, 'bob', 'who did it?')]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY comment_1 ON comment USING (blog_id < 4);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE comment ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

-- Check RLS JOIN RLS
SELECT id, author, message FROM blog JOIN comment ON id = blog_id;
RESULT:
	[(2, 'bob', 'who did it?')]

-----------
QUERY:

SELECT id, author, message FROM comment JOIN blog ON id = blog_id;
RESULT:
	[(2, 'bob', 'who did it?')]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

DROP TABLE blog, comment;
RESULT:
	[]

-----------
QUERY:


--
-- Default Deny Policy
--
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p2 ON t1;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE t1 OWNER TO regress_rls_alice;
RESULT:
	[]

-----------
QUERY:


-- Check that default deny does not apply to superuser.
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM t1;
RESULT:
	[(1, '6b86b273ff34fce19d6b804eff5a3f57'), (3, '4e07408562bedb8b60ce05c1decfe3ad'), (5, 'ef2d127de37b942baad06145e54b0c61'), (7, '7902699be42c8a8e46fbbb4501726517'), (9, '19581e27de7ced00ff1ce50b2047e7a5'), (11, '4fc82b26aecb47d2868c4efbe3581732'), (13, '3fdba35f04dc8c462986c992bcf87554'), (15, 'e629fa6598d732768f7c726b4b621285'), (17, '4523540f1504cd17100c4835e85b7eef'), (19, '9400f1b21cb527d7fa3d3eabba93557a'), (0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3'), (20, 'Success')]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1;
RESULT:
	[('Seq Scan on t1',)]

-----------
QUERY:


-- Check that default deny does not apply to table owner.
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM t1;
RESULT:
	[(1, '6b86b273ff34fce19d6b804eff5a3f57'), (3, '4e07408562bedb8b60ce05c1decfe3ad'), (5, 'ef2d127de37b942baad06145e54b0c61'), (7, '7902699be42c8a8e46fbbb4501726517'), (9, '19581e27de7ced00ff1ce50b2047e7a5'), (11, '4fc82b26aecb47d2868c4efbe3581732'), (13, '3fdba35f04dc8c462986c992bcf87554'), (15, 'e629fa6598d732768f7c726b4b621285'), (17, '4523540f1504cd17100c4835e85b7eef'), (19, '9400f1b21cb527d7fa3d3eabba93557a'), (0, '5feceb66ffc86f38d952786c6d696c79'), (2, 'd4735e3a265e16eee03f59718b9b5d03'), (4, '4b227777d4dd1fc61c6f884f48641d02'), (6, 'e7f6c011776e8db7cd330b54174fd76f'), (8, '2c624232cdd221771294dfbb310aca00'), (10, '4a44dc15364204a80fe80e9039455cc1'), (12, '6b51d431df5d7f141cbececcf79edf3d'), (14, '8527a891e224136950ff32ca212b45bc'), (16, 'b17ef6d19c7a5b1ee83b907c595526dc'), (18, '4ec9599fc203d176a301536c2e091a19'), (20, 'f5ca38f748a1d6eaf726b8a42fb575c3'), (20, 'Success')]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1;
RESULT:
	[('Seq Scan on t1',)]

-----------
QUERY:


-- Check that default deny applies to non-owner/non-superuser when RLS on.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM t1;
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1;
RESULT:
	[('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM t1;
RESULT:
	[]

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT * FROM t1;
RESULT:
	[('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


--
-- COPY TO/FROM
--

RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

DROP TABLE copy_t CASCADE;
RESULT:
	ERROR - table "copy_t" does not exist


-----------
QUERY:

CREATE TABLE copy_t (a integer, b text);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p1 ON copy_t USING (a % 2 = 0);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE copy_t ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


GRANT ALL ON copy_t TO regress_rls_bob, regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:


INSERT INTO copy_t (SELECT x, public.fipshash(x::text) FROM generate_series(0,10) x);
RESULT:
	[]

-----------
QUERY:


-- Check COPY TO as Superuser/owner.
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:


-- Check COPY TO as user with permissions.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - query would be affected by row-level security policy for table "copy_t"


-----------
QUERY:
 --fail - would be affected by RLS
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 --ok

-- Check COPY TO as user with permissions and BYPASSRLS
SET SESSION AUTHORIZATION regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 --ok
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 --ok

-- Check COPY TO as user without permissions. SET row_security TO OFF /* REPLACED */ ,
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - query would be affected by row-level security policy for table "copy_t"


-----------
QUERY:
 --fail - would be affected by RLS
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY (SELECT * FROM copy_t ORDER BY a ASC) TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - permission denied for table copy_t


-----------
QUERY:
 --fail - permission denied

-- Check COPY relation TO /* REPLACED */ , keep it just one row to avoid reordering issues
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE copy_rel_to (a integer, b text);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p1 ON copy_rel_to USING (a % 2 = 0);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE copy_rel_to ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


GRANT ALL ON copy_rel_to TO regress_rls_bob, regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:


INSERT INTO copy_rel_to VALUES (1, public.fipshash('1'));
RESULT:
	[]

-----------
QUERY:


-- Check COPY TO as Superuser/owner.
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:


-- Check COPY TO as user with permissions.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - query would be affected by row-level security policy for table "copy_rel_to"


-----------
QUERY:
 --fail - would be affected by RLS
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 --ok

-- Check COPY TO as user with permissions and BYPASSRLS
SET SESSION AUTHORIZATION regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 --ok
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 --ok

-- Check COPY TO as user without permissions. SET row_security TO OFF /* REPLACED */ ,
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - permission denied for table copy_rel_to


-----------
QUERY:
 --fail - permission denied
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - permission denied for table copy_rel_to


-----------
QUERY:
 --fail - permission denied

-- Check behavior with a child table.
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE copy_rel_to_child () INHERITS (copy_rel_to);
RESULT:
	[]

-----------
QUERY:

INSERT INTO copy_rel_to_child VALUES (1, 'one'), (2, 'two');
RESULT:
	[]

-----------
QUERY:


-- Check COPY TO as Superuser/owner.
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:


-- Check COPY TO as user with permissions.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - query would be affected by row-level security policy for table "copy_rel_to"


-----------
QUERY:
 --fail - would be affected by RLS
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 --ok

-- Check COPY TO as user with permissions and BYPASSRLS
SET SESSION AUTHORIZATION regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 --ok
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - can't execute COPY TO: use the copy_to() method instead

-----------
QUERY:
 --ok

-- Check COPY TO as user without permissions. SET row_security TO OFF /* REPLACED */ ,
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - permission denied for table copy_rel_to


-----------
QUERY:
 --fail - permission denied
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_rel_to TO STDOUT WITH DELIMITER ',';
RESULT:
	ERROR - permission denied for table copy_rel_to


-----------
QUERY:
 --fail - permission denied

-- Check COPY FROM as Superuser/owner.
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_t FROM STDIN;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 --ok
1	abc
2	bcd
3	cde
4	def
-- \.
SET row_security TO ON;
RESULT:
	ERROR - syntax error at or near "1"
LINE 2: 1 abc
        ^


-----------
QUERY:

COPY copy_t FROM STDIN;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 --ok
1	abc
2	bcd
3	cde
4	def
-- \.

-- Check COPY FROM as user with permissions.
SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	ERROR - syntax error at or near "1"
LINE 2: 1 abc
        ^


-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_t FROM STDIN;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 --fail - would be affected by RLS.
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_t FROM STDIN;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 --fail - COPY FROM not supported by RLS.

-- Check COPY FROM as user with permissions and BYPASSRLS
SET SESSION AUTHORIZATION regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:

SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_t FROM STDIN;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 --ok
1	abc
2	bcd
3	cde
4	def
-- \.

-- Check COPY FROM as user without permissions.
SET SESSION AUTHORIZATION regress_rls_carol;
RESULT:
	ERROR - syntax error at or near "1"
LINE 2: 1 abc
        ^


-----------
QUERY:

SET row_security TO OFF;
RESULT:
	[]

-----------
QUERY:

COPY copy_t FROM STDIN;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 --fail - permission denied.
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

COPY copy_t FROM STDIN;
RESULT:
	ERROR - function missing required argument 'table' (pos 2)

-----------
QUERY:
 --fail - permission denied.

RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

DROP TABLE copy_t;
RESULT:
	[]

-----------
QUERY:

DROP TABLE copy_rel_to CASCADE;
RESULT:
	[]

-----------
QUERY:


-- Check WHERE CURRENT OF
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE current_check (currentid int, payload text, rlsuser text);
RESULT:
	[]

-----------
QUERY:

GRANT ALL ON current_check TO PUBLIC;
RESULT:
	[]

-----------
QUERY:


INSERT INTO current_check VALUES
    (1, 'abc', 'regress_rls_bob'),
    (2, 'bcd', 'regress_rls_bob'),
    (3, 'cde', 'regress_rls_bob'),
    (4, 'def', 'regress_rls_bob');
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON current_check FOR SELECT USING (currentid % 2 = 0);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON current_check FOR DELETE USING (currentid = 4 AND rlsuser = current_user);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON current_check FOR UPDATE USING (currentid = 4) WITH CHECK (rlsuser = current_user);
RESULT:
	[]

-----------
QUERY:


ALTER TABLE current_check ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


-- Can SELECT even rows
SELECT * FROM current_check;
RESULT:
	[(2, 'bcd', 'regress_rls_bob'), (4, 'def', 'regress_rls_bob')]

-----------
QUERY:


-- Cannot UPDATE row 2
UPDATE current_check SET payload = payload || '_new' WHERE currentid = 2 RETURNING *;
RESULT:
	[]

-----------
QUERY:


BEGIN;
RESULT:
	[]

-----------
QUERY:


DECLARE current_check_cursor SCROLL CURSOR FOR SELECT * FROM current_check;
RESULT:
	[]

-----------
QUERY:

-- Returns rows that can be seen according to SELECT policy, like plain SELECT
-- above (even rows)
FETCH ABSOLUTE 1 FROM current_check_cursor;
RESULT:
	[(2, 'bcd', 'regress_rls_bob')]

-----------
QUERY:

-- Still cannot UPDATE row 2 through cursor
UPDATE current_check SET payload = payload || '_new' WHERE CURRENT OF current_check_cursor RETURNING *;
RESULT:
	[]

-----------
QUERY:

-- Can update row 4 through cursor, which is the next visible row
FETCH RELATIVE 1 FROM current_check_cursor;
RESULT:
	[(4, 'def', 'regress_rls_bob')]

-----------
QUERY:

UPDATE current_check SET payload = payload || '_new' WHERE CURRENT OF current_check_cursor RETURNING *;
RESULT:
	[(4, 'def_new', 'regress_rls_bob')]

-----------
QUERY:

SELECT * FROM current_check;
RESULT:
	[(2, 'bcd', 'regress_rls_bob'), (4, 'def_new', 'regress_rls_bob')]

-----------
QUERY:

-- Plan should be a subquery TID scan
EXPLAIN (COSTS OFF) UPDATE current_check SET payload = payload WHERE CURRENT OF current_check_cursor;
RESULT:
	[('Update on current_check',), ('  ->  Tid Scan on current_check',), ('        TID Cond: CURRENT OF current_check_cursor',), ('        Filter: ((currentid = 4) AND ((currentid % 2) = 0))',)]

-----------
QUERY:

-- Similarly can only delete row 4
FETCH ABSOLUTE 1 FROM current_check_cursor;
RESULT:
	[(2, 'bcd', 'regress_rls_bob')]

-----------
QUERY:

DELETE FROM current_check WHERE CURRENT OF current_check_cursor RETURNING *;
RESULT:
	[]

-----------
QUERY:

FETCH RELATIVE 1 FROM current_check_cursor;
RESULT:
	[(4, 'def', 'regress_rls_bob')]

-----------
QUERY:

DELETE FROM current_check WHERE CURRENT OF current_check_cursor RETURNING *;
RESULT:
	[(4, 'def_new', 'regress_rls_bob')]

-----------
QUERY:

SELECT * FROM current_check;
RESULT:
	[(2, 'bcd', 'regress_rls_bob')]

-----------
QUERY:


COMMIT;
RESULT:
	[]

-----------
QUERY:


--
-- check pg_stats view filtering
--
SET row_security TO ON;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

ANALYZE current_check;
RESULT:
	[]

-----------
QUERY:

-- Stats visible
SELECT row_security_active('current_check');
RESULT:
	[(False,)]

-----------
QUERY:

SELECT attname, most_common_vals FROM pg_stats
  WHERE tablename = 'current_check'
  ORDER BY 1;
RESULT:
	[('currentid', None), ('payload', None), ('rlsuser', '{regress_rls_bob}')]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

-- Stats not visible
SELECT row_security_active('current_check');
RESULT:
	[(True,)]

-----------
QUERY:

SELECT attname, most_common_vals FROM pg_stats
  WHERE tablename = 'current_check'
  ORDER BY 1;
RESULT:
	[]

-----------
QUERY:


--
-- Collation support
--
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE coll_t (c) AS VALUES ('bar'::text);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY coll_p ON coll_t USING (c < ('foo'::text COLLATE "C"));
RESULT:
	[]

-----------
QUERY:

ALTER TABLE coll_t ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON coll_t TO regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SELECT (string_to_array(polqual, ':'))[7] AS inputcollid FROM pg_policy WHERE polrelid = 'coll_t'::regclass;
RESULT:
	[('inputcollid 950 ',)]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM coll_t;
RESULT:
	[('bar',)]

-----------
QUERY:

ROLLBACK;
RESULT:
	[]

-----------
QUERY:


--
-- Shared Object Dependencies
--
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_rls_eve;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_rls_frank;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE tbl1 (c) AS VALUES ('bar'::text);
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON TABLE tbl1 TO regress_rls_eve;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY P ON tbl1 TO regress_rls_eve, regress_rls_frank USING (true);
RESULT:
	[]

-----------
QUERY:

SELECT refclassid::regclass, deptype
  FROM pg_depend
  WHERE classid = 'pg_policy'::regclass
  AND refobjid = 'tbl1'::regclass;
RESULT:
	[('pg_class', 'a')]

-----------
QUERY:

SELECT refclassid::regclass, deptype
  FROM pg_shdepend
  WHERE classid = 'pg_policy'::regclass
  AND refobjid IN ('regress_rls_eve'::regrole, 'regress_rls_frank'::regrole);
RESULT:
	[('pg_authid', 'r'), ('pg_authid', 'r')]

-----------
QUERY:


SAVEPOINT q;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_rls_eve;
RESULT:
	ERROR - role "regress_rls_eve" cannot be dropped because some objects depend on it
DETAIL:  privileges for table tbl1
target of policy p on table tbl1


-----------
QUERY:
 --fails due to dependency on POLICY p
ROLLBACK TO q;
RESULT:
	[]

-----------
QUERY:


ALTER POLICY p ON tbl1 TO regress_rls_frank USING (true);
RESULT:
	[]

-----------
QUERY:

SAVEPOINT q;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_rls_eve;
RESULT:
	ERROR - role "regress_rls_eve" cannot be dropped because some objects depend on it
DETAIL:  privileges for table tbl1


-----------
QUERY:
 --fails due to dependency on GRANT SELECT
ROLLBACK TO q;
RESULT:
	[]

-----------
QUERY:


REVOKE ALL ON TABLE tbl1 FROM regress_rls_eve;
RESULT:
	[]

-----------
QUERY:

SAVEPOINT q;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_rls_eve;
RESULT:
	[]

-----------
QUERY:
 --succeeds
ROLLBACK TO q;
RESULT:
	[]

-----------
QUERY:


SAVEPOINT q;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_rls_frank;
RESULT:
	ERROR - role "regress_rls_frank" cannot be dropped because some objects depend on it
DETAIL:  target of policy p on table tbl1


-----------
QUERY:
 --fails due to dependency on POLICY p
ROLLBACK TO q;
RESULT:
	[]

-----------
QUERY:


DROP POLICY p ON tbl1;
RESULT:
	[]

-----------
QUERY:

SAVEPOINT q;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_rls_frank;
RESULT:
	[]

-----------
QUERY:
 -- succeeds
ROLLBACK TO q;
RESULT:
	[]

-----------
QUERY:


ROLLBACK;
RESULT:
	[]

-----------
QUERY:
 -- cleanup

--
-- Policy expression handling
--
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE t (c) AS VALUES ('bar'::text);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p ON t USING (max(c));
RESULT:
	ERROR - aggregate functions are not allowed in policy expressions


-----------
QUERY:
 -- fails: aggregate functions are not allowed in policy expressions
ROLLBACK;
RESULT:
	[]

-----------
QUERY:


--
-- Non-target relations are only subject to SELECT policies
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE r1 (a int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE r2 (a int);
RESULT:
	[]

-----------
QUERY:

INSERT INTO r1 VALUES (10), (20);
RESULT:
	[]

-----------
QUERY:

INSERT INTO r2 VALUES (10), (20);
RESULT:
	[]

-----------
QUERY:


GRANT ALL ON r1, r2 TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON r1 USING (true);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON r2 FOR SELECT USING (true);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON r2 FOR INSERT WITH CHECK (false);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON r2 FOR UPDATE USING (false);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p4 ON r2 FOR DELETE USING (false);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM r1;
RESULT:
	[(10,), (20,)]

-----------
QUERY:

SELECT * FROM r2;
RESULT:
	[(10,), (20,)]

-----------
QUERY:


-- r2 is read-only
INSERT INTO r2 VALUES (2);
RESULT:
	ERROR - new row violates row-level security policy for table "r2"


-----------
QUERY:
 -- Not allowed
UPDATE r2 SET a = 2 RETURNING *;
RESULT:
	[]

-----------
QUERY:
 -- Updates nothing
DELETE FROM r2 RETURNING *;
RESULT:
	[]

-----------
QUERY:
 -- Deletes nothing

-- r2 can be used as a non-target relation in DML
INSERT INTO r1 SELECT a + 1 FROM r2 RETURNING *;
RESULT:
	[(11,), (21,)]

-----------
QUERY:
 -- OK
UPDATE r1 SET a = r2.a + 2 FROM r2 WHERE r1.a = r2.a RETURNING *;
RESULT:
	[(12, 10), (22, 20)]

-----------
QUERY:
 -- OK
DELETE FROM r1 USING r2 WHERE r1.a = r2.a + 2 RETURNING *;
RESULT:
	[(12, 10), (22, 20)]

-----------
QUERY:
 -- OK
SELECT * FROM r1;
RESULT:
	[(11,), (21,)]

-----------
QUERY:

SELECT * FROM r2;
RESULT:
	[(10,), (20,)]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

DROP TABLE r1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE r2;
RESULT:
	[]

-----------
QUERY:


--
-- FORCE ROW LEVEL SECURITY applies RLS to owners too
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SET row_security = on;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE r1 (a int);
RESULT:
	[]

-----------
QUERY:

INSERT INTO r1 VALUES (10), (20);
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON r1 USING (false);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- No error, but no rows
TABLE r1;
RESULT:
	[]

-----------
QUERY:


-- RLS error
INSERT INTO r1 VALUES (1);
RESULT:
	ERROR - new row violates row-level security policy for table "r1"


-----------
QUERY:


-- No error (unable to see any rows to update)
UPDATE r1 SET a = 1;
RESULT:
	[]

-----------
QUERY:

TABLE r1;
RESULT:
	[]

-----------
QUERY:


-- No error (unable to see any rows to delete)
DELETE FROM r1;
RESULT:
	[]

-----------
QUERY:

TABLE r1;
RESULT:
	[]

-----------
QUERY:


SET row_security = off;
RESULT:
	[]

-----------
QUERY:

-- these all fail, would be affected by RLS
TABLE r1;
RESULT:
	ERROR - query would be affected by row-level security policy for table "r1"
HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.


-----------
QUERY:

UPDATE r1 SET a = 1;
RESULT:
	ERROR - query would be affected by row-level security policy for table "r1"
HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.


-----------
QUERY:

DELETE FROM r1;
RESULT:
	ERROR - query would be affected by row-level security policy for table "r1"
HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.


-----------
QUERY:


DROP TABLE r1;
RESULT:
	[]

-----------
QUERY:


--
-- FORCE ROW LEVEL SECURITY does not break RI
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SET row_security = on;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE r1 (a int PRIMARY KEY);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE r2 (a int REFERENCES r1);
RESULT:
	[]

-----------
QUERY:

INSERT INTO r1 VALUES (10), (20);
RESULT:
	[]

-----------
QUERY:

INSERT INTO r2 VALUES (10), (20);
RESULT:
	[]

-----------
QUERY:


-- Create policies on r2 which prevent the
-- owner from seeing any rows, but RI should
-- still see them.
CREATE POLICY p1 ON r2 USING (false);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- Errors due to rows in r2
DELETE FROM r1;
RESULT:
	ERROR - update or delete on table "r1" violates foreign key constraint "r2_a_fkey" on table "r2"
DETAIL:  Key (a)=(10) is still referenced from table "r2".


-----------
QUERY:


-- Reset r2 to no-RLS
DROP POLICY p1 ON r2;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r2 DISABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- clean out r2 for INSERT test below
DELETE FROM r2;
RESULT:
	[]

-----------
QUERY:


-- Change r1 to not allow rows to be seen
CREATE POLICY p1 ON r1 USING (false);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- No rows seen
TABLE r1;
RESULT:
	[]

-----------
QUERY:


-- No error, RI still sees that row exists in r1
INSERT INTO r2 VALUES (10);
RESULT:
	[]

-----------
QUERY:


DROP TABLE r2;
RESULT:
	[]

-----------
QUERY:

DROP TABLE r1;
RESULT:
	[]

-----------
QUERY:


-- Ensure cascaded DELETE works
CREATE TABLE r1 (a int PRIMARY KEY);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE r2 (a int REFERENCES r1 ON DELETE CASCADE);
RESULT:
	[]

-----------
QUERY:

INSERT INTO r1 VALUES (10), (20);
RESULT:
	[]

-----------
QUERY:

INSERT INTO r2 VALUES (10), (20);
RESULT:
	[]

-----------
QUERY:


-- Create policies on r2 which prevent the
-- owner from seeing any rows, but RI should
-- still see them.
CREATE POLICY p1 ON r2 USING (false);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- Deletes all records from both
DELETE FROM r1;
RESULT:
	[]

-----------
QUERY:


-- Remove FORCE from r2
ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- As owner, we now bypass RLS
-- verify no rows in r2 now
TABLE r2;
RESULT:
	[]

-----------
QUERY:


DROP TABLE r2;
RESULT:
	[]

-----------
QUERY:

DROP TABLE r1;
RESULT:
	[]

-----------
QUERY:


-- Ensure cascaded UPDATE works
CREATE TABLE r1 (a int PRIMARY KEY);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE r2 (a int REFERENCES r1 ON UPDATE CASCADE);
RESULT:
	[]

-----------
QUERY:

INSERT INTO r1 VALUES (10), (20);
RESULT:
	[]

-----------
QUERY:

INSERT INTO r2 VALUES (10), (20);
RESULT:
	[]

-----------
QUERY:


-- Create policies on r2 which prevent the
-- owner from seeing any rows, but RI should
-- still see them.
CREATE POLICY p1 ON r2 USING (false);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r2 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r2 FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- Updates records in both
UPDATE r1 SET a = a+5;
RESULT:
	[]

-----------
QUERY:


-- Remove FORCE from r2
ALTER TABLE r2 NO FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- As owner, we now bypass RLS
-- verify records in r2 updated
TABLE r2;
RESULT:
	[(15,), (25,)]

-----------
QUERY:


DROP TABLE r2;
RESULT:
	[]

-----------
QUERY:

DROP TABLE r1;
RESULT:
	[]

-----------
QUERY:


--
-- Test INSERT+RETURNING applies SELECT policies as
-- WithCheckOptions (meaning an error is thrown)
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SET row_security = on;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE r1 (a int);
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON r1 FOR SELECT USING (false);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON r1 FOR INSERT WITH CHECK (true);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- Works fine
INSERT INTO r1 VALUES (10), (20);
RESULT:
	[]

-----------
QUERY:


-- No error, but no rows
TABLE r1;
RESULT:
	[]

-----------
QUERY:


SET row_security = off;
RESULT:
	[]

-----------
QUERY:

-- fail, would be affected by RLS
TABLE r1;
RESULT:
	ERROR - query would be affected by row-level security policy for table "r1"
HINT:  To disable the policy for the table's owner, use ALTER TABLE NO FORCE ROW LEVEL SECURITY.


-----------
QUERY:


SET row_security = on;
RESULT:
	[]

-----------
QUERY:


-- Error
INSERT INTO r1 VALUES (10), (20) RETURNING *;
RESULT:
	ERROR - new row violates row-level security policy for table "r1"


-----------
QUERY:


DROP TABLE r1;
RESULT:
	[]

-----------
QUERY:


--
-- Test UPDATE+RETURNING applies SELECT policies as
-- WithCheckOptions (meaning an error is thrown)
--
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SET row_security = on;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE r1 (a int PRIMARY KEY);
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON r1 FOR SELECT USING (a < 20);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON r1 FOR UPDATE USING (a < 20) WITH CHECK (true);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON r1 FOR INSERT WITH CHECK (true);
RESULT:
	[]

-----------
QUERY:

INSERT INTO r1 VALUES (10);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r1 ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- Works fine
UPDATE r1 SET a = 30;
RESULT:
	[]

-----------
QUERY:


-- Show updated rows
ALTER TABLE r1 NO FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

TABLE r1;
RESULT:
	[(30,)]

-----------
QUERY:

-- reset value in r1 for test with RETURNING
UPDATE r1 SET a = 10;
RESULT:
	[]

-----------
QUERY:


-- Verify row reset
TABLE r1;
RESULT:
	[(10,)]

-----------
QUERY:


ALTER TABLE r1 FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


-- Error
UPDATE r1 SET a = 30 RETURNING *;
RESULT:
	ERROR - new row violates row-level security policy for table "r1"


-----------
QUERY:


-- UPDATE path of INSERT ... ON CONFLICT DO UPDATE should also error out
INSERT INTO r1 VALUES (10)
    ON CONFLICT (a) DO UPDATE SET a = 30 RETURNING *;
RESULT:
	ERROR - new row violates row-level security policy for table "r1"


-----------
QUERY:


-- Should still error out without RETURNING (use of arbiter always requires
-- SELECT permissions)
INSERT INTO r1 VALUES (10)
    ON CONFLICT (a) DO UPDATE SET a = 30;
RESULT:
	ERROR - new row violates row-level security policy for table "r1"


-----------
QUERY:

INSERT INTO r1 VALUES (10)
    ON CONFLICT ON CONSTRAINT r1_pkey DO UPDATE SET a = 30;
RESULT:
	ERROR - new row violates row-level security policy for table "r1"


-----------
QUERY:


DROP TABLE r1;
RESULT:
	[]

-----------
QUERY:


-- Check dependency handling
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE dep1 (c1 int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE dep2 (c1 int);
RESULT:
	[]

-----------
QUERY:


CREATE POLICY dep_p1 ON dep1 TO regress_rls_bob USING (c1 > (select max(dep2.c1) from dep2));
RESULT:
	[]

-----------
QUERY:

ALTER POLICY dep_p1 ON dep1 TO regress_rls_bob,regress_rls_carol;
RESULT:
	[]

-----------
QUERY:


-- Should return one
SELECT count(*) = 1 FROM pg_depend
				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
					 AND refobjid = (SELECT oid FROM pg_class WHERE relname = 'dep2');
RESULT:
	[(True,)]

-----------
QUERY:


ALTER POLICY dep_p1 ON dep1 USING (true);
RESULT:
	[]

-----------
QUERY:


-- Should return one
SELECT count(*) = 1 FROM pg_shdepend
				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
					 AND refobjid = (SELECT oid FROM pg_authid WHERE rolname = 'regress_rls_bob');
RESULT:
	[(True,)]

-----------
QUERY:


-- Should return one
SELECT count(*) = 1 FROM pg_shdepend
				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
					 AND refobjid = (SELECT oid FROM pg_authid WHERE rolname = 'regress_rls_carol');
RESULT:
	[(True,)]

-----------
QUERY:


-- Should return zero
SELECT count(*) = 0 FROM pg_depend
				   WHERE objid = (SELECT oid FROM pg_policy WHERE polname = 'dep_p1')
					 AND refobjid = (SELECT oid FROM pg_class WHERE relname = 'dep2');
RESULT:
	[(True,)]

-----------
QUERY:


-- DROP OWNED BY testing
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:


CREATE ROLE regress_rls_dob_role1;
RESULT:
	[]

-----------
QUERY:

CREATE ROLE regress_rls_dob_role2;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE dob_t1 (c1 int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE dob_t2 (c1 int) PARTITION BY RANGE (c1);
RESULT:
	[]

-----------
QUERY:


CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1 USING (true);
RESULT:
	[]

-----------
QUERY:

DROP OWNED BY regress_rls_dob_role1;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p1 ON dob_t1;
RESULT:
	ERROR - policy "p1" for table "dob_t1" does not exist


-----------
QUERY:
 -- should fail, already gone

CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
RESULT:
	[]

-----------
QUERY:

DROP OWNED BY regress_rls_dob_role1;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p1 ON dob_t1;
RESULT:
	[]

-----------
QUERY:
 -- should succeed

-- same cases with duplicate polroles entries
CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role1 USING (true);
RESULT:
	[]

-----------
QUERY:

DROP OWNED BY regress_rls_dob_role1;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p1 ON dob_t1;
RESULT:
	ERROR - policy "p1" for table "dob_t1" does not exist


-----------
QUERY:
 -- should fail, already gone

CREATE POLICY p1 ON dob_t1 TO regress_rls_dob_role1,regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
RESULT:
	[]

-----------
QUERY:

DROP OWNED BY regress_rls_dob_role1;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p1 ON dob_t1;
RESULT:
	[]

-----------
QUERY:
 -- should succeed

-- partitioned target
CREATE POLICY p1 ON dob_t2 TO regress_rls_dob_role1,regress_rls_dob_role2 USING (true);
RESULT:
	[]

-----------
QUERY:

DROP OWNED BY regress_rls_dob_role1;
RESULT:
	[]

-----------
QUERY:

DROP POLICY p1 ON dob_t2;
RESULT:
	[]

-----------
QUERY:
 -- should succeed

DROP USER regress_rls_dob_role1;
RESULT:
	[]

-----------
QUERY:

DROP USER regress_rls_dob_role2;
RESULT:
	[]

-----------
QUERY:


-- Bug #15708: view + table with RLS should check policies as view owner
CREATE TABLE ref_tbl (a int);
RESULT:
	[]

-----------
QUERY:

INSERT INTO ref_tbl VALUES (1);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE rls_tbl (a int);
RESULT:
	[]

-----------
QUERY:

INSERT INTO rls_tbl VALUES (10);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p1 ON rls_tbl USING (EXISTS (SELECT 1 FROM ref_tbl));
RESULT:
	[]

-----------
QUERY:


GRANT SELECT ON ref_tbl TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON rls_tbl TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:


CREATE VIEW rls_view AS SELECT * FROM rls_tbl;
RESULT:
	[]

-----------
QUERY:

ALTER VIEW rls_view OWNER TO regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON rls_view TO regress_rls_alice;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM ref_tbl;
RESULT:
	ERROR - permission denied for table ref_tbl


-----------
QUERY:
 -- Permission denied
SELECT * FROM rls_tbl;
RESULT:
	ERROR - permission denied for table rls_tbl


-----------
QUERY:
 -- Permission denied
SELECT * FROM rls_view;
RESULT:
	[(10,)]

-----------
QUERY:
 -- OK
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:


DROP VIEW rls_view;
RESULT:
	[]

-----------
QUERY:

DROP TABLE rls_tbl;
RESULT:
	[]

-----------
QUERY:

DROP TABLE ref_tbl;
RESULT:
	[]

-----------
QUERY:


-- Leaky operator test
CREATE TABLE rls_tbl (a int);
RESULT:
	[]

-----------
QUERY:

INSERT INTO rls_tbl SELECT x/10 FROM generate_series(1, 100) x;
RESULT:
	[]

-----------
QUERY:

ANALYZE rls_tbl;
RESULT:
	[]

-----------
QUERY:


ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

GRANT SELECT ON rls_tbl TO regress_rls_alice;
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE FUNCTION op_leak(int, int) RETURNS bool
    AS 'BEGIN RAISE NOTICE ''op_leak => %, %'', $1, $2;
RESULT:
	ERROR - unterminated quoted string at or near "'BEGIN RAISE NOTICE ''op_leak => %, %'', $1, $2;"
LINE 3:     AS 'BEGIN RAISE NOTICE ''op_leak => %, %'', $1, $2;
               ^


-----------
QUERY:
 RETURN $1 < $2;
RESULT:
	ERROR - syntax error at or near "RETURN"
LINE 1:  RETURN $1 < $2;
         ^


-----------
QUERY:
 END'
    LANGUAGE plpgsql;
RESULT:
	ERROR - unterminated quoted string at or near "'
    LANGUAGE plpgsql;"
LINE 1:  END'
            ^


-----------
QUERY:

CREATE OPERATOR <<< (procedure = op_leak, leftarg = int, rightarg = int,
                     restrict = scalarltsel);
RESULT:
	ERROR - function op_leak(integer, integer) does not exist


-----------
QUERY:

SELECT * FROM rls_tbl WHERE a <<< 1000;
RESULT:
	ERROR - operator does not exist: integer <<< integer
LINE 2: SELECT * FROM rls_tbl WHERE a <<< 1000;
                                      ^
HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

DROP OPERATOR <<< (int, int);
RESULT:
	ERROR - operator does not exist: integer <<< integer


-----------
QUERY:

DROP FUNCTION op_leak(int, int);
RESULT:
	ERROR - function op_leak(integer, integer) does not exist


-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

DROP TABLE rls_tbl;
RESULT:
	[]

-----------
QUERY:


-- Bug #16006: whole-row Vars in a policy don/* REPLACED */ ''t play nice with sub-selects
SET SESSION AUTHORIZATION regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE rls_tbl (a int, b int, c int);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p1 ON rls_tbl USING (rls_tbl >= ROW(1,1,1));
RESULT:
	[]

-----------
QUERY:


ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE rls_tbl FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:


INSERT INTO rls_tbl SELECT 10, 20, 30;
RESULT:
	[]

-----------
QUERY:

EXPLAIN (VERBOSE, COSTS OFF)
INSERT INTO rls_tbl
  SELECT * FROM (SELECT b, c FROM rls_tbl ORDER BY a) ss;
RESULT:
	[('Insert on regress_rls_schema.rls_tbl',), ('  ->  Subquery Scan on ss',), ('        Output: ss.b, ss.c, NULL::integer',), ('        ->  Sort',), ('              Output: rls_tbl_1.b, rls_tbl_1.c, rls_tbl_1.a',), ('              Sort Key: rls_tbl_1.a',), ('              ->  Seq Scan on regress_rls_schema.rls_tbl rls_tbl_1',), ('                    Output: rls_tbl_1.b, rls_tbl_1.c, rls_tbl_1.a',), ("                    Filter: (rls_tbl_1.* >= '(1,1,1)'::record)",)]

-----------
QUERY:

INSERT INTO rls_tbl
  SELECT * FROM (SELECT b, c FROM rls_tbl ORDER BY a) ss;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rls_tbl;
RESULT:
	[(10, 20, 30), (20, 30, None)]

-----------
QUERY:


DROP TABLE rls_tbl;
RESULT:
	[]

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:


-- CVE-2023-2455: inlining an SRF may introduce an RLS dependency
create table rls_t (c text);
RESULT:
	[]

-----------
QUERY:

insert into rls_t values ('invisible to bob');
RESULT:
	[]

-----------
QUERY:

alter table rls_t enable row level security;
RESULT:
	[]

-----------
QUERY:

grant select on rls_t to regress_rls_alice, regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

create policy p1 on rls_t for select to regress_rls_alice using (true);
RESULT:
	[]

-----------
QUERY:

create policy p2 on rls_t for select to regress_rls_bob using (false);
RESULT:
	[]

-----------
QUERY:

create function rls_f () returns setof rls_t
  stable language sql
  as $$ select * from rls_t $$;
RESULT:
	[]

-----------
QUERY:

prepare q as select current_user, * from rls_f();
RESULT:
	[]

-----------
QUERY:

set role regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

execute q;
RESULT:
	[('regress_rls_alice', 'invisible to bob')]

-----------
QUERY:

set role regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

execute q;
RESULT:
	[]

-----------
QUERY:


RESET ROLE;
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION rls_f();
RESULT:
	[]

-----------
QUERY:

DROP TABLE rls_t;
RESULT:
	[]

-----------
QUERY:


--
-- Clean up objects
--
RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:


DROP SCHEMA regress_rls_schema CASCADE;
RESULT:
	[]

-----------
QUERY:


DROP USER regress_rls_alice;
RESULT:
	[]

-----------
QUERY:

DROP USER regress_rls_bob;
RESULT:
	[]

-----------
QUERY:

DROP USER regress_rls_carol;
RESULT:
	[]

-----------
QUERY:

DROP USER regress_rls_dave;
RESULT:
	[]

-----------
QUERY:

DROP USER regress_rls_exempt_user;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_rls_group1;
RESULT:
	[]

-----------
QUERY:

DROP ROLE regress_rls_group2;
RESULT:
	[]

-----------
QUERY:


-- Arrange to have a few policies left over, for testing
-- pg_dump/pg_restore
CREATE SCHEMA regress_rls_schema;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE rls_tbl (c1 int);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE rls_tbl ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p1 ON rls_tbl USING (c1 > 5);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON rls_tbl FOR SELECT USING (c1 <= 3);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON rls_tbl FOR UPDATE USING (c1 <= 3) WITH CHECK (c1 > 5);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p4 ON rls_tbl FOR DELETE USING (c1 <= 3);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE rls_tbl_force (c1 int);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE rls_tbl_force ENABLE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE rls_tbl_force FORCE ROW LEVEL SECURITY;
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p1 ON rls_tbl_force USING (c1 = 5) WITH CHECK (c1 < 5);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p2 ON rls_tbl_force FOR SELECT USING (c1 = 8);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p3 ON rls_tbl_force FOR UPDATE USING (c1 = 8) WITH CHECK (c1 >= 5);
RESULT:
	[]

-----------
QUERY:

CREATE POLICY p4 ON rls_tbl_force FOR DELETE USING (c1 = 8);
RESULT:
	[]
