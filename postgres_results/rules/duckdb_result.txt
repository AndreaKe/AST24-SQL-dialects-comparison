
-----------
QUERY:
--
-- RULES
-- From Jan/* REPLACED */ ''s original setup_ruletest.sql and run_ruletest.sql
-- - thomas 1998-09-13
--

--
-- Tables and rules for the view test
--
create table rtest_t1 (a int4, b int4);
RESULT:
	[]

-----------
QUERY:

create table rtest_t2 (a int4, b int4);
RESULT:
	[]

-----------
QUERY:

create table rtest_t3 (a int4, b int4);
RESULT:
	[]

-----------
QUERY:


create view rtest_v1 as select * from rtest_t1;
RESULT:
	[]

-----------
QUERY:

create rule rtest_v1_ins as on insert to rtest_v1 do instead
	insert into rtest_t1 values (new.a, new.b);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

create rule rtest_v1_upd as on update to rtest_v1 do instead
	update rtest_t1 set a = new.a, b = new.b
	where a = old.a;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

create rule rtest_v1_del as on delete to rtest_v1 do instead
	delete from rtest_t1 where a = old.a;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

-- Test comments
COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'bad rule';
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'delete rule';
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

--
-- Tables and rules for the constraint update/delete test
--
-- Note:
-- 	Now that we have multiple action rule support, we check
-- 	both possible syntaxes to define them (The last action
--  can but must not have a semicolon at the end).
--
create table rtest_system (sysname text, sysdesc text);
RESULT:
	[]

-----------
QUERY:

create table rtest_interface (sysname text, ifname text);
RESULT:
	[]

-----------
QUERY:

create table rtest_person (pname text, pdesc text);
RESULT:
	[]

-----------
QUERY:

create table rtest_admin (pname text, sysname text);
RESULT:
	[]

-----------
QUERY:


create rule rtest_sys_upd as on update to rtest_system do also (
	update rtest_interface set sysname = new.sysname
		where sysname = old.sysname;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

	update rtest_admin set sysname = new.sysname
		where sysname = old.sysname
	);
RESULT:
	ERROR - Parser Error: syntax error at or near ")"

-----------
QUERY:


create rule rtest_sys_del as on delete to rtest_system do also (
	delete from rtest_interface where sysname = old.sysname;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

	delete from rtest_admin where sysname = old.sysname;
RESULT:
	ERROR - Binder Error: Referenced table "old" not found!
Candidate tables: "rtest_admin"
LINE 2: ...delete from rtest_admin where sysname = old.sysname;
                                                  ^

-----------
QUERY:

	);
RESULT:
	ERROR - Parser Error: syntax error at or near ")"

-----------
QUERY:


create rule rtest_pers_upd as on update to rtest_person do also
	update rtest_admin set pname = new.pname where pname = old.pname;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_pers_del as on delete to rtest_person do also
	delete from rtest_admin where pname = old.pname;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


--
-- Tables and rules for the logging test
--
create table rtest_emp (ename char(20), salary numeric);
RESULT:
	[]

-----------
QUERY:

create table rtest_emplog (ename char(20), who name, action char(10), newsal numeric, oldsal numeric);
RESULT:
	ERROR - Catalog Error: Type with name name does not exist!
Did you mean "date"?

-----------
QUERY:

create table rtest_empmass (ename char(20), salary numeric);
RESULT:
	[]

-----------
QUERY:


create rule rtest_emp_ins as on insert to rtest_emp do
	insert into rtest_emplog values (new.ename, current_user,
			'hired', new.salary, '0.00');
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_emp_upd as on update to rtest_emp where new.salary != old.salary do
	insert into rtest_emplog values (new.ename, current_user,
			'honored', new.salary, old.salary);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_emp_del as on delete to rtest_emp do
	insert into rtest_emplog values (old.ename, current_user,
			'fired', '0.00', old.salary);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


--
-- Tables and rules for the multiple cascaded qualified instead
-- rule test
--
create table rtest_t4 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_t5 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_t6 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_t7 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_t8 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_t9 (a int4, b text);
RESULT:
	[]

-----------
QUERY:


create rule rtest_t4_ins1 as on insert to rtest_t4
		where new.a >= 10 and new.a < 20 do instead
	insert into rtest_t5 values (new.a, new.b);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_t4_ins2 as on insert to rtest_t4
		where new.a >= 20 and new.a < 30 do
	insert into rtest_t6 values (new.a, new.b);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_t5_ins as on insert to rtest_t5
		where new.a > 15 do
	insert into rtest_t7 values (new.a, new.b);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_t6_ins as on insert to rtest_t6
		where new.a > 25 do instead
	insert into rtest_t8 values (new.a, new.b);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


--
-- Tables and rules for the rule fire order test
--
-- As of PG 7.3, the rules should fire in order by name, regardless
-- of INSTEAD attributes or creation order.
--
create table rtest_order1 (a int4);
RESULT:
	[]

-----------
QUERY:

create table rtest_order2 (a int4, b int4, c text);
RESULT:
	[]

-----------
QUERY:


create sequence rtest_seq;
RESULT:
	[]

-----------
QUERY:


create rule rtest_order_r3 as on insert to rtest_order1 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 3 - this should run 3rd');
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_order_r4 as on insert to rtest_order1
		where a < 100 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 4 - this should run 4th');
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_order_r2 as on insert to rtest_order1 do
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 2 - this should run 2nd');
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_order_r1 as on insert to rtest_order1 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 1 - this should run 1st');
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


--
-- Tables and rules for the instead nothing test
--
create table rtest_nothn1 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_nothn2 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_nothn3 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_nothn4 (a int4, b text);
RESULT:
	[]

-----------
QUERY:


create rule rtest_nothn_r1 as on insert to rtest_nothn1
	where new.a >= 10 and new.a < 20 do instead nothing;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_nothn_r2 as on insert to rtest_nothn1
	where new.a >= 30 and new.a < 40 do instead nothing;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_nothn_r3 as on insert to rtest_nothn2
	where new.a >= 100 do instead
	insert into rtest_nothn3 values (new.a, new.b);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule rtest_nothn_r4 as on insert to rtest_nothn2
	do instead nothing;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


--
-- Tests on a view that is select * of a table
-- and has insert/update/delete instead rules to
-- behave close like the real table.
--

--
-- We need test date later
--
insert into rtest_t2 values (1, 21);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t2 values (2, 22);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t2 values (3, 23);
RESULT:
	[]

-----------
QUERY:


insert into rtest_t3 values (1, 31);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t3 values (2, 32);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t3 values (3, 33);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t3 values (4, 34);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t3 values (5, 35);
RESULT:
	[]

-----------
QUERY:


-- insert values
insert into rtest_v1 values (1, 11);
RESULT:
	ERROR - Catalog Error: rtest_v1 is not an table

-----------
QUERY:

insert into rtest_v1 values (2, 12);
RESULT:
	ERROR - Catalog Error: rtest_v1 is not an table

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:


-- delete with constant expression
delete from rtest_v1 where a = 1;
RESULT:
	ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

insert into rtest_v1 values (1, 11);
RESULT:
	ERROR - Catalog Error: rtest_v1 is not an table

-----------
QUERY:

delete from rtest_v1 where b = 12;
RESULT:
	ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

insert into rtest_v1 values (2, 12);
RESULT:
	ERROR - Catalog Error: rtest_v1 is not an table

-----------
QUERY:

insert into rtest_v1 values (2, 13);
RESULT:
	ERROR - Catalog Error: rtest_v1 is not an table

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

** Remember the delete rule on rtest_v1: It says
** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
** So this time both rows with a = 2 must get deleted
-- \p
-- \r
delete from rtest_v1 where b = 12;
RESULT:
	ERROR - Parser Error: syntax error at or near "**"

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

delete from rtest_v1;
RESULT:
	ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:


-- insert select
insert into rtest_v1 select * from rtest_t2;
RESULT:
	ERROR - Catalog Error: rtest_v1 is not an table

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

delete from rtest_v1;
RESULT:
	ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:


-- same with swapped targetlist
insert into rtest_v1 (b, a) select b, a from rtest_t2;
RESULT:
	ERROR - Catalog Error: rtest_v1 is not an table

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:


-- now with only one target attribute
insert into rtest_v1 (a) select a from rtest_t3;
RESULT:
	ERROR - Catalog Error: rtest_v1 is not an table

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1 where b isnull;
RESULT:
	[]

-----------
QUERY:


-- let attribute a differ (must be done on rtest_t1 - see above)
update rtest_t1 set a = a + 10 where b isnull;
RESULT:
	[]

-----------
QUERY:

delete from rtest_v1 where b isnull;
RESULT:
	ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:


-- now updates with constant expression
update rtest_v1 set b = 42 where a = 2;
RESULT:
	ERROR - Binder Error: Can only update base table!

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

update rtest_v1 set b = 99 where b = 42;
RESULT:
	ERROR - Binder Error: Can only update base table!

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

update rtest_v1 set b = 88 where b < 50;
RESULT:
	ERROR - Binder Error: Can only update base table!

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

delete from rtest_v1;
RESULT:
	ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

insert into rtest_v1 select rtest_t2.a, rtest_t3.b
    from rtest_t2, rtest_t3
    where rtest_t2.a = rtest_t3.a;
RESULT:
	ERROR - Catalog Error: rtest_v1 is not an table

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:


-- updates in a mergejoin
update rtest_v1 set b = rtest_t2.b from rtest_t2 where rtest_v1.a = rtest_t2.a;
RESULT:
	ERROR - Binder Error: Can only update base table!

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

insert into rtest_v1 select * from rtest_t3;
RESULT:
	ERROR - Catalog Error: rtest_v1 is not an table

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

update rtest_t1 set a = a + 10 where b > 30;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:

update rtest_v1 set a = rtest_t3.a + 20 from rtest_t3 where rtest_v1.b = rtest_t3.b;
RESULT:
	ERROR - Binder Error: Can only update base table!

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[]

-----------
QUERY:


--
-- Test for constraint updates/deletes
--
insert into rtest_system values ('orion', 'Linux Jan Wieck');
RESULT:
	[]

-----------
QUERY:

insert into rtest_system values ('notjw', 'WinNT Jan Wieck (notebook)');
RESULT:
	[]

-----------
QUERY:

insert into rtest_system values ('neptun', 'Fileserver');
RESULT:
	[]

-----------
QUERY:


insert into rtest_interface values ('orion', 'eth0');
RESULT:
	[]

-----------
QUERY:

insert into rtest_interface values ('orion', 'eth1');
RESULT:
	[]

-----------
QUERY:

insert into rtest_interface values ('notjw', 'eth0');
RESULT:
	[]

-----------
QUERY:

insert into rtest_interface values ('neptun', 'eth0');
RESULT:
	[]

-----------
QUERY:


insert into rtest_person values ('jw', 'Jan Wieck');
RESULT:
	[]

-----------
QUERY:

insert into rtest_person values ('bm', 'Bruce Momjian');
RESULT:
	[]

-----------
QUERY:


insert into rtest_admin values ('jw', 'orion');
RESULT:
	[]

-----------
QUERY:

insert into rtest_admin values ('jw', 'notjw');
RESULT:
	[]

-----------
QUERY:

insert into rtest_admin values ('bm', 'neptun');
RESULT:
	[]

-----------
QUERY:


update rtest_system set sysname = 'pluto' where sysname = 'neptun';
RESULT:
	[]

-----------
QUERY:


select * from rtest_interface;
RESULT:
	[('orion', 'eth0'), ('orion', 'eth1'), ('notjw', 'eth0'), ('neptun', 'eth0')]

-----------
QUERY:

select * from rtest_admin;
RESULT:
	[('jw', 'orion'), ('jw', 'notjw'), ('bm', 'neptun')]

-----------
QUERY:


update rtest_person set pname = 'jwieck' where pdesc = 'Jan Wieck';
RESULT:
	[]

-----------
QUERY:


-- Note: use ORDER BY here to ensure consistent output across all systems.
-- The above UPDATE affects two rows with equal keys, so they could be
-- updated in either order depending on the whim of the local qsort().

select * from rtest_admin order by pname, sysname;
RESULT:
	[('bm', 'neptun'), ('jw', 'notjw'), ('jw', 'orion')]

-----------
QUERY:


delete from rtest_system where sysname = 'orion';
RESULT:
	[]

-----------
QUERY:


select * from rtest_interface;
RESULT:
	[('orion', 'eth0'), ('orion', 'eth1'), ('notjw', 'eth0'), ('neptun', 'eth0')]

-----------
QUERY:

select * from rtest_admin;
RESULT:
	[('jw', 'orion'), ('jw', 'notjw'), ('bm', 'neptun')]

-----------
QUERY:


--
-- Rule qualification test
--
insert into rtest_emp values ('wiecc', '5000.00');
RESULT:
	[]

-----------
QUERY:

insert into rtest_emp values ('gates', '80000.00');
RESULT:
	[]

-----------
QUERY:

update rtest_emp set ename = 'wiecx' where ename = 'wiecc';
RESULT:
	[]

-----------
QUERY:

update rtest_emp set ename = 'wieck', salary = '6000.00' where ename = 'wiecx';
RESULT:
	[]

-----------
QUERY:

update rtest_emp set salary = '7000.00' where ename = 'wieck';
RESULT:
	[]

-----------
QUERY:

delete from rtest_emp where ename = 'gates';
RESULT:
	[]

-----------
QUERY:


select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
RESULT:
	ERROR - Catalog Error: Table with name rtest_emplog does not exist!
Did you mean "rtest_emp"?

-----------
QUERY:

insert into rtest_empmass values ('meyer', '4000.00');
RESULT:
	[]

-----------
QUERY:

insert into rtest_empmass values ('maier', '5000.00');
RESULT:
	[]

-----------
QUERY:

insert into rtest_empmass values ('mayr', '6000.00');
RESULT:
	[]

-----------
QUERY:

insert into rtest_emp select * from rtest_empmass;
RESULT:
	[]

-----------
QUERY:

select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
RESULT:
	ERROR - Catalog Error: Table with name rtest_emplog does not exist!
Did you mean "rtest_emp"?

-----------
QUERY:

update rtest_empmass set salary = salary + '1000.00';
RESULT:
	[]

-----------
QUERY:

update rtest_emp set salary = rtest_empmass.salary from rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
RESULT:
	[]

-----------
QUERY:

select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
RESULT:
	ERROR - Catalog Error: Table with name rtest_emplog does not exist!
Did you mean "rtest_emp"?

-----------
QUERY:

delete from rtest_emp using rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
RESULT:
	[]

-----------
QUERY:

select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
RESULT:
	ERROR - Catalog Error: Table with name rtest_emplog does not exist!
Did you mean "rtest_emp"?

-----------
QUERY:


--
-- Multiple cascaded qualified instead rule test
--
insert into rtest_t4 values (1, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (2, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (10, 'Record should go to rtest_t5');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (15, 'Record should go to rtest_t5');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (19, 'Record should go to rtest_t5 and t7');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (20, 'Record should go to rtest_t4 and t6');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (26, 'Record should go to rtest_t4 and t8');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (28, 'Record should go to rtest_t4 and t8');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (30, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (40, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:


select * from rtest_t4;
RESULT:
	[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4'), (10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7'), (20, 'Record should go to rtest_t4 and t6'), (26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8'), (30, 'Record should go to rtest_t4'), (40, 'Record should go to rtest_t4')]

-----------
QUERY:

select * from rtest_t5;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t6;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t7;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t8;
RESULT:
	[]

-----------
QUERY:


delete from rtest_t4;
RESULT:
	[]

-----------
QUERY:

delete from rtest_t5;
RESULT:
	[]

-----------
QUERY:

delete from rtest_t6;
RESULT:
	[]

-----------
QUERY:

delete from rtest_t7;
RESULT:
	[]

-----------
QUERY:

delete from rtest_t8;
RESULT:
	[]

-----------
QUERY:


insert into rtest_t9 values (1, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (2, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (10, 'Record should go to rtest_t5');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (15, 'Record should go to rtest_t5');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (19, 'Record should go to rtest_t5 and t7');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (20, 'Record should go to rtest_t4 and t6');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (26, 'Record should go to rtest_t4 and t8');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (28, 'Record should go to rtest_t4 and t8');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (30, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (40, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:


insert into rtest_t4 select * from rtest_t9 where a < 20;
RESULT:
	[]

-----------
QUERY:


select * from rtest_t4;
RESULT:
	[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4'), (10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7')]

-----------
QUERY:

select * from rtest_t5;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t6;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t7;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t8;
RESULT:
	[]

-----------
QUERY:


insert into rtest_t4 select * from rtest_t9 where b ~ 'and t8';
RESULT:
	[]

-----------
QUERY:


select * from rtest_t4;
RESULT:
	[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4'), (10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7')]

-----------
QUERY:

select * from rtest_t5;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t6;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t7;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t8;
RESULT:
	[]

-----------
QUERY:


insert into rtest_t4 select a + 1, b from rtest_t9 where a in (20, 30, 40);
RESULT:
	[]

-----------
QUERY:


select * from rtest_t4;
RESULT:
	[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4'), (10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7'), (21, 'Record should go to rtest_t4 and t6'), (31, 'Record should go to rtest_t4'), (41, 'Record should go to rtest_t4')]

-----------
QUERY:

select * from rtest_t5;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t6;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t7;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t8;
RESULT:
	[]

-----------
QUERY:


--
-- Check that the ordering of rules fired is correct
--
insert into rtest_order1 values (1);
RESULT:
	[]

-----------
QUERY:

select * from rtest_order2;
RESULT:
	[]

-----------
QUERY:


--
-- Check if instead nothing w/without qualification works
--
insert into rtest_nothn1 values (1, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (2, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (10, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (19, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (20, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (29, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (30, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (39, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (40, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (50, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (60, 'want this');
RESULT:
	[]

-----------
QUERY:


select * from rtest_nothn1;
RESULT:
	[(1, 'want this'), (2, 'want this'), (10, "don't want this"), (19, "don't want this"), (20, 'want this'), (29, 'want this'), (30, "don't want this"), (39, "don't want this"), (40, 'want this'), (50, 'want this'), (60, 'want this')]

-----------
QUERY:


insert into rtest_nothn2 values (10, 'too small');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn2 values (50, 'too small');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn2 values (100, 'OK');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn2 values (200, 'OK');
RESULT:
	[]

-----------
QUERY:


select * from rtest_nothn2;
RESULT:
	[(10, 'too small'), (50, 'too small'), (100, 'OK'), (200, 'OK')]

-----------
QUERY:

select * from rtest_nothn3;
RESULT:
	[]

-----------
QUERY:


delete from rtest_nothn1;
RESULT:
	[]

-----------
QUERY:

delete from rtest_nothn2;
RESULT:
	[]

-----------
QUERY:

delete from rtest_nothn3;
RESULT:
	[]

-----------
QUERY:


insert into rtest_nothn4 values (1, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (2, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (10, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (19, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (20, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (29, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (30, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (39, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (40, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (50, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (60, 'want this');
RESULT:
	[]

-----------
QUERY:


insert into rtest_nothn1 select * from rtest_nothn4;
RESULT:
	[]

-----------
QUERY:


select * from rtest_nothn1;
RESULT:
	[(1, 'want this'), (2, 'want this'), (10, "don't want this"), (19, "don't want this"), (20, 'want this'), (29, 'want this'), (30, "don't want this"), (39, "don't want this"), (40, 'want this'), (50, 'want this'), (60, 'want this')]

-----------
QUERY:


delete from rtest_nothn4;
RESULT:
	[]

-----------
QUERY:


insert into rtest_nothn4 values (10, 'too small');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (50, 'too small');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (100, 'OK');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (200, 'OK');
RESULT:
	[]

-----------
QUERY:


insert into rtest_nothn2 select * from rtest_nothn4;
RESULT:
	[]

-----------
QUERY:


select * from rtest_nothn2;
RESULT:
	[(10, 'too small'), (50, 'too small'), (100, 'OK'), (200, 'OK')]

-----------
QUERY:

select * from rtest_nothn3;
RESULT:
	[]

-----------
QUERY:


create table rtest_view1 (a int4, b text, v bool);
RESULT:
	[]

-----------
QUERY:

create table rtest_view2 (a int4);
RESULT:
	[]

-----------
QUERY:

create table rtest_view3 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_view4 (a int4, b text, c int4);
RESULT:
	[]

-----------
QUERY:

create view rtest_vview1 as select a, b from rtest_view1 X
	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
RESULT:
	[]

-----------
QUERY:

create view rtest_vview2 as select a, b from rtest_view1 where v;
RESULT:
	[]

-----------
QUERY:

create view rtest_vview3 as select a, b from rtest_vview2 X
	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
RESULT:
	[]

-----------
QUERY:

create view rtest_vview4 as select X.a, X.b, count(Y.a) as refcount
	from rtest_view1 X, rtest_view2 Y
	where X.a = Y.a
	group by X.a, X.b;
RESULT:
	[]

-----------
QUERY:

create function rtest_viewfunc1(int4) returns int4 as
	'select count(*)::int4 from rtest_view2 where a = $1'
	language sql;
RESULT:
	ERROR - Parser Error: syntax error at or near "returns"

-----------
QUERY:

create view rtest_vview5 as select a, b, rtest_viewfunc1(a) as refcount
	from rtest_view1;
RESULT:
	ERROR - Catalog Error: Scalar Function with name rtest_viewfunc1 does not exist!
Did you mean "even"?
LINE 2: ...reate view rtest_vview5 as select a, b, rtest_viewfunc1(a) as refcount
                                                  ^

-----------
QUERY:


insert into rtest_view1 values (1, 'item 1', 't');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (2, 'item 2', 't');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (3, 'item 3', 't');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (4, 'item 4', 'f');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (5, 'item 5', 't');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (6, 'item 6', 'f');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (7, 'item 7', 't');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (8, 'item 8', 't');
RESULT:
	[]

-----------
QUERY:


insert into rtest_view2 values (2);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (2);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (4);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (5);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (7);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (7);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (7);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (7);
RESULT:
	[]

-----------
QUERY:


select * from rtest_vview1;
RESULT:
	[(2, 'item 2'), (4, 'item 4'), (5, 'item 5'), (7, 'item 7')]

-----------
QUERY:

select * from rtest_vview2;
RESULT:
	[(1, 'item 1'), (2, 'item 2'), (3, 'item 3'), (5, 'item 5'), (7, 'item 7'), (8, 'item 8')]

-----------
QUERY:

select * from rtest_vview3;
RESULT:
	[(2, 'item 2'), (5, 'item 5'), (7, 'item 7')]

-----------
QUERY:

select * from rtest_vview4 order by a, b;
RESULT:
	[(2, 'item 2', 2), (4, 'item 4', 1), (5, 'item 5', 1), (7, 'item 7', 4)]

-----------
QUERY:

select * from rtest_vview5;
RESULT:
	ERROR - Catalog Error: Table with name rtest_vview5 does not exist!
Did you mean "rtest_vview1"?

-----------
QUERY:


insert into rtest_view3 select * from rtest_vview1 where a < 7;
RESULT:
	[]

-----------
QUERY:

select * from rtest_view3;
RESULT:
	[(2, 'item 2'), (4, 'item 4'), (5, 'item 5')]

-----------
QUERY:

delete from rtest_view3;
RESULT:
	[]

-----------
QUERY:


insert into rtest_view3 select * from rtest_vview2 where a != 5 and b !~ '2';
RESULT:
	[]

-----------
QUERY:

select * from rtest_view3;
RESULT:
	[(1, 'item 1'), (2, 'item 2'), (3, 'item 3'), (7, 'item 7'), (8, 'item 8')]

-----------
QUERY:

delete from rtest_view3;
RESULT:
	[]

-----------
QUERY:


insert into rtest_view3 select * from rtest_vview3;
RESULT:
	[]

-----------
QUERY:

select * from rtest_view3;
RESULT:
	[(2, 'item 2'), (5, 'item 5'), (7, 'item 7')]

-----------
QUERY:

delete from rtest_view3;
RESULT:
	[]

-----------
QUERY:


insert into rtest_view4 select * from rtest_vview4 where 3 > refcount;
RESULT:
	[]

-----------
QUERY:

select * from rtest_view4 order by a, b;
RESULT:
	[(2, 'item 2', 2), (4, 'item 4', 1), (5, 'item 5', 1)]

-----------
QUERY:

delete from rtest_view4;
RESULT:
	[]

-----------
QUERY:


insert into rtest_view4 select * from rtest_vview5 where a > 2 and refcount = 0;
RESULT:
	ERROR - Catalog Error: Table with name rtest_vview5 does not exist!
Did you mean "rtest_vview1"?
LINE 3: insert into rtest_view4 select * from rtest_vview5 where a > 2 and refcount...
                                              ^

-----------
QUERY:

select * from rtest_view4;
RESULT:
	[]

-----------
QUERY:

delete from rtest_view4;
RESULT:
	[]

-----------
QUERY:

--
-- Test for computations in views
--
create table rtest_comp (
	part	text,
	unit	char(4),
	size	float
);
RESULT:
	[]

-----------
QUERY:



create table rtest_unitfact (
	unit	char(4),
	factor	float
);
RESULT:
	[]

-----------
QUERY:


create view rtest_vcomp as
	select X.part, (X.size * Y.factor) as size_in_cm
			from rtest_comp X, rtest_unitfact Y
			where X.unit = Y.unit;
RESULT:
	[]

-----------
QUERY:



insert into rtest_unitfact values ('m', 100.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_unitfact values ('cm', 1.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_unitfact values ('inch', 2.54);
RESULT:
	[]

-----------
QUERY:


insert into rtest_comp values ('p1', 'm', 5.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_comp values ('p2', 'm', 3.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_comp values ('p3', 'cm', 5.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_comp values ('p4', 'cm', 15.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_comp values ('p5', 'inch', 7.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_comp values ('p6', 'inch', 4.4);
RESULT:
	[]

-----------
QUERY:


select * from rtest_vcomp order by part;
RESULT:
	[('p1', 500.0), ('p2', 300.0), ('p3', 5.0), ('p4', 15.0), ('p5', 17.779998779296875), ('p6', 11.175999641418457)]

-----------
QUERY:


select * from rtest_vcomp where size_in_cm > 10.0 order by size_in_cm using >;
RESULT:
	ERROR - Not implemented Error: Unimplemented order by type

-----------
QUERY:


--
-- In addition run the (slightly modified) queries from the
-- programmers manual section on the rule system.
--
CREATE TABLE shoe_data (
	shoename   char(10),      -- primary key
	sh_avail   integer,       -- available # of pairs
	slcolor    char(10),      -- preferred shoelace color
	slminlen   float,         -- minimum shoelace length
	slmaxlen   float,         -- maximum shoelace length
	slunit     char(8)        -- length unit
);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE shoelace_data (
	sl_name    char(10),      -- primary key
	sl_avail   integer,       -- available # of pairs
	sl_color   char(10),      -- shoelace color
	sl_len     float,         -- shoelace length
	sl_unit    char(8)        -- length unit
);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE unit (
	un_name    char(8),       -- the primary key
	un_fact    float          -- factor to transform to cm
);
RESULT:
	[]

-----------
QUERY:


CREATE VIEW shoe AS
	SELECT sh.shoename,
		   sh.sh_avail,
		   sh.slcolor,
		   sh.slminlen,
		   sh.slminlen * un.un_fact AS slminlen_cm,
		   sh.slmaxlen,
		   sh.slmaxlen * un.un_fact AS slmaxlen_cm,
		   sh.slunit
	  FROM shoe_data sh, unit un
	 WHERE sh.slunit = un.un_name;
RESULT:
	[]

-----------
QUERY:


CREATE VIEW shoelace AS
	SELECT s.sl_name,
		   s.sl_avail,
		   s.sl_color,
		   s.sl_len,
		   s.sl_unit,
		   s.sl_len * u.un_fact AS sl_len_cm
	  FROM shoelace_data s, unit u
	 WHERE s.sl_unit = u.un_name;
RESULT:
	[]

-----------
QUERY:


CREATE VIEW shoe_ready AS
	SELECT rsh.shoename,
		   rsh.sh_avail,
		   rsl.sl_name,
		   rsl.sl_avail,
		   int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
	  FROM shoe rsh, shoelace rsl
	 WHERE rsl.sl_color = rsh.slcolor
	   AND rsl.sl_len_cm >= rsh.slminlen_cm
	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
RESULT:
	ERROR - Catalog Error: Scalar Function with name int4smaller does not exist!
Did you mean "instr"?
LINE 8: 		   int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
	  FROM shoe rsh, shoelace rsl
	 WHERE rsl.sl_color = rsh.slcolor
	   AND rsl.sl_len_cm >= rsh.slminlen_cm
	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm;...
           ^

-----------
QUERY:


INSERT INTO unit VALUES ('cm', 1.0);
RESULT:
	[]

-----------
QUERY:

INSERT INTO unit VALUES ('m', 100.0);
RESULT:
	[]

-----------
QUERY:

INSERT INTO unit VALUES ('inch', 2.54);
RESULT:
	[]

-----------
QUERY:


INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
RESULT:
	[]

-----------
QUERY:


INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');
RESULT:
	[]

-----------
QUERY:


-- SELECTs in doc
SELECT * FROM shoelace ORDER BY sl_name;
RESULT:
	[('sl1', 5, 'black', 80.0, 'cm', 80.0), ('sl2', 6, 'black', 100.0, 'cm', 100.0), ('sl3', 0, 'black', 35.0, 'inch', 88.9000015258789), ('sl4', 8, 'black', 40.0, 'inch', 101.5999984741211), ('sl5', 4, 'brown', 1.0, 'm', 100.0), ('sl6', 0, 'brown', 0.8999999761581421, 'm', 90.0), ('sl7', 7, 'brown', 60.0, 'cm', 60.0), ('sl8', 1, 'brown', 40.0, 'inch', 101.5999984741211)]

-----------
QUERY:

SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1;
RESULT:
	ERROR - Catalog Error: Table with name shoe_ready does not exist!
Did you mean "shoe"?

-----------
QUERY:


    CREATE TABLE shoelace_log (
        sl_name    char(10),      -- shoelace changed
        sl_avail   integer,       -- new available value
        log_who    name,          -- who did it
        log_when   timestamp      -- when
    );
RESULT:
	ERROR - Catalog Error: Type with name name does not exist!
Did you mean "date"?

-----------
QUERY:


-- Want /* REPLACED */ ''log_who/* REPLACED */ '' to be CURRENT_USER,
-- but that is non-portable for the regression test
-- - thomas 1999-02-21

    CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
        WHERE NEW.sl_avail != OLD.sl_avail
        DO INSERT INTO shoelace_log VALUES (
                                        NEW.sl_name,
                                        NEW.sl_avail,
                                        'Al Bundy',
                                        'epoch'
                                    );
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


UPDATE shoelace_data SET sl_avail = 6 WHERE  sl_name = 'sl7';
RESULT:
	[]

-----------
QUERY:


SELECT * FROM shoelace_log;
RESULT:
	ERROR - Catalog Error: Table with name shoelace_log does not exist!
Did you mean "shoelace"?

-----------
QUERY:


    CREATE RULE shoelace_ins AS ON INSERT TO shoelace
        DO INSTEAD
        INSERT INTO shoelace_data VALUES (
               NEW.sl_name,
               NEW.sl_avail,
               NEW.sl_color,
               NEW.sl_len,
               NEW.sl_unit);
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


    CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
        DO INSTEAD
        UPDATE shoelace_data SET
               sl_name = NEW.sl_name,
               sl_avail = NEW.sl_avail,
               sl_color = NEW.sl_color,
               sl_len = NEW.sl_len,
               sl_unit = NEW.sl_unit
         WHERE sl_name = OLD.sl_name;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


    CREATE RULE shoelace_del AS ON DELETE TO shoelace
        DO INSTEAD
        DELETE FROM shoelace_data
         WHERE sl_name = OLD.sl_name;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


    CREATE TABLE shoelace_arrive (
        arr_name    char(10),
        arr_quant   integer
    );
RESULT:
	[]

-----------
QUERY:


    CREATE TABLE shoelace_ok (
        ok_name     char(10),
        ok_quant    integer
    );
RESULT:
	[]

-----------
QUERY:


    CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
        DO INSTEAD
        UPDATE shoelace SET
               sl_avail = sl_avail + NEW.ok_quant
         WHERE sl_name = NEW.ok_name;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


INSERT INTO shoelace_arrive VALUES ('sl3', 10);
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_arrive VALUES ('sl6', 20);
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_arrive VALUES ('sl8', 20);
RESULT:
	[]

-----------
QUERY:


SELECT * FROM shoelace ORDER BY sl_name;
RESULT:
	[('sl1', 5, 'black', 80.0, 'cm', 80.0), ('sl2', 6, 'black', 100.0, 'cm', 100.0), ('sl3', 0, 'black', 35.0, 'inch', 88.9000015258789), ('sl4', 8, 'black', 40.0, 'inch', 101.5999984741211), ('sl5', 4, 'brown', 1.0, 'm', 100.0), ('sl6', 0, 'brown', 0.8999999761581421, 'm', 90.0), ('sl7', 6, 'brown', 60.0, 'cm', 60.0), ('sl8', 1, 'brown', 40.0, 'inch', 101.5999984741211)]

-----------
QUERY:


insert into shoelace_ok select * from shoelace_arrive;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM shoelace ORDER BY sl_name;
RESULT:
	[('sl1', 5, 'black', 80.0, 'cm', 80.0), ('sl2', 6, 'black', 100.0, 'cm', 100.0), ('sl3', 0, 'black', 35.0, 'inch', 88.9000015258789), ('sl4', 8, 'black', 40.0, 'inch', 101.5999984741211), ('sl5', 4, 'brown', 1.0, 'm', 100.0), ('sl6', 0, 'brown', 0.8999999761581421, 'm', 90.0), ('sl7', 6, 'brown', 60.0, 'cm', 60.0), ('sl8', 1, 'brown', 40.0, 'inch', 101.5999984741211)]

-----------
QUERY:


SELECT * FROM shoelace_log ORDER BY sl_name;
RESULT:
	ERROR - Catalog Error: Table with name shoelace_log does not exist!
Did you mean "shoelace_ok"?

-----------
QUERY:


    CREATE VIEW shoelace_obsolete AS
	SELECT * FROM shoelace WHERE NOT EXISTS
	    (SELECT shoename FROM shoe WHERE slcolor = sl_color);
RESULT:
	[]

-----------
QUERY:


    CREATE VIEW shoelace_candelete AS
	SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
RESULT:
	[]

-----------
QUERY:


insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
RESULT:
	ERROR - Catalog Error: shoelace is not an table

-----------
QUERY:

insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
RESULT:
	ERROR - Catalog Error: shoelace is not an table

-----------
QUERY:

-- Unsupported (even though a similar updatable view construct is)
insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0)
  on conflict do nothing;
RESULT:
	ERROR - Catalog Error: shoelace is not an table

-----------
QUERY:


SELECT * FROM shoelace_obsolete ORDER BY sl_len_cm;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM shoelace_candelete;
RESULT:
	[]

-----------
QUERY:


DELETE FROM shoelace WHERE EXISTS
    (SELECT * FROM shoelace_candelete
             WHERE sl_name = shoelace.sl_name);
RESULT:
	ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:


SELECT * FROM shoelace ORDER BY sl_name;
RESULT:
	[('sl1', 5, 'black', 80.0, 'cm', 80.0), ('sl2', 6, 'black', 100.0, 'cm', 100.0), ('sl3', 0, 'black', 35.0, 'inch', 88.9000015258789), ('sl4', 8, 'black', 40.0, 'inch', 101.5999984741211), ('sl5', 4, 'brown', 1.0, 'm', 100.0), ('sl6', 0, 'brown', 0.8999999761581421, 'm', 90.0), ('sl7', 6, 'brown', 60.0, 'cm', 60.0), ('sl8', 1, 'brown', 40.0, 'inch', 101.5999984741211)]

-----------
QUERY:


SELECT * FROM shoe ORDER BY shoename;
RESULT:
	[('sh1', 2, 'black', 70.0, 70.0, 90.0, 90.0, 'cm'), ('sh2', 0, 'black', 30.0, 76.19999694824219, 40.0, 101.5999984741211, 'inch'), ('sh3', 4, 'brown', 50.0, 50.0, 65.0, 65.0, 'cm'), ('sh4', 3, 'brown', 40.0, 101.5999984741211, 50.0, 127.0, 'inch')]

-----------
QUERY:

SELECT count(*) FROM shoe;
RESULT:
	[(4,)]

-----------
QUERY:



--
-- Simple test of qualified ON INSERT ... this did not work in 7.0 ...
--
create table rules_foo (f1 int);
RESULT:
	[]

-----------
QUERY:

create table rules_foo2 (f1 int);
RESULT:
	[]

-----------
QUERY:


create rule rules_foorule as on insert to rules_foo where f1 < 100
do instead nothing;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


insert into rules_foo values(1);
RESULT:
	[]

-----------
QUERY:

insert into rules_foo values(1001);
RESULT:
	[]

-----------
QUERY:

select * from rules_foo;
RESULT:
	[(1,), (1001,)]

-----------
QUERY:


drop rule rules_foorule on rules_foo;
RESULT:
	ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:


-- this should fail because f1 is not exposed for unqualified reference:
create rule rules_foorule as on insert to rules_foo where f1 < 100
do instead insert into rules_foo2 values (f1);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

-- this is the correct way:
create rule rules_foorule as on insert to rules_foo where f1 < 100
do instead insert into rules_foo2 values (new.f1);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


insert into rules_foo values(2);
RESULT:
	[]

-----------
QUERY:

insert into rules_foo values(100);
RESULT:
	[]

-----------
QUERY:


select * from rules_foo;
RESULT:
	[(1,), (1001,), (2,), (100,)]

-----------
QUERY:

select * from rules_foo2;
RESULT:
	[]

-----------
QUERY:


drop rule rules_foorule on rules_foo;
RESULT:
	ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

drop table rules_foo;
RESULT:
	[]

-----------
QUERY:

drop table rules_foo2;
RESULT:
	[]

-----------
QUERY:



--
-- Test rules containing INSERT ... SELECT, which is a very ugly special
-- case as of 7.1.  Example is based on bug report from Joel Burton.
--
create table pparent (pid int, txt text);
RESULT:
	[]

-----------
QUERY:

insert into pparent values (1,'parent1');
RESULT:
	[]

-----------
QUERY:

insert into pparent values (2,'parent2');
RESULT:
	[]

-----------
QUERY:


create table cchild (pid int, descrip text);
RESULT:
	[]

-----------
QUERY:

insert into cchild values (1,'descrip1');
RESULT:
	[]

-----------
QUERY:


create view vview as
  select pparent.pid, txt, descrip from
    pparent left join cchild using (pid);
RESULT:
	[]

-----------
QUERY:


create rule rrule as
  on update to vview do instead
(
  insert into cchild (pid, descrip)
    select old.pid, new.descrip where old.descrip isnull;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

  update cchild set descrip = new.descrip where cchild.pid = old.pid;
RESULT:
	ERROR - Binder Error: Referenced table "old" not found!
Candidate tables: "cchild"
LINE 2: ...escrip = new.descrip where cchild.pid = old.pid;
                                                  ^

-----------
QUERY:

);
RESULT:
	ERROR - Parser Error: syntax error at or near ")"

-----------
QUERY:


select * from vview;
RESULT:
	[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]

-----------
QUERY:

update vview set descrip='test1' where pid=1;
RESULT:
	ERROR - Binder Error: Can only update base table!

-----------
QUERY:

select * from vview;
RESULT:
	[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]

-----------
QUERY:

update vview set descrip='test2' where pid=2;
RESULT:
	ERROR - Binder Error: Can only update base table!

-----------
QUERY:

select * from vview;
RESULT:
	[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]

-----------
QUERY:

update vview set descrip='test3' where pid=3;
RESULT:
	ERROR - Binder Error: Can only update base table!

-----------
QUERY:

select * from vview;
RESULT:
	[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]

-----------
QUERY:

select * from cchild;
RESULT:
	[(1, 'descrip1')]

-----------
QUERY:


drop rule rrule on vview;
RESULT:
	ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

drop view vview;
RESULT:
	[]

-----------
QUERY:

drop table pparent;
RESULT:
	[]

-----------
QUERY:

drop table cchild;
RESULT:
	[]

-----------
QUERY:



--
-- Check that ruleutils are working
--

-- temporarily disable fancy output, so view changes create less diff noise
-- \a\t

SELECT viewname, definition FROM pg_views
WHERE schemaname = 'pg_catalog'
ORDER BY viewname;
RESULT:
	[('pg_am', "CREATE TEMPORARY VIEW pg_catalog.pg_am AS SELECT 0 AS oid, 'art' AS amname, NULL AS amhandler, 'i' AS amtype;\n"), ('pg_am', "CREATE TEMPORARY VIEW pg_catalog.pg_am AS SELECT 0 AS oid, 'art' AS amname, NULL AS amhandler, 'i' AS amtype;\n"), ('pg_am', "CREATE TEMPORARY VIEW pg_catalog.pg_am AS SELECT 0 AS oid, 'art' AS amname, NULL AS amhandler, 'i' AS amtype;\n"), ('pg_attrdef', 'CREATE TEMPORARY VIEW pg_catalog.pg_attrdef AS SELECT column_index AS oid, table_oid AS adrelid, column_index AS adnum, column_default AS adbin FROM duckdb_columns() WHERE (column_default IS NOT NULL);\n'), ('pg_attrdef', 'CREATE TEMPORARY VIEW pg_catalog.pg_attrdef AS SELECT column_index AS oid, table_oid AS adrelid, column_index AS adnum, column_default AS adbin FROM duckdb_columns() WHERE (column_default IS NOT NULL);\n'), ('pg_attrdef', 'CREATE TEMPORARY VIEW pg_catalog.pg_attrdef AS SELECT column_index AS oid, table_oid AS adrelid, column_index AS adnum, column_default AS adbin FROM duckdb_columns() WHERE (column_default IS NOT NULL);\n'), ('pg_attribute', "CREATE TEMPORARY VIEW pg_catalog.pg_attribute AS SELECT table_oid AS attrelid, column_name AS attname, data_type_id AS atttypid, 0 AS attstattarget, NULL AS attlen, column_index AS attnum, 0 AS attndims, -1 AS attcacheoff, CASE  WHEN ((data_type ~~* '%decimal%')) THEN (((numeric_precision * 1000) + numeric_scale)) ELSE -1 END AS atttypmod, CAST('f' AS BOOLEAN) AS attbyval, NULL AS attstorage, NULL AS attalign, (NOT is_nullable) AS attnotnull, (column_default IS NOT NULL) AS atthasdef, CAST('f' AS BOOLEAN) AS atthasmissing, '' AS attidentity, '' AS attgenerated, CAST('f' AS BOOLEAN) AS attisdropped, CAST('t' AS BOOLEAN) AS attislocal, 0 AS attinhcount, 0 AS attcollation, NULL AS attcompression, NULL AS attacl, NULL AS attoptions, NULL AS attfdwoptions, NULL AS attmissingval FROM duckdb_columns();\n"), ('pg_attribute', "CREATE TEMPORARY VIEW pg_catalog.pg_attribute AS SELECT table_oid AS attrelid, column_name AS attname, data_type_id AS atttypid, 0 AS attstattarget, NULL AS attlen, column_index AS attnum, 0 AS attndims, -1 AS attcacheoff, CASE  WHEN ((data_type ~~* '%decimal%')) THEN (((numeric_precision * 1000) + numeric_scale)) ELSE -1 END AS atttypmod, CAST('f' AS BOOLEAN) AS attbyval, NULL AS attstorage, NULL AS attalign, (NOT is_nullable) AS attnotnull, (column_default IS NOT NULL) AS atthasdef, CAST('f' AS BOOLEAN) AS atthasmissing, '' AS attidentity, '' AS attgenerated, CAST('f' AS BOOLEAN) AS attisdropped, CAST('t' AS BOOLEAN) AS attislocal, 0 AS attinhcount, 0 AS attcollation, NULL AS attcompression, NULL AS attacl, NULL AS attoptions, NULL AS attfdwoptions, NULL AS attmissingval FROM duckdb_columns();\n"), ('pg_attribute', "CREATE TEMPORARY VIEW pg_catalog.pg_attribute AS SELECT table_oid AS attrelid, column_name AS attname, data_type_id AS atttypid, 0 AS attstattarget, NULL AS attlen, column_index AS attnum, 0 AS attndims, -1 AS attcacheoff, CASE  WHEN ((data_type ~~* '%decimal%')) THEN (((numeric_precision * 1000) + numeric_scale)) ELSE -1 END AS atttypmod, CAST('f' AS BOOLEAN) AS attbyval, NULL AS attstorage, NULL AS attalign, (NOT is_nullable) AS attnotnull, (column_default IS NOT NULL) AS atthasdef, CAST('f' AS BOOLEAN) AS atthasmissing, '' AS attidentity, '' AS attgenerated, CAST('f' AS BOOLEAN) AS attisdropped, CAST('t' AS BOOLEAN) AS attislocal, 0 AS attinhcount, 0 AS attcollation, NULL AS attcompression, NULL AS attacl, NULL AS attoptions, NULL AS attfdwoptions, NULL AS attmissingval FROM duckdb_columns();\n"), ('pg_class', 'CREATE TEMPORARY VIEW pg_catalog.pg_class AS (((SELECT table_oid AS oid, table_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, CAST(estimated_size AS FLOAT) AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, (index_count > 0) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN (\'t\') ELSE \'p\' END AS relpersistence, \'r\' AS relkind, column_count AS relnatts, check_constraint_count AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, has_primary_key AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_tables()) UNION ALL (SELECT view_oid AS oid, view_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST(\'f\' AS BOOLEAN) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN (\'t\') ELSE \'p\' END AS relpersistence, \'v\' AS relkind, column_count AS relnatts, 0 AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, CAST(\'f\' AS BOOLEAN) AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_views())) UNION ALL (SELECT sequence_oid AS oid, sequence_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST(\'f\' AS BOOLEAN) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN (\'t\') ELSE \'p\' END AS relpersistence, \'S\' AS relkind, 0 AS relnatts, 0 AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, CAST(\'f\' AS BOOLEAN) AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_sequences())) UNION ALL (SELECT index_oid AS oid, index_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST(\'f\' AS BOOLEAN) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, \'t\' AS relpersistence, \'i\' AS relkind, NULL AS relnatts, 0 AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, CAST(\'f\' AS BOOLEAN) AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_indexes());\n'), ('pg_class', 'CREATE TEMPORARY VIEW pg_catalog.pg_class AS (((SELECT table_oid AS oid, table_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, CAST(estimated_size AS FLOAT) AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, (index_count > 0) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN (\'t\') ELSE \'p\' END AS relpersistence, \'r\' AS relkind, column_count AS relnatts, check_constraint_count AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, has_primary_key AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_tables()) UNION ALL (SELECT view_oid AS oid, view_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST(\'f\' AS BOOLEAN) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN (\'t\') ELSE \'p\' END AS relpersistence, \'v\' AS relkind, column_count AS relnatts, 0 AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, CAST(\'f\' AS BOOLEAN) AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_views())) UNION ALL (SELECT sequence_oid AS oid, sequence_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST(\'f\' AS BOOLEAN) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN (\'t\') ELSE \'p\' END AS relpersistence, \'S\' AS relkind, 0 AS relnatts, 0 AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, CAST(\'f\' AS BOOLEAN) AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_sequences())) UNION ALL (SELECT index_oid AS oid, index_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST(\'f\' AS BOOLEAN) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, \'t\' AS relpersistence, \'i\' AS relkind, NULL AS relnatts, 0 AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, CAST(\'f\' AS BOOLEAN) AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_indexes());\n'), ('pg_class', 'CREATE TEMPORARY VIEW pg_catalog.pg_class AS (((SELECT table_oid AS oid, table_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, CAST(estimated_size AS FLOAT) AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, (index_count > 0) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN (\'t\') ELSE \'p\' END AS relpersistence, \'r\' AS relkind, column_count AS relnatts, check_constraint_count AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, has_primary_key AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_tables()) UNION ALL (SELECT view_oid AS oid, view_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST(\'f\' AS BOOLEAN) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN (\'t\') ELSE \'p\' END AS relpersistence, \'v\' AS relkind, column_count AS relnatts, 0 AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, CAST(\'f\' AS BOOLEAN) AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_views())) UNION ALL (SELECT sequence_oid AS oid, sequence_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST(\'f\' AS BOOLEAN) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, CASE  WHEN ("temporary") THEN (\'t\') ELSE \'p\' END AS relpersistence, \'S\' AS relkind, 0 AS relnatts, 0 AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, CAST(\'f\' AS BOOLEAN) AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_sequences())) UNION ALL (SELECT index_oid AS oid, index_name AS relname, schema_oid AS relnamespace, 0 AS reltype, 0 AS reloftype, 0 AS relowner, 0 AS relam, 0 AS relfilenode, 0 AS reltablespace, 0 AS relpages, 0 AS reltuples, 0 AS relallvisible, 0 AS reltoastrelid, 0 AS reltoastidxid, CAST(\'f\' AS BOOLEAN) AS relhasindex, CAST(\'f\' AS BOOLEAN) AS relisshared, \'t\' AS relpersistence, \'i\' AS relkind, NULL AS relnatts, 0 AS relchecks, CAST(\'f\' AS BOOLEAN) AS relhasoids, CAST(\'f\' AS BOOLEAN) AS relhaspkey, CAST(\'f\' AS BOOLEAN) AS relhasrules, CAST(\'f\' AS BOOLEAN) AS relhastriggers, CAST(\'f\' AS BOOLEAN) AS relhassubclass, CAST(\'f\' AS BOOLEAN) AS relrowsecurity, CAST(\'t\' AS BOOLEAN) AS relispopulated, NULL AS relreplident, CAST(\'f\' AS BOOLEAN) AS relispartition, 0 AS relrewrite, 0 AS relfrozenxid, NULL AS relminmxid, NULL AS relacl, NULL AS reloptions, NULL AS relpartbound FROM duckdb_indexes());\n'), ('pg_constraint', "CREATE TEMPORARY VIEW pg_catalog.pg_constraint AS SELECT ((table_oid * 1000000) + constraint_index) AS oid, constraint_text AS conname, schema_oid AS connamespace, CASE  WHEN ((constraint_type = 'CHECK')) THEN ('c') WHEN ((constraint_type = 'UNIQUE')) THEN ('u') WHEN ((constraint_type = 'PRIMARY KEY')) THEN ('p') WHEN ((constraint_type = 'FOREIGN KEY')) THEN ('f') ELSE 'x' END AS contype, CAST('f' AS BOOLEAN) AS condeferrable, CAST('f' AS BOOLEAN) AS condeferred, CAST('t' AS BOOLEAN) AS convalidated, table_oid AS conrelid, 0 AS contypid, 0 AS conindid, 0 AS conparentid, 0 AS confrelid, NULL AS confupdtype, NULL AS confdeltype, NULL AS confmatchtype, CAST('t' AS BOOLEAN) AS conislocal, 0 AS coninhcount, CAST('f' AS BOOLEAN) AS connoinherit, constraint_column_indexes AS conkey, NULL AS confkey, NULL AS conpfeqop, NULL AS conppeqop, NULL AS conffeqop, NULL AS conexclop, expression AS conbin FROM duckdb_constraints();\n"), ('pg_constraint', "CREATE TEMPORARY VIEW pg_catalog.pg_constraint AS SELECT ((table_oid * 1000000) + constraint_index) AS oid, constraint_text AS conname, schema_oid AS connamespace, CASE  WHEN ((constraint_type = 'CHECK')) THEN ('c') WHEN ((constraint_type = 'UNIQUE')) THEN ('u') WHEN ((constraint_type = 'PRIMARY KEY')) THEN ('p') WHEN ((constraint_type = 'FOREIGN KEY')) THEN ('f') ELSE 'x' END AS contype, CAST('f' AS BOOLEAN) AS condeferrable, CAST('f' AS BOOLEAN) AS condeferred, CAST('t' AS BOOLEAN) AS convalidated, table_oid AS conrelid, 0 AS contypid, 0 AS conindid, 0 AS conparentid, 0 AS confrelid, NULL AS confupdtype, NULL AS confdeltype, NULL AS confmatchtype, CAST('t' AS BOOLEAN) AS conislocal, 0 AS coninhcount, CAST('f' AS BOOLEAN) AS connoinherit, constraint_column_indexes AS conkey, NULL AS confkey, NULL AS conpfeqop, NULL AS conppeqop, NULL AS conffeqop, NULL AS conexclop, expression AS conbin FROM duckdb_constraints();\n"), ('pg_constraint', "CREATE TEMPORARY VIEW pg_catalog.pg_constraint AS SELECT ((table_oid * 1000000) + constraint_index) AS oid, constraint_text AS conname, schema_oid AS connamespace, CASE  WHEN ((constraint_type = 'CHECK')) THEN ('c') WHEN ((constraint_type = 'UNIQUE')) THEN ('u') WHEN ((constraint_type = 'PRIMARY KEY')) THEN ('p') WHEN ((constraint_type = 'FOREIGN KEY')) THEN ('f') ELSE 'x' END AS contype, CAST('f' AS BOOLEAN) AS condeferrable, CAST('f' AS BOOLEAN) AS condeferred, CAST('t' AS BOOLEAN) AS convalidated, table_oid AS conrelid, 0 AS contypid, 0 AS conindid, 0 AS conparentid, 0 AS confrelid, NULL AS confupdtype, NULL AS confdeltype, NULL AS confmatchtype, CAST('t' AS BOOLEAN) AS conislocal, 0 AS coninhcount, CAST('f' AS BOOLEAN) AS connoinherit, constraint_column_indexes AS conkey, NULL AS confkey, NULL AS conpfeqop, NULL AS conppeqop, NULL AS conffeqop, NULL AS conexclop, expression AS conbin FROM duckdb_constraints();\n"), ('pg_database', 'CREATE TEMPORARY VIEW pg_catalog.pg_database AS SELECT database_oid AS oid, database_name AS datname FROM duckdb_databases();\n'), ('pg_database', 'CREATE TEMPORARY VIEW pg_catalog.pg_database AS SELECT database_oid AS oid, database_name AS datname FROM duckdb_databases();\n'), ('pg_database', 'CREATE TEMPORARY VIEW pg_catalog.pg_database AS SELECT database_oid AS oid, database_name AS datname FROM duckdb_databases();\n'), ('pg_depend', 'CREATE TEMPORARY VIEW pg_catalog.pg_depend AS SELECT * FROM duckdb_dependencies();\n'), ('pg_depend', 'CREATE TEMPORARY VIEW pg_catalog.pg_depend AS SELECT * FROM duckdb_dependencies();\n'), ('pg_depend', 'CREATE TEMPORARY VIEW pg_catalog.pg_depend AS SELECT * FROM duckdb_dependencies();\n'), ('pg_description', 'CREATE TEMPORARY VIEW pg_catalog.pg_description AS ((((((SELECT table_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_tables() WHERE (NOT internal)) UNION ALL (SELECT table_oid AS objoid, database_oid AS classoid, column_index AS objsubid, "comment" AS description FROM duckdb_columns() WHERE (NOT internal))) UNION ALL (SELECT view_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_views() WHERE (NOT internal))) UNION ALL (SELECT index_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_indexes)) UNION ALL (SELECT sequence_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_sequences())) UNION ALL (SELECT type_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_types() WHERE (NOT internal))) UNION ALL (SELECT function_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_functions() WHERE (NOT internal));\n'), ('pg_description', 'CREATE TEMPORARY VIEW pg_catalog.pg_description AS ((((((SELECT table_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_tables() WHERE (NOT internal)) UNION ALL (SELECT table_oid AS objoid, database_oid AS classoid, column_index AS objsubid, "comment" AS description FROM duckdb_columns() WHERE (NOT internal))) UNION ALL (SELECT view_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_views() WHERE (NOT internal))) UNION ALL (SELECT index_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_indexes)) UNION ALL (SELECT sequence_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_sequences())) UNION ALL (SELECT type_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_types() WHERE (NOT internal))) UNION ALL (SELECT function_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_functions() WHERE (NOT internal));\n'), ('pg_description', 'CREATE TEMPORARY VIEW pg_catalog.pg_description AS ((((((SELECT table_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_tables() WHERE (NOT internal)) UNION ALL (SELECT table_oid AS objoid, database_oid AS classoid, column_index AS objsubid, "comment" AS description FROM duckdb_columns() WHERE (NOT internal))) UNION ALL (SELECT view_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_views() WHERE (NOT internal))) UNION ALL (SELECT index_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_indexes)) UNION ALL (SELECT sequence_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_sequences())) UNION ALL (SELECT type_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_types() WHERE (NOT internal))) UNION ALL (SELECT function_oid AS objoid, database_oid AS classoid, 0 AS objsubid, "comment" AS description FROM duckdb_functions() WHERE (NOT internal));\n'), ('pg_enum', "CREATE TEMPORARY VIEW pg_catalog.pg_enum AS SELECT NULL AS oid, a.type_oid AS enumtypid, list_position(b.labels, a.elabel) AS enumsortorder, a.elabel AS enumlabel FROM (SELECT unnest(labels) AS elabel, type_oid FROM duckdb_types() WHERE (logical_type = 'ENUM')) AS a INNER JOIN duckdb_types() AS b ON ((a.type_oid = b.type_oid));\n"), ('pg_enum', "CREATE TEMPORARY VIEW pg_catalog.pg_enum AS SELECT NULL AS oid, a.type_oid AS enumtypid, list_position(b.labels, a.elabel) AS enumsortorder, a.elabel AS enumlabel FROM (SELECT unnest(labels) AS elabel, type_oid FROM duckdb_types() WHERE (logical_type = 'ENUM')) AS a INNER JOIN duckdb_types() AS b ON ((a.type_oid = b.type_oid));\n"), ('pg_enum', "CREATE TEMPORARY VIEW pg_catalog.pg_enum AS SELECT NULL AS oid, a.type_oid AS enumtypid, list_position(b.labels, a.elabel) AS enumsortorder, a.elabel AS enumlabel FROM (SELECT unnest(labels) AS elabel, type_oid FROM duckdb_types() WHERE (logical_type = 'ENUM')) AS a INNER JOIN duckdb_types() AS b ON ((a.type_oid = b.type_oid));\n"), ('pg_index', "CREATE TEMPORARY VIEW pg_catalog.pg_index AS SELECT index_oid AS indexrelid, table_oid AS indrelid, 0 AS indnatts, 0 AS indnkeyatts, is_unique AS indisunique, is_primary AS indisprimary, CAST('f' AS BOOLEAN) AS indisexclusion, CAST('t' AS BOOLEAN) AS indimmediate, CAST('f' AS BOOLEAN) AS indisclustered, CAST('t' AS BOOLEAN) AS indisvalid, CAST('f' AS BOOLEAN) AS indcheckxmin, CAST('t' AS BOOLEAN) AS indisready, CAST('t' AS BOOLEAN) AS indislive, CAST('f' AS BOOLEAN) AS indisreplident, CAST(NULL AS INTEGER[]) AS indkey, CAST(NULL AS BIGINT[]) AS indcollation, CAST(NULL AS BIGINT[]) AS indclass, CAST(NULL AS INTEGER[]) AS indoption, expressions AS indexprs, NULL AS indpred FROM duckdb_indexes();\n"), ('pg_index', "CREATE TEMPORARY VIEW pg_catalog.pg_index AS SELECT index_oid AS indexrelid, table_oid AS indrelid, 0 AS indnatts, 0 AS indnkeyatts, is_unique AS indisunique, is_primary AS indisprimary, CAST('f' AS BOOLEAN) AS indisexclusion, CAST('t' AS BOOLEAN) AS indimmediate, CAST('f' AS BOOLEAN) AS indisclustered, CAST('t' AS BOOLEAN) AS indisvalid, CAST('f' AS BOOLEAN) AS indcheckxmin, CAST('t' AS BOOLEAN) AS indisready, CAST('t' AS BOOLEAN) AS indislive, CAST('f' AS BOOLEAN) AS indisreplident, CAST(NULL AS INTEGER[]) AS indkey, CAST(NULL AS BIGINT[]) AS indcollation, CAST(NULL AS BIGINT[]) AS indclass, CAST(NULL AS INTEGER[]) AS indoption, expressions AS indexprs, NULL AS indpred FROM duckdb_indexes();\n"), ('pg_index', "CREATE TEMPORARY VIEW pg_catalog.pg_index AS SELECT index_oid AS indexrelid, table_oid AS indrelid, 0 AS indnatts, 0 AS indnkeyatts, is_unique AS indisunique, is_primary AS indisprimary, CAST('f' AS BOOLEAN) AS indisexclusion, CAST('t' AS BOOLEAN) AS indimmediate, CAST('f' AS BOOLEAN) AS indisclustered, CAST('t' AS BOOLEAN) AS indisvalid, CAST('f' AS BOOLEAN) AS indcheckxmin, CAST('t' AS BOOLEAN) AS indisready, CAST('t' AS BOOLEAN) AS indislive, CAST('f' AS BOOLEAN) AS indisreplident, CAST(NULL AS INTEGER[]) AS indkey, CAST(NULL AS BIGINT[]) AS indcollation, CAST(NULL AS BIGINT[]) AS indclass, CAST(NULL AS INTEGER[]) AS indoption, expressions AS indexprs, NULL AS indpred FROM duckdb_indexes();\n"), ('pg_indexes', 'CREATE TEMPORARY VIEW pg_catalog.pg_indexes AS SELECT schema_name AS schemaname, table_name AS tablename, index_name AS indexname, NULL AS "tablespace", "sql" AS indexdef FROM duckdb_indexes();\n'), ('pg_indexes', 'CREATE TEMPORARY VIEW pg_catalog.pg_indexes AS SELECT schema_name AS schemaname, table_name AS tablename, index_name AS indexname, NULL AS "tablespace", "sql" AS indexdef FROM duckdb_indexes();\n'), ('pg_indexes', 'CREATE TEMPORARY VIEW pg_catalog.pg_indexes AS SELECT schema_name AS schemaname, table_name AS tablename, index_name AS indexname, NULL AS "tablespace", "sql" AS indexdef FROM duckdb_indexes();\n'), ('pg_namespace', 'CREATE TEMPORARY VIEW pg_catalog.pg_namespace AS SELECT oid, schema_name AS nspname, 0 AS nspowner, NULL AS nspacl FROM duckdb_schemas();\n'), ('pg_namespace', 'CREATE TEMPORARY VIEW pg_catalog.pg_namespace AS SELECT oid, schema_name AS nspname, 0 AS nspowner, NULL AS nspacl FROM duckdb_schemas();\n'), ('pg_namespace', 'CREATE TEMPORARY VIEW pg_catalog.pg_namespace AS SELECT oid, schema_name AS nspname, 0 AS nspowner, NULL AS nspacl FROM duckdb_schemas();\n'), ('pg_proc', "CREATE TEMPORARY VIEW pg_catalog.pg_proc AS SELECT f.function_oid AS oid, function_name AS proname, s.oid AS pronamespace, NULL AS proowner, NULL AS prolang, 0 AS procost, 0 AS prorows, varargs AS provariadic, 0 AS prosupport, CASE  WHEN ((function_type = 'aggregate')) THEN ('a') ELSE 'f' END AS prokind, CAST('f' AS BOOLEAN) AS prosecdef, CAST('f' AS BOOLEAN) AS proleakproof, CAST('f' AS BOOLEAN) AS proisstrict, (function_type = 'table') AS proretset, CASE  WHEN ((stability = 'CONSISTENT')) THEN ('i') WHEN ((stability = 'CONSISTENT_WITHIN_QUERY')) THEN ('s') WHEN ((stability = 'VOLATILE')) THEN ('v') ELSE NULL END AS provolatile, 'u' AS proparallel, length(parameters) AS pronargs, 0 AS pronargdefaults, return_type AS prorettype, parameter_types AS proargtypes, NULL AS proallargtypes, NULL AS proargmodes, parameters AS proargnames, NULL AS proargdefaults, NULL AS protrftypes, NULL AS prosrc, NULL AS probin, macro_definition AS prosqlbody, NULL AS proconfig, NULL AS proacl, (function_type = 'aggregate') AS proisagg FROM duckdb_functions() AS f LEFT JOIN duckdb_schemas() AS s USING (database_name, schema_name);\n"), ('pg_proc', "CREATE TEMPORARY VIEW pg_catalog.pg_proc AS SELECT f.function_oid AS oid, function_name AS proname, s.oid AS pronamespace, NULL AS proowner, NULL AS prolang, 0 AS procost, 0 AS prorows, varargs AS provariadic, 0 AS prosupport, CASE  WHEN ((function_type = 'aggregate')) THEN ('a') ELSE 'f' END AS prokind, CAST('f' AS BOOLEAN) AS prosecdef, CAST('f' AS BOOLEAN) AS proleakproof, CAST('f' AS BOOLEAN) AS proisstrict, (function_type = 'table') AS proretset, CASE  WHEN ((stability = 'CONSISTENT')) THEN ('i') WHEN ((stability = 'CONSISTENT_WITHIN_QUERY')) THEN ('s') WHEN ((stability = 'VOLATILE')) THEN ('v') ELSE NULL END AS provolatile, 'u' AS proparallel, length(parameters) AS pronargs, 0 AS pronargdefaults, return_type AS prorettype, parameter_types AS proargtypes, NULL AS proallargtypes, NULL AS proargmodes, parameters AS proargnames, NULL AS proargdefaults, NULL AS protrftypes, NULL AS prosrc, NULL AS probin, macro_definition AS prosqlbody, NULL AS proconfig, NULL AS proacl, (function_type = 'aggregate') AS proisagg FROM duckdb_functions() AS f LEFT JOIN duckdb_schemas() AS s USING (database_name, schema_name);\n"), ('pg_proc', "CREATE TEMPORARY VIEW pg_catalog.pg_proc AS SELECT f.function_oid AS oid, function_name AS proname, s.oid AS pronamespace, NULL AS proowner, NULL AS prolang, 0 AS procost, 0 AS prorows, varargs AS provariadic, 0 AS prosupport, CASE  WHEN ((function_type = 'aggregate')) THEN ('a') ELSE 'f' END AS prokind, CAST('f' AS BOOLEAN) AS prosecdef, CAST('f' AS BOOLEAN) AS proleakproof, CAST('f' AS BOOLEAN) AS proisstrict, (function_type = 'table') AS proretset, CASE  WHEN ((stability = 'CONSISTENT')) THEN ('i') WHEN ((stability = 'CONSISTENT_WITHIN_QUERY')) THEN ('s') WHEN ((stability = 'VOLATILE')) THEN ('v') ELSE NULL END AS provolatile, 'u' AS proparallel, length(parameters) AS pronargs, 0 AS pronargdefaults, return_type AS prorettype, parameter_types AS proargtypes, NULL AS proallargtypes, NULL AS proargmodes, parameters AS proargnames, NULL AS proargdefaults, NULL AS protrftypes, NULL AS prosrc, NULL AS probin, macro_definition AS prosqlbody, NULL AS proconfig, NULL AS proacl, (function_type = 'aggregate') AS proisagg FROM duckdb_functions() AS f LEFT JOIN duckdb_schemas() AS s USING (database_name, schema_name);\n"), ('pg_sequence', 'CREATE TEMPORARY VIEW pg_catalog.pg_sequence AS SELECT sequence_oid AS seqrelid, 0 AS seqtypid, start_value AS seqstart, increment_by AS seqincrement, max_value AS seqmax, min_value AS seqmin, 0 AS seqcache, "cycle" AS seqcycle FROM duckdb_sequences();\n'), ('pg_sequence', 'CREATE TEMPORARY VIEW pg_catalog.pg_sequence AS SELECT sequence_oid AS seqrelid, 0 AS seqtypid, start_value AS seqstart, increment_by AS seqincrement, max_value AS seqmax, min_value AS seqmin, 0 AS seqcache, "cycle" AS seqcycle FROM duckdb_sequences();\n'), ('pg_sequence', 'CREATE TEMPORARY VIEW pg_catalog.pg_sequence AS SELECT sequence_oid AS seqrelid, 0 AS seqtypid, start_value AS seqstart, increment_by AS seqincrement, max_value AS seqmax, min_value AS seqmin, 0 AS seqcache, "cycle" AS seqcycle FROM duckdb_sequences();\n'), ('pg_sequences', 'CREATE TEMPORARY VIEW pg_catalog.pg_sequences AS SELECT schema_name AS schemaname, sequence_name AS sequencename, \'duckdb\' AS sequenceowner, 0 AS data_type, start_value, min_value, max_value, increment_by, "cycle", 0 AS cache_size, last_value FROM duckdb_sequences();\n'), ('pg_sequences', 'CREATE TEMPORARY VIEW pg_catalog.pg_sequences AS SELECT schema_name AS schemaname, sequence_name AS sequencename, \'duckdb\' AS sequenceowner, 0 AS data_type, start_value, min_value, max_value, increment_by, "cycle", 0 AS cache_size, last_value FROM duckdb_sequences();\n'), ('pg_sequences', 'CREATE TEMPORARY VIEW pg_catalog.pg_sequences AS SELECT schema_name AS schemaname, sequence_name AS sequencename, \'duckdb\' AS sequenceowner, 0 AS data_type, start_value, min_value, max_value, increment_by, "cycle", 0 AS cache_size, last_value FROM duckdb_sequences();\n'), ('pg_settings', 'CREATE TEMPORARY VIEW pg_catalog.pg_settings AS SELECT "name", "value" AS setting, description AS short_desc, CASE  WHEN ((input_type = \'VARCHAR\')) THEN (\'string\') WHEN ((input_type = \'BOOLEAN\')) THEN (\'bool\') WHEN ((input_type IN (\'BIGINT\', \'UBIGINT\'))) THEN (\'integer\') ELSE input_type END AS vartype FROM duckdb_settings();\n'), ('pg_settings', 'CREATE TEMPORARY VIEW pg_catalog.pg_settings AS SELECT "name", "value" AS setting, description AS short_desc, CASE  WHEN ((input_type = \'VARCHAR\')) THEN (\'string\') WHEN ((input_type = \'BOOLEAN\')) THEN (\'bool\') WHEN ((input_type IN (\'BIGINT\', \'UBIGINT\'))) THEN (\'integer\') ELSE input_type END AS vartype FROM duckdb_settings();\n'), ('pg_settings', 'CREATE TEMPORARY VIEW pg_catalog.pg_settings AS SELECT "name", "value" AS setting, description AS short_desc, CASE  WHEN ((input_type = \'VARCHAR\')) THEN (\'string\') WHEN ((input_type = \'BOOLEAN\')) THEN (\'bool\') WHEN ((input_type IN (\'BIGINT\', \'UBIGINT\'))) THEN (\'integer\') ELSE input_type END AS vartype FROM duckdb_settings();\n'), ('pg_tables', 'CREATE TEMPORARY VIEW pg_catalog.pg_tables AS SELECT schema_name AS schemaname, table_name AS tablename, \'duckdb\' AS tableowner, NULL AS "tablespace", (index_count > 0) AS hasindexes, CAST(\'f\' AS BOOLEAN) AS hasrules, CAST(\'f\' AS BOOLEAN) AS hastriggers FROM duckdb_tables();\n'), ('pg_tables', 'CREATE TEMPORARY VIEW pg_catalog.pg_tables AS SELECT schema_name AS schemaname, table_name AS tablename, \'duckdb\' AS tableowner, NULL AS "tablespace", (index_count > 0) AS hasindexes, CAST(\'f\' AS BOOLEAN) AS hasrules, CAST(\'f\' AS BOOLEAN) AS hastriggers FROM duckdb_tables();\n'), ('pg_tables', 'CREATE TEMPORARY VIEW pg_catalog.pg_tables AS SELECT schema_name AS schemaname, table_name AS tablename, \'duckdb\' AS tableowner, NULL AS "tablespace", (index_count > 0) AS hasindexes, CAST(\'f\' AS BOOLEAN) AS hasrules, CAST(\'f\' AS BOOLEAN) AS hastriggers FROM duckdb_tables();\n'), ('pg_tablespace', "CREATE TEMPORARY VIEW pg_catalog.pg_tablespace AS SELECT 0 AS oid, 'pg_default' AS spcname, 0 AS spcowner, NULL AS spcacl, NULL AS spcoptions;\n"), ('pg_tablespace', "CREATE TEMPORARY VIEW pg_catalog.pg_tablespace AS SELECT 0 AS oid, 'pg_default' AS spcname, 0 AS spcowner, NULL AS spcacl, NULL AS spcoptions;\n"), ('pg_tablespace', "CREATE TEMPORARY VIEW pg_catalog.pg_tablespace AS SELECT 0 AS oid, 'pg_default' AS spcname, 0 AS spcowner, NULL AS spcacl, NULL AS spcoptions;\n"), ('pg_type', "CREATE TEMPORARY VIEW pg_catalog.pg_type AS SELECT type_oid AS oid, format_pg_type(type_name) AS typname, schema_oid AS typnamespace, 0 AS typowner, type_size AS typlen, CAST('f' AS BOOLEAN) AS typbyval, CASE  WHEN ((logical_type = 'ENUM')) THEN ('e') ELSE 'b' END AS typtype, CASE  WHEN ((type_category = 'NUMERIC')) THEN ('N') WHEN ((type_category = 'STRING')) THEN ('S') WHEN ((type_category = 'DATETIME')) THEN ('D') WHEN ((type_category = 'BOOLEAN')) THEN ('B') WHEN ((type_category = 'COMPOSITE')) THEN ('C') WHEN ((type_category = 'USER')) THEN ('U') ELSE 'X' END AS typcategory, CAST('f' AS BOOLEAN) AS typispreferred, CAST('t' AS BOOLEAN) AS typisdefined, NULL AS typdelim, NULL AS typrelid, NULL AS typsubscript, NULL AS typelem, NULL AS typarray, NULL AS typinput, NULL AS typoutput, NULL AS typreceive, NULL AS typsend, NULL AS typmodin, NULL AS typmodout, NULL AS typanalyze, 'd' AS typalign, 'p' AS typstorage, NULL AS typnotnull, NULL AS typbasetype, NULL AS typtypmod, NULL AS typndims, NULL AS typcollation, NULL AS typdefaultbin, NULL AS typdefault, NULL AS typacl FROM duckdb_types() WHERE (type_size IS NOT NULL);\n"), ('pg_type', "CREATE TEMPORARY VIEW pg_catalog.pg_type AS SELECT type_oid AS oid, format_pg_type(type_name) AS typname, schema_oid AS typnamespace, 0 AS typowner, type_size AS typlen, CAST('f' AS BOOLEAN) AS typbyval, CASE  WHEN ((logical_type = 'ENUM')) THEN ('e') ELSE 'b' END AS typtype, CASE  WHEN ((type_category = 'NUMERIC')) THEN ('N') WHEN ((type_category = 'STRING')) THEN ('S') WHEN ((type_category = 'DATETIME')) THEN ('D') WHEN ((type_category = 'BOOLEAN')) THEN ('B') WHEN ((type_category = 'COMPOSITE')) THEN ('C') WHEN ((type_category = 'USER')) THEN ('U') ELSE 'X' END AS typcategory, CAST('f' AS BOOLEAN) AS typispreferred, CAST('t' AS BOOLEAN) AS typisdefined, NULL AS typdelim, NULL AS typrelid, NULL AS typsubscript, NULL AS typelem, NULL AS typarray, NULL AS typinput, NULL AS typoutput, NULL AS typreceive, NULL AS typsend, NULL AS typmodin, NULL AS typmodout, NULL AS typanalyze, 'd' AS typalign, 'p' AS typstorage, NULL AS typnotnull, NULL AS typbasetype, NULL AS typtypmod, NULL AS typndims, NULL AS typcollation, NULL AS typdefaultbin, NULL AS typdefault, NULL AS typacl FROM duckdb_types() WHERE (type_size IS NOT NULL);\n"), ('pg_type', "CREATE TEMPORARY VIEW pg_catalog.pg_type AS SELECT type_oid AS oid, format_pg_type(type_name) AS typname, schema_oid AS typnamespace, 0 AS typowner, type_size AS typlen, CAST('f' AS BOOLEAN) AS typbyval, CASE  WHEN ((logical_type = 'ENUM')) THEN ('e') ELSE 'b' END AS typtype, CASE  WHEN ((type_category = 'NUMERIC')) THEN ('N') WHEN ((type_category = 'STRING')) THEN ('S') WHEN ((type_category = 'DATETIME')) THEN ('D') WHEN ((type_category = 'BOOLEAN')) THEN ('B') WHEN ((type_category = 'COMPOSITE')) THEN ('C') WHEN ((type_category = 'USER')) THEN ('U') ELSE 'X' END AS typcategory, CAST('f' AS BOOLEAN) AS typispreferred, CAST('t' AS BOOLEAN) AS typisdefined, NULL AS typdelim, NULL AS typrelid, NULL AS typsubscript, NULL AS typelem, NULL AS typarray, NULL AS typinput, NULL AS typoutput, NULL AS typreceive, NULL AS typsend, NULL AS typmodin, NULL AS typmodout, NULL AS typanalyze, 'd' AS typalign, 'p' AS typstorage, NULL AS typnotnull, NULL AS typbasetype, NULL AS typtypmod, NULL AS typndims, NULL AS typcollation, NULL AS typdefaultbin, NULL AS typdefault, NULL AS typacl FROM duckdb_types() WHERE (type_size IS NOT NULL);\n"), ('pg_views', 'CREATE TEMPORARY VIEW pg_catalog.pg_views AS SELECT schema_name AS schemaname, view_name AS viewname, \'duckdb\' AS viewowner, "sql" AS definition FROM duckdb_views();\n'), ('pg_views', 'CREATE TEMPORARY VIEW pg_catalog.pg_views AS SELECT schema_name AS schemaname, view_name AS viewname, \'duckdb\' AS viewowner, "sql" AS definition FROM duckdb_views();\n'), ('pg_views', 'CREATE TEMPORARY VIEW pg_catalog.pg_views AS SELECT schema_name AS schemaname, view_name AS viewname, \'duckdb\' AS viewowner, "sql" AS definition FROM duckdb_views();\n')]

-----------
QUERY:


SELECT tablename, rulename, definition FROM pg_rules
WHERE schemaname = 'pg_catalog'
ORDER BY tablename, rulename;
RESULT:
	ERROR - Catalog Error: Table with name pg_rules does not exist!
Did you mean "pg_tables"?

-----------
QUERY:


-- restore normal output mode
-- \a\t

--
-- CREATE OR REPLACE RULE
--

CREATE TABLE ruletest_tbl (a int, b int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE ruletest_tbl2 (a int, b int);
RESULT:
	[]

-----------
QUERY:


CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (10, 10);
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


INSERT INTO ruletest_tbl VALUES (99, 99);
RESULT:
	[]

-----------
QUERY:


CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (1000, 1000);
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


INSERT INTO ruletest_tbl VALUES (99, 99);
RESULT:
	[]

-----------
QUERY:


SELECT * FROM ruletest_tbl2;
RESULT:
	[]

-----------
QUERY:


-- Check that rewrite rules splitting one INSERT into multiple
-- conditional statements does not disable FK checking.
create table rule_and_refint_t1 (
	id1a integer,
	id1b integer,

	primary key (id1a, id1b)
);
RESULT:
	[]

-----------
QUERY:


create table rule_and_refint_t2 (
	id2a integer,
	id2c integer,

	primary key (id2a, id2c)
);
RESULT:
	[]

-----------
QUERY:


create table rule_and_refint_t3 (
	id3a integer,
	id3b integer,
	id3c integer,
	data text,

	primary key (id3a, id3b, id3c),

	foreign key (id3a, id3b) references rule_and_refint_t1 (id1a, id1b),
	foreign key (id3a, id3c) references rule_and_refint_t2 (id2a, id2c)
);
RESULT:
	[]

-----------
QUERY:



insert into rule_and_refint_t1 values (1, 11);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t1 values (1, 12);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t1 values (2, 21);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t1 values (2, 22);
RESULT:
	[]

-----------
QUERY:


insert into rule_and_refint_t2 values (1, 11);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t2 values (1, 12);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t2 values (2, 21);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t2 values (2, 22);
RESULT:
	[]

-----------
QUERY:


insert into rule_and_refint_t3 values (1, 11, 11, 'row1');
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t3 values (1, 11, 12, 'row2');
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t3 values (1, 12, 11, 'row3');
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t3 values (1, 12, 12, 'row4');
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t3 values (1, 11, 13, 'row5');
RESULT:
	ERROR - Constraint Error: Violates foreign key constraint because key "id2a: 1, id2c: 13" does not exist in the referenced table

-----------
QUERY:

insert into rule_and_refint_t3 values (1, 13, 11, 'row6');
RESULT:
	ERROR - Constraint Error: Violates foreign key constraint because key "id1a: 1, id1b: 13" does not exist in the referenced table

-----------
QUERY:

-- Ordinary table
insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
  on conflict do nothing;
RESULT:
	ERROR - Constraint Error: Violates foreign key constraint because key "id1a: 1, id1b: 13" does not exist in the referenced table

-----------
QUERY:

-- rule not fired, so fk violation
insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
  on conflict (id3a, id3b, id3c) do update
  set id3b = excluded.id3b;
RESULT:
	ERROR - Binder Error: Can not assign to column 'id3b' because it has a UNIQUE/PRIMARY KEY constraint

-----------
QUERY:

-- rule fired, so unsupported
insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0)
  on conflict (sl_name) do update
  set sl_avail = excluded.sl_avail;
RESULT:
	ERROR - Catalog Error: shoelace is not an table

-----------
QUERY:


create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3
	where (exists (select 1 from rule_and_refint_t3
			where (((rule_and_refint_t3.id3a = new.id3a)
			and (rule_and_refint_t3.id3b = new.id3b))
			and (rule_and_refint_t3.id3c = new.id3c))))
	do instead update rule_and_refint_t3 set data = new.data
	where (((rule_and_refint_t3.id3a = new.id3a)
	and (rule_and_refint_t3.id3b = new.id3b))
	and (rule_and_refint_t3.id3c = new.id3c));
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


insert into rule_and_refint_t3 values (1, 11, 13, 'row7');
RESULT:
	ERROR - Constraint Error: Violates foreign key constraint because key "id2a: 1, id2c: 13" does not exist in the referenced table

-----------
QUERY:

insert into rule_and_refint_t3 values (1, 13, 11, 'row8');
RESULT:
	ERROR - Constraint Error: Violates foreign key constraint because key "id1a: 1, id1b: 13" does not exist in the referenced table

-----------
QUERY:


--
-- disallow dropping a view/* REPLACED */ ''s rule (bug #5072)
--

create view rules_fooview as select 'rules_foo'::text;
RESULT:
	[]

-----------
QUERY:

drop rule "_RETURN" on rules_fooview;
RESULT:
	ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

drop view rules_fooview;
RESULT:
	[]

-----------
QUERY:


--
-- We used to allow converting a table to a view by creating a /* REPLACED */ ''_RETURN/* REPLACED */ ''
-- rule for it, but no more.
--

create table rules_fooview (x int, y text);
RESULT:
	[]

-----------
QUERY:

create rule "_RETURN" as on select to rules_fooview do instead
  select 1 as x, 'aaa'::text as y;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

drop table rules_fooview;
RESULT:
	[]

-----------
QUERY:


-- likewise, converting a partitioned table or partition to view is not allowed
create table rules_fooview (x int, y text) partition by list (x);
RESULT:
	ERROR - Parser Error: syntax error at or near "partition"

-----------
QUERY:

create rule "_RETURN" as on select to rules_fooview do instead
  select 1 as x, 'aaa'::text as y;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create table rules_fooview_part partition of rules_fooview for values in (1);
RESULT:
	ERROR - Parser Error: syntax error at or near "partition"

-----------
QUERY:

create rule "_RETURN" as on select to rules_fooview_part do instead
  select 1 as x, 'aaa'::text as y;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


drop table rules_fooview;
RESULT:
	ERROR - Catalog Error: Table with name rules_fooview does not exist!
Did you mean "rtest_view1"?

-----------
QUERY:


--
-- check for planner problems with complex inherited UPDATES
--

create table id (id serial primary key, name text);
RESULT:
	ERROR - Catalog Error: Type with name serial does not exist!
Did you mean "real"?

-----------
QUERY:

-- currently, must respecify PKEY for each inherited subtable
create table test_1 (id integer primary key) inherits (id);
RESULT:
	ERROR - Parser Error: syntax error at or near "inherits"

-----------
QUERY:

create table test_2 (id integer primary key) inherits (id);
RESULT:
	ERROR - Parser Error: syntax error at or near "inherits"

-----------
QUERY:

create table test_3 (id integer primary key) inherits (id);
RESULT:
	ERROR - Parser Error: syntax error at or near "inherits"

-----------
QUERY:


insert into test_1 (name) values ('Test 1');
RESULT:
	ERROR - Catalog Error: Table with name test_1 does not exist!
Did you mean "rtest_t1"?

-----------
QUERY:

insert into test_1 (name) values ('Test 2');
RESULT:
	ERROR - Catalog Error: Table with name test_1 does not exist!
Did you mean "rtest_t1"?

-----------
QUERY:

insert into test_2 (name) values ('Test 3');
RESULT:
	ERROR - Catalog Error: Table with name test_2 does not exist!
Did you mean "rtest_t2"?

-----------
QUERY:

insert into test_2 (name) values ('Test 4');
RESULT:
	ERROR - Catalog Error: Table with name test_2 does not exist!
Did you mean "rtest_t2"?

-----------
QUERY:

insert into test_3 (name) values ('Test 5');
RESULT:
	ERROR - Catalog Error: Table with name test_3 does not exist!
Did you mean "rtest_t3"?

-----------
QUERY:

insert into test_3 (name) values ('Test 6');
RESULT:
	ERROR - Catalog Error: Table with name test_3 does not exist!
Did you mean "rtest_t3"?

-----------
QUERY:


create view id_ordered as select * from id order by id;
RESULT:
	ERROR - Catalog Error: Table with name id does not exist!
Did you mean "unit"?
LINE 3: ...
create view id_ordered as select * from id order by id;
                                                  ^

-----------
QUERY:


create rule update_id_ordered as on update to id_ordered
	do instead update id set name = new.name where id = old.id;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


select * from id_ordered;
RESULT:
	ERROR - Catalog Error: Table with name id_ordered does not exist!
Did you mean "pg_depend"?

-----------
QUERY:

update id_ordered set name = 'update 2' where id = 2;
RESULT:
	ERROR - Catalog Error: Table with name id_ordered does not exist!
Did you mean "pg_depend"?
LINE 2: update id_ordered set name = 'update 2' where...
               ^

-----------
QUERY:

update id_ordered set name = 'update 4' where id = 4;
RESULT:
	ERROR - Catalog Error: Table with name id_ordered does not exist!
Did you mean "pg_depend"?
LINE 2: update id_ordered set name = 'update 4' where...
               ^

-----------
QUERY:

update id_ordered set name = 'update 5' where id = 5;
RESULT:
	ERROR - Catalog Error: Table with name id_ordered does not exist!
Did you mean "pg_depend"?
LINE 2: update id_ordered set name = 'update 5' where...
               ^

-----------
QUERY:

select * from id_ordered;
RESULT:
	ERROR - Catalog Error: Table with name id_ordered does not exist!
Did you mean "pg_depend"?

-----------
QUERY:


drop table id cascade;
RESULT:
	ERROR - Catalog Error: Table with name id does not exist!
Did you mean "unit"?

-----------
QUERY:


--
-- check corner case where an entirely-dummy subplan is created by
-- constraint exclusion
--

create temp table t1 (a integer primary key);
RESULT:
	[]

-----------
QUERY:


create temp table t1_1 (check (a >= 0 and a < 10)) inherits (t1);
RESULT:
	ERROR - Parser Error: syntax error at or near "inherits"

-----------
QUERY:

create temp table t1_2 (check (a >= 10 and a < 20)) inherits (t1);
RESULT:
	ERROR - Parser Error: syntax error at or near "inherits"

-----------
QUERY:


create rule t1_ins_1 as on insert to t1
	where new.a >= 0 and new.a < 10
	do instead
	insert into t1_1 values (new.a);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

create rule t1_ins_2 as on insert to t1
	where new.a >= 10 and new.a < 20
	do instead
	insert into t1_2 values (new.a);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


create rule t1_upd_1 as on update to t1
	where old.a >= 0 and old.a < 10
	do instead
	update t1_1 set a = new.a where a = old.a;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

create rule t1_upd_2 as on update to t1
	where old.a >= 10 and old.a < 20
	do instead
	update t1_2 set a = new.a where a = old.a;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


set constraint_exclusion = on;
RESULT:
	ERROR - Parser Error: syntax error at or near "on"

-----------
QUERY:


insert into t1 select * from generate_series(5,19,1) g;
RESULT:
	[]

-----------
QUERY:

update t1 set a = 4 where a = 5;
RESULT:
	[]

-----------
QUERY:


select * from only t1;
RESULT:
	[(6,), (7,), (8,), (9,), (10,), (11,), (12,), (13,), (14,), (15,), (16,), (17,), (18,), (19,), (4,)]

-----------
QUERY:

select * from only t1_1;
RESULT:
	ERROR - Catalog Error: Table with name t1_1 does not exist!
Did you mean "t1"?

-----------
QUERY:

select * from only t1_2;
RESULT:
	ERROR - Catalog Error: Table with name t1_2 does not exist!
Did you mean "t1"?

-----------
QUERY:


reset constraint_exclusion;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "constraint_exclusion"

Did you mean: "TimeZone"

-----------
QUERY:


-- test FOR UPDATE in rules

create table rules_base(f1 int, f2 int);
RESULT:
	[]

-----------
QUERY:

insert into rules_base values(1,2), (11,12);
RESULT:
	[]

-----------
QUERY:

create rule r1 as on update to rules_base do instead
  select * from rules_base where f1 = 1 for update;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

update rules_base set f2 = f2 + 1;
RESULT:
	[]

-----------
QUERY:

create or replace rule r1 as on update to rules_base do instead
  select * from rules_base where f1 = 11 for update of rules_base;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

update rules_base set f2 = f2 + 1;
RESULT:
	[]

-----------
QUERY:

create or replace rule r1 as on update to rules_base do instead
  select * from rules_base where f1 = 11 for update of old;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:
 -- error
drop table rules_base;
RESULT:
	[]

-----------
QUERY:


-- test various flavors of pg_get_viewdef()

select pg_get_viewdef('shoe'::regclass) as unpretty;
RESULT:
	ERROR - Catalog Error: Type with name regclass does not exist!
Did you mean "real"?

-----------
QUERY:

select pg_get_viewdef('shoe'::regclass,true) as pretty;
RESULT:
	ERROR - Binder Error: Macro function 'pg_get_viewdef(oid)' requires a single positional argument, but 2 positional arguments were provided.

-----------
QUERY:

select pg_get_viewdef('shoe'::regclass,0) as prettier;
RESULT:
	ERROR - Binder Error: Macro function 'pg_get_viewdef(oid)' requires a single positional argument, but 2 positional arguments were provided.

-----------
QUERY:


--
-- check multi-row VALUES in rules
--

create table rules_src(f1 int, f2 int default 0);
RESULT:
	[]

-----------
QUERY:

create table rules_log(f1 int, f2 int, tag text, id serial);
RESULT:
	ERROR - Catalog Error: Type with name serial does not exist!
Did you mean "real"?

-----------
QUERY:

insert into rules_src values(1,2), (11,12);
RESULT:
	[]

-----------
QUERY:

create rule r1 as on update to rules_src do also
  insert into rules_log values(old.*, 'old', default), (new.*, 'new', default);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

update rules_src set f2 = f2 + 1;
RESULT:
	[]

-----------
QUERY:

update rules_src set f2 = f2 * 10;
RESULT:
	[]

-----------
QUERY:

select * from rules_src;
RESULT:
	[(1, 30), (11, 130)]

-----------
QUERY:

select * from rules_log;
RESULT:
	ERROR - Catalog Error: Table with name rules_log does not exist!
Did you mean "rules_src"?

-----------
QUERY:

create rule r2 as on update to rules_src do also
  values(old.*, 'old'), (new.*, 'new');
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

update rules_src set f2 = f2 / 10;
RESULT:
	[]

-----------
QUERY:

create rule r3 as on insert to rules_src do also
  insert into rules_log values(null, null, '-', default), (new.*, 'new', default);
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

insert into rules_src values(22,23), (33,default);
RESULT:
	[]

-----------
QUERY:

select * from rules_src;
RESULT:
	[(1, 3), (11, 13), (22, 23), (33, 0)]

-----------
QUERY:

select * from rules_log;
RESULT:
	ERROR - Catalog Error: Table with name rules_log does not exist!
Did you mean "rules_src"?

-----------
QUERY:

create rule r4 as on delete to rules_src do notify rules_src_deletion;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


--
-- Ensure an aliased target relation for insert is correctly deparsed.
--
create rule r5 as on insert to rules_src do instead insert into rules_log AS trgt SELECT NEW.* RETURNING trgt.f1, trgt.f2;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

create rule r6 as on update to rules_src do instead UPDATE rules_log AS trgt SET tag = 'updated' WHERE trgt.f1 = new.f1;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


--
-- Check deparse disambiguation of INSERT/UPDATE/DELETE targets.
--
create rule r7 as on delete to rules_src do instead
  with wins as (insert into int4_tbl as trgt values (0) returning *),
       wupd as (update int4_tbl trgt set f1 = f1+1 returning *),
       wdel as (delete from int4_tbl trgt where f1 = 0 returning *)
  insert into rules_log AS trgt select old.* from wins, wupd, wdel
  returning trgt.f1, trgt.f2;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:


-- check display of all rules added above
-- \d+ rules_src

--
-- Also check multiassignment deparsing.
--
create table rule_t1(f1 int, f2 int);
RESULT:
	[]

-----------
QUERY:

create table rule_dest(f1 int, f2 int[], tag text);
RESULT:
	[]

-----------
QUERY:

create rule rr as on update to rule_t1 do instead UPDATE rule_dest trgt
  SET (f2[1], f1, tag) = (SELECT new.f2, new.f1, 'updated'::varchar)
  WHERE trgt.f1 = new.f1 RETURNING new.*;
RESULT:
	ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

-- \d+ rule_t1
drop table rule_t1, rule_dest;
RESULT:
	ERROR - Not implemented Error: Can only drop one object at a time

-----------
QUERY:


--
-- Test implicit LATERAL references to old/new in rules
--
CREATE TABLE rule_t1(a int, b text DEFAULT 'xxx', c int);
RESULT:
	ERROR - Catalog Error: Table with name "rule_t1" already exists!

-----------
QUERY:

CREATE VIEW rule_v1 AS SELECT * FROM rule_t1;
RESULT:
	[]

-----------
QUERY:

CREATE RULE v1_ins AS ON INSERT TO rule_v1
  DO ALSO INSERT INTO rule_t1
  SELECT * FROM (SELECT a + 10 FROM rule_t1 WHERE a = NEW.a) tt;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

CREATE RULE v1_upd AS ON UPDATE TO rule_v1
  DO ALSO UPDATE rule_t1 t
  SET c = tt.a * 10
  FROM (SELECT a FROM rule_t1 WHERE a = OLD.a) tt WHERE t.a = tt.a;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

INSERT INTO rule_v1 VALUES (1, 'a'), (2, 'b');
RESULT:
	ERROR - Catalog Error: rule_v1 is not an table

-----------
QUERY:

UPDATE rule_v1 SET b = upper(b);
RESULT:
	ERROR - Binder Error: Can only update base table!

-----------
QUERY:

SELECT * FROM rule_t1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE rule_t1 CASCADE;
RESULT:
	[]

-----------
QUERY:


--
-- check alter rename rule
--
CREATE TABLE rule_t1 (a INT);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rule_v1 AS SELECT * FROM rule_t1;
RESULT:
	ERROR - Catalog Error: View with name "rule_v1" already exists!

-----------
QUERY:


CREATE RULE InsertRule AS
    ON INSERT TO rule_v1
    DO INSTEAD
        INSERT INTO rule_t1 VALUES(new.a);
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


ALTER RULE InsertRule ON rule_v1 RENAME to NewInsertRule;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


INSERT INTO rule_v1 VALUES(1);
RESULT:
	ERROR - Catalog Error: rule_v1 is not an table

-----------
QUERY:

SELECT * FROM rule_v1;
RESULT:
	ERROR - Binder Error: table "rule_v1" has 1 columns available but 2 columns specified

-----------
QUERY:


-- \d+ rule_v1

--
-- error conditions for alter rename rule
--
ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:
 -- doesn/* REPLACED */ ''t exist
ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN";
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:
 -- already exists
ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:
 -- ON SELECT rule cannot be renamed

DROP VIEW rule_v1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE rule_t1;
RESULT:
	[]

-----------
QUERY:


--
-- check display of VALUES in view definitions
--
create view rule_v1 as values(1,2);
RESULT:
	[]

-----------
QUERY:

-- \d+ rule_v1
alter table rule_v1 rename column column2 to q2;
RESULT:
	ERROR - Catalog Error: Can only modify view with ALTER VIEW statement

-----------
QUERY:

-- \d+ rule_v1
drop view rule_v1;
RESULT:
	[]

-----------
QUERY:

create view rule_v1(x) as values(1,2);
RESULT:
	[]

-----------
QUERY:

-- \d+ rule_v1
drop view rule_v1;
RESULT:
	[]

-----------
QUERY:

create view rule_v1(x) as select * from (values(1,2)) v;
RESULT:
	[]

-----------
QUERY:

-- \d+ rule_v1
drop view rule_v1;
RESULT:
	[]

-----------
QUERY:

create view rule_v1(x) as select * from (values(1,2)) v(q,w);
RESULT:
	[]

-----------
QUERY:

-- \d+ rule_v1
drop view rule_v1;
RESULT:
	[]

-----------
QUERY:


--
-- Check DO INSTEAD rules with ON CONFLICT
--
CREATE TABLE hats (
	hat_name    char(10) primary key,
	hat_color   char(10)      -- hat color
);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE hat_data (
	hat_name    char(10),
	hat_color   char(10)      -- hat color
);
RESULT:
	[]

-----------
QUERY:

create unique index hat_data_unique_idx
  on hat_data (hat_name COLLATE "C" bpchar_pattern_ops);
RESULT:
	ERROR - Not implemented Error: Index with collation not supported yet!

-----------
QUERY:


-- DO NOTHING with ON CONFLICT
CREATE RULE hat_nosert AS ON INSERT TO hats
    DO INSTEAD
    INSERT INTO hat_data VALUES (
           NEW.hat_name,
           NEW.hat_color)
        ON CONFLICT (hat_name COLLATE "C" bpchar_pattern_ops) WHERE hat_color = 'green'
        DO NOTHING
        RETURNING *;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
RESULT:
	ERROR - Catalog Error: Table with name pg_rules does not exist!
Did you mean "pg_tables"?

-----------
QUERY:


-- Works (projects row)
INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
RESULT:
	[('h7', 'black')]

-----------
QUERY:

-- Works (does nothing)
INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
RESULT:
	ERROR - Constraint Error: Duplicate key "hat_name: h7" violates primary key constraint. If this is an unexpected constraint violation please double check with the known index limitations section in our documentation (https://duckdb.org/docs/sql/indexes).

-----------
QUERY:

SELECT tablename, rulename, definition FROM pg_rules
	WHERE tablename = 'hats';
RESULT:
	ERROR - Catalog Error: Table with name pg_rules does not exist!
Did you mean "pg_tables"?

-----------
QUERY:

DROP RULE hat_nosert ON hats;
RESULT:
	ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:


-- DO NOTHING without ON CONFLICT
CREATE RULE hat_nosert_all AS ON INSERT TO hats
    DO INSTEAD
    INSERT INTO hat_data VALUES (
           NEW.hat_name,
           NEW.hat_color)
        ON CONFLICT
        DO NOTHING
        RETURNING *;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
RESULT:
	ERROR - Catalog Error: Table with name pg_rules does not exist!
Did you mean "pg_tables"?

-----------
QUERY:

DROP RULE hat_nosert_all ON hats;
RESULT:
	ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:


-- Works (does nothing)
INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
RESULT:
	ERROR - Constraint Error: Duplicate key "hat_name: h7" violates primary key constraint. If this is an unexpected constraint violation please double check with the known index limitations section in our documentation (https://duckdb.org/docs/sql/indexes).

-----------
QUERY:


-- DO UPDATE with a WHERE clause
CREATE RULE hat_upsert AS ON INSERT TO hats
    DO INSTEAD
    INSERT INTO hat_data VALUES (
           NEW.hat_name,
           NEW.hat_color)
        ON CONFLICT (hat_name)
        DO UPDATE
           SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color
           WHERE excluded.hat_color <>  'forbidden' AND hat_data.* != excluded.*
        RETURNING *;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
RESULT:
	ERROR - Catalog Error: Table with name pg_rules does not exist!
Did you mean "pg_tables"?

-----------
QUERY:


-- Works (does upsert)
INSERT INTO hats VALUES ('h8', 'black') RETURNING *;
RESULT:
	[('h8', 'black')]

-----------
QUERY:

SELECT * FROM hat_data WHERE hat_name = 'h8';
RESULT:
	[]

-----------
QUERY:

INSERT INTO hats VALUES ('h8', 'white') RETURNING *;
RESULT:
	ERROR - Constraint Error: Duplicate key "hat_name: h8" violates primary key constraint. If this is an unexpected constraint violation please double check with the known index limitations section in our documentation (https://duckdb.org/docs/sql/indexes).

-----------
QUERY:

SELECT * FROM hat_data WHERE hat_name = 'h8';
RESULT:
	[]

-----------
QUERY:

INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *;
RESULT:
	ERROR - Constraint Error: Duplicate key "hat_name: h8" violates primary key constraint. If this is an unexpected constraint violation please double check with the known index limitations section in our documentation (https://duckdb.org/docs/sql/indexes).

-----------
QUERY:

SELECT * FROM hat_data WHERE hat_name = 'h8';
RESULT:
	[]

-----------
QUERY:

SELECT tablename, rulename, definition FROM pg_rules
	WHERE tablename = 'hats';
RESULT:
	ERROR - Catalog Error: Table with name pg_rules does not exist!
Did you mean "pg_tables"?

-----------
QUERY:

-- ensure explain works for on insert conflict rules
explain (costs off) INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


-- ensure upserting into a rule, with a CTE (different offsets!) works
WITH data(hat_name, hat_color) AS MATERIALIZED (
    VALUES ('h8', 'green'),
        ('h9', 'blue'),
        ('h7', 'forbidden')
)
INSERT INTO hats
    SELECT * FROM data
RETURNING *;
RESULT:
	ERROR - Not implemented Error: Materialized CTEs are not implemented for insert.

-----------
QUERY:

EXPLAIN (costs off)
WITH data(hat_name, hat_color) AS MATERIALIZED (
    VALUES ('h8', 'green'),
        ('h9', 'blue'),
        ('h7', 'forbidden')
)
INSERT INTO hats
    SELECT * FROM data
RETURNING *;
RESULT:
	ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

SELECT * FROM hat_data WHERE hat_name IN ('h8', 'h9', 'h7') ORDER BY hat_name;
RESULT:
	[]

-----------
QUERY:


DROP RULE hat_upsert ON hats;
RESULT:
	ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:


drop table hats;
RESULT:
	[]

-----------
QUERY:

drop table hat_data;
RESULT:
	[]

-----------
QUERY:


-- test for pg_get_functiondef properly regurgitating SET parameters
-- Note that the function is kept around to stress pg_dump.
CREATE FUNCTION func_with_set_params() RETURNS integer
    AS 'select 1;
RESULT:
	ERROR - Parser Error: syntax error at or near "RETURNS"

-----------
QUERY:
'
    LANGUAGE SQL
    SET search_path TO PG_CATALOG
    SET extra_float_digits TO 2
    SET work_mem TO '4MB'
    SET datestyle to iso, mdy
    SET local_preload_libraries TO "Mixed/Case", 'c:/''a"/path', '', '0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789'
    IMMUTABLE STRICT;
RESULT:
	ERROR - Parser Error: syntax error at or near "'
    LANGUAGE SQL
    SET search_path TO PG_CATALOG
    SET extra_float_digits TO 2
    SET work_mem TO '"

-----------
QUERY:

SELECT pg_get_functiondef('func_with_set_params()'::regprocedure);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_functiondef does not exist!
Did you mean "pg_get_constraintdef"?

-----------
QUERY:


-- tests for pg_get_*def with invalid objects
SELECT pg_get_constraintdef(0);
RESULT:
	ERROR - Binder Error: Macro function 'pg_get_constraintdef(constraint_oid, pretty_bool)' requires 2 positional arguments, but a single positional argument was provided.

-----------
QUERY:

SELECT pg_get_functiondef(0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_functiondef does not exist!
Did you mean "pg_get_constraintdef"?

-----------
QUERY:

SELECT pg_get_indexdef(0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_indexdef does not exist!
Did you mean "pg_get_viewdef"?

-----------
QUERY:

SELECT pg_get_ruledef(0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_ruledef does not exist!
Did you mean "pg_get_viewdef"?

-----------
QUERY:

SELECT pg_get_statisticsobjdef(0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_statisticsobjdef does not exist!
Did you mean "pg_get_constraintdef"?

-----------
QUERY:

SELECT pg_get_triggerdef(0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_triggerdef does not exist!
Did you mean "pg_get_viewdef"?

-----------
QUERY:

SELECT pg_get_viewdef(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_function_arguments(0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_function_arguments does not exist!
Did you mean "union_tag"?

-----------
QUERY:

SELECT pg_get_function_identity_arguments(0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_function_identity_arguments does not exist!
Did you mean "union_tag"?

-----------
QUERY:

SELECT pg_get_function_result(0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_function_result does not exist!
Did you mean "pg_function_is_visible"?

-----------
QUERY:

SELECT pg_get_function_arg_default(0, 0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_function_arg_default does not exist!
Did you mean "pg_get_constraintdef"?

-----------
QUERY:

SELECT pg_get_function_arg_default('pg_class'::regclass, 0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_function_arg_default does not exist!
Did you mean "pg_get_constraintdef"?

-----------
QUERY:

SELECT pg_get_partkeydef(0);
RESULT:
	ERROR - Catalog Error: Scalar Function with name pg_get_partkeydef does not exist!
Did you mean "pg_get_viewdef"?

-----------
QUERY:


-- test rename for a rule defined on a partitioned table
CREATE TABLE rules_parted_table (a int) PARTITION BY LIST (a);
RESULT:
	ERROR - Parser Error: syntax error at or near "PARTITION"

-----------
QUERY:

CREATE TABLE rules_parted_table_1 PARTITION OF rules_parted_table FOR VALUES IN (1);
RESULT:
	ERROR - Parser Error: syntax error at or near "PARTITION"

-----------
QUERY:

CREATE RULE rules_parted_table_insert AS ON INSERT to rules_parted_table
    DO INSTEAD INSERT INTO rules_parted_table_1 VALUES (NEW.*);
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

ALTER RULE rules_parted_table_insert ON rules_parted_table RENAME TO rules_parted_table_insert_redirect;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

DROP TABLE rules_parted_table;
RESULT:
	ERROR - Catalog Error: Table with name rules_parted_table does not exist!
Did you mean "ruletest_tbl"?

-----------
QUERY:


--
-- test MERGE
--
CREATE TABLE rule_merge1 (a int, b text);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE rule_merge2 (a int, b text);
RESULT:
	[]

-----------
QUERY:

CREATE RULE rule1 AS ON INSERT TO rule_merge1
	DO INSTEAD INSERT INTO rule_merge2 VALUES (NEW.*);
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

CREATE RULE rule2 AS ON UPDATE TO rule_merge1
	DO INSTEAD UPDATE rule_merge2 SET a = NEW.a, b = NEW.b
	WHERE a = OLD.a;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

CREATE RULE rule3 AS ON DELETE TO rule_merge1
	DO INSTEAD DELETE FROM rule_merge2 WHERE a = OLD.a;
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


-- MERGE not supported for table with rules
MERGE INTO rule_merge1 t USING (SELECT 1 AS a) s
	ON t.a = s.a
	WHEN MATCHED AND t.a < 2 THEN
		UPDATE SET b = b || ' updated by merge'
	WHEN MATCHED AND t.a > 2 THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT VALUES (s.a, '');
RESULT:
	ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


-- should be ok with the other table though
MERGE INTO rule_merge2 t USING (SELECT 1 AS a) s
	ON t.a = s.a
	WHEN MATCHED AND t.a < 2 THEN
		UPDATE SET b = b || ' updated by merge'
	WHEN MATCHED AND t.a > 2 THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT VALUES (s.a, '');
RESULT:
	ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


-- also ok if the rules are disabled
ALTER TABLE rule_merge1 DISABLE RULE rule1;
RESULT:
	ERROR - Parser Error: syntax error at or near "DISABLE"

-----------
QUERY:

ALTER TABLE rule_merge1 DISABLE RULE rule2;
RESULT:
	ERROR - Parser Error: syntax error at or near "DISABLE"

-----------
QUERY:

ALTER TABLE rule_merge1 DISABLE RULE rule3;
RESULT:
	ERROR - Parser Error: syntax error at or near "DISABLE"

-----------
QUERY:

MERGE INTO rule_merge1 t USING (SELECT 1 AS a) s
	ON t.a = s.a
	WHEN MATCHED AND t.a < 2 THEN
		UPDATE SET b = b || ' updated by merge'
	WHEN MATCHED AND t.a > 2 THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT VALUES (s.a, '');
RESULT:
	ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


-- test deparsing
CREATE TABLE sf_target(id int, data text, filling int[]);
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION merge_sf_test()
 RETURNS TABLE(action text, a int, b text, id int, data text, filling int[])
 LANGUAGE sql
BEGIN ATOMIC
 MERGE INTO sf_target t
   USING rule_merge1 s
   ON (s.a = t.id)
WHEN MATCHED
   AND (s.a + t.id) = 42
   THEN UPDATE SET data = repeat(t.data, s.a) || s.b, id = length(s.b)
WHEN NOT MATCHED
   AND (s.b IS NOT NULL)
   THEN INSERT (data, id)
   VALUES (s.b, s.a)
WHEN MATCHED
   AND length(s.b || t.data) > 10
   THEN UPDATE SET data = s.b
WHEN MATCHED
   AND s.a > 200
   THEN UPDATE SET filling[s.a] = t.id
WHEN MATCHED
   AND s.a > 100
   THEN DELETE
WHEN MATCHED
   THEN DO NOTHING
WHEN NOT MATCHED
   AND s.a > 200
   THEN INSERT DEFAULT VALUES
WHEN NOT MATCHED
   AND s.a > 100
   THEN INSERT (id, data) OVERRIDING USER VALUE
   VALUES (s.a, DEFAULT)
WHEN NOT MATCHED
   AND s.a > 0
   THEN INSERT
   VALUES (s.a, s.b, DEFAULT)
WHEN NOT MATCHED
   THEN INSERT (filling[1], id)
   VALUES (s.a, s.a)
RETURNING
   merge_action() AS action, *;
RESULT:
	ERROR - Parser Error: syntax error at or near "RETURNS"

-----------
QUERY:

END;
RESULT:
	ERROR - TransactionContext Error: cannot commit - no transaction is active

-----------
QUERY:


-- \sf merge_sf_test

DROP FUNCTION merge_sf_test;
RESULT:
	ERROR - Catalog Error: Macro Function with name merge_sf_test does not exist!
Did you mean "greatest"?

-----------
QUERY:

DROP TABLE sf_target;
RESULT:
	[]

-----------
QUERY:


--
-- Test enabling/disabling
--
CREATE TABLE ruletest1 (a int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE ruletest2 (b int);
RESULT:
	[]

-----------
QUERY:


CREATE RULE rule1 AS ON INSERT TO ruletest1
    DO INSTEAD INSERT INTO ruletest2 VALUES (NEW.*);
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


INSERT INTO ruletest1 VALUES (1);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE ruletest1 DISABLE RULE rule1;
RESULT:
	ERROR - Parser Error: syntax error at or near "DISABLE"

-----------
QUERY:

INSERT INTO ruletest1 VALUES (2);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE ruletest1 ENABLE RULE rule1;
RESULT:
	ERROR - Parser Error: syntax error at or near "ENABLE"

-----------
QUERY:

SET session_replication_role = replica;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "session_replication_role"

Did you mean: "extension_directory"

-----------
QUERY:

INSERT INTO ruletest1 VALUES (3);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE ruletest1 ENABLE REPLICA RULE rule1;
RESULT:
	ERROR - Parser Error: syntax error at or near "ENABLE"

-----------
QUERY:

INSERT INTO ruletest1 VALUES (4);
RESULT:
	[]

-----------
QUERY:

RESET session_replication_role;
RESULT:
	ERROR - Catalog Error: unrecognized configuration parameter "session_replication_role"

Did you mean: "extension_directory"

-----------
QUERY:

INSERT INTO ruletest1 VALUES (5);
RESULT:
	[]

-----------
QUERY:


SELECT * FROM ruletest1;
RESULT:
	[(1,), (2,), (3,), (4,), (5,)]

-----------
QUERY:

SELECT * FROM ruletest2;
RESULT:
	[]

-----------
QUERY:


DROP TABLE ruletest1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE ruletest2;
RESULT:
	[]

-----------
QUERY:


--
-- Test non-SELECT rule on security invoker view.
-- Should use view owner/* REPLACED */ ''s permissions.
--
CREATE USER regress_rule_user1;
RESULT:
	ERROR - Parser Error: syntax error at or near "USER"

-----------
QUERY:


CREATE TABLE ruletest_t1 (x int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE ruletest_t2 (x int);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW ruletest_v1 WITH (security_invoker=true) AS
    SELECT * FROM ruletest_t1;
RESULT:
	ERROR - Not implemented Error: VIEW options

-----------
QUERY:

GRANT INSERT ON ruletest_v1 TO regress_rule_user1;
RESULT:
	ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


CREATE RULE rule1 AS ON INSERT TO ruletest_v1
    DO INSTEAD INSERT INTO ruletest_t2 VALUES (NEW.*);
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rule_user1;
RESULT:
	ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

INSERT INTO ruletest_v1 VALUES (1);
RESULT:
	ERROR - Catalog Error: Table with name ruletest_v1 does not exist!
Did you mean "ruletest_t1"?

-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


-- Test that main query/* REPLACED */ ''s relation/* REPLACED */ ''s permissions are checked before
-- the rule action/* REPLACED */ ''s relation/* REPLACED */ ''s.
CREATE TABLE ruletest_t3 (x int);
RESULT:
	[]

-----------
QUERY:

CREATE RULE rule2 AS ON UPDATE TO ruletest_t1
    DO INSTEAD INSERT INTO ruletest_t2 VALUES (OLD.*);
RESULT:
	ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

REVOKE ALL ON ruletest_t2 FROM regress_rule_user1;
RESULT:
	ERROR - Parser Error: syntax error at or near "REVOKE"

-----------
QUERY:

REVOKE ALL ON ruletest_t3 FROM regress_rule_user1;
RESULT:
	ERROR - Parser Error: syntax error at or near "REVOKE"

-----------
QUERY:

ALTER TABLE ruletest_t1 OWNER TO regress_rule_user1;
RESULT:
	ERROR - Parser Error: syntax error at or near "OWNER"

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rule_user1;
RESULT:
	ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

UPDATE ruletest_t1 t1 SET x = 0 FROM ruletest_t3 t3 WHERE t1.x = t3.x;
RESULT:
	[]

-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM ruletest_t1;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM ruletest_t2;
RESULT:
	[]

-----------
QUERY:


DROP VIEW ruletest_v1;
RESULT:
	ERROR - Catalog Error: View with name ruletest_v1 does not exist!
Did you mean "ruletest_t1"?

-----------
QUERY:

DROP RULE rule2 ON ruletest_t1;
RESULT:
	ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

DROP TABLE ruletest_t3;
RESULT:
	[]

-----------
QUERY:

DROP TABLE ruletest_t2;
RESULT:
	[]

-----------
QUERY:

DROP TABLE ruletest_t1;
RESULT:
	[]

-----------
QUERY:


DROP USER regress_rule_user1;
RESULT:
	ERROR - Parser Error: syntax error at or near "USER"
