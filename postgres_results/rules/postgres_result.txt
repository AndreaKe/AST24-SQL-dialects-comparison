
-----------
QUERY:
--
-- RULES
-- From Jan/* REPLACED */ ''s original setup_ruletest.sql and run_ruletest.sql
-- - thomas 1998-09-13
--

--
-- Tables and rules for the view test
--
create table rtest_t1 (a int4, b int4);
RESULT:
	[]

-----------
QUERY:

create table rtest_t2 (a int4, b int4);
RESULT:
	[]

-----------
QUERY:

create table rtest_t3 (a int4, b int4);
RESULT:
	[]

-----------
QUERY:


create view rtest_v1 as select * from rtest_t1;
RESULT:
	[]

-----------
QUERY:

create rule rtest_v1_ins as on insert to rtest_v1 do instead
	insert into rtest_t1 values (new.a, new.b);
RESULT:
	[]

-----------
QUERY:

create rule rtest_v1_upd as on update to rtest_v1 do instead
	update rtest_t1 set a = new.a, b = new.b
	where a = old.a;
RESULT:
	[]

-----------
QUERY:

create rule rtest_v1_del as on delete to rtest_v1 do instead
	delete from rtest_t1 where a = old.a;
RESULT:
	[]

-----------
QUERY:

-- Test comments
COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'bad rule';
RESULT:
	ERROR - rule "rtest_v1_bad" for relation "rtest_v1" does not exist


-----------
QUERY:

COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'delete rule';
RESULT:
	[]

-----------
QUERY:

COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL;
RESULT:
	[]

-----------
QUERY:

--
-- Tables and rules for the constraint update/delete test
--
-- Note:
-- 	Now that we have multiple action rule support, we check
-- 	both possible syntaxes to define them (The last action
--  can but must not have a semicolon at the end).
--
create table rtest_system (sysname text, sysdesc text);
RESULT:
	[]

-----------
QUERY:

create table rtest_interface (sysname text, ifname text);
RESULT:
	[]

-----------
QUERY:

create table rtest_person (pname text, pdesc text);
RESULT:
	[]

-----------
QUERY:

create table rtest_admin (pname text, sysname text);
RESULT:
	[]

-----------
QUERY:


create rule rtest_sys_upd as on update to rtest_system do also (
	update rtest_interface set sysname = new.sysname
		where sysname = old.sysname;
RESULT:
	ERROR - syntax error at end of input
LINE 5:   where sysname = old.sysname;
                                      ^


-----------
QUERY:

	update rtest_admin set sysname = new.sysname
		where sysname = old.sysname
	);
RESULT:
	ERROR - syntax error at or near ")"
LINE 4:  );
         ^


-----------
QUERY:


create rule rtest_sys_del as on delete to rtest_system do also (
	delete from rtest_interface where sysname = old.sysname;
RESULT:
	ERROR - syntax error at end of input
LINE 4:  delete from rtest_interface where sysname = old.sysname;
                                                                 ^


-----------
QUERY:

	delete from rtest_admin where sysname = old.sysname;
RESULT:
	ERROR - missing FROM-clause entry for table "old"
LINE 2:  delete from rtest_admin where sysname = old.sysname;
                                                 ^


-----------
QUERY:

	);
RESULT:
	ERROR - syntax error at or near ")"
LINE 2:  );
         ^


-----------
QUERY:


create rule rtest_pers_upd as on update to rtest_person do also
	update rtest_admin set pname = new.pname where pname = old.pname;
RESULT:
	[]

-----------
QUERY:


create rule rtest_pers_del as on delete to rtest_person do also
	delete from rtest_admin where pname = old.pname;
RESULT:
	[]

-----------
QUERY:


--
-- Tables and rules for the logging test
--
create table rtest_emp (ename char(20), salary numeric);
RESULT:
	[]

-----------
QUERY:

create table rtest_emplog (ename char(20), who name, action char(10), newsal numeric, oldsal numeric);
RESULT:
	[]

-----------
QUERY:

create table rtest_empmass (ename char(20), salary numeric);
RESULT:
	[]

-----------
QUERY:


create rule rtest_emp_ins as on insert to rtest_emp do
	insert into rtest_emplog values (new.ename, current_user,
			'hired', new.salary, '0.00');
RESULT:
	[]

-----------
QUERY:


create rule rtest_emp_upd as on update to rtest_emp where new.salary != old.salary do
	insert into rtest_emplog values (new.ename, current_user,
			'honored', new.salary, old.salary);
RESULT:
	[]

-----------
QUERY:


create rule rtest_emp_del as on delete to rtest_emp do
	insert into rtest_emplog values (old.ename, current_user,
			'fired', '0.00', old.salary);
RESULT:
	[]

-----------
QUERY:


--
-- Tables and rules for the multiple cascaded qualified instead
-- rule test
--
create table rtest_t4 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_t5 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_t6 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_t7 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_t8 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_t9 (a int4, b text);
RESULT:
	[]

-----------
QUERY:


create rule rtest_t4_ins1 as on insert to rtest_t4
		where new.a >= 10 and new.a < 20 do instead
	insert into rtest_t5 values (new.a, new.b);
RESULT:
	[]

-----------
QUERY:


create rule rtest_t4_ins2 as on insert to rtest_t4
		where new.a >= 20 and new.a < 30 do
	insert into rtest_t6 values (new.a, new.b);
RESULT:
	[]

-----------
QUERY:


create rule rtest_t5_ins as on insert to rtest_t5
		where new.a > 15 do
	insert into rtest_t7 values (new.a, new.b);
RESULT:
	[]

-----------
QUERY:


create rule rtest_t6_ins as on insert to rtest_t6
		where new.a > 25 do instead
	insert into rtest_t8 values (new.a, new.b);
RESULT:
	[]

-----------
QUERY:


--
-- Tables and rules for the rule fire order test
--
-- As of PG 7.3, the rules should fire in order by name, regardless
-- of INSTEAD attributes or creation order.
--
create table rtest_order1 (a int4);
RESULT:
	[]

-----------
QUERY:

create table rtest_order2 (a int4, b int4, c text);
RESULT:
	[]

-----------
QUERY:


create sequence rtest_seq;
RESULT:
	[]

-----------
QUERY:


create rule rtest_order_r3 as on insert to rtest_order1 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 3 - this should run 3rd');
RESULT:
	[]

-----------
QUERY:


create rule rtest_order_r4 as on insert to rtest_order1
		where a < 100 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 4 - this should run 4th');
RESULT:
	[]

-----------
QUERY:


create rule rtest_order_r2 as on insert to rtest_order1 do
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 2 - this should run 2nd');
RESULT:
	[]

-----------
QUERY:


create rule rtest_order_r1 as on insert to rtest_order1 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 1 - this should run 1st');
RESULT:
	[]

-----------
QUERY:


--
-- Tables and rules for the instead nothing test
--
create table rtest_nothn1 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_nothn2 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_nothn3 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_nothn4 (a int4, b text);
RESULT:
	[]

-----------
QUERY:


create rule rtest_nothn_r1 as on insert to rtest_nothn1
	where new.a >= 10 and new.a < 20 do instead nothing;
RESULT:
	[]

-----------
QUERY:


create rule rtest_nothn_r2 as on insert to rtest_nothn1
	where new.a >= 30 and new.a < 40 do instead nothing;
RESULT:
	[]

-----------
QUERY:


create rule rtest_nothn_r3 as on insert to rtest_nothn2
	where new.a >= 100 do instead
	insert into rtest_nothn3 values (new.a, new.b);
RESULT:
	[]

-----------
QUERY:


create rule rtest_nothn_r4 as on insert to rtest_nothn2
	do instead nothing;
RESULT:
	[]

-----------
QUERY:


--
-- Tests on a view that is select * of a table
-- and has insert/update/delete instead rules to
-- behave close like the real table.
--

--
-- We need test date later
--
insert into rtest_t2 values (1, 21);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t2 values (2, 22);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t2 values (3, 23);
RESULT:
	[]

-----------
QUERY:


insert into rtest_t3 values (1, 31);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t3 values (2, 32);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t3 values (3, 33);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t3 values (4, 34);
RESULT:
	[]

-----------
QUERY:

insert into rtest_t3 values (5, 35);
RESULT:
	[]

-----------
QUERY:


-- insert values
insert into rtest_v1 values (1, 11);
RESULT:
	[]

-----------
QUERY:

insert into rtest_v1 values (2, 12);
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 11), (2, 12)]

-----------
QUERY:


-- delete with constant expression
delete from rtest_v1 where a = 1;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(2, 12)]

-----------
QUERY:

insert into rtest_v1 values (1, 11);
RESULT:
	[]

-----------
QUERY:

delete from rtest_v1 where b = 12;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 11)]

-----------
QUERY:

insert into rtest_v1 values (2, 12);
RESULT:
	[]

-----------
QUERY:

insert into rtest_v1 values (2, 13);
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 11), (2, 12), (2, 13)]

-----------
QUERY:

** Remember the delete rule on rtest_v1: It says
** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
** So this time both rows with a = 2 must get deleted
-- \p
-- \r
delete from rtest_v1 where b = 12;
RESULT:
	ERROR - syntax error at or near "**"
LINE 2: ** Remember the delete rule on rtest_v1: It says
        ^


-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 11), (2, 12), (2, 13)]

-----------
QUERY:

delete from rtest_v1;
RESULT:
	[]

-----------
QUERY:


-- insert select
insert into rtest_v1 select * from rtest_t2;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 21), (2, 22), (3, 23)]

-----------
QUERY:

delete from rtest_v1;
RESULT:
	[]

-----------
QUERY:


-- same with swapped targetlist
insert into rtest_v1 (b, a) select b, a from rtest_t2;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 21), (2, 22), (3, 23)]

-----------
QUERY:


-- now with only one target attribute
insert into rtest_v1 (a) select a from rtest_t3;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 21), (2, 22), (3, 23), (1, None), (2, None), (3, None), (4, None), (5, None)]

-----------
QUERY:

select * from rtest_v1 where b isnull;
RESULT:
	[(1, None), (2, None), (3, None), (4, None), (5, None)]

-----------
QUERY:


-- let attribute a differ (must be done on rtest_t1 - see above)
update rtest_t1 set a = a + 10 where b isnull;
RESULT:
	[]

-----------
QUERY:

delete from rtest_v1 where b isnull;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 21), (2, 22), (3, 23)]

-----------
QUERY:


-- now updates with constant expression
update rtest_v1 set b = 42 where a = 2;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 21), (3, 23), (2, 42)]

-----------
QUERY:

update rtest_v1 set b = 99 where b = 42;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 21), (3, 23), (2, 99)]

-----------
QUERY:

update rtest_v1 set b = 88 where b < 50;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(2, 99), (1, 88), (3, 88)]

-----------
QUERY:

delete from rtest_v1;
RESULT:
	[]

-----------
QUERY:

insert into rtest_v1 select rtest_t2.a, rtest_t3.b
    from rtest_t2, rtest_t3
    where rtest_t2.a = rtest_t3.a;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 31), (2, 32), (3, 33)]

-----------
QUERY:


-- updates in a mergejoin
update rtest_v1 set b = rtest_t2.b from rtest_t2 where rtest_v1.a = rtest_t2.a;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 21), (2, 22), (3, 23)]

-----------
QUERY:

insert into rtest_v1 select * from rtest_t3;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 21), (2, 22), (3, 23), (1, 31), (2, 32), (3, 33), (4, 34), (5, 35)]

-----------
QUERY:

update rtest_t1 set a = a + 10 where b > 30;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 21), (2, 22), (3, 23), (11, 31), (12, 32), (13, 33), (14, 34), (15, 35)]

-----------
QUERY:

update rtest_v1 set a = rtest_t3.a + 20 from rtest_t3 where rtest_v1.b = rtest_t3.b;
RESULT:
	[]

-----------
QUERY:

select * from rtest_v1;
RESULT:
	[(1, 21), (2, 22), (3, 23), (21, 31), (22, 32), (23, 33), (24, 34), (25, 35)]

-----------
QUERY:


--
-- Test for constraint updates/deletes
--
insert into rtest_system values ('orion', 'Linux Jan Wieck');
RESULT:
	[]

-----------
QUERY:

insert into rtest_system values ('notjw', 'WinNT Jan Wieck (notebook)');
RESULT:
	[]

-----------
QUERY:

insert into rtest_system values ('neptun', 'Fileserver');
RESULT:
	[]

-----------
QUERY:


insert into rtest_interface values ('orion', 'eth0');
RESULT:
	[]

-----------
QUERY:

insert into rtest_interface values ('orion', 'eth1');
RESULT:
	[]

-----------
QUERY:

insert into rtest_interface values ('notjw', 'eth0');
RESULT:
	[]

-----------
QUERY:

insert into rtest_interface values ('neptun', 'eth0');
RESULT:
	[]

-----------
QUERY:


insert into rtest_person values ('jw', 'Jan Wieck');
RESULT:
	[]

-----------
QUERY:

insert into rtest_person values ('bm', 'Bruce Momjian');
RESULT:
	[]

-----------
QUERY:


insert into rtest_admin values ('jw', 'orion');
RESULT:
	[]

-----------
QUERY:

insert into rtest_admin values ('jw', 'notjw');
RESULT:
	[]

-----------
QUERY:

insert into rtest_admin values ('bm', 'neptun');
RESULT:
	[]

-----------
QUERY:


update rtest_system set sysname = 'pluto' where sysname = 'neptun';
RESULT:
	[]

-----------
QUERY:


select * from rtest_interface;
RESULT:
	[('orion', 'eth0'), ('orion', 'eth1'), ('notjw', 'eth0'), ('neptun', 'eth0')]

-----------
QUERY:

select * from rtest_admin;
RESULT:
	[('jw', 'orion'), ('jw', 'notjw'), ('bm', 'neptun')]

-----------
QUERY:


update rtest_person set pname = 'jwieck' where pdesc = 'Jan Wieck';
RESULT:
	[]

-----------
QUERY:


-- Note: use ORDER BY here to ensure consistent output across all systems.
-- The above UPDATE affects two rows with equal keys, so they could be
-- updated in either order depending on the whim of the local qsort().

select * from rtest_admin order by pname, sysname;
RESULT:
	[('bm', 'neptun'), ('jwieck', 'notjw'), ('jwieck', 'orion')]

-----------
QUERY:


delete from rtest_system where sysname = 'orion';
RESULT:
	[]

-----------
QUERY:


select * from rtest_interface;
RESULT:
	[('orion', 'eth0'), ('orion', 'eth1'), ('notjw', 'eth0'), ('neptun', 'eth0')]

-----------
QUERY:

select * from rtest_admin;
RESULT:
	[('bm', 'neptun'), ('jwieck', 'orion'), ('jwieck', 'notjw')]

-----------
QUERY:


--
-- Rule qualification test
--
insert into rtest_emp values ('wiecc', '5000.00');
RESULT:
	[]

-----------
QUERY:

insert into rtest_emp values ('gates', '80000.00');
RESULT:
	[]

-----------
QUERY:

update rtest_emp set ename = 'wiecx' where ename = 'wiecc';
RESULT:
	[]

-----------
QUERY:

update rtest_emp set ename = 'wieck', salary = '6000.00' where ename = 'wiecx';
RESULT:
	[]

-----------
QUERY:

update rtest_emp set salary = '7000.00' where ename = 'wieck';
RESULT:
	[]

-----------
QUERY:

delete from rtest_emp where ename = 'gates';
RESULT:
	[]

-----------
QUERY:


select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
RESULT:
	[('gates               ', True, 'fired     ', Decimal('0.00'), Decimal('80000.00')), ('gates               ', True, 'hired     ', Decimal('80000.00'), Decimal('0.00')), ('wiecc               ', True, 'hired     ', Decimal('5000.00'), Decimal('0.00')), ('wieck               ', True, 'honored   ', Decimal('6000.00'), Decimal('5000.00')), ('wieck               ', True, 'honored   ', Decimal('7000.00'), Decimal('6000.00'))]

-----------
QUERY:

insert into rtest_empmass values ('meyer', '4000.00');
RESULT:
	[]

-----------
QUERY:

insert into rtest_empmass values ('maier', '5000.00');
RESULT:
	[]

-----------
QUERY:

insert into rtest_empmass values ('mayr', '6000.00');
RESULT:
	[]

-----------
QUERY:

insert into rtest_emp select * from rtest_empmass;
RESULT:
	[]

-----------
QUERY:

select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
RESULT:
	[('gates               ', True, 'fired     ', Decimal('0.00'), Decimal('80000.00')), ('gates               ', True, 'hired     ', Decimal('80000.00'), Decimal('0.00')), ('maier               ', True, 'hired     ', Decimal('5000.00'), Decimal('0.00')), ('mayr                ', True, 'hired     ', Decimal('6000.00'), Decimal('0.00')), ('meyer               ', True, 'hired     ', Decimal('4000.00'), Decimal('0.00')), ('wiecc               ', True, 'hired     ', Decimal('5000.00'), Decimal('0.00')), ('wieck               ', True, 'honored   ', Decimal('6000.00'), Decimal('5000.00')), ('wieck               ', True, 'honored   ', Decimal('7000.00'), Decimal('6000.00'))]

-----------
QUERY:

update rtest_empmass set salary = salary + '1000.00';
RESULT:
	[]

-----------
QUERY:

update rtest_emp set salary = rtest_empmass.salary from rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
RESULT:
	[]

-----------
QUERY:

select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
RESULT:
	[('gates               ', True, 'fired     ', Decimal('0.00'), Decimal('80000.00')), ('gates               ', True, 'hired     ', Decimal('80000.00'), Decimal('0.00')), ('maier               ', True, 'hired     ', Decimal('5000.00'), Decimal('0.00')), ('maier               ', True, 'honored   ', Decimal('6000.00'), Decimal('5000.00')), ('mayr                ', True, 'hired     ', Decimal('6000.00'), Decimal('0.00')), ('mayr                ', True, 'honored   ', Decimal('7000.00'), Decimal('6000.00')), ('meyer               ', True, 'hired     ', Decimal('4000.00'), Decimal('0.00')), ('meyer               ', True, 'honored   ', Decimal('5000.00'), Decimal('4000.00')), ('wiecc               ', True, 'hired     ', Decimal('5000.00'), Decimal('0.00')), ('wieck               ', True, 'honored   ', Decimal('6000.00'), Decimal('5000.00')), ('wieck               ', True, 'honored   ', Decimal('7000.00'), Decimal('6000.00'))]

-----------
QUERY:

delete from rtest_emp using rtest_empmass where rtest_emp.ename = rtest_empmass.ename;
RESULT:
	[]

-----------
QUERY:

select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal;
RESULT:
	[('gates               ', True, 'fired     ', Decimal('0.00'), Decimal('80000.00')), ('gates               ', True, 'hired     ', Decimal('80000.00'), Decimal('0.00')), ('maier               ', True, 'fired     ', Decimal('0.00'), Decimal('6000.00')), ('maier               ', True, 'hired     ', Decimal('5000.00'), Decimal('0.00')), ('maier               ', True, 'honored   ', Decimal('6000.00'), Decimal('5000.00')), ('mayr                ', True, 'fired     ', Decimal('0.00'), Decimal('7000.00')), ('mayr                ', True, 'hired     ', Decimal('6000.00'), Decimal('0.00')), ('mayr                ', True, 'honored   ', Decimal('7000.00'), Decimal('6000.00')), ('meyer               ', True, 'fired     ', Decimal('0.00'), Decimal('5000.00')), ('meyer               ', True, 'hired     ', Decimal('4000.00'), Decimal('0.00')), ('meyer               ', True, 'honored   ', Decimal('5000.00'), Decimal('4000.00')), ('wiecc               ', True, 'hired     ', Decimal('5000.00'), Decimal('0.00')), ('wieck               ', True, 'honored   ', Decimal('6000.00'), Decimal('5000.00')), ('wieck               ', True, 'honored   ', Decimal('7000.00'), Decimal('6000.00'))]

-----------
QUERY:


--
-- Multiple cascaded qualified instead rule test
--
insert into rtest_t4 values (1, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (2, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (10, 'Record should go to rtest_t5');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (15, 'Record should go to rtest_t5');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (19, 'Record should go to rtest_t5 and t7');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (20, 'Record should go to rtest_t4 and t6');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (26, 'Record should go to rtest_t4 and t8');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (28, 'Record should go to rtest_t4 and t8');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (30, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t4 values (40, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:


select * from rtest_t4;
RESULT:
	[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4'), (20, 'Record should go to rtest_t4 and t6'), (26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8'), (30, 'Record should go to rtest_t4'), (40, 'Record should go to rtest_t4')]

-----------
QUERY:

select * from rtest_t5;
RESULT:
	[(10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7')]

-----------
QUERY:

select * from rtest_t6;
RESULT:
	[(20, 'Record should go to rtest_t4 and t6')]

-----------
QUERY:

select * from rtest_t7;
RESULT:
	[(19, 'Record should go to rtest_t5 and t7')]

-----------
QUERY:

select * from rtest_t8;
RESULT:
	[(26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8')]

-----------
QUERY:


delete from rtest_t4;
RESULT:
	[]

-----------
QUERY:

delete from rtest_t5;
RESULT:
	[]

-----------
QUERY:

delete from rtest_t6;
RESULT:
	[]

-----------
QUERY:

delete from rtest_t7;
RESULT:
	[]

-----------
QUERY:

delete from rtest_t8;
RESULT:
	[]

-----------
QUERY:


insert into rtest_t9 values (1, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (2, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (10, 'Record should go to rtest_t5');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (15, 'Record should go to rtest_t5');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (19, 'Record should go to rtest_t5 and t7');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (20, 'Record should go to rtest_t4 and t6');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (26, 'Record should go to rtest_t4 and t8');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (28, 'Record should go to rtest_t4 and t8');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (30, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:

insert into rtest_t9 values (40, 'Record should go to rtest_t4');
RESULT:
	[]

-----------
QUERY:


insert into rtest_t4 select * from rtest_t9 where a < 20;
RESULT:
	[]

-----------
QUERY:


select * from rtest_t4;
RESULT:
	[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4')]

-----------
QUERY:

select * from rtest_t5;
RESULT:
	[(10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7')]

-----------
QUERY:

select * from rtest_t6;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t7;
RESULT:
	[(19, 'Record should go to rtest_t5 and t7')]

-----------
QUERY:

select * from rtest_t8;
RESULT:
	[]

-----------
QUERY:


insert into rtest_t4 select * from rtest_t9 where b ~ 'and t8';
RESULT:
	[]

-----------
QUERY:


select * from rtest_t4;
RESULT:
	[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4'), (26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8')]

-----------
QUERY:

select * from rtest_t5;
RESULT:
	[(10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7')]

-----------
QUERY:

select * from rtest_t6;
RESULT:
	[]

-----------
QUERY:

select * from rtest_t7;
RESULT:
	[(19, 'Record should go to rtest_t5 and t7')]

-----------
QUERY:

select * from rtest_t8;
RESULT:
	[(26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8')]

-----------
QUERY:


insert into rtest_t4 select a + 1, b from rtest_t9 where a in (20, 30, 40);
RESULT:
	[]

-----------
QUERY:


select * from rtest_t4;
RESULT:
	[(1, 'Record should go to rtest_t4'), (2, 'Record should go to rtest_t4'), (26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8'), (21, 'Record should go to rtest_t4 and t6'), (31, 'Record should go to rtest_t4'), (41, 'Record should go to rtest_t4')]

-----------
QUERY:

select * from rtest_t5;
RESULT:
	[(10, 'Record should go to rtest_t5'), (15, 'Record should go to rtest_t5'), (19, 'Record should go to rtest_t5 and t7')]

-----------
QUERY:

select * from rtest_t6;
RESULT:
	[(21, 'Record should go to rtest_t4 and t6')]

-----------
QUERY:

select * from rtest_t7;
RESULT:
	[(19, 'Record should go to rtest_t5 and t7')]

-----------
QUERY:

select * from rtest_t8;
RESULT:
	[(26, 'Record should go to rtest_t4 and t8'), (28, 'Record should go to rtest_t4 and t8')]

-----------
QUERY:


--
-- Check that the ordering of rules fired is correct
--
insert into rtest_order1 values (1);
RESULT:
	[]

-----------
QUERY:

select * from rtest_order2;
RESULT:
	[(1, 1, 'rule 1 - this should run 1st'), (1, 2, 'rule 2 - this should run 2nd'), (1, 3, 'rule 3 - this should run 3rd'), (1, 4, 'rule 4 - this should run 4th')]

-----------
QUERY:


--
-- Check if instead nothing w/without qualification works
--
insert into rtest_nothn1 values (1, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (2, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (10, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (19, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (20, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (29, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (30, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (39, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (40, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (50, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn1 values (60, 'want this');
RESULT:
	[]

-----------
QUERY:


select * from rtest_nothn1;
RESULT:
	[(1, 'want this'), (2, 'want this'), (20, 'want this'), (29, 'want this'), (40, 'want this'), (50, 'want this'), (60, 'want this')]

-----------
QUERY:


insert into rtest_nothn2 values (10, 'too small');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn2 values (50, 'too small');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn2 values (100, 'OK');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn2 values (200, 'OK');
RESULT:
	[]

-----------
QUERY:


select * from rtest_nothn2;
RESULT:
	[]

-----------
QUERY:

select * from rtest_nothn3;
RESULT:
	[(100, 'OK'), (200, 'OK')]

-----------
QUERY:


delete from rtest_nothn1;
RESULT:
	[]

-----------
QUERY:

delete from rtest_nothn2;
RESULT:
	[]

-----------
QUERY:

delete from rtest_nothn3;
RESULT:
	[]

-----------
QUERY:


insert into rtest_nothn4 values (1, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (2, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (10, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (19, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (20, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (29, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (30, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (39, 'don''t want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (40, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (50, 'want this');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (60, 'want this');
RESULT:
	[]

-----------
QUERY:


insert into rtest_nothn1 select * from rtest_nothn4;
RESULT:
	[]

-----------
QUERY:


select * from rtest_nothn1;
RESULT:
	[(1, 'want this'), (2, 'want this'), (20, 'want this'), (29, 'want this'), (40, 'want this'), (50, 'want this'), (60, 'want this')]

-----------
QUERY:


delete from rtest_nothn4;
RESULT:
	[]

-----------
QUERY:


insert into rtest_nothn4 values (10, 'too small');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (50, 'too small');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (100, 'OK');
RESULT:
	[]

-----------
QUERY:

insert into rtest_nothn4 values (200, 'OK');
RESULT:
	[]

-----------
QUERY:


insert into rtest_nothn2 select * from rtest_nothn4;
RESULT:
	[]

-----------
QUERY:


select * from rtest_nothn2;
RESULT:
	[]

-----------
QUERY:

select * from rtest_nothn3;
RESULT:
	[(100, 'OK'), (200, 'OK')]

-----------
QUERY:


create table rtest_view1 (a int4, b text, v bool);
RESULT:
	[]

-----------
QUERY:

create table rtest_view2 (a int4);
RESULT:
	[]

-----------
QUERY:

create table rtest_view3 (a int4, b text);
RESULT:
	[]

-----------
QUERY:

create table rtest_view4 (a int4, b text, c int4);
RESULT:
	[]

-----------
QUERY:

create view rtest_vview1 as select a, b from rtest_view1 X
	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
RESULT:
	[]

-----------
QUERY:

create view rtest_vview2 as select a, b from rtest_view1 where v;
RESULT:
	[]

-----------
QUERY:

create view rtest_vview3 as select a, b from rtest_vview2 X
	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a);
RESULT:
	[]

-----------
QUERY:

create view rtest_vview4 as select X.a, X.b, count(Y.a) as refcount
	from rtest_view1 X, rtest_view2 Y
	where X.a = Y.a
	group by X.a, X.b;
RESULT:
	[]

-----------
QUERY:

create function rtest_viewfunc1(int4) returns int4 as
	'select count(*)::int4 from rtest_view2 where a = $1'
	language sql;
RESULT:
	[]

-----------
QUERY:

create view rtest_vview5 as select a, b, rtest_viewfunc1(a) as refcount
	from rtest_view1;
RESULT:
	[]

-----------
QUERY:


insert into rtest_view1 values (1, 'item 1', 't');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (2, 'item 2', 't');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (3, 'item 3', 't');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (4, 'item 4', 'f');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (5, 'item 5', 't');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (6, 'item 6', 'f');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (7, 'item 7', 't');
RESULT:
	[]

-----------
QUERY:

insert into rtest_view1 values (8, 'item 8', 't');
RESULT:
	[]

-----------
QUERY:


insert into rtest_view2 values (2);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (2);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (4);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (5);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (7);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (7);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (7);
RESULT:
	[]

-----------
QUERY:

insert into rtest_view2 values (7);
RESULT:
	[]

-----------
QUERY:


select * from rtest_vview1;
RESULT:
	[(2, 'item 2'), (4, 'item 4'), (5, 'item 5'), (7, 'item 7')]

-----------
QUERY:

select * from rtest_vview2;
RESULT:
	[(1, 'item 1'), (2, 'item 2'), (3, 'item 3'), (5, 'item 5'), (7, 'item 7'), (8, 'item 8')]

-----------
QUERY:

select * from rtest_vview3;
RESULT:
	[(2, 'item 2'), (5, 'item 5'), (7, 'item 7')]

-----------
QUERY:

select * from rtest_vview4 order by a, b;
RESULT:
	[(2, 'item 2', 2), (4, 'item 4', 1), (5, 'item 5', 1), (7, 'item 7', 4)]

-----------
QUERY:

select * from rtest_vview5;
RESULT:
	[(1, 'item 1', 0), (2, 'item 2', 2), (3, 'item 3', 0), (4, 'item 4', 1), (5, 'item 5', 1), (6, 'item 6', 0), (7, 'item 7', 4), (8, 'item 8', 0)]

-----------
QUERY:


insert into rtest_view3 select * from rtest_vview1 where a < 7;
RESULT:
	[]

-----------
QUERY:

select * from rtest_view3;
RESULT:
	[(2, 'item 2'), (4, 'item 4'), (5, 'item 5')]

-----------
QUERY:

delete from rtest_view3;
RESULT:
	[]

-----------
QUERY:


insert into rtest_view3 select * from rtest_vview2 where a != 5 and b !~ '2';
RESULT:
	[]

-----------
QUERY:

select * from rtest_view3;
RESULT:
	[(1, 'item 1'), (3, 'item 3'), (7, 'item 7'), (8, 'item 8')]

-----------
QUERY:

delete from rtest_view3;
RESULT:
	[]

-----------
QUERY:


insert into rtest_view3 select * from rtest_vview3;
RESULT:
	[]

-----------
QUERY:

select * from rtest_view3;
RESULT:
	[(2, 'item 2'), (5, 'item 5'), (7, 'item 7')]

-----------
QUERY:

delete from rtest_view3;
RESULT:
	[]

-----------
QUERY:


insert into rtest_view4 select * from rtest_vview4 where 3 > refcount;
RESULT:
	[]

-----------
QUERY:

select * from rtest_view4 order by a, b;
RESULT:
	[(2, 'item 2', 2), (4, 'item 4', 1), (5, 'item 5', 1)]

-----------
QUERY:

delete from rtest_view4;
RESULT:
	[]

-----------
QUERY:


insert into rtest_view4 select * from rtest_vview5 where a > 2 and refcount = 0;
RESULT:
	[]

-----------
QUERY:

select * from rtest_view4;
RESULT:
	[(3, 'item 3', 0), (6, 'item 6', 0), (8, 'item 8', 0)]

-----------
QUERY:

delete from rtest_view4;
RESULT:
	[]

-----------
QUERY:

--
-- Test for computations in views
--
create table rtest_comp (
	part	text,
	unit	char(4),
	size	float
);
RESULT:
	[]

-----------
QUERY:



create table rtest_unitfact (
	unit	char(4),
	factor	float
);
RESULT:
	[]

-----------
QUERY:


create view rtest_vcomp as
	select X.part, (X.size * Y.factor) as size_in_cm
			from rtest_comp X, rtest_unitfact Y
			where X.unit = Y.unit;
RESULT:
	[]

-----------
QUERY:



insert into rtest_unitfact values ('m', 100.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_unitfact values ('cm', 1.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_unitfact values ('inch', 2.54);
RESULT:
	[]

-----------
QUERY:


insert into rtest_comp values ('p1', 'm', 5.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_comp values ('p2', 'm', 3.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_comp values ('p3', 'cm', 5.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_comp values ('p4', 'cm', 15.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_comp values ('p5', 'inch', 7.0);
RESULT:
	[]

-----------
QUERY:

insert into rtest_comp values ('p6', 'inch', 4.4);
RESULT:
	[]

-----------
QUERY:


select * from rtest_vcomp order by part;
RESULT:
	[('p1', 500.0), ('p2', 300.0), ('p3', 5.0), ('p4', 15.0), ('p5', 17.78), ('p6', 11.176000000000002)]

-----------
QUERY:


select * from rtest_vcomp where size_in_cm > 10.0 order by size_in_cm using >;
RESULT:
	[('p1', 500.0), ('p2', 300.0), ('p5', 17.78), ('p4', 15.0), ('p6', 11.176000000000002)]

-----------
QUERY:


--
-- In addition run the (slightly modified) queries from the
-- programmers manual section on the rule system.
--
CREATE TABLE shoe_data (
	shoename   char(10),      -- primary key
	sh_avail   integer,       -- available # of pairs
	slcolor    char(10),      -- preferred shoelace color
	slminlen   float,         -- minimum shoelace length
	slmaxlen   float,         -- maximum shoelace length
	slunit     char(8)        -- length unit
);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE shoelace_data (
	sl_name    char(10),      -- primary key
	sl_avail   integer,       -- available # of pairs
	sl_color   char(10),      -- shoelace color
	sl_len     float,         -- shoelace length
	sl_unit    char(8)        -- length unit
);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE unit (
	un_name    char(8),       -- the primary key
	un_fact    float          -- factor to transform to cm
);
RESULT:
	[]

-----------
QUERY:


CREATE VIEW shoe AS
	SELECT sh.shoename,
		   sh.sh_avail,
		   sh.slcolor,
		   sh.slminlen,
		   sh.slminlen * un.un_fact AS slminlen_cm,
		   sh.slmaxlen,
		   sh.slmaxlen * un.un_fact AS slmaxlen_cm,
		   sh.slunit
	  FROM shoe_data sh, unit un
	 WHERE sh.slunit = un.un_name;
RESULT:
	[]

-----------
QUERY:


CREATE VIEW shoelace AS
	SELECT s.sl_name,
		   s.sl_avail,
		   s.sl_color,
		   s.sl_len,
		   s.sl_unit,
		   s.sl_len * u.un_fact AS sl_len_cm
	  FROM shoelace_data s, unit u
	 WHERE s.sl_unit = u.un_name;
RESULT:
	[]

-----------
QUERY:


CREATE VIEW shoe_ready AS
	SELECT rsh.shoename,
		   rsh.sh_avail,
		   rsl.sl_name,
		   rsl.sl_avail,
		   int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
	  FROM shoe rsh, shoelace rsl
	 WHERE rsl.sl_color = rsh.slcolor
	   AND rsl.sl_len_cm >= rsh.slminlen_cm
	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm;
RESULT:
	[]

-----------
QUERY:


INSERT INTO unit VALUES ('cm', 1.0);
RESULT:
	[]

-----------
QUERY:

INSERT INTO unit VALUES ('m', 100.0);
RESULT:
	[]

-----------
QUERY:

INSERT INTO unit VALUES ('inch', 2.54);
RESULT:
	[]

-----------
QUERY:


INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch');
RESULT:
	[]

-----------
QUERY:


INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm');
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch');
RESULT:
	[]

-----------
QUERY:


-- SELECTs in doc
SELECT * FROM shoelace ORDER BY sl_name;
RESULT:
	[('sl1       ', 5, 'black     ', 80.0, 'cm      ', 80.0), ('sl2       ', 6, 'black     ', 100.0, 'cm      ', 100.0), ('sl3       ', 0, 'black     ', 35.0, 'inch    ', 88.9), ('sl4       ', 8, 'black     ', 40.0, 'inch    ', 101.6), ('sl5       ', 4, 'brown     ', 1.0, 'm       ', 100.0), ('sl6       ', 0, 'brown     ', 0.9, 'm       ', 90.0), ('sl7       ', 7, 'brown     ', 60.0, 'cm      ', 60.0), ('sl8       ', 1, 'brown     ', 40.0, 'inch    ', 101.6)]

-----------
QUERY:

SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1;
RESULT:
	[('sh1       ', 2, 'sl1       ', 5, 2), ('sh3       ', 4, 'sl7       ', 7, 4)]

-----------
QUERY:


    CREATE TABLE shoelace_log (
        sl_name    char(10),      -- shoelace changed
        sl_avail   integer,       -- new available value
        log_who    name,          -- who did it
        log_when   timestamp      -- when
    );
RESULT:
	[]

-----------
QUERY:


-- Want /* REPLACED */ ''log_who/* REPLACED */ '' to be CURRENT_USER,
-- but that is non-portable for the regression test
-- - thomas 1999-02-21

    CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
        WHERE NEW.sl_avail != OLD.sl_avail
        DO INSERT INTO shoelace_log VALUES (
                                        NEW.sl_name,
                                        NEW.sl_avail,
                                        'Al Bundy',
                                        'epoch'
                                    );
RESULT:
	[]

-----------
QUERY:


UPDATE shoelace_data SET sl_avail = 6 WHERE  sl_name = 'sl7';
RESULT:
	[]

-----------
QUERY:


SELECT * FROM shoelace_log;
RESULT:
	[('sl7       ', 6, 'Al Bundy', datetime.datetime(1970, 1, 1, 0, 0))]

-----------
QUERY:


    CREATE RULE shoelace_ins AS ON INSERT TO shoelace
        DO INSTEAD
        INSERT INTO shoelace_data VALUES (
               NEW.sl_name,
               NEW.sl_avail,
               NEW.sl_color,
               NEW.sl_len,
               NEW.sl_unit);
RESULT:
	[]

-----------
QUERY:


    CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
        DO INSTEAD
        UPDATE shoelace_data SET
               sl_name = NEW.sl_name,
               sl_avail = NEW.sl_avail,
               sl_color = NEW.sl_color,
               sl_len = NEW.sl_len,
               sl_unit = NEW.sl_unit
         WHERE sl_name = OLD.sl_name;
RESULT:
	[]

-----------
QUERY:


    CREATE RULE shoelace_del AS ON DELETE TO shoelace
        DO INSTEAD
        DELETE FROM shoelace_data
         WHERE sl_name = OLD.sl_name;
RESULT:
	[]

-----------
QUERY:


    CREATE TABLE shoelace_arrive (
        arr_name    char(10),
        arr_quant   integer
    );
RESULT:
	[]

-----------
QUERY:


    CREATE TABLE shoelace_ok (
        ok_name     char(10),
        ok_quant    integer
    );
RESULT:
	[]

-----------
QUERY:


    CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
        DO INSTEAD
        UPDATE shoelace SET
               sl_avail = sl_avail + NEW.ok_quant
         WHERE sl_name = NEW.ok_name;
RESULT:
	[]

-----------
QUERY:


INSERT INTO shoelace_arrive VALUES ('sl3', 10);
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_arrive VALUES ('sl6', 20);
RESULT:
	[]

-----------
QUERY:

INSERT INTO shoelace_arrive VALUES ('sl8', 20);
RESULT:
	[]

-----------
QUERY:


SELECT * FROM shoelace ORDER BY sl_name;
RESULT:
	[('sl1       ', 5, 'black     ', 80.0, 'cm      ', 80.0), ('sl2       ', 6, 'black     ', 100.0, 'cm      ', 100.0), ('sl3       ', 0, 'black     ', 35.0, 'inch    ', 88.9), ('sl4       ', 8, 'black     ', 40.0, 'inch    ', 101.6), ('sl5       ', 4, 'brown     ', 1.0, 'm       ', 100.0), ('sl6       ', 0, 'brown     ', 0.9, 'm       ', 90.0), ('sl7       ', 6, 'brown     ', 60.0, 'cm      ', 60.0), ('sl8       ', 1, 'brown     ', 40.0, 'inch    ', 101.6)]

-----------
QUERY:


insert into shoelace_ok select * from shoelace_arrive;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM shoelace ORDER BY sl_name;
RESULT:
	[('sl1       ', 5, 'black     ', 80.0, 'cm      ', 80.0), ('sl2       ', 6, 'black     ', 100.0, 'cm      ', 100.0), ('sl3       ', 10, 'black     ', 35.0, 'inch    ', 88.9), ('sl4       ', 8, 'black     ', 40.0, 'inch    ', 101.6), ('sl5       ', 4, 'brown     ', 1.0, 'm       ', 100.0), ('sl6       ', 20, 'brown     ', 0.9, 'm       ', 90.0), ('sl7       ', 6, 'brown     ', 60.0, 'cm      ', 60.0), ('sl8       ', 21, 'brown     ', 40.0, 'inch    ', 101.6)]

-----------
QUERY:


SELECT * FROM shoelace_log ORDER BY sl_name;
RESULT:
	[('sl3       ', 10, 'Al Bundy', datetime.datetime(1970, 1, 1, 0, 0)), ('sl6       ', 20, 'Al Bundy', datetime.datetime(1970, 1, 1, 0, 0)), ('sl7       ', 6, 'Al Bundy', datetime.datetime(1970, 1, 1, 0, 0)), ('sl8       ', 21, 'Al Bundy', datetime.datetime(1970, 1, 1, 0, 0))]

-----------
QUERY:


    CREATE VIEW shoelace_obsolete AS
	SELECT * FROM shoelace WHERE NOT EXISTS
	    (SELECT shoename FROM shoe WHERE slcolor = sl_color);
RESULT:
	[]

-----------
QUERY:


    CREATE VIEW shoelace_candelete AS
	SELECT * FROM shoelace_obsolete WHERE sl_avail = 0;
RESULT:
	[]

-----------
QUERY:


insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0);
RESULT:
	[]

-----------
QUERY:

insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0);
RESULT:
	[]

-----------
QUERY:

-- Unsupported (even though a similar updatable view construct is)
insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0)
  on conflict do nothing;
RESULT:
	ERROR - INSERT with ON CONFLICT clause cannot be used with table that has INSERT or UPDATE rules


-----------
QUERY:


SELECT * FROM shoelace_obsolete ORDER BY sl_len_cm;
RESULT:
	[('sl9       ', 0, 'pink      ', 35.0, 'inch    ', 88.9), ('sl10      ', 1000, 'magenta   ', 40.0, 'inch    ', 101.6)]

-----------
QUERY:

SELECT * FROM shoelace_candelete;
RESULT:
	[('sl9       ', 0, 'pink      ', 35.0, 'inch    ', 88.9)]

-----------
QUERY:


DELETE FROM shoelace WHERE EXISTS
    (SELECT * FROM shoelace_candelete
             WHERE sl_name = shoelace.sl_name);
RESULT:
	[]

-----------
QUERY:


SELECT * FROM shoelace ORDER BY sl_name;
RESULT:
	[('sl1       ', 5, 'black     ', 80.0, 'cm      ', 80.0), ('sl10      ', 1000, 'magenta   ', 40.0, 'inch    ', 101.6), ('sl2       ', 6, 'black     ', 100.0, 'cm      ', 100.0), ('sl3       ', 10, 'black     ', 35.0, 'inch    ', 88.9), ('sl4       ', 8, 'black     ', 40.0, 'inch    ', 101.6), ('sl5       ', 4, 'brown     ', 1.0, 'm       ', 100.0), ('sl6       ', 20, 'brown     ', 0.9, 'm       ', 90.0), ('sl7       ', 6, 'brown     ', 60.0, 'cm      ', 60.0), ('sl8       ', 21, 'brown     ', 40.0, 'inch    ', 101.6)]

-----------
QUERY:


SELECT * FROM shoe ORDER BY shoename;
RESULT:
	[('sh1       ', 2, 'black     ', 70.0, 70.0, 90.0, 90.0, 'cm      '), ('sh2       ', 0, 'black     ', 30.0, 76.2, 40.0, 101.6, 'inch    '), ('sh3       ', 4, 'brown     ', 50.0, 50.0, 65.0, 65.0, 'cm      '), ('sh4       ', 3, 'brown     ', 40.0, 101.6, 50.0, 127.0, 'inch    ')]

-----------
QUERY:

SELECT count(*) FROM shoe;
RESULT:
	[(4,)]

-----------
QUERY:



--
-- Simple test of qualified ON INSERT ... this did not work in 7.0 ...
--
create table rules_foo (f1 int);
RESULT:
	[]

-----------
QUERY:

create table rules_foo2 (f1 int);
RESULT:
	[]

-----------
QUERY:


create rule rules_foorule as on insert to rules_foo where f1 < 100
do instead nothing;
RESULT:
	[]

-----------
QUERY:


insert into rules_foo values(1);
RESULT:
	[]

-----------
QUERY:

insert into rules_foo values(1001);
RESULT:
	[]

-----------
QUERY:

select * from rules_foo;
RESULT:
	[(1001,)]

-----------
QUERY:


drop rule rules_foorule on rules_foo;
RESULT:
	[]

-----------
QUERY:


-- this should fail because f1 is not exposed for unqualified reference:
create rule rules_foorule as on insert to rules_foo where f1 < 100
do instead insert into rules_foo2 values (f1);
RESULT:
	ERROR - column "f1" does not exist
LINE 5: do instead insert into rules_foo2 values (f1);
                                                  ^
DETAIL:  There are columns named "f1", but they are in tables that cannot be referenced from this part of the query.
HINT:  Try using a table-qualified name.


-----------
QUERY:

-- this is the correct way:
create rule rules_foorule as on insert to rules_foo where f1 < 100
do instead insert into rules_foo2 values (new.f1);
RESULT:
	[]

-----------
QUERY:


insert into rules_foo values(2);
RESULT:
	[]

-----------
QUERY:

insert into rules_foo values(100);
RESULT:
	[]

-----------
QUERY:


select * from rules_foo;
RESULT:
	[(1001,), (100,)]

-----------
QUERY:

select * from rules_foo2;
RESULT:
	[(2,)]

-----------
QUERY:


drop rule rules_foorule on rules_foo;
RESULT:
	[]

-----------
QUERY:

drop table rules_foo;
RESULT:
	[]

-----------
QUERY:

drop table rules_foo2;
RESULT:
	[]

-----------
QUERY:



--
-- Test rules containing INSERT ... SELECT, which is a very ugly special
-- case as of 7.1.  Example is based on bug report from Joel Burton.
--
create table pparent (pid int, txt text);
RESULT:
	[]

-----------
QUERY:

insert into pparent values (1,'parent1');
RESULT:
	[]

-----------
QUERY:

insert into pparent values (2,'parent2');
RESULT:
	[]

-----------
QUERY:


create table cchild (pid int, descrip text);
RESULT:
	[]

-----------
QUERY:

insert into cchild values (1,'descrip1');
RESULT:
	[]

-----------
QUERY:


create view vview as
  select pparent.pid, txt, descrip from
    pparent left join cchild using (pid);
RESULT:
	[]

-----------
QUERY:


create rule rrule as
  on update to vview do instead
(
  insert into cchild (pid, descrip)
    select old.pid, new.descrip where old.descrip isnull;
RESULT:
	ERROR - syntax error at end of input
LINE 7:     select old.pid, new.descrip where old.descrip isnull;
                                                                 ^


-----------
QUERY:

  update cchild set descrip = new.descrip where cchild.pid = old.pid;
RESULT:
	ERROR - missing FROM-clause entry for table "old"
LINE 2: ...cchild set descrip = new.descrip where cchild.pid = old.pid;
                                                               ^


-----------
QUERY:

);
RESULT:
	ERROR - syntax error at or near ")"
LINE 2: );
        ^


-----------
QUERY:


select * from vview;
RESULT:
	[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]

-----------
QUERY:

update vview set descrip='test1' where pid=1;
RESULT:
	ERROR - cannot update view "vview"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:

select * from vview;
RESULT:
	[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]

-----------
QUERY:

update vview set descrip='test2' where pid=2;
RESULT:
	ERROR - cannot update view "vview"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:

select * from vview;
RESULT:
	[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]

-----------
QUERY:

update vview set descrip='test3' where pid=3;
RESULT:
	ERROR - cannot update view "vview"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:

select * from vview;
RESULT:
	[(1, 'parent1', 'descrip1'), (2, 'parent2', None)]

-----------
QUERY:

select * from cchild;
RESULT:
	[(1, 'descrip1')]

-----------
QUERY:


drop rule rrule on vview;
RESULT:
	ERROR - rule "rrule" for relation "vview" does not exist


-----------
QUERY:

drop view vview;
RESULT:
	[]

-----------
QUERY:

drop table pparent;
RESULT:
	[]

-----------
QUERY:

drop table cchild;
RESULT:
	[]

-----------
QUERY:



--
-- Check that ruleutils are working
--

-- temporarily disable fancy output, so view changes create less diff noise
-- \a\t

SELECT viewname, definition FROM pg_views
WHERE schemaname = 'pg_catalog'
ORDER BY viewname;
RESULT:
	[('pg_available_extension_versions', ' SELECT e.name,\n    e.version,\n    (x.extname IS NOT NULL) AS installed,\n    e.superuser,\n    e.trusted,\n    e.relocatable,\n    e.schema,\n    e.requires,\n    e.comment\n   FROM (pg_available_extension_versions() e(name, version, superuser, trusted, relocatable, schema, requires, comment)\n     LEFT JOIN pg_extension x ON (((e.name = x.extname) AND (e.version = x.extversion))));'), ('pg_available_extensions', ' SELECT e.name,\n    e.default_version,\n    x.extversion AS installed_version,\n    e.comment\n   FROM (pg_available_extensions() e(name, default_version, comment)\n     LEFT JOIN pg_extension x ON ((e.name = x.extname)));'), ('pg_backend_memory_contexts', ' SELECT name,\n    ident,\n    parent,\n    level,\n    total_bytes,\n    total_nblocks,\n    free_bytes,\n    free_chunks,\n    used_bytes\n   FROM pg_get_backend_memory_contexts() pg_get_backend_memory_contexts(name, ident, parent, level, total_bytes, total_nblocks, free_bytes, free_chunks, used_bytes);'), ('pg_config', ' SELECT name,\n    setting\n   FROM pg_config() pg_config(name, setting);'), ('pg_cursors', ' SELECT name,\n    statement,\n    is_holdable,\n    is_binary,\n    is_scrollable,\n    creation_time\n   FROM pg_cursor() c(name, statement, is_holdable, is_binary, is_scrollable, creation_time);'), ('pg_file_settings', ' SELECT sourcefile,\n    sourceline,\n    seqno,\n    name,\n    setting,\n    applied,\n    error\n   FROM pg_show_all_file_settings() a(sourcefile, sourceline, seqno, name, setting, applied, error);'), ('pg_group', ' SELECT rolname AS groname,\n    oid AS grosysid,\n    ARRAY( SELECT pg_auth_members.member\n           FROM pg_auth_members\n          WHERE (pg_auth_members.roleid = pg_authid.oid)) AS grolist\n   FROM pg_authid\n  WHERE (NOT rolcanlogin);'), ('pg_hba_file_rules', ' SELECT rule_number,\n    file_name,\n    line_number,\n    type,\n    database,\n    user_name,\n    address,\n    netmask,\n    auth_method,\n    options,\n    error\n   FROM pg_hba_file_rules() a(rule_number, file_name, line_number, type, database, user_name, address, netmask, auth_method, options, error);'), ('pg_ident_file_mappings', ' SELECT map_number,\n    file_name,\n    line_number,\n    map_name,\n    sys_name,\n    pg_username,\n    error\n   FROM pg_ident_file_mappings() a(map_number, file_name, line_number, map_name, sys_name, pg_username, error);'), ('pg_indexes', ' SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    i.relname AS indexname,\n    t.spcname AS tablespace,\n    pg_get_indexdef(i.oid) AS indexdef\n   FROM ((((pg_index x\n     JOIN pg_class c ON ((c.oid = x.indrelid)))\n     JOIN pg_class i ON ((i.oid = x.indexrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n     LEFT JOIN pg_tablespace t ON ((t.oid = i.reltablespace)))\n  WHERE ((c.relkind = ANY (ARRAY[\'r\'::"char", \'m\'::"char", \'p\'::"char"])) AND (i.relkind = ANY (ARRAY[\'i\'::"char", \'I\'::"char"])));'), ('pg_locks', ' SELECT locktype,\n    database,\n    relation,\n    page,\n    tuple,\n    virtualxid,\n    transactionid,\n    classid,\n    objid,\n    objsubid,\n    virtualtransaction,\n    pid,\n    mode,\n    granted,\n    fastpath,\n    waitstart\n   FROM pg_lock_status() l(locktype, database, relation, page, tuple, virtualxid, transactionid, classid, objid, objsubid, virtualtransaction, pid, mode, granted, fastpath, waitstart);'), ('pg_matviews', ' SELECT n.nspname AS schemaname,\n    c.relname AS matviewname,\n    pg_get_userbyid(c.relowner) AS matviewowner,\n    t.spcname AS tablespace,\n    c.relhasindex AS hasindexes,\n    c.relispopulated AS ispopulated,\n    pg_get_viewdef(c.oid) AS definition\n   FROM ((pg_class c\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n     LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))\n  WHERE (c.relkind = \'m\'::"char");'), ('pg_policies', ' SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    pol.polname AS policyname,\n        CASE\n            WHEN pol.polpermissive THEN \'PERMISSIVE\'::text\n            ELSE \'RESTRICTIVE\'::text\n        END AS permissive,\n        CASE\n            WHEN (pol.polroles = \'{0}\'::oid[]) THEN (string_to_array(\'public\'::text, \'\'::text))::name[]\n            ELSE ARRAY( SELECT pg_authid.rolname\n               FROM pg_authid\n              WHERE (pg_authid.oid = ANY (pol.polroles))\n              ORDER BY pg_authid.rolname)\n        END AS roles,\n        CASE pol.polcmd\n            WHEN \'r\'::"char" THEN \'SELECT\'::text\n            WHEN \'a\'::"char" THEN \'INSERT\'::text\n            WHEN \'w\'::"char" THEN \'UPDATE\'::text\n            WHEN \'d\'::"char" THEN \'DELETE\'::text\n            WHEN \'*\'::"char" THEN \'ALL\'::text\n            ELSE NULL::text\n        END AS cmd,\n    pg_get_expr(pol.polqual, pol.polrelid) AS qual,\n    pg_get_expr(pol.polwithcheck, pol.polrelid) AS with_check\n   FROM ((pg_policy pol\n     JOIN pg_class c ON ((c.oid = pol.polrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)));'), ('pg_prepared_statements', ' SELECT name,\n    statement,\n    prepare_time,\n    parameter_types,\n    result_types,\n    from_sql,\n    generic_plans,\n    custom_plans\n   FROM pg_prepared_statement() p(name, statement, prepare_time, parameter_types, result_types, from_sql, generic_plans, custom_plans);'), ('pg_prepared_xacts', ' SELECT p.transaction,\n    p.gid,\n    p.prepared,\n    u.rolname AS owner,\n    d.datname AS database\n   FROM ((pg_prepared_xact() p(transaction, gid, prepared, ownerid, dbid)\n     LEFT JOIN pg_authid u ON ((p.ownerid = u.oid)))\n     LEFT JOIN pg_database d ON ((p.dbid = d.oid)));'), ('pg_publication_tables', ' SELECT p.pubname,\n    n.nspname AS schemaname,\n    c.relname AS tablename,\n    ( SELECT array_agg(a.attname ORDER BY a.attnum) AS array_agg\n           FROM pg_attribute a\n          WHERE ((a.attrelid = gpt.relid) AND (a.attnum = ANY ((gpt.attrs)::smallint[])))) AS attnames,\n    pg_get_expr(gpt.qual, gpt.relid) AS rowfilter\n   FROM pg_publication p,\n    LATERAL pg_get_publication_tables(VARIADIC ARRAY[(p.pubname)::text]) gpt(pubid, relid, attrs, qual),\n    (pg_class c\n     JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.oid = gpt.relid);'), ('pg_replication_origin_status', ' SELECT local_id,\n    external_id,\n    remote_lsn,\n    local_lsn\n   FROM pg_show_replication_origin_status() pg_show_replication_origin_status(local_id, external_id, remote_lsn, local_lsn);'), ('pg_replication_slots', ' SELECT l.slot_name,\n    l.plugin,\n    l.slot_type,\n    l.datoid,\n    d.datname AS database,\n    l.temporary,\n    l.active,\n    l.active_pid,\n    l.xmin,\n    l.catalog_xmin,\n    l.restart_lsn,\n    l.confirmed_flush_lsn,\n    l.wal_status,\n    l.safe_wal_size,\n    l.two_phase,\n    l.conflicting,\n    l.invalidation_reason,\n    l.failover,\n    l.synced\n   FROM (pg_get_replication_slots() l(slot_name, plugin, slot_type, datoid, temporary, active, active_pid, xmin, catalog_xmin, restart_lsn, confirmed_flush_lsn, wal_status, safe_wal_size, two_phase, conflicting, invalidation_reason, failover, synced)\n     LEFT JOIN pg_database d ON ((l.datoid = d.oid)));'), ('pg_roles', " SELECT pg_authid.rolname,\n    pg_authid.rolsuper,\n    pg_authid.rolinherit,\n    pg_authid.rolcreaterole,\n    pg_authid.rolcreatedb,\n    pg_authid.rolcanlogin,\n    pg_authid.rolreplication,\n    pg_authid.rolconnlimit,\n    '********'::text AS rolpassword,\n    pg_authid.rolvaliduntil,\n    pg_authid.rolbypassrls,\n    s.setconfig AS rolconfig,\n    pg_authid.oid\n   FROM (pg_authid\n     LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))));"), ('pg_rules', " SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    r.rulename,\n    pg_get_ruledef(r.oid) AS definition\n   FROM ((pg_rewrite r\n     JOIN pg_class c ON ((c.oid = r.ev_class)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (r.rulename <> '_RETURN'::name);"), ('pg_seclabels', ' SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n        CASE\n            WHEN (rel.relkind = ANY (ARRAY[\'r\'::"char", \'p\'::"char"])) THEN \'table\'::text\n            WHEN (rel.relkind = \'v\'::"char") THEN \'view\'::text\n            WHEN (rel.relkind = \'m\'::"char") THEN \'materialized view\'::text\n            WHEN (rel.relkind = \'S\'::"char") THEN \'sequence\'::text\n            WHEN (rel.relkind = \'f\'::"char") THEN \'foreign table\'::text\n            ELSE NULL::text\n        END AS objtype,\n    rel.relnamespace AS objnamespace,\n        CASE\n            WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text)\n            ELSE ((quote_ident((nsp.nspname)::text) || \'.\'::text) || quote_ident((rel.relname)::text))\n        END AS objname,\n    l.provider,\n    l.label\n   FROM ((pg_seclabel l\n     JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))\n     JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'column\'::text AS objtype,\n    rel.relnamespace AS objnamespace,\n    ((\n        CASE\n            WHEN pg_table_is_visible(rel.oid) THEN quote_ident((rel.relname)::text)\n            ELSE ((quote_ident((nsp.nspname)::text) || \'.\'::text) || quote_ident((rel.relname)::text))\n        END || \'.\'::text) || (att.attname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (((pg_seclabel l\n     JOIN pg_class rel ON (((l.classoid = rel.tableoid) AND (l.objoid = rel.oid))))\n     JOIN pg_attribute att ON (((rel.oid = att.attrelid) AND (l.objsubid = att.attnum))))\n     JOIN pg_namespace nsp ON ((rel.relnamespace = nsp.oid)))\n  WHERE (l.objsubid <> 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n        CASE pro.prokind\n            WHEN \'a\'::"char" THEN \'aggregate\'::text\n            WHEN \'f\'::"char" THEN \'function\'::text\n            WHEN \'p\'::"char" THEN \'procedure\'::text\n            WHEN \'w\'::"char" THEN \'window\'::text\n            ELSE NULL::text\n        END AS objtype,\n    pro.pronamespace AS objnamespace,\n    (((\n        CASE\n            WHEN pg_function_is_visible(pro.oid) THEN quote_ident((pro.proname)::text)\n            ELSE ((quote_ident((nsp.nspname)::text) || \'.\'::text) || quote_ident((pro.proname)::text))\n        END || \'(\'::text) || pg_get_function_arguments(pro.oid)) || \')\'::text) AS objname,\n    l.provider,\n    l.label\n   FROM ((pg_seclabel l\n     JOIN pg_proc pro ON (((l.classoid = pro.tableoid) AND (l.objoid = pro.oid))))\n     JOIN pg_namespace nsp ON ((pro.pronamespace = nsp.oid)))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n        CASE\n            WHEN (typ.typtype = \'d\'::"char") THEN \'domain\'::text\n            ELSE \'type\'::text\n        END AS objtype,\n    typ.typnamespace AS objnamespace,\n        CASE\n            WHEN pg_type_is_visible(typ.oid) THEN quote_ident((typ.typname)::text)\n            ELSE ((quote_ident((nsp.nspname)::text) || \'.\'::text) || quote_ident((typ.typname)::text))\n        END AS objname,\n    l.provider,\n    l.label\n   FROM ((pg_seclabel l\n     JOIN pg_type typ ON (((l.classoid = typ.tableoid) AND (l.objoid = typ.oid))))\n     JOIN pg_namespace nsp ON ((typ.typnamespace = nsp.oid)))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'large object\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    (l.objoid)::text AS objname,\n    l.provider,\n    l.label\n   FROM (pg_seclabel l\n     JOIN pg_largeobject_metadata lom ON ((l.objoid = lom.oid)))\n  WHERE ((l.classoid = (\'pg_largeobject\'::regclass)::oid) AND (l.objsubid = 0))\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'language\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((lan.lanname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_seclabel l\n     JOIN pg_language lan ON (((l.classoid = lan.tableoid) AND (l.objoid = lan.oid))))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'schema\'::text AS objtype,\n    nsp.oid AS objnamespace,\n    quote_ident((nsp.nspname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_seclabel l\n     JOIN pg_namespace nsp ON (((l.classoid = nsp.tableoid) AND (l.objoid = nsp.oid))))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'event trigger\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((evt.evtname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_seclabel l\n     JOIN pg_event_trigger evt ON (((l.classoid = evt.tableoid) AND (l.objoid = evt.oid))))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    l.objsubid,\n    \'publication\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((p.pubname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_seclabel l\n     JOIN pg_publication p ON (((l.classoid = p.tableoid) AND (l.objoid = p.oid))))\n  WHERE (l.objsubid = 0)\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    \'subscription\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((s.subname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_shseclabel l\n     JOIN pg_subscription s ON (((l.classoid = s.tableoid) AND (l.objoid = s.oid))))\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    \'database\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((dat.datname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_shseclabel l\n     JOIN pg_database dat ON (((l.classoid = dat.tableoid) AND (l.objoid = dat.oid))))\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    \'tablespace\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((spc.spcname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_shseclabel l\n     JOIN pg_tablespace spc ON (((l.classoid = spc.tableoid) AND (l.objoid = spc.oid))))\nUNION ALL\n SELECT l.objoid,\n    l.classoid,\n    0 AS objsubid,\n    \'role\'::text AS objtype,\n    NULL::oid AS objnamespace,\n    quote_ident((rol.rolname)::text) AS objname,\n    l.provider,\n    l.label\n   FROM (pg_shseclabel l\n     JOIN pg_authid rol ON (((l.classoid = rol.tableoid) AND (l.objoid = rol.oid))));'), ('pg_sequences', ' SELECT n.nspname AS schemaname,\n    c.relname AS sequencename,\n    pg_get_userbyid(c.relowner) AS sequenceowner,\n    (s.seqtypid)::regtype AS data_type,\n    s.seqstart AS start_value,\n    s.seqmin AS min_value,\n    s.seqmax AS max_value,\n    s.seqincrement AS increment_by,\n    s.seqcycle AS cycle,\n    s.seqcache AS cache_size,\n        CASE\n            WHEN has_sequence_privilege(c.oid, \'SELECT,USAGE\'::text) THEN pg_sequence_last_value((c.oid)::regclass)\n            ELSE NULL::bigint\n        END AS last_value\n   FROM ((pg_sequence s\n     JOIN pg_class c ON ((c.oid = s.seqrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE ((NOT pg_is_other_temp_schema(n.oid)) AND (c.relkind = \'S\'::"char"));'), ('pg_settings', ' SELECT name,\n    setting,\n    unit,\n    category,\n    short_desc,\n    extra_desc,\n    context,\n    vartype,\n    source,\n    min_val,\n    max_val,\n    enumvals,\n    boot_val,\n    reset_val,\n    sourcefile,\n    sourceline,\n    pending_restart\n   FROM pg_show_all_settings() a(name, setting, unit, category, short_desc, extra_desc, context, vartype, source, min_val, max_val, enumvals, boot_val, reset_val, sourcefile, sourceline, pending_restart);'), ('pg_shadow', ' SELECT pg_authid.rolname AS usename,\n    pg_authid.oid AS usesysid,\n    pg_authid.rolcreatedb AS usecreatedb,\n    pg_authid.rolsuper AS usesuper,\n    pg_authid.rolreplication AS userepl,\n    pg_authid.rolbypassrls AS usebypassrls,\n    pg_authid.rolpassword AS passwd,\n    pg_authid.rolvaliduntil AS valuntil,\n    s.setconfig AS useconfig\n   FROM (pg_authid\n     LEFT JOIN pg_db_role_setting s ON (((pg_authid.oid = s.setrole) AND (s.setdatabase = (0)::oid))))\n  WHERE pg_authid.rolcanlogin;'), ('pg_shmem_allocations', ' SELECT name,\n    off,\n    size,\n    allocated_size\n   FROM pg_get_shmem_allocations() pg_get_shmem_allocations(name, off, size, allocated_size);'), ('pg_stat_activity', ' SELECT s.datid,\n    d.datname,\n    s.pid,\n    s.leader_pid,\n    s.usesysid,\n    u.rolname AS usename,\n    s.application_name,\n    s.client_addr,\n    s.client_hostname,\n    s.client_port,\n    s.backend_start,\n    s.xact_start,\n    s.query_start,\n    s.state_change,\n    s.wait_event_type,\n    s.wait_event,\n    s.state,\n    s.backend_xid,\n    s.backend_xmin,\n    s.query_id,\n    s.query,\n    s.backend_type\n   FROM ((pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, gss_delegation, leader_pid, query_id)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)))\n     LEFT JOIN pg_authid u ON ((s.usesysid = u.oid)));'), ('pg_stat_all_indexes', ' SELECT c.oid AS relid,\n    i.oid AS indexrelid,\n    n.nspname AS schemaname,\n    c.relname,\n    i.relname AS indexrelname,\n    pg_stat_get_numscans(i.oid) AS idx_scan,\n    pg_stat_get_lastscan(i.oid) AS last_idx_scan,\n    pg_stat_get_tuples_returned(i.oid) AS idx_tup_read,\n    pg_stat_get_tuples_fetched(i.oid) AS idx_tup_fetch\n   FROM (((pg_class c\n     JOIN pg_index x ON ((c.oid = x.indrelid)))\n     JOIN pg_class i ON ((i.oid = x.indexrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'t\'::"char", \'m\'::"char"]));'), ('pg_stat_all_tables', ' SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    pg_stat_get_numscans(c.oid) AS seq_scan,\n    pg_stat_get_lastscan(c.oid) AS last_seq_scan,\n    pg_stat_get_tuples_returned(c.oid) AS seq_tup_read,\n    (sum(pg_stat_get_numscans(i.indexrelid)))::bigint AS idx_scan,\n    max(pg_stat_get_lastscan(i.indexrelid)) AS last_idx_scan,\n    ((sum(pg_stat_get_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_tuples_fetched(c.oid)) AS idx_tup_fetch,\n    pg_stat_get_tuples_inserted(c.oid) AS n_tup_ins,\n    pg_stat_get_tuples_updated(c.oid) AS n_tup_upd,\n    pg_stat_get_tuples_deleted(c.oid) AS n_tup_del,\n    pg_stat_get_tuples_hot_updated(c.oid) AS n_tup_hot_upd,\n    pg_stat_get_tuples_newpage_updated(c.oid) AS n_tup_newpage_upd,\n    pg_stat_get_live_tuples(c.oid) AS n_live_tup,\n    pg_stat_get_dead_tuples(c.oid) AS n_dead_tup,\n    pg_stat_get_mod_since_analyze(c.oid) AS n_mod_since_analyze,\n    pg_stat_get_ins_since_vacuum(c.oid) AS n_ins_since_vacuum,\n    pg_stat_get_last_vacuum_time(c.oid) AS last_vacuum,\n    pg_stat_get_last_autovacuum_time(c.oid) AS last_autovacuum,\n    pg_stat_get_last_analyze_time(c.oid) AS last_analyze,\n    pg_stat_get_last_autoanalyze_time(c.oid) AS last_autoanalyze,\n    pg_stat_get_vacuum_count(c.oid) AS vacuum_count,\n    pg_stat_get_autovacuum_count(c.oid) AS autovacuum_count,\n    pg_stat_get_analyze_count(c.oid) AS analyze_count,\n    pg_stat_get_autoanalyze_count(c.oid) AS autoanalyze_count\n   FROM ((pg_class c\n     LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'t\'::"char", \'m\'::"char", \'p\'::"char"]))\n  GROUP BY c.oid, n.nspname, c.relname;'), ('pg_stat_archiver', ' SELECT archived_count,\n    last_archived_wal,\n    last_archived_time,\n    failed_count,\n    last_failed_wal,\n    last_failed_time,\n    stats_reset\n   FROM pg_stat_get_archiver() s(archived_count, last_archived_wal, last_archived_time, failed_count, last_failed_wal, last_failed_time, stats_reset);'), ('pg_stat_bgwriter', ' SELECT pg_stat_get_bgwriter_buf_written_clean() AS buffers_clean,\n    pg_stat_get_bgwriter_maxwritten_clean() AS maxwritten_clean,\n    pg_stat_get_buf_alloc() AS buffers_alloc,\n    pg_stat_get_bgwriter_stat_reset_time() AS stats_reset;'), ('pg_stat_checkpointer', ' SELECT pg_stat_get_checkpointer_num_timed() AS num_timed,\n    pg_stat_get_checkpointer_num_requested() AS num_requested,\n    pg_stat_get_checkpointer_restartpoints_timed() AS restartpoints_timed,\n    pg_stat_get_checkpointer_restartpoints_requested() AS restartpoints_req,\n    pg_stat_get_checkpointer_restartpoints_performed() AS restartpoints_done,\n    pg_stat_get_checkpointer_write_time() AS write_time,\n    pg_stat_get_checkpointer_sync_time() AS sync_time,\n    pg_stat_get_checkpointer_buffers_written() AS buffers_written,\n    pg_stat_get_checkpointer_stat_reset_time() AS stats_reset;'), ('pg_stat_database', ' SELECT oid AS datid,\n    datname,\n        CASE\n            WHEN (oid = (0)::oid) THEN 0\n            ELSE pg_stat_get_db_numbackends(oid)\n        END AS numbackends,\n    pg_stat_get_db_xact_commit(oid) AS xact_commit,\n    pg_stat_get_db_xact_rollback(oid) AS xact_rollback,\n    (pg_stat_get_db_blocks_fetched(oid) - pg_stat_get_db_blocks_hit(oid)) AS blks_read,\n    pg_stat_get_db_blocks_hit(oid) AS blks_hit,\n    pg_stat_get_db_tuples_returned(oid) AS tup_returned,\n    pg_stat_get_db_tuples_fetched(oid) AS tup_fetched,\n    pg_stat_get_db_tuples_inserted(oid) AS tup_inserted,\n    pg_stat_get_db_tuples_updated(oid) AS tup_updated,\n    pg_stat_get_db_tuples_deleted(oid) AS tup_deleted,\n    pg_stat_get_db_conflict_all(oid) AS conflicts,\n    pg_stat_get_db_temp_files(oid) AS temp_files,\n    pg_stat_get_db_temp_bytes(oid) AS temp_bytes,\n    pg_stat_get_db_deadlocks(oid) AS deadlocks,\n    pg_stat_get_db_checksum_failures(oid) AS checksum_failures,\n    pg_stat_get_db_checksum_last_failure(oid) AS checksum_last_failure,\n    pg_stat_get_db_blk_read_time(oid) AS blk_read_time,\n    pg_stat_get_db_blk_write_time(oid) AS blk_write_time,\n    pg_stat_get_db_session_time(oid) AS session_time,\n    pg_stat_get_db_active_time(oid) AS active_time,\n    pg_stat_get_db_idle_in_transaction_time(oid) AS idle_in_transaction_time,\n    pg_stat_get_db_sessions(oid) AS sessions,\n    pg_stat_get_db_sessions_abandoned(oid) AS sessions_abandoned,\n    pg_stat_get_db_sessions_fatal(oid) AS sessions_fatal,\n    pg_stat_get_db_sessions_killed(oid) AS sessions_killed,\n    pg_stat_get_db_stat_reset_time(oid) AS stats_reset\n   FROM ( SELECT 0 AS oid,\n            NULL::name AS datname\n        UNION ALL\n         SELECT pg_database.oid,\n            pg_database.datname\n           FROM pg_database) d;'), ('pg_stat_database_conflicts', ' SELECT oid AS datid,\n    datname,\n    pg_stat_get_db_conflict_tablespace(oid) AS confl_tablespace,\n    pg_stat_get_db_conflict_lock(oid) AS confl_lock,\n    pg_stat_get_db_conflict_snapshot(oid) AS confl_snapshot,\n    pg_stat_get_db_conflict_bufferpin(oid) AS confl_bufferpin,\n    pg_stat_get_db_conflict_startup_deadlock(oid) AS confl_deadlock,\n    pg_stat_get_db_conflict_logicalslot(oid) AS confl_active_logicalslot\n   FROM pg_database d;'), ('pg_stat_gssapi', ' SELECT pid,\n    gss_auth AS gss_authenticated,\n    gss_princ AS principal,\n    gss_enc AS encrypted,\n    gss_delegation AS credentials_delegated\n   FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, gss_delegation, leader_pid, query_id)\n  WHERE (client_port IS NOT NULL);'), ('pg_stat_io', ' SELECT backend_type,\n    object,\n    context,\n    reads,\n    read_time,\n    writes,\n    write_time,\n    writebacks,\n    writeback_time,\n    extends,\n    extend_time,\n    op_bytes,\n    hits,\n    evictions,\n    reuses,\n    fsyncs,\n    fsync_time,\n    stats_reset\n   FROM pg_stat_get_io() b(backend_type, object, context, reads, read_time, writes, write_time, writebacks, writeback_time, extends, extend_time, op_bytes, hits, evictions, reuses, fsyncs, fsync_time, stats_reset);'), ('pg_stat_progress_analyze', " SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param1\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'acquiring sample rows'::text\n            WHEN 2 THEN 'acquiring inherited sample rows'::text\n            WHEN 3 THEN 'computing statistics'::text\n            WHEN 4 THEN 'computing extended statistics'::text\n            WHEN 5 THEN 'finalizing analyze'::text\n            ELSE NULL::text\n        END AS phase,\n    s.param2 AS sample_blks_total,\n    s.param3 AS sample_blks_scanned,\n    s.param4 AS ext_stats_total,\n    s.param5 AS ext_stats_computed,\n    s.param6 AS child_tables_total,\n    s.param7 AS child_tables_done,\n    (s.param8)::oid AS current_child_table_relid\n   FROM (pg_stat_get_progress_info('ANALYZE'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)));"), ('pg_stat_progress_basebackup', " SELECT pid,\n        CASE param1\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'waiting for checkpoint to finish'::text\n            WHEN 2 THEN 'estimating backup size'::text\n            WHEN 3 THEN 'streaming database files'::text\n            WHEN 4 THEN 'waiting for wal archiving to finish'::text\n            WHEN 5 THEN 'transferring wal files'::text\n            ELSE NULL::text\n        END AS phase,\n        CASE param2\n            WHEN '-1'::integer THEN NULL::bigint\n            ELSE param2\n        END AS backup_total,\n    param3 AS backup_streamed,\n    param4 AS tablespaces_total,\n    param5 AS tablespaces_streamed\n   FROM pg_stat_get_progress_info('BASEBACKUP'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20);"), ('pg_stat_progress_cluster', " SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param1\n            WHEN 1 THEN 'CLUSTER'::text\n            WHEN 2 THEN 'VACUUM FULL'::text\n            ELSE NULL::text\n        END AS command,\n        CASE s.param2\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'seq scanning heap'::text\n            WHEN 2 THEN 'index scanning heap'::text\n            WHEN 3 THEN 'sorting tuples'::text\n            WHEN 4 THEN 'writing new heap'::text\n            WHEN 5 THEN 'swapping relation files'::text\n            WHEN 6 THEN 'rebuilding index'::text\n            WHEN 7 THEN 'performing final cleanup'::text\n            ELSE NULL::text\n        END AS phase,\n    (s.param3)::oid AS cluster_index_relid,\n    s.param4 AS heap_tuples_scanned,\n    s.param5 AS heap_tuples_written,\n    s.param6 AS heap_blks_total,\n    s.param7 AS heap_blks_scanned,\n    s.param8 AS index_rebuild_count\n   FROM (pg_stat_get_progress_info('CLUSTER'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)));"), ('pg_stat_progress_copy', " SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param5\n            WHEN 1 THEN 'COPY FROM'::text\n            WHEN 2 THEN 'COPY TO'::text\n            ELSE NULL::text\n        END AS command,\n        CASE s.param6\n            WHEN 1 THEN 'FILE'::text\n            WHEN 2 THEN 'PROGRAM'::text\n            WHEN 3 THEN 'PIPE'::text\n            WHEN 4 THEN 'CALLBACK'::text\n            ELSE NULL::text\n        END AS type,\n    s.param1 AS bytes_processed,\n    s.param2 AS bytes_total,\n    s.param3 AS tuples_processed,\n    s.param4 AS tuples_excluded,\n    s.param7 AS tuples_skipped\n   FROM (pg_stat_get_progress_info('COPY'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)));"), ('pg_stat_progress_create_index', " SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n    (s.param7)::oid AS index_relid,\n        CASE s.param1\n            WHEN 1 THEN 'CREATE INDEX'::text\n            WHEN 2 THEN 'CREATE INDEX CONCURRENTLY'::text\n            WHEN 3 THEN 'REINDEX'::text\n            WHEN 4 THEN 'REINDEX CONCURRENTLY'::text\n            ELSE NULL::text\n        END AS command,\n        CASE s.param10\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'waiting for writers before build'::text\n            WHEN 2 THEN ('building index'::text || COALESCE((': '::text || pg_indexam_progress_phasename((s.param9)::oid, s.param11)), ''::text))\n            WHEN 3 THEN 'waiting for writers before validation'::text\n            WHEN 4 THEN 'index validation: scanning index'::text\n            WHEN 5 THEN 'index validation: sorting tuples'::text\n            WHEN 6 THEN 'index validation: scanning table'::text\n            WHEN 7 THEN 'waiting for old snapshots'::text\n            WHEN 8 THEN 'waiting for readers before marking dead'::text\n            WHEN 9 THEN 'waiting for readers before dropping'::text\n            ELSE NULL::text\n        END AS phase,\n    s.param4 AS lockers_total,\n    s.param5 AS lockers_done,\n    s.param6 AS current_locker_pid,\n    s.param16 AS blocks_total,\n    s.param17 AS blocks_done,\n    s.param12 AS tuples_total,\n    s.param13 AS tuples_done,\n    s.param14 AS partitions_total,\n    s.param15 AS partitions_done\n   FROM (pg_stat_get_progress_info('CREATE INDEX'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)));"), ('pg_stat_progress_vacuum', " SELECT s.pid,\n    s.datid,\n    d.datname,\n    s.relid,\n        CASE s.param1\n            WHEN 0 THEN 'initializing'::text\n            WHEN 1 THEN 'scanning heap'::text\n            WHEN 2 THEN 'vacuuming indexes'::text\n            WHEN 3 THEN 'vacuuming heap'::text\n            WHEN 4 THEN 'cleaning up indexes'::text\n            WHEN 5 THEN 'truncating heap'::text\n            WHEN 6 THEN 'performing final cleanup'::text\n            ELSE NULL::text\n        END AS phase,\n    s.param2 AS heap_blks_total,\n    s.param3 AS heap_blks_scanned,\n    s.param4 AS heap_blks_vacuumed,\n    s.param5 AS index_vacuum_count,\n    s.param6 AS max_dead_tuples,\n    s.param7 AS num_dead_tuples,\n    s.param8 AS indexes_total,\n    s.param9 AS indexes_processed\n   FROM (pg_stat_get_progress_info('VACUUM'::text) s(pid, datid, relid, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10, param11, param12, param13, param14, param15, param16, param17, param18, param19, param20)\n     LEFT JOIN pg_database d ON ((s.datid = d.oid)));"), ('pg_stat_recovery_prefetch', ' SELECT stats_reset,\n    prefetch,\n    hit,\n    skip_init,\n    skip_new,\n    skip_fpw,\n    skip_rep,\n    wal_distance,\n    block_distance,\n    io_depth\n   FROM pg_stat_get_recovery_prefetch() s(stats_reset, prefetch, hit, skip_init, skip_new, skip_fpw, skip_rep, wal_distance, block_distance, io_depth);'), ('pg_stat_replication', ' SELECT s.pid,\n    s.usesysid,\n    u.rolname AS usename,\n    s.application_name,\n    s.client_addr,\n    s.client_hostname,\n    s.client_port,\n    s.backend_start,\n    s.backend_xmin,\n    w.state,\n    w.sent_lsn,\n    w.write_lsn,\n    w.flush_lsn,\n    w.replay_lsn,\n    w.write_lag,\n    w.flush_lag,\n    w.replay_lag,\n    w.sync_priority,\n    w.sync_state,\n    w.reply_time\n   FROM ((pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, gss_delegation, leader_pid, query_id)\n     JOIN pg_stat_get_wal_senders() w(pid, state, sent_lsn, write_lsn, flush_lsn, replay_lsn, write_lag, flush_lag, replay_lag, sync_priority, sync_state, reply_time) ON ((s.pid = w.pid)))\n     LEFT JOIN pg_authid u ON ((s.usesysid = u.oid)));'), ('pg_stat_replication_slots', ' SELECT s.slot_name,\n    s.spill_txns,\n    s.spill_count,\n    s.spill_bytes,\n    s.stream_txns,\n    s.stream_count,\n    s.stream_bytes,\n    s.total_txns,\n    s.total_bytes,\n    s.stats_reset\n   FROM pg_replication_slots r,\n    LATERAL pg_stat_get_replication_slot((r.slot_name)::text) s(slot_name, spill_txns, spill_count, spill_bytes, stream_txns, stream_count, stream_bytes, total_txns, total_bytes, stats_reset)\n  WHERE (r.datoid IS NOT NULL);'), ('pg_stat_slru', ' SELECT name,\n    blks_zeroed,\n    blks_hit,\n    blks_read,\n    blks_written,\n    blks_exists,\n    flushes,\n    truncates,\n    stats_reset\n   FROM pg_stat_get_slru() s(name, blks_zeroed, blks_hit, blks_read, blks_written, blks_exists, flushes, truncates, stats_reset);'), ('pg_stat_ssl', ' SELECT pid,\n    ssl,\n    sslversion AS version,\n    sslcipher AS cipher,\n    sslbits AS bits,\n    ssl_client_dn AS client_dn,\n    ssl_client_serial AS client_serial,\n    ssl_issuer_dn AS issuer_dn\n   FROM pg_stat_get_activity(NULL::integer) s(datid, pid, usesysid, application_name, state, query, wait_event_type, wait_event, xact_start, query_start, backend_start, state_change, client_addr, client_hostname, client_port, backend_xid, backend_xmin, backend_type, ssl, sslversion, sslcipher, sslbits, ssl_client_dn, ssl_client_serial, ssl_issuer_dn, gss_auth, gss_princ, gss_enc, gss_delegation, leader_pid, query_id)\n  WHERE (client_port IS NOT NULL);'), ('pg_stat_subscription', ' SELECT su.oid AS subid,\n    su.subname,\n    st.worker_type,\n    st.pid,\n    st.leader_pid,\n    st.relid,\n    st.received_lsn,\n    st.last_msg_send_time,\n    st.last_msg_receipt_time,\n    st.latest_end_lsn,\n    st.latest_end_time\n   FROM (pg_subscription su\n     LEFT JOIN pg_stat_get_subscription(NULL::oid) st(subid, relid, pid, leader_pid, received_lsn, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, worker_type) ON ((st.subid = su.oid)));'), ('pg_stat_subscription_stats', ' SELECT ss.subid,\n    s.subname,\n    ss.apply_error_count,\n    ss.sync_error_count,\n    ss.stats_reset\n   FROM pg_subscription s,\n    LATERAL pg_stat_get_subscription_stats(s.oid) ss(subid, apply_error_count, sync_error_count, stats_reset);'), ('pg_stat_sys_indexes', " SELECT relid,\n    indexrelid,\n    schemaname,\n    relname,\n    indexrelname,\n    idx_scan,\n    last_idx_scan,\n    idx_tup_read,\n    idx_tup_fetch\n   FROM pg_stat_all_indexes\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_stat_sys_tables', " SELECT relid,\n    schemaname,\n    relname,\n    seq_scan,\n    last_seq_scan,\n    seq_tup_read,\n    idx_scan,\n    last_idx_scan,\n    idx_tup_fetch,\n    n_tup_ins,\n    n_tup_upd,\n    n_tup_del,\n    n_tup_hot_upd,\n    n_tup_newpage_upd,\n    n_live_tup,\n    n_dead_tup,\n    n_mod_since_analyze,\n    n_ins_since_vacuum,\n    last_vacuum,\n    last_autovacuum,\n    last_analyze,\n    last_autoanalyze,\n    vacuum_count,\n    autovacuum_count,\n    analyze_count,\n    autoanalyze_count\n   FROM pg_stat_all_tables\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_stat_user_functions', ' SELECT p.oid AS funcid,\n    n.nspname AS schemaname,\n    p.proname AS funcname,\n    pg_stat_get_function_calls(p.oid) AS calls,\n    pg_stat_get_function_total_time(p.oid) AS total_time,\n    pg_stat_get_function_self_time(p.oid) AS self_time\n   FROM (pg_proc p\n     LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))\n  WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_function_calls(p.oid) IS NOT NULL));'), ('pg_stat_user_indexes', " SELECT relid,\n    indexrelid,\n    schemaname,\n    relname,\n    indexrelname,\n    idx_scan,\n    last_idx_scan,\n    idx_tup_read,\n    idx_tup_fetch\n   FROM pg_stat_all_indexes\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_stat_user_tables', " SELECT relid,\n    schemaname,\n    relname,\n    seq_scan,\n    last_seq_scan,\n    seq_tup_read,\n    idx_scan,\n    last_idx_scan,\n    idx_tup_fetch,\n    n_tup_ins,\n    n_tup_upd,\n    n_tup_del,\n    n_tup_hot_upd,\n    n_tup_newpage_upd,\n    n_live_tup,\n    n_dead_tup,\n    n_mod_since_analyze,\n    n_ins_since_vacuum,\n    last_vacuum,\n    last_autovacuum,\n    last_analyze,\n    last_autoanalyze,\n    vacuum_count,\n    autovacuum_count,\n    analyze_count,\n    autoanalyze_count\n   FROM pg_stat_all_tables\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_stat_wal', ' SELECT wal_records,\n    wal_fpi,\n    wal_bytes,\n    wal_buffers_full,\n    wal_write,\n    wal_sync,\n    wal_write_time,\n    wal_sync_time,\n    stats_reset\n   FROM pg_stat_get_wal() w(wal_records, wal_fpi, wal_bytes, wal_buffers_full, wal_write, wal_sync, wal_write_time, wal_sync_time, stats_reset);'), ('pg_stat_wal_receiver', ' SELECT pid,\n    status,\n    receive_start_lsn,\n    receive_start_tli,\n    written_lsn,\n    flushed_lsn,\n    received_tli,\n    last_msg_send_time,\n    last_msg_receipt_time,\n    latest_end_lsn,\n    latest_end_time,\n    slot_name,\n    sender_host,\n    sender_port,\n    conninfo\n   FROM pg_stat_get_wal_receiver() s(pid, status, receive_start_lsn, receive_start_tli, written_lsn, flushed_lsn, received_tli, last_msg_send_time, last_msg_receipt_time, latest_end_lsn, latest_end_time, slot_name, sender_host, sender_port, conninfo)\n  WHERE (pid IS NOT NULL);'), ('pg_stat_xact_all_tables', ' SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    pg_stat_get_xact_numscans(c.oid) AS seq_scan,\n    pg_stat_get_xact_tuples_returned(c.oid) AS seq_tup_read,\n    (sum(pg_stat_get_xact_numscans(i.indexrelid)))::bigint AS idx_scan,\n    ((sum(pg_stat_get_xact_tuples_fetched(i.indexrelid)))::bigint + pg_stat_get_xact_tuples_fetched(c.oid)) AS idx_tup_fetch,\n    pg_stat_get_xact_tuples_inserted(c.oid) AS n_tup_ins,\n    pg_stat_get_xact_tuples_updated(c.oid) AS n_tup_upd,\n    pg_stat_get_xact_tuples_deleted(c.oid) AS n_tup_del,\n    pg_stat_get_xact_tuples_hot_updated(c.oid) AS n_tup_hot_upd,\n    pg_stat_get_xact_tuples_newpage_updated(c.oid) AS n_tup_newpage_upd\n   FROM ((pg_class c\n     LEFT JOIN pg_index i ON ((c.oid = i.indrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'t\'::"char", \'m\'::"char", \'p\'::"char"]))\n  GROUP BY c.oid, n.nspname, c.relname;'), ('pg_stat_xact_sys_tables', " SELECT relid,\n    schemaname,\n    relname,\n    seq_scan,\n    seq_tup_read,\n    idx_scan,\n    idx_tup_fetch,\n    n_tup_ins,\n    n_tup_upd,\n    n_tup_del,\n    n_tup_hot_upd,\n    n_tup_newpage_upd\n   FROM pg_stat_xact_all_tables\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_stat_xact_user_functions', ' SELECT p.oid AS funcid,\n    n.nspname AS schemaname,\n    p.proname AS funcname,\n    pg_stat_get_xact_function_calls(p.oid) AS calls,\n    pg_stat_get_xact_function_total_time(p.oid) AS total_time,\n    pg_stat_get_xact_function_self_time(p.oid) AS self_time\n   FROM (pg_proc p\n     LEFT JOIN pg_namespace n ON ((n.oid = p.pronamespace)))\n  WHERE ((p.prolang <> (12)::oid) AND (pg_stat_get_xact_function_calls(p.oid) IS NOT NULL));'), ('pg_stat_xact_user_tables', " SELECT relid,\n    schemaname,\n    relname,\n    seq_scan,\n    seq_tup_read,\n    idx_scan,\n    idx_tup_fetch,\n    n_tup_ins,\n    n_tup_upd,\n    n_tup_del,\n    n_tup_hot_upd,\n    n_tup_newpage_upd\n   FROM pg_stat_xact_all_tables\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_statio_all_indexes', ' SELECT c.oid AS relid,\n    i.oid AS indexrelid,\n    n.nspname AS schemaname,\n    c.relname,\n    i.relname AS indexrelname,\n    (pg_stat_get_blocks_fetched(i.oid) - pg_stat_get_blocks_hit(i.oid)) AS idx_blks_read,\n    pg_stat_get_blocks_hit(i.oid) AS idx_blks_hit\n   FROM (((pg_class c\n     JOIN pg_index x ON ((c.oid = x.indrelid)))\n     JOIN pg_class i ON ((i.oid = x.indexrelid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'t\'::"char", \'m\'::"char"]));'), ('pg_statio_all_sequences', ' SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS blks_read,\n    pg_stat_get_blocks_hit(c.oid) AS blks_hit\n   FROM (pg_class c\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = \'S\'::"char");'), ('pg_statio_all_tables', ' SELECT c.oid AS relid,\n    n.nspname AS schemaname,\n    c.relname,\n    (pg_stat_get_blocks_fetched(c.oid) - pg_stat_get_blocks_hit(c.oid)) AS heap_blks_read,\n    pg_stat_get_blocks_hit(c.oid) AS heap_blks_hit,\n    i.idx_blks_read,\n    i.idx_blks_hit,\n    (pg_stat_get_blocks_fetched(t.oid) - pg_stat_get_blocks_hit(t.oid)) AS toast_blks_read,\n    pg_stat_get_blocks_hit(t.oid) AS toast_blks_hit,\n    x.idx_blks_read AS tidx_blks_read,\n    x.idx_blks_hit AS tidx_blks_hit\n   FROM ((((pg_class c\n     LEFT JOIN pg_class t ON ((c.reltoastrelid = t.oid)))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n     LEFT JOIN LATERAL ( SELECT (sum((pg_stat_get_blocks_fetched(pg_index.indexrelid) - pg_stat_get_blocks_hit(pg_index.indexrelid))))::bigint AS idx_blks_read,\n            (sum(pg_stat_get_blocks_hit(pg_index.indexrelid)))::bigint AS idx_blks_hit\n           FROM pg_index\n          WHERE (pg_index.indrelid = c.oid)) i ON (true))\n     LEFT JOIN LATERAL ( SELECT (sum((pg_stat_get_blocks_fetched(pg_index.indexrelid) - pg_stat_get_blocks_hit(pg_index.indexrelid))))::bigint AS idx_blks_read,\n            (sum(pg_stat_get_blocks_hit(pg_index.indexrelid)))::bigint AS idx_blks_hit\n           FROM pg_index\n          WHERE (pg_index.indrelid = t.oid)) x ON (true))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'t\'::"char", \'m\'::"char"]));'), ('pg_statio_sys_indexes', " SELECT relid,\n    indexrelid,\n    schemaname,\n    relname,\n    indexrelname,\n    idx_blks_read,\n    idx_blks_hit\n   FROM pg_statio_all_indexes\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_statio_sys_sequences', " SELECT relid,\n    schemaname,\n    relname,\n    blks_read,\n    blks_hit\n   FROM pg_statio_all_sequences\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_statio_sys_tables', " SELECT relid,\n    schemaname,\n    relname,\n    heap_blks_read,\n    heap_blks_hit,\n    idx_blks_read,\n    idx_blks_hit,\n    toast_blks_read,\n    toast_blks_hit,\n    tidx_blks_read,\n    tidx_blks_hit\n   FROM pg_statio_all_tables\n  WHERE ((schemaname = ANY (ARRAY['pg_catalog'::name, 'information_schema'::name])) OR (schemaname ~ '^pg_toast'::text));"), ('pg_statio_user_indexes', " SELECT relid,\n    indexrelid,\n    schemaname,\n    relname,\n    indexrelname,\n    idx_blks_read,\n    idx_blks_hit\n   FROM pg_statio_all_indexes\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_statio_user_sequences', " SELECT relid,\n    schemaname,\n    relname,\n    blks_read,\n    blks_hit\n   FROM pg_statio_all_sequences\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_statio_user_tables', " SELECT relid,\n    schemaname,\n    relname,\n    heap_blks_read,\n    heap_blks_hit,\n    idx_blks_read,\n    idx_blks_hit,\n    toast_blks_read,\n    toast_blks_hit,\n    tidx_blks_read,\n    tidx_blks_hit\n   FROM pg_statio_all_tables\n  WHERE ((schemaname <> ALL (ARRAY['pg_catalog'::name, 'information_schema'::name])) AND (schemaname !~ '^pg_toast'::text));"), ('pg_stats', " SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    a.attname,\n    s.stainherit AS inherited,\n    s.stanullfrac AS null_frac,\n    s.stawidth AS avg_width,\n    s.stadistinct AS n_distinct,\n        CASE\n            WHEN (s.stakind1 = 1) THEN s.stavalues1\n            WHEN (s.stakind2 = 1) THEN s.stavalues2\n            WHEN (s.stakind3 = 1) THEN s.stavalues3\n            WHEN (s.stakind4 = 1) THEN s.stavalues4\n            WHEN (s.stakind5 = 1) THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_vals,\n        CASE\n            WHEN (s.stakind1 = 1) THEN s.stanumbers1\n            WHEN (s.stakind2 = 1) THEN s.stanumbers2\n            WHEN (s.stakind3 = 1) THEN s.stanumbers3\n            WHEN (s.stakind4 = 1) THEN s.stanumbers4\n            WHEN (s.stakind5 = 1) THEN s.stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_freqs,\n        CASE\n            WHEN (s.stakind1 = 2) THEN s.stavalues1\n            WHEN (s.stakind2 = 2) THEN s.stavalues2\n            WHEN (s.stakind3 = 2) THEN s.stavalues3\n            WHEN (s.stakind4 = 2) THEN s.stavalues4\n            WHEN (s.stakind5 = 2) THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS histogram_bounds,\n        CASE\n            WHEN (s.stakind1 = 3) THEN s.stanumbers1[1]\n            WHEN (s.stakind2 = 3) THEN s.stanumbers2[1]\n            WHEN (s.stakind3 = 3) THEN s.stanumbers3[1]\n            WHEN (s.stakind4 = 3) THEN s.stanumbers4[1]\n            WHEN (s.stakind5 = 3) THEN s.stanumbers5[1]\n            ELSE NULL::real\n        END AS correlation,\n        CASE\n            WHEN (s.stakind1 = 4) THEN s.stavalues1\n            WHEN (s.stakind2 = 4) THEN s.stavalues2\n            WHEN (s.stakind3 = 4) THEN s.stavalues3\n            WHEN (s.stakind4 = 4) THEN s.stavalues4\n            WHEN (s.stakind5 = 4) THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_elems,\n        CASE\n            WHEN (s.stakind1 = 4) THEN s.stanumbers1\n            WHEN (s.stakind2 = 4) THEN s.stanumbers2\n            WHEN (s.stakind3 = 4) THEN s.stanumbers3\n            WHEN (s.stakind4 = 4) THEN s.stanumbers4\n            WHEN (s.stakind5 = 4) THEN s.stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_elem_freqs,\n        CASE\n            WHEN (s.stakind1 = 5) THEN s.stanumbers1\n            WHEN (s.stakind2 = 5) THEN s.stanumbers2\n            WHEN (s.stakind3 = 5) THEN s.stanumbers3\n            WHEN (s.stakind4 = 5) THEN s.stanumbers4\n            WHEN (s.stakind5 = 5) THEN s.stanumbers5\n            ELSE NULL::real[]\n        END AS elem_count_histogram,\n        CASE\n            WHEN (s.stakind1 = 6) THEN s.stavalues1\n            WHEN (s.stakind2 = 6) THEN s.stavalues2\n            WHEN (s.stakind3 = 6) THEN s.stavalues3\n            WHEN (s.stakind4 = 6) THEN s.stavalues4\n            WHEN (s.stakind5 = 6) THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS range_length_histogram,\n        CASE\n            WHEN (s.stakind1 = 6) THEN s.stanumbers1[1]\n            WHEN (s.stakind2 = 6) THEN s.stanumbers2[1]\n            WHEN (s.stakind3 = 6) THEN s.stanumbers3[1]\n            WHEN (s.stakind4 = 6) THEN s.stanumbers4[1]\n            WHEN (s.stakind5 = 6) THEN s.stanumbers5[1]\n            ELSE NULL::real\n        END AS range_empty_frac,\n        CASE\n            WHEN (s.stakind1 = 7) THEN s.stavalues1\n            WHEN (s.stakind2 = 7) THEN s.stavalues2\n            WHEN (s.stakind3 = 7) THEN s.stavalues3\n            WHEN (s.stakind4 = 7) THEN s.stavalues4\n            WHEN (s.stakind5 = 7) THEN s.stavalues5\n            ELSE NULL::anyarray\n        END AS range_bounds_histogram\n   FROM (((pg_statistic s\n     JOIN pg_class c ON ((c.oid = s.starelid)))\n     JOIN pg_attribute a ON (((c.oid = a.attrelid) AND (a.attnum = s.staattnum))))\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE ((NOT a.attisdropped) AND has_column_privilege(c.oid, a.attnum, 'select'::text) AND ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));"), ('pg_stats_ext', ' SELECT cn.nspname AS schemaname,\n    c.relname AS tablename,\n    sn.nspname AS statistics_schemaname,\n    s.stxname AS statistics_name,\n    pg_get_userbyid(s.stxowner) AS statistics_owner,\n    ( SELECT array_agg(a.attname ORDER BY a.attnum) AS array_agg\n           FROM (unnest(s.stxkeys) k(k)\n             JOIN pg_attribute a ON (((a.attrelid = s.stxrelid) AND (a.attnum = k.k))))) AS attnames,\n    pg_get_statisticsobjdef_expressions(s.oid) AS exprs,\n    s.stxkind AS kinds,\n    sd.stxdinherit AS inherited,\n    sd.stxdndistinct AS n_distinct,\n    sd.stxddependencies AS dependencies,\n    m.most_common_vals,\n    m.most_common_val_nulls,\n    m.most_common_freqs,\n    m.most_common_base_freqs\n   FROM (((((pg_statistic_ext s\n     JOIN pg_class c ON ((c.oid = s.stxrelid)))\n     JOIN pg_statistic_ext_data sd ON ((s.oid = sd.stxoid)))\n     LEFT JOIN pg_namespace cn ON ((cn.oid = c.relnamespace)))\n     LEFT JOIN pg_namespace sn ON ((sn.oid = s.stxnamespace)))\n     LEFT JOIN LATERAL ( SELECT array_agg(pg_mcv_list_items."values") AS most_common_vals,\n            array_agg(pg_mcv_list_items.nulls) AS most_common_val_nulls,\n            array_agg(pg_mcv_list_items.frequency) AS most_common_freqs,\n            array_agg(pg_mcv_list_items.base_frequency) AS most_common_base_freqs\n           FROM pg_mcv_list_items(sd.stxdmcv) pg_mcv_list_items(index, "values", nulls, frequency, base_frequency)) m ON ((sd.stxdmcv IS NOT NULL)))\n  WHERE ((NOT (EXISTS ( SELECT 1\n           FROM (unnest(s.stxkeys) k(k)\n             JOIN pg_attribute a ON (((a.attrelid = s.stxrelid) AND (a.attnum = k.k))))\n          WHERE (NOT has_column_privilege(c.oid, a.attnum, \'select\'::text))))) AND ((c.relrowsecurity = false) OR (NOT row_security_active(c.oid))));'), ('pg_stats_ext_exprs', ' SELECT cn.nspname AS schemaname,\n    c.relname AS tablename,\n    sn.nspname AS statistics_schemaname,\n    s.stxname AS statistics_name,\n    pg_get_userbyid(s.stxowner) AS statistics_owner,\n    stat.expr,\n    sd.stxdinherit AS inherited,\n    (stat.a).stanullfrac AS null_frac,\n    (stat.a).stawidth AS avg_width,\n    (stat.a).stadistinct AS n_distinct,\n        CASE\n            WHEN ((stat.a).stakind1 = 1) THEN (stat.a).stavalues1\n            WHEN ((stat.a).stakind2 = 1) THEN (stat.a).stavalues2\n            WHEN ((stat.a).stakind3 = 1) THEN (stat.a).stavalues3\n            WHEN ((stat.a).stakind4 = 1) THEN (stat.a).stavalues4\n            WHEN ((stat.a).stakind5 = 1) THEN (stat.a).stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_vals,\n        CASE\n            WHEN ((stat.a).stakind1 = 1) THEN (stat.a).stanumbers1\n            WHEN ((stat.a).stakind2 = 1) THEN (stat.a).stanumbers2\n            WHEN ((stat.a).stakind3 = 1) THEN (stat.a).stanumbers3\n            WHEN ((stat.a).stakind4 = 1) THEN (stat.a).stanumbers4\n            WHEN ((stat.a).stakind5 = 1) THEN (stat.a).stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_freqs,\n        CASE\n            WHEN ((stat.a).stakind1 = 2) THEN (stat.a).stavalues1\n            WHEN ((stat.a).stakind2 = 2) THEN (stat.a).stavalues2\n            WHEN ((stat.a).stakind3 = 2) THEN (stat.a).stavalues3\n            WHEN ((stat.a).stakind4 = 2) THEN (stat.a).stavalues4\n            WHEN ((stat.a).stakind5 = 2) THEN (stat.a).stavalues5\n            ELSE NULL::anyarray\n        END AS histogram_bounds,\n        CASE\n            WHEN ((stat.a).stakind1 = 3) THEN (stat.a).stanumbers1[1]\n            WHEN ((stat.a).stakind2 = 3) THEN (stat.a).stanumbers2[1]\n            WHEN ((stat.a).stakind3 = 3) THEN (stat.a).stanumbers3[1]\n            WHEN ((stat.a).stakind4 = 3) THEN (stat.a).stanumbers4[1]\n            WHEN ((stat.a).stakind5 = 3) THEN (stat.a).stanumbers5[1]\n            ELSE NULL::real\n        END AS correlation,\n        CASE\n            WHEN ((stat.a).stakind1 = 4) THEN (stat.a).stavalues1\n            WHEN ((stat.a).stakind2 = 4) THEN (stat.a).stavalues2\n            WHEN ((stat.a).stakind3 = 4) THEN (stat.a).stavalues3\n            WHEN ((stat.a).stakind4 = 4) THEN (stat.a).stavalues4\n            WHEN ((stat.a).stakind5 = 4) THEN (stat.a).stavalues5\n            ELSE NULL::anyarray\n        END AS most_common_elems,\n        CASE\n            WHEN ((stat.a).stakind1 = 4) THEN (stat.a).stanumbers1\n            WHEN ((stat.a).stakind2 = 4) THEN (stat.a).stanumbers2\n            WHEN ((stat.a).stakind3 = 4) THEN (stat.a).stanumbers3\n            WHEN ((stat.a).stakind4 = 4) THEN (stat.a).stanumbers4\n            WHEN ((stat.a).stakind5 = 4) THEN (stat.a).stanumbers5\n            ELSE NULL::real[]\n        END AS most_common_elem_freqs,\n        CASE\n            WHEN ((stat.a).stakind1 = 5) THEN (stat.a).stanumbers1\n            WHEN ((stat.a).stakind2 = 5) THEN (stat.a).stanumbers2\n            WHEN ((stat.a).stakind3 = 5) THEN (stat.a).stanumbers3\n            WHEN ((stat.a).stakind4 = 5) THEN (stat.a).stanumbers4\n            WHEN ((stat.a).stakind5 = 5) THEN (stat.a).stanumbers5\n            ELSE NULL::real[]\n        END AS elem_count_histogram\n   FROM (((((pg_statistic_ext s\n     JOIN pg_class c ON ((c.oid = s.stxrelid)))\n     LEFT JOIN pg_statistic_ext_data sd ON ((s.oid = sd.stxoid)))\n     LEFT JOIN pg_namespace cn ON ((cn.oid = c.relnamespace)))\n     LEFT JOIN pg_namespace sn ON ((sn.oid = s.stxnamespace)))\n     JOIN LATERAL ( SELECT unnest(pg_get_statisticsobjdef_expressions(s.oid)) AS expr,\n            unnest(sd.stxdexpr) AS a) stat ON ((stat.expr IS NOT NULL)));'), ('pg_tables', ' SELECT n.nspname AS schemaname,\n    c.relname AS tablename,\n    pg_get_userbyid(c.relowner) AS tableowner,\n    t.spcname AS tablespace,\n    c.relhasindex AS hasindexes,\n    c.relhasrules AS hasrules,\n    c.relhastriggers AS hastriggers,\n    c.relrowsecurity AS rowsecurity\n   FROM ((pg_class c\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n     LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace)))\n  WHERE (c.relkind = ANY (ARRAY[\'r\'::"char", \'p\'::"char"]));'), ('pg_timezone_abbrevs', ' SELECT abbrev,\n    utc_offset,\n    is_dst\n   FROM pg_timezone_abbrevs() pg_timezone_abbrevs(abbrev, utc_offset, is_dst);'), ('pg_timezone_names', ' SELECT name,\n    abbrev,\n    utc_offset,\n    is_dst\n   FROM pg_timezone_names() pg_timezone_names(name, abbrev, utc_offset, is_dst);'), ('pg_user', " SELECT usename,\n    usesysid,\n    usecreatedb,\n    usesuper,\n    userepl,\n    usebypassrls,\n    '********'::text AS passwd,\n    valuntil,\n    useconfig\n   FROM pg_shadow;"), ('pg_user_mappings', " SELECT u.oid AS umid,\n    s.oid AS srvid,\n    s.srvname,\n    u.umuser,\n        CASE\n            WHEN (u.umuser = (0)::oid) THEN 'public'::name\n            ELSE a.rolname\n        END AS usename,\n        CASE\n            WHEN (((u.umuser <> (0)::oid) AND (a.rolname = CURRENT_USER) AND (pg_has_role(s.srvowner, 'USAGE'::text) OR has_server_privilege(s.oid, 'USAGE'::text))) OR ((u.umuser = (0)::oid) AND pg_has_role(s.srvowner, 'USAGE'::text)) OR ( SELECT pg_authid.rolsuper\n               FROM pg_authid\n              WHERE (pg_authid.rolname = CURRENT_USER))) THEN u.umoptions\n            ELSE NULL::text[]\n        END AS umoptions\n   FROM ((pg_user_mapping u\n     JOIN pg_foreign_server s ON ((u.umserver = s.oid)))\n     LEFT JOIN pg_authid a ON ((a.oid = u.umuser)));"), ('pg_views', ' SELECT n.nspname AS schemaname,\n    c.relname AS viewname,\n    pg_get_userbyid(c.relowner) AS viewowner,\n    pg_get_viewdef(c.oid) AS definition\n   FROM (pg_class c\n     LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace)))\n  WHERE (c.relkind = \'v\'::"char");'), ('pg_wait_events', ' SELECT type,\n    name,\n    description\n   FROM pg_get_wait_events() pg_get_wait_events(type, name, description);')]

-----------
QUERY:


SELECT tablename, rulename, definition FROM pg_rules
WHERE schemaname = 'pg_catalog'
ORDER BY tablename, rulename;
RESULT:
	[('pg_settings', 'pg_settings_n', 'CREATE RULE pg_settings_n AS\n    ON UPDATE TO pg_catalog.pg_settings DO INSTEAD NOTHING;'), ('pg_settings', 'pg_settings_u', 'CREATE RULE pg_settings_u AS\n    ON UPDATE TO pg_catalog.pg_settings\n   WHERE (new.name = old.name) DO  SELECT set_config(old.name, new.setting, false) AS set_config;')]

-----------
QUERY:


-- restore normal output mode
-- \a\t

--
-- CREATE OR REPLACE RULE
--

CREATE TABLE ruletest_tbl (a int, b int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE ruletest_tbl2 (a int, b int);
RESULT:
	[]

-----------
QUERY:


CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (10, 10);
RESULT:
	[]

-----------
QUERY:


INSERT INTO ruletest_tbl VALUES (99, 99);
RESULT:
	[]

-----------
QUERY:


CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (1000, 1000);
RESULT:
	[]

-----------
QUERY:


INSERT INTO ruletest_tbl VALUES (99, 99);
RESULT:
	[]

-----------
QUERY:


SELECT * FROM ruletest_tbl2;
RESULT:
	[(10, 10), (1000, 1000)]

-----------
QUERY:


-- Check that rewrite rules splitting one INSERT into multiple
-- conditional statements does not disable FK checking.
create table rule_and_refint_t1 (
	id1a integer,
	id1b integer,

	primary key (id1a, id1b)
);
RESULT:
	[]

-----------
QUERY:


create table rule_and_refint_t2 (
	id2a integer,
	id2c integer,

	primary key (id2a, id2c)
);
RESULT:
	[]

-----------
QUERY:


create table rule_and_refint_t3 (
	id3a integer,
	id3b integer,
	id3c integer,
	data text,

	primary key (id3a, id3b, id3c),

	foreign key (id3a, id3b) references rule_and_refint_t1 (id1a, id1b),
	foreign key (id3a, id3c) references rule_and_refint_t2 (id2a, id2c)
);
RESULT:
	[]

-----------
QUERY:



insert into rule_and_refint_t1 values (1, 11);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t1 values (1, 12);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t1 values (2, 21);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t1 values (2, 22);
RESULT:
	[]

-----------
QUERY:


insert into rule_and_refint_t2 values (1, 11);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t2 values (1, 12);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t2 values (2, 21);
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t2 values (2, 22);
RESULT:
	[]

-----------
QUERY:


insert into rule_and_refint_t3 values (1, 11, 11, 'row1');
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t3 values (1, 11, 12, 'row2');
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t3 values (1, 12, 11, 'row3');
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t3 values (1, 12, 12, 'row4');
RESULT:
	[]

-----------
QUERY:

insert into rule_and_refint_t3 values (1, 11, 13, 'row5');
RESULT:
	ERROR - insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3c_fkey"
DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".


-----------
QUERY:

insert into rule_and_refint_t3 values (1, 13, 11, 'row6');
RESULT:
	ERROR - insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3b_fkey"
DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".


-----------
QUERY:

-- Ordinary table
insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
  on conflict do nothing;
RESULT:
	ERROR - insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3b_fkey"
DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".


-----------
QUERY:

-- rule not fired, so fk violation
insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
  on conflict (id3a, id3b, id3c) do update
  set id3b = excluded.id3b;
RESULT:
	ERROR - insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3b_fkey"
DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".


-----------
QUERY:

-- rule fired, so unsupported
insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0)
  on conflict (sl_name) do update
  set sl_avail = excluded.sl_avail;
RESULT:
	ERROR - INSERT with ON CONFLICT clause cannot be used with table that has INSERT or UPDATE rules


-----------
QUERY:


create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3
	where (exists (select 1 from rule_and_refint_t3
			where (((rule_and_refint_t3.id3a = new.id3a)
			and (rule_and_refint_t3.id3b = new.id3b))
			and (rule_and_refint_t3.id3c = new.id3c))))
	do instead update rule_and_refint_t3 set data = new.data
	where (((rule_and_refint_t3.id3a = new.id3a)
	and (rule_and_refint_t3.id3b = new.id3b))
	and (rule_and_refint_t3.id3c = new.id3c));
RESULT:
	[]

-----------
QUERY:


insert into rule_and_refint_t3 values (1, 11, 13, 'row7');
RESULT:
	ERROR - insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3c_fkey"
DETAIL:  Key (id3a, id3c)=(1, 13) is not present in table "rule_and_refint_t2".


-----------
QUERY:

insert into rule_and_refint_t3 values (1, 13, 11, 'row8');
RESULT:
	ERROR - insert or update on table "rule_and_refint_t3" violates foreign key constraint "rule_and_refint_t3_id3a_id3b_fkey"
DETAIL:  Key (id3a, id3b)=(1, 13) is not present in table "rule_and_refint_t1".


-----------
QUERY:


--
-- disallow dropping a view/* REPLACED */ ''s rule (bug #5072)
--

create view rules_fooview as select 'rules_foo'::text;
RESULT:
	[]

-----------
QUERY:

drop rule "_RETURN" on rules_fooview;
RESULT:
	ERROR - cannot drop rule _RETURN on view rules_fooview because view rules_fooview requires it
HINT:  You can drop view rules_fooview instead.


-----------
QUERY:

drop view rules_fooview;
RESULT:
	[]

-----------
QUERY:


--
-- We used to allow converting a table to a view by creating a /* REPLACED */ ''_RETURN/* REPLACED */ ''
-- rule for it, but no more.
--

create table rules_fooview (x int, y text);
RESULT:
	[]

-----------
QUERY:

create rule "_RETURN" as on select to rules_fooview do instead
  select 1 as x, 'aaa'::text as y;
RESULT:
	ERROR - relation "rules_fooview" cannot have ON SELECT rules
DETAIL:  This operation is not supported for tables.


-----------
QUERY:

drop table rules_fooview;
RESULT:
	[]

-----------
QUERY:


-- likewise, converting a partitioned table or partition to view is not allowed
create table rules_fooview (x int, y text) partition by list (x);
RESULT:
	[]

-----------
QUERY:

create rule "_RETURN" as on select to rules_fooview do instead
  select 1 as x, 'aaa'::text as y;
RESULT:
	ERROR - relation "rules_fooview" cannot have ON SELECT rules
DETAIL:  This operation is not supported for partitioned tables.


-----------
QUERY:


create table rules_fooview_part partition of rules_fooview for values in (1);
RESULT:
	[]

-----------
QUERY:

create rule "_RETURN" as on select to rules_fooview_part do instead
  select 1 as x, 'aaa'::text as y;
RESULT:
	ERROR - relation "rules_fooview_part" cannot have ON SELECT rules
DETAIL:  This operation is not supported for tables.


-----------
QUERY:


drop table rules_fooview;
RESULT:
	[]

-----------
QUERY:


--
-- check for planner problems with complex inherited UPDATES
--

create table id (id serial primary key, name text);
RESULT:
	[]

-----------
QUERY:

-- currently, must respecify PKEY for each inherited subtable
create table test_1 (id integer primary key) inherits (id);
RESULT:
	[]

-----------
QUERY:

create table test_2 (id integer primary key) inherits (id);
RESULT:
	[]

-----------
QUERY:

create table test_3 (id integer primary key) inherits (id);
RESULT:
	[]

-----------
QUERY:


insert into test_1 (name) values ('Test 1');
RESULT:
	[]

-----------
QUERY:

insert into test_1 (name) values ('Test 2');
RESULT:
	[]

-----------
QUERY:

insert into test_2 (name) values ('Test 3');
RESULT:
	[]

-----------
QUERY:

insert into test_2 (name) values ('Test 4');
RESULT:
	[]

-----------
QUERY:

insert into test_3 (name) values ('Test 5');
RESULT:
	[]

-----------
QUERY:

insert into test_3 (name) values ('Test 6');
RESULT:
	[]

-----------
QUERY:


create view id_ordered as select * from id order by id;
RESULT:
	[]

-----------
QUERY:


create rule update_id_ordered as on update to id_ordered
	do instead update id set name = new.name where id = old.id;
RESULT:
	[]

-----------
QUERY:


select * from id_ordered;
RESULT:
	[(1, 'Test 1'), (2, 'Test 2'), (3, 'Test 3'), (4, 'Test 4'), (5, 'Test 5'), (6, 'Test 6')]

-----------
QUERY:

update id_ordered set name = 'update 2' where id = 2;
RESULT:
	[]

-----------
QUERY:

update id_ordered set name = 'update 4' where id = 4;
RESULT:
	[]

-----------
QUERY:

update id_ordered set name = 'update 5' where id = 5;
RESULT:
	[]

-----------
QUERY:

select * from id_ordered;
RESULT:
	[(1, 'Test 1'), (2, 'update 2'), (3, 'Test 3'), (4, 'update 4'), (5, 'update 5'), (6, 'Test 6')]

-----------
QUERY:


drop table id cascade;
RESULT:
	[]

-----------
QUERY:


--
-- check corner case where an entirely-dummy subplan is created by
-- constraint exclusion
--

create temp table t1 (a integer primary key);
RESULT:
	[]

-----------
QUERY:


create temp table t1_1 (check (a >= 0 and a < 10)) inherits (t1);
RESULT:
	[]

-----------
QUERY:

create temp table t1_2 (check (a >= 10 and a < 20)) inherits (t1);
RESULT:
	[]

-----------
QUERY:


create rule t1_ins_1 as on insert to t1
	where new.a >= 0 and new.a < 10
	do instead
	insert into t1_1 values (new.a);
RESULT:
	[]

-----------
QUERY:

create rule t1_ins_2 as on insert to t1
	where new.a >= 10 and new.a < 20
	do instead
	insert into t1_2 values (new.a);
RESULT:
	[]

-----------
QUERY:


create rule t1_upd_1 as on update to t1
	where old.a >= 0 and old.a < 10
	do instead
	update t1_1 set a = new.a where a = old.a;
RESULT:
	[]

-----------
QUERY:

create rule t1_upd_2 as on update to t1
	where old.a >= 10 and old.a < 20
	do instead
	update t1_2 set a = new.a where a = old.a;
RESULT:
	[]

-----------
QUERY:


set constraint_exclusion = on;
RESULT:
	[]

-----------
QUERY:


insert into t1 select * from generate_series(5,19,1) g;
RESULT:
	[]

-----------
QUERY:

update t1 set a = 4 where a = 5;
RESULT:
	[]

-----------
QUERY:


select * from only t1;
RESULT:
	[]

-----------
QUERY:

select * from only t1_1;
RESULT:
	[(6,), (7,), (8,), (9,), (4,)]

-----------
QUERY:

select * from only t1_2;
RESULT:
	[(10,), (11,), (12,), (13,), (14,), (15,), (16,), (17,), (18,), (19,)]

-----------
QUERY:


reset constraint_exclusion;
RESULT:
	[]

-----------
QUERY:


-- test FOR UPDATE in rules

create table rules_base(f1 int, f2 int);
RESULT:
	[]

-----------
QUERY:

insert into rules_base values(1,2), (11,12);
RESULT:
	[]

-----------
QUERY:

create rule r1 as on update to rules_base do instead
  select * from rules_base where f1 = 1 for update;
RESULT:
	[]

-----------
QUERY:

update rules_base set f2 = f2 + 1;
RESULT:
	[(1, 2)]

-----------
QUERY:

create or replace rule r1 as on update to rules_base do instead
  select * from rules_base where f1 = 11 for update of rules_base;
RESULT:
	[]

-----------
QUERY:

update rules_base set f2 = f2 + 1;
RESULT:
	[(11, 12)]

-----------
QUERY:

create or replace rule r1 as on update to rules_base do instead
  select * from rules_base where f1 = 11 for update of old;
RESULT:
	ERROR - relation "old" in FOR UPDATE clause not found in FROM clause
LINE 3:   select * from rules_base where f1 = 11 for update of old;
                                                               ^


-----------
QUERY:
 -- error
drop table rules_base;
RESULT:
	[]

-----------
QUERY:


-- test various flavors of pg_get_viewdef()

select pg_get_viewdef('shoe'::regclass) as unpretty;
RESULT:
	[(' SELECT sh.shoename,\n    sh.sh_avail,\n    sh.slcolor,\n    sh.slminlen,\n    (sh.slminlen * un.un_fact) AS slminlen_cm,\n    sh.slmaxlen,\n    (sh.slmaxlen * un.un_fact) AS slmaxlen_cm,\n    sh.slunit\n   FROM shoe_data sh,\n    unit un\n  WHERE (sh.slunit = un.un_name);',)]

-----------
QUERY:

select pg_get_viewdef('shoe'::regclass,true) as pretty;
RESULT:
	[(' SELECT sh.shoename,\n    sh.sh_avail,\n    sh.slcolor,\n    sh.slminlen,\n    sh.slminlen * un.un_fact AS slminlen_cm,\n    sh.slmaxlen,\n    sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n    sh.slunit\n   FROM shoe_data sh,\n    unit un\n  WHERE sh.slunit = un.un_name;',)]

-----------
QUERY:

select pg_get_viewdef('shoe'::regclass,0) as prettier;
RESULT:
	[(' SELECT sh.shoename,\n    sh.sh_avail,\n    sh.slcolor,\n    sh.slminlen,\n    sh.slminlen * un.un_fact AS slminlen_cm,\n    sh.slmaxlen,\n    sh.slmaxlen * un.un_fact AS slmaxlen_cm,\n    sh.slunit\n   FROM shoe_data sh,\n    unit un\n  WHERE sh.slunit = un.un_name;',)]

-----------
QUERY:


--
-- check multi-row VALUES in rules
--

create table rules_src(f1 int, f2 int default 0);
RESULT:
	[]

-----------
QUERY:

create table rules_log(f1 int, f2 int, tag text, id serial);
RESULT:
	[]

-----------
QUERY:

insert into rules_src values(1,2), (11,12);
RESULT:
	[]

-----------
QUERY:

create rule r1 as on update to rules_src do also
  insert into rules_log values(old.*, 'old', default), (new.*, 'new', default);
RESULT:
	[]

-----------
QUERY:

update rules_src set f2 = f2 + 1;
RESULT:
	[]

-----------
QUERY:

update rules_src set f2 = f2 * 10;
RESULT:
	[]

-----------
QUERY:

select * from rules_src;
RESULT:
	[(1, 30), (11, 130)]

-----------
QUERY:

select * from rules_log;
RESULT:
	[(1, 2, 'old', 1), (1, 3, 'new', 2), (11, 12, 'old', 3), (11, 13, 'new', 4), (1, 3, 'old', 5), (1, 30, 'new', 6), (11, 13, 'old', 7), (11, 130, 'new', 8)]

-----------
QUERY:

create rule r2 as on update to rules_src do also
  values(old.*, 'old'), (new.*, 'new');
RESULT:
	[]

-----------
QUERY:

update rules_src set f2 = f2 / 10;
RESULT:
	[(1, 30, 'old'), (1, 3, 'new'), (11, 130, 'old'), (11, 13, 'new')]

-----------
QUERY:

create rule r3 as on insert to rules_src do also
  insert into rules_log values(null, null, '-', default), (new.*, 'new', default);
RESULT:
	[]

-----------
QUERY:

insert into rules_src values(22,23), (33,default);
RESULT:
	[]

-----------
QUERY:

select * from rules_src;
RESULT:
	[(1, 3), (11, 13), (22, 23), (33, 0)]

-----------
QUERY:

select * from rules_log;
RESULT:
	[(1, 2, 'old', 1), (1, 3, 'new', 2), (11, 12, 'old', 3), (11, 13, 'new', 4), (1, 3, 'old', 5), (1, 30, 'new', 6), (11, 13, 'old', 7), (11, 130, 'new', 8), (1, 30, 'old', 9), (1, 3, 'new', 10), (11, 130, 'old', 11), (11, 13, 'new', 12), (None, None, '-', 13), (22, 23, 'new', 14), (None, None, '-', 15), (33, 0, 'new', 16)]

-----------
QUERY:

create rule r4 as on delete to rules_src do notify rules_src_deletion;
RESULT:
	[]

-----------
QUERY:


--
-- Ensure an aliased target relation for insert is correctly deparsed.
--
create rule r5 as on insert to rules_src do instead insert into rules_log AS trgt SELECT NEW.* RETURNING trgt.f1, trgt.f2;
RESULT:
	[]

-----------
QUERY:

create rule r6 as on update to rules_src do instead UPDATE rules_log AS trgt SET tag = 'updated' WHERE trgt.f1 = new.f1;
RESULT:
	[]

-----------
QUERY:


--
-- Check deparse disambiguation of INSERT/UPDATE/DELETE targets.
--
create rule r7 as on delete to rules_src do instead
  with wins as (insert into int4_tbl as trgt values (0) returning *),
       wupd as (update int4_tbl trgt set f1 = f1+1 returning *),
       wdel as (delete from int4_tbl trgt where f1 = 0 returning *)
  insert into rules_log AS trgt select old.* from wins, wupd, wdel
  returning trgt.f1, trgt.f2;
RESULT:
	[]

-----------
QUERY:


-- check display of all rules added above
-- \d+ rules_src

--
-- Also check multiassignment deparsing.
--
create table rule_t1(f1 int, f2 int);
RESULT:
	[]

-----------
QUERY:

create table rule_dest(f1 int, f2 int[], tag text);
RESULT:
	[]

-----------
QUERY:

create rule rr as on update to rule_t1 do instead UPDATE rule_dest trgt
  SET (f2[1], f1, tag) = (SELECT new.f2, new.f1, 'updated'::varchar)
  WHERE trgt.f1 = new.f1 RETURNING new.*;
RESULT:
	[]

-----------
QUERY:

-- \d+ rule_t1
drop table rule_t1, rule_dest;
RESULT:
	[]

-----------
QUERY:


--
-- Test implicit LATERAL references to old/new in rules
--
CREATE TABLE rule_t1(a int, b text DEFAULT 'xxx', c int);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rule_v1 AS SELECT * FROM rule_t1;
RESULT:
	[]

-----------
QUERY:

CREATE RULE v1_ins AS ON INSERT TO rule_v1
  DO ALSO INSERT INTO rule_t1
  SELECT * FROM (SELECT a + 10 FROM rule_t1 WHERE a = NEW.a) tt;
RESULT:
	[]

-----------
QUERY:

CREATE RULE v1_upd AS ON UPDATE TO rule_v1
  DO ALSO UPDATE rule_t1 t
  SET c = tt.a * 10
  FROM (SELECT a FROM rule_t1 WHERE a = OLD.a) tt WHERE t.a = tt.a;
RESULT:
	[]

-----------
QUERY:

INSERT INTO rule_v1 VALUES (1, 'a'), (2, 'b');
RESULT:
	[]

-----------
QUERY:

UPDATE rule_v1 SET b = upper(b);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rule_t1;
RESULT:
	[(1, 'A', 10), (2, 'B', 20), (11, 'XXX', 110), (12, 'XXX', 120)]

-----------
QUERY:

DROP TABLE rule_t1 CASCADE;
RESULT:
	[]

-----------
QUERY:


--
-- check alter rename rule
--
CREATE TABLE rule_t1 (a INT);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW rule_v1 AS SELECT * FROM rule_t1;
RESULT:
	[]

-----------
QUERY:


CREATE RULE InsertRule AS
    ON INSERT TO rule_v1
    DO INSTEAD
        INSERT INTO rule_t1 VALUES(new.a);
RESULT:
	[]

-----------
QUERY:


ALTER RULE InsertRule ON rule_v1 RENAME to NewInsertRule;
RESULT:
	[]

-----------
QUERY:


INSERT INTO rule_v1 VALUES(1);
RESULT:
	[]

-----------
QUERY:

SELECT * FROM rule_v1;
RESULT:
	[(1,)]

-----------
QUERY:


-- \d+ rule_v1

--
-- error conditions for alter rename rule
--
ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule;
RESULT:
	ERROR - rule "insertrule" for relation "rule_v1" does not exist


-----------
QUERY:
 -- doesn/* REPLACED */ ''t exist
ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN";
RESULT:
	ERROR - rule "_RETURN" for relation "rule_v1" already exists


-----------
QUERY:
 -- already exists
ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc;
RESULT:
	ERROR - renaming an ON SELECT rule is not allowed


-----------
QUERY:
 -- ON SELECT rule cannot be renamed

DROP VIEW rule_v1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE rule_t1;
RESULT:
	[]

-----------
QUERY:


--
-- check display of VALUES in view definitions
--
create view rule_v1 as values(1,2);
RESULT:
	[]

-----------
QUERY:

-- \d+ rule_v1
alter table rule_v1 rename column column2 to q2;
RESULT:
	[]

-----------
QUERY:

-- \d+ rule_v1
drop view rule_v1;
RESULT:
	[]

-----------
QUERY:

create view rule_v1(x) as values(1,2);
RESULT:
	[]

-----------
QUERY:

-- \d+ rule_v1
drop view rule_v1;
RESULT:
	[]

-----------
QUERY:

create view rule_v1(x) as select * from (values(1,2)) v;
RESULT:
	[]

-----------
QUERY:

-- \d+ rule_v1
drop view rule_v1;
RESULT:
	[]

-----------
QUERY:

create view rule_v1(x) as select * from (values(1,2)) v(q,w);
RESULT:
	[]

-----------
QUERY:

-- \d+ rule_v1
drop view rule_v1;
RESULT:
	[]

-----------
QUERY:


--
-- Check DO INSTEAD rules with ON CONFLICT
--
CREATE TABLE hats (
	hat_name    char(10) primary key,
	hat_color   char(10)      -- hat color
);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE hat_data (
	hat_name    char(10),
	hat_color   char(10)      -- hat color
);
RESULT:
	[]

-----------
QUERY:

create unique index hat_data_unique_idx
  on hat_data (hat_name COLLATE "C" bpchar_pattern_ops);
RESULT:
	[]

-----------
QUERY:


-- DO NOTHING with ON CONFLICT
CREATE RULE hat_nosert AS ON INSERT TO hats
    DO INSTEAD
    INSERT INTO hat_data VALUES (
           NEW.hat_name,
           NEW.hat_color)
        ON CONFLICT (hat_name COLLATE "C" bpchar_pattern_ops) WHERE hat_color = 'green'
        DO NOTHING
        RETURNING *;
RESULT:
	[]

-----------
QUERY:

SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
RESULT:
	[('CREATE RULE hat_nosert AS\n    ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)\n  VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name COLLATE "C" bpchar_pattern_ops)\n  WHERE (hat_color = \'green\'::bpchar) DO NOTHING\n  RETURNING hat_data.hat_name,\n    hat_data.hat_color;',)]

-----------
QUERY:


-- Works (projects row)
INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
RESULT:
	[('h7        ', 'black     ')]

-----------
QUERY:

-- Works (does nothing)
INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
RESULT:
	[]

-----------
QUERY:

SELECT tablename, rulename, definition FROM pg_rules
	WHERE tablename = 'hats';
RESULT:
	[('hats', 'hat_nosert', 'CREATE RULE hat_nosert AS\n    ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)\n  VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name COLLATE "C" bpchar_pattern_ops)\n  WHERE (hat_color = \'green\'::bpchar) DO NOTHING\n  RETURNING hat_data.hat_name,\n    hat_data.hat_color;')]

-----------
QUERY:

DROP RULE hat_nosert ON hats;
RESULT:
	[]

-----------
QUERY:


-- DO NOTHING without ON CONFLICT
CREATE RULE hat_nosert_all AS ON INSERT TO hats
    DO INSTEAD
    INSERT INTO hat_data VALUES (
           NEW.hat_name,
           NEW.hat_color)
        ON CONFLICT
        DO NOTHING
        RETURNING *;
RESULT:
	[]

-----------
QUERY:

SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
RESULT:
	[('CREATE RULE hat_nosert_all AS\n    ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)\n  VALUES (new.hat_name, new.hat_color) ON CONFLICT DO NOTHING\n  RETURNING hat_data.hat_name,\n    hat_data.hat_color;',)]

-----------
QUERY:

DROP RULE hat_nosert_all ON hats;
RESULT:
	[]

-----------
QUERY:


-- Works (does nothing)
INSERT INTO hats VALUES ('h7', 'black') RETURNING *;
RESULT:
	[('h7        ', 'black     ')]

-----------
QUERY:


-- DO UPDATE with a WHERE clause
CREATE RULE hat_upsert AS ON INSERT TO hats
    DO INSTEAD
    INSERT INTO hat_data VALUES (
           NEW.hat_name,
           NEW.hat_color)
        ON CONFLICT (hat_name)
        DO UPDATE
           SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color
           WHERE excluded.hat_color <>  'forbidden' AND hat_data.* != excluded.*
        RETURNING *;
RESULT:
	[]

-----------
QUERY:

SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename;
RESULT:
	[("CREATE RULE hat_upsert AS\n    ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)\n  VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name) DO UPDATE SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color\n  WHERE ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))\n  RETURNING hat_data.hat_name,\n    hat_data.hat_color;",)]

-----------
QUERY:


-- Works (does upsert)
INSERT INTO hats VALUES ('h8', 'black') RETURNING *;
RESULT:
	[('h8        ', 'black     ')]

-----------
QUERY:

SELECT * FROM hat_data WHERE hat_name = 'h8';
RESULT:
	[('h8        ', 'black     ')]

-----------
QUERY:

INSERT INTO hats VALUES ('h8', 'white') RETURNING *;
RESULT:
	[('h8        ', 'white     ')]

-----------
QUERY:

SELECT * FROM hat_data WHERE hat_name = 'h8';
RESULT:
	[('h8        ', 'white     ')]

-----------
QUERY:

INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM hat_data WHERE hat_name = 'h8';
RESULT:
	[('h8        ', 'white     ')]

-----------
QUERY:

SELECT tablename, rulename, definition FROM pg_rules
	WHERE tablename = 'hats';
RESULT:
	[('hats', 'hat_upsert', "CREATE RULE hat_upsert AS\n    ON INSERT TO public.hats DO INSTEAD  INSERT INTO hat_data (hat_name, hat_color)\n  VALUES (new.hat_name, new.hat_color) ON CONFLICT(hat_name) DO UPDATE SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color\n  WHERE ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))\n  RETURNING hat_data.hat_name,\n    hat_data.hat_color;")]

-----------
QUERY:

-- ensure explain works for on insert conflict rules
explain (costs off) INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *;
RESULT:
	[('Insert on hat_data',), ('  Conflict Resolution: UPDATE',), ('  Conflict Arbiter Indexes: hat_data_unique_idx',), ("  Conflict Filter: ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))",), ('  ->  Result',)]

-----------
QUERY:


-- ensure upserting into a rule, with a CTE (different offsets!) works
WITH data(hat_name, hat_color) AS MATERIALIZED (
    VALUES ('h8', 'green'),
        ('h9', 'blue'),
        ('h7', 'forbidden')
)
INSERT INTO hats
    SELECT * FROM data
RETURNING *;
RESULT:
	[('h8        ', 'green     '), ('h9        ', 'blue      ')]

-----------
QUERY:

EXPLAIN (costs off)
WITH data(hat_name, hat_color) AS MATERIALIZED (
    VALUES ('h8', 'green'),
        ('h9', 'blue'),
        ('h7', 'forbidden')
)
INSERT INTO hats
    SELECT * FROM data
RETURNING *;
RESULT:
	[('Insert on hat_data',), ('  Conflict Resolution: UPDATE',), ('  Conflict Arbiter Indexes: hat_data_unique_idx',), ("  Conflict Filter: ((excluded.hat_color <> 'forbidden'::bpchar) AND (hat_data.* <> excluded.*))",), ('  CTE data',), ('    ->  Values Scan on "*VALUES*"',), ('  ->  CTE Scan on data',)]

-----------
QUERY:

SELECT * FROM hat_data WHERE hat_name IN ('h8', 'h9', 'h7') ORDER BY hat_name;
RESULT:
	[('h7        ', 'black     '), ('h8        ', 'green     '), ('h9        ', 'blue      ')]

-----------
QUERY:


DROP RULE hat_upsert ON hats;
RESULT:
	[]

-----------
QUERY:


drop table hats;
RESULT:
	[]

-----------
QUERY:

drop table hat_data;
RESULT:
	[]

-----------
QUERY:


-- test for pg_get_functiondef properly regurgitating SET parameters
-- Note that the function is kept around to stress pg_dump.
CREATE FUNCTION func_with_set_params() RETURNS integer
    AS 'select 1;
RESULT:
	ERROR - unterminated quoted string at or near "'select 1;"
LINE 6:     AS 'select 1;
               ^


-----------
QUERY:
'
    LANGUAGE SQL
    SET search_path TO PG_CATALOG
    SET extra_float_digits TO 2
    SET work_mem TO '4MB'
    SET datestyle to iso, mdy
    SET local_preload_libraries TO "Mixed/Case", 'c:/''a"/path', '', '0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789'
    IMMUTABLE STRICT;
RESULT:
	ERROR - syntax error at or near "'
    LANGUAGE SQL
    SET search_path TO PG_CATALOG
    SET extra_float_digits TO 2
    SET work_mem TO '"
LINE 1: '
        ^


-----------
QUERY:

SELECT pg_get_functiondef('func_with_set_params()'::regprocedure);
RESULT:
	ERROR - function "func_with_set_params()" does not exist
LINE 2: SELECT pg_get_functiondef('func_with_set_params()'::regproce...
                                  ^


-----------
QUERY:


-- tests for pg_get_*def with invalid objects
SELECT pg_get_constraintdef(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_functiondef(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_indexdef(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_ruledef(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_statisticsobjdef(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_triggerdef(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_viewdef(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_function_arguments(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_function_identity_arguments(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_function_result(0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_function_arg_default(0, 0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_function_arg_default('pg_class'::regclass, 0);
RESULT:
	[(None,)]

-----------
QUERY:

SELECT pg_get_partkeydef(0);
RESULT:
	[(None,)]

-----------
QUERY:


-- test rename for a rule defined on a partitioned table
CREATE TABLE rules_parted_table (a int) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE rules_parted_table_1 PARTITION OF rules_parted_table FOR VALUES IN (1);
RESULT:
	[]

-----------
QUERY:

CREATE RULE rules_parted_table_insert AS ON INSERT to rules_parted_table
    DO INSTEAD INSERT INTO rules_parted_table_1 VALUES (NEW.*);
RESULT:
	[]

-----------
QUERY:

ALTER RULE rules_parted_table_insert ON rules_parted_table RENAME TO rules_parted_table_insert_redirect;
RESULT:
	[]

-----------
QUERY:

DROP TABLE rules_parted_table;
RESULT:
	[]

-----------
QUERY:


--
-- test MERGE
--
CREATE TABLE rule_merge1 (a int, b text);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE rule_merge2 (a int, b text);
RESULT:
	[]

-----------
QUERY:

CREATE RULE rule1 AS ON INSERT TO rule_merge1
	DO INSTEAD INSERT INTO rule_merge2 VALUES (NEW.*);
RESULT:
	[]

-----------
QUERY:

CREATE RULE rule2 AS ON UPDATE TO rule_merge1
	DO INSTEAD UPDATE rule_merge2 SET a = NEW.a, b = NEW.b
	WHERE a = OLD.a;
RESULT:
	[]

-----------
QUERY:

CREATE RULE rule3 AS ON DELETE TO rule_merge1
	DO INSTEAD DELETE FROM rule_merge2 WHERE a = OLD.a;
RESULT:
	[]

-----------
QUERY:


-- MERGE not supported for table with rules
MERGE INTO rule_merge1 t USING (SELECT 1 AS a) s
	ON t.a = s.a
	WHEN MATCHED AND t.a < 2 THEN
		UPDATE SET b = b || ' updated by merge'
	WHEN MATCHED AND t.a > 2 THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT VALUES (s.a, '');
RESULT:
	ERROR - cannot execute MERGE on relation "rule_merge1"
DETAIL:  MERGE is not supported for relations with rules.


-----------
QUERY:


-- should be ok with the other table though
MERGE INTO rule_merge2 t USING (SELECT 1 AS a) s
	ON t.a = s.a
	WHEN MATCHED AND t.a < 2 THEN
		UPDATE SET b = b || ' updated by merge'
	WHEN MATCHED AND t.a > 2 THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT VALUES (s.a, '');
RESULT:
	[]

-----------
QUERY:


-- also ok if the rules are disabled
ALTER TABLE rule_merge1 DISABLE RULE rule1;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE rule_merge1 DISABLE RULE rule2;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE rule_merge1 DISABLE RULE rule3;
RESULT:
	[]

-----------
QUERY:

MERGE INTO rule_merge1 t USING (SELECT 1 AS a) s
	ON t.a = s.a
	WHEN MATCHED AND t.a < 2 THEN
		UPDATE SET b = b || ' updated by merge'
	WHEN MATCHED AND t.a > 2 THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT VALUES (s.a, '');
RESULT:
	[]

-----------
QUERY:


-- test deparsing
CREATE TABLE sf_target(id int, data text, filling int[]);
RESULT:
	[]

-----------
QUERY:


CREATE FUNCTION merge_sf_test()
 RETURNS TABLE(action text, a int, b text, id int, data text, filling int[])
 LANGUAGE sql
BEGIN ATOMIC
 MERGE INTO sf_target t
   USING rule_merge1 s
   ON (s.a = t.id)
WHEN MATCHED
   AND (s.a + t.id) = 42
   THEN UPDATE SET data = repeat(t.data, s.a) || s.b, id = length(s.b)
WHEN NOT MATCHED
   AND (s.b IS NOT NULL)
   THEN INSERT (data, id)
   VALUES (s.b, s.a)
WHEN MATCHED
   AND length(s.b || t.data) > 10
   THEN UPDATE SET data = s.b
WHEN MATCHED
   AND s.a > 200
   THEN UPDATE SET filling[s.a] = t.id
WHEN MATCHED
   AND s.a > 100
   THEN DELETE
WHEN MATCHED
   THEN DO NOTHING
WHEN NOT MATCHED
   AND s.a > 200
   THEN INSERT DEFAULT VALUES
WHEN NOT MATCHED
   AND s.a > 100
   THEN INSERT (id, data) OVERRIDING USER VALUE
   VALUES (s.a, DEFAULT)
WHEN NOT MATCHED
   AND s.a > 0
   THEN INSERT
   VALUES (s.a, s.b, DEFAULT)
WHEN NOT MATCHED
   THEN INSERT (filling[1], id)
   VALUES (s.a, s.a)
RETURNING
   merge_action() AS action, *;
RESULT:
	ERROR - syntax error at end of input
LINE 43:    merge_action() AS action, *;
                                        ^


-----------
QUERY:

END;
RESULT:
	[]

-----------
QUERY:


-- \sf merge_sf_test

DROP FUNCTION merge_sf_test;
RESULT:
	ERROR - could not find a function named "merge_sf_test"


-----------
QUERY:

DROP TABLE sf_target;
RESULT:
	[]

-----------
QUERY:


--
-- Test enabling/disabling
--
CREATE TABLE ruletest1 (a int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE ruletest2 (b int);
RESULT:
	[]

-----------
QUERY:


CREATE RULE rule1 AS ON INSERT TO ruletest1
    DO INSTEAD INSERT INTO ruletest2 VALUES (NEW.*);
RESULT:
	[]

-----------
QUERY:


INSERT INTO ruletest1 VALUES (1);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE ruletest1 DISABLE RULE rule1;
RESULT:
	[]

-----------
QUERY:

INSERT INTO ruletest1 VALUES (2);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE ruletest1 ENABLE RULE rule1;
RESULT:
	[]

-----------
QUERY:

SET session_replication_role = replica;
RESULT:
	[]

-----------
QUERY:

INSERT INTO ruletest1 VALUES (3);
RESULT:
	[]

-----------
QUERY:

ALTER TABLE ruletest1 ENABLE REPLICA RULE rule1;
RESULT:
	[]

-----------
QUERY:

INSERT INTO ruletest1 VALUES (4);
RESULT:
	[]

-----------
QUERY:

RESET session_replication_role;
RESULT:
	[]

-----------
QUERY:

INSERT INTO ruletest1 VALUES (5);
RESULT:
	[]

-----------
QUERY:


SELECT * FROM ruletest1;
RESULT:
	[(2,), (3,), (5,)]

-----------
QUERY:

SELECT * FROM ruletest2;
RESULT:
	[(1,), (4,)]

-----------
QUERY:


DROP TABLE ruletest1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE ruletest2;
RESULT:
	[]

-----------
QUERY:


--
-- Test non-SELECT rule on security invoker view.
-- Should use view owner/* REPLACED */ ''s permissions.
--
CREATE USER regress_rule_user1;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE ruletest_t1 (x int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE ruletest_t2 (x int);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW ruletest_v1 WITH (security_invoker=true) AS
    SELECT * FROM ruletest_t1;
RESULT:
	[]

-----------
QUERY:

GRANT INSERT ON ruletest_v1 TO regress_rule_user1;
RESULT:
	[]

-----------
QUERY:


CREATE RULE rule1 AS ON INSERT TO ruletest_v1
    DO INSTEAD INSERT INTO ruletest_t2 VALUES (NEW.*);
RESULT:
	[]

-----------
QUERY:


SET SESSION AUTHORIZATION regress_rule_user1;
RESULT:
	[]

-----------
QUERY:

INSERT INTO ruletest_v1 VALUES (1);
RESULT:
	[]

-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:


-- Test that main query/* REPLACED */ ''s relation/* REPLACED */ ''s permissions are checked before
-- the rule action/* REPLACED */ ''s relation/* REPLACED */ ''s.
CREATE TABLE ruletest_t3 (x int);
RESULT:
	[]

-----------
QUERY:

CREATE RULE rule2 AS ON UPDATE TO ruletest_t1
    DO INSTEAD INSERT INTO ruletest_t2 VALUES (OLD.*);
RESULT:
	[]

-----------
QUERY:

REVOKE ALL ON ruletest_t2 FROM regress_rule_user1;
RESULT:
	[]

-----------
QUERY:

REVOKE ALL ON ruletest_t3 FROM regress_rule_user1;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE ruletest_t1 OWNER TO regress_rule_user1;
RESULT:
	[]

-----------
QUERY:

SET SESSION AUTHORIZATION regress_rule_user1;
RESULT:
	[]

-----------
QUERY:

UPDATE ruletest_t1 t1 SET x = 0 FROM ruletest_t3 t3 WHERE t1.x = t3.x;
RESULT:
	ERROR - permission denied for table ruletest_t3


-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM ruletest_t1;
RESULT:
	[]

-----------
QUERY:

SELECT * FROM ruletest_t2;
RESULT:
	[(1,)]

-----------
QUERY:


DROP VIEW ruletest_v1;
RESULT:
	[]

-----------
QUERY:

DROP RULE rule2 ON ruletest_t1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE ruletest_t3;
RESULT:
	[]

-----------
QUERY:

DROP TABLE ruletest_t2;
RESULT:
	[]

-----------
QUERY:

DROP TABLE ruletest_t1;
RESULT:
	[]

-----------
QUERY:


DROP USER regress_rule_user1;
RESULT:
	[]
