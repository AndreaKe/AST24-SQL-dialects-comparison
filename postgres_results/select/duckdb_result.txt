--
-- SELECT
--

-- btree index
-- awk ''{if($1<10){print /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +0n -1
--
SELECT * FROM onek
   WHERE onek.unique1 < 10
   ORDER BY onek.unique1
ERROR: --
-- SELECT
--

-- btree index
-- awk ''{if($1<10){print /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +0n -1
--
SELECT * FROM onek
   WHERE onek.unique1 < 10
   ORDER BY onek.unique1

Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?


--
-- awk ''{if($1<20){print $1,$14 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +0nr -1
--
SELECT onek.unique1, onek.stringu1 FROM onek
   WHERE onek.unique1 < 20
   ORDER BY unique1 using >
ERROR: 

--
-- awk ''{if($1<20){print $1,$14 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +0nr -1
--
SELECT onek.unique1, onek.stringu1 FROM onek
   WHERE onek.unique1 < 20
   ORDER BY unique1 using >

Not implemented Error: Unimplemented order by type


--
-- awk ''{if($1>980){print $1,$14 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +1d -2
--
SELECT onek.unique1, onek.stringu1 FROM onek
   WHERE onek.unique1 > 980
   ORDER BY stringu1 using <
ERROR: 

--
-- awk ''{if($1>980){print $1,$14 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +1d -2
--
SELECT onek.unique1, onek.stringu1 FROM onek
   WHERE onek.unique1 > 980
   ORDER BY stringu1 using <

Not implemented Error: Unimplemented order by type


--
-- awk ''{if($1>980){print $1,$16 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data |
-- sort +1d -2 +0nr -1
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 > 980
   ORDER BY string4 using <, unique1 using >
ERROR: 

--
-- awk ''{if($1>980){print $1,$16 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data |
-- sort +1d -2 +0nr -1
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 > 980
   ORDER BY string4 using <, unique1 using >

Not implemented Error: Unimplemented order by type


--
-- awk ''{if($1>980){print $1,$16 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data |
-- sort +1dr -2 +0n -1
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 > 980
   ORDER BY string4 using >, unique1 using <
ERROR: 

--
-- awk ''{if($1>980){print $1,$16 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data |
-- sort +1dr -2 +0n -1
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 > 980
   ORDER BY string4 using >, unique1 using <

Not implemented Error: Unimplemented order by type


--
-- awk ''{if($1<20){print $1,$16 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data |
-- sort +0nr -1 +1d -2
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 < 20
   ORDER BY unique1 using >, string4 using <
ERROR: 

--
-- awk ''{if($1<20){print $1,$16 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data |
-- sort +0nr -1 +1d -2
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 < 20
   ORDER BY unique1 using >, string4 using <

Not implemented Error: Unimplemented order by type


--
-- awk ''{if($1<20){print $1,$16 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data |
-- sort +0n -1 +1dr -2
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 < 20
   ORDER BY unique1 using <, string4 using >
ERROR: 

--
-- awk ''{if($1<20){print $1,$16 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data |
-- sort +0n -1 +1dr -2
--
SELECT onek.unique1, onek.string4 FROM onek
   WHERE onek.unique1 < 20
   ORDER BY unique1 using <, string4 using >

Not implemented Error: Unimplemented order by type


--
-- test partial btree indexes
--
-- As of 7.2, planner probably won''t pick an indexscan without stats,
-- so ANALYZE first.  Also, we want to prevent it from picking a bitmapscan
-- followed by sort, because that could hide index ordering problems.
--
ANALYZE onek2
ERROR: 

--
-- test partial btree indexes
--
-- As of 7.2, planner probably won''t pick an indexscan without stats,
-- so ANALYZE first.  Also, we want to prevent it from picking a bitmapscan
-- followed by sort, because that could hide index ordering problems.
--
ANALYZE onek2

Catalog Error: Table with name onek2 does not exist!
Did you mean "boolindex"?
LINE 10: ANALYZE onek2
                 ^


SET enable_seqscan TO off
ERROR: 

SET enable_seqscan TO off

Catalog Error: unrecognized configuration parameter "enable_seqscan"

Did you mean: "enable_object_cache"

SET enable_bitmapscan TO off
ERROR: 
SET enable_bitmapscan TO off

Catalog Error: unrecognized configuration parameter "enable_bitmapscan"

Did you mean: "enable_object_cache"

SET enable_sort TO off
ERROR: 
SET enable_sort TO off

Catalog Error: unrecognized configuration parameter "enable_sort"

Did you mean: "enable_fsst_vectors"


--
-- awk ''{if($1<10){print $0 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +0n -1
--
SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10
ERROR: 

--
-- awk ''{if($1<10){print $0 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +0n -1
--
SELECT onek2.* FROM onek2 WHERE onek2.unique1 < 10

Catalog Error: Table with name onek2 does not exist!
Did you mean "boolindex"?


--
-- awk ''{if($1<20){print $1,$14 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +0nr -1
--
SELECT onek2.unique1, onek2.stringu1 FROM onek2
    WHERE onek2.unique1 < 20
    ORDER BY unique1 using >
ERROR: 

--
-- awk ''{if($1<20){print $1,$14 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +0nr -1
--
SELECT onek2.unique1, onek2.stringu1 FROM onek2
    WHERE onek2.unique1 < 20
    ORDER BY unique1 using >

Not implemented Error: Unimplemented order by type


--
-- awk ''{if($1>980){print $1,$14 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +1d -2
--
SELECT onek2.unique1, onek2.stringu1 FROM onek2
   WHERE onek2.unique1 > 980
ERROR: 

--
-- awk ''{if($1>980){print $1,$14 /* REPLACED */,}else{next /* REPLACED */,}}'' onek.data | sort +1d -2
--
SELECT onek2.unique1, onek2.stringu1 FROM onek2
   WHERE onek2.unique1 > 980

Catalog Error: Table with name onek2 does not exist!
Did you mean "boolindex"?


RESET enable_seqscan
ERROR: 

RESET enable_seqscan

Catalog Error: unrecognized configuration parameter "enable_seqscan"

Did you mean: "enable_object_cache"

RESET enable_bitmapscan
ERROR: 
RESET enable_bitmapscan

Catalog Error: unrecognized configuration parameter "enable_bitmapscan"

Did you mean: "enable_object_cache"

RESET enable_sort
ERROR: 
RESET enable_sort

Catalog Error: unrecognized configuration parameter "enable_sort"

Did you mean: "enable_fsst_vectors"


--
-- awk ''{print $1,$2 /* REPLACED */,}'' person.data |
-- awk ''{if(NF!=2){print $3,$2 /* REPLACED */,}else{print /* REPLACED */,}}'' - emp.data |
-- awk ''{if(NF!=2){print $3,$2 /* REPLACED */,}else{print /* REPLACED */,}}'' - student.data |
-- awk ''BEGIN{FS=''      '' /* REPLACED */,}{if(NF!=2){print $4,$5 /* REPLACED */,}else{print /* REPLACED */,}}'' - stud_emp.data
--
-- SELECT name, age FROM person* /* REPLACED */, ??? check if different
SELECT p.name, p.age FROM person* p
ERROR: 

--
-- awk ''{print $1,$2 /* REPLACED */,}'' person.data |
-- awk ''{if(NF!=2){print $3,$2 /* REPLACED */,}else{print /* REPLACED */,}}'' - emp.data |
-- awk ''{if(NF!=2){print $3,$2 /* REPLACED */,}else{print /* REPLACED */,}}'' - student.data |
-- awk ''BEGIN{FS=''      '' /* REPLACED */,}{if(NF!=2){print $4,$5 /* REPLACED */,}else{print /* REPLACED */,}}'' - stud_emp.data
--
-- SELECT name, age FROM person* /* REPLACED */, ??? check if different
SELECT p.name, p.age FROM person* p

Catalog Error: Table with name person does not exist!
Did you mean "pg_enum"?


--
-- awk ''{print $1,$2 /* REPLACED */,}'' person.data |
-- awk ''{if(NF!=2){print $3,$2 /* REPLACED */,}else{print /* REPLACED */,}}'' - emp.data |
-- awk ''{if(NF!=2){print $3,$2 /* REPLACED */,}else{print /* REPLACED */,}}'' - student.data |
-- awk ''BEGIN{FS=''      '' /* REPLACED */,}{if(NF!=1){print $4,$5 /* REPLACED */,}else{print /* REPLACED */,}}'' - stud_emp.data |
-- sort +1nr -2
--
SELECT p.name, p.age FROM person* p ORDER BY age using >, name
ERROR: 

--
-- awk ''{print $1,$2 /* REPLACED */,}'' person.data |
-- awk ''{if(NF!=2){print $3,$2 /* REPLACED */,}else{print /* REPLACED */,}}'' - emp.data |
-- awk ''{if(NF!=2){print $3,$2 /* REPLACED */,}else{print /* REPLACED */,}}'' - student.data |
-- awk ''BEGIN{FS=''      '' /* REPLACED */,}{if(NF!=1){print $4,$5 /* REPLACED */,}else{print /* REPLACED */,}}'' - stud_emp.data |
-- sort +1nr -2
--
SELECT p.name, p.age FROM person* p ORDER BY age using >, name

Not implemented Error: Unimplemented order by type


--
-- Test some cases involving whole-row Var referencing a subquery
--
select foo from (select 1 offset 0) as foo
RESULT: 
	[({'1': 1},)]

select foo from (select null offset 0) as foo
RESULT: 
	[({'NULL': None},)]

select foo from (select 'xyzzy',1,null offset 0) as foo
RESULT: 
	[({"'xyzzy'": 'xyzzy', '1': 1, 'NULL': None},)]


--
-- Test VALUES lists
--
select * from onek, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)
    WHERE onek.unique1 = v.i and onek.stringu1 = v.j
ERROR: 

--
-- Test VALUES lists
--
select * from onek, (values(147, 'RFAAAA'), (931, 'VJAAAA')) as v (i, j)
    WHERE onek.unique1 = v.i and onek.stringu1 = v.j

Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?


-- a more complex case
-- looks like we''re coding lisp :-)
select * from onek,
  (values ((select i from
    (values(10000), (2), (389), (1000), (2000), ((select 10029))) as foo(i)
    order by i asc limit 1))) bar (i)
  where onek.unique1 = bar.i
ERROR: 

-- a more complex case
-- looks like we''re coding lisp :-)
select * from onek,
  (values ((select i from
    (values(10000), (2), (389), (1000), (2000), ((select 10029))) as foo(i)
    order by i asc limit 1))) bar (i)
  where onek.unique1 = bar.i

Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?


-- try VALUES in a subquery
select * from onek
    where (unique1,ten) in (values (1,1), (20,0), (99,9), (17,99))
    order by unique1
ERROR: 

-- try VALUES in a subquery
select * from onek
    where (unique1,ten) in (values (1,1), (20,0), (99,9), (17,99))
    order by unique1

Catalog Error: Table with name onek does not exist!
Did you mean "boolindex"?


-- VALUES is also legal as a standalone query or a set-operation member
VALUES (1,2), (3,4+4), (7,77.7)
RESULT: 
	[(1, Decimal('2.0')), (3, Decimal('8.0')), (7, Decimal('77.7'))]


VALUES (1,2), (3,4+4), (7,77.7)
UNION ALL
SELECT 2+2, 57
UNION ALL
TABLE int8_tbl
RESULT: 
	[(1, Decimal('2.0')), (3, Decimal('8.0')), (7, Decimal('77.7')), (4, Decimal('57.0')), (123, Decimal('456.0')), (123, Decimal('4567890123456789.0')), (4567890123456789, Decimal('123.0')), (4567890123456789, Decimal('4567890123456789.0')), (4567890123456789, Decimal('-4567890123456789.0'))]


-- corner case: VALUES with no columns
CREATE TEMP TABLE nocols()
ERROR: 

-- corner case: VALUES with no columns
CREATE TEMP TABLE nocols()

Parser Error: Table must have at least one column!

INSERT INTO nocols DEFAULT VALUES
ERROR: 
INSERT INTO nocols DEFAULT VALUES

Catalog Error: Table with name nocols does not exist!
Did you mean "temp.information_schema.columns"?

SELECT * FROM nocols n, LATERAL (VALUES(n.*)) v
ERROR: 
SELECT * FROM nocols n, LATERAL (VALUES(n.*)) v

Catalog Error: Table with name nocols does not exist!
Did you mean "temp.information_schema.columns"?


--
-- Test ORDER BY options
--

CREATE TEMP TABLE foo (f1 int)


INSERT INTO foo VALUES (42),(3),(10),(7),(null),(null),(1)


SELECT * FROM foo ORDER BY f1
RESULT: 
	[(1,), (3,), (7,), (10,), (42,), (None,), (None,)]

SELECT * FROM foo ORDER BY f1 ASC
RESULT: 
	[(1,), (3,), (7,), (10,), (42,), (None,), (None,)]
	-- same thing
SELECT * FROM foo ORDER BY f1 NULLS FIRST
RESULT: 
	[(None,), (None,), (1,), (3,), (7,), (10,), (42,)]

SELECT * FROM foo ORDER BY f1 DESC
RESULT: 
	[(42,), (10,), (7,), (3,), (1,), (None,), (None,)]

SELECT * FROM foo ORDER BY f1 DESC NULLS LAST
RESULT: 
	[(42,), (10,), (7,), (3,), (1,), (None,), (None,)]


-- check if indexscans do the right things
CREATE INDEX fooi ON foo (f1)

SET enable_sort = false
ERROR: 
SET enable_sort = false

Catalog Error: unrecognized configuration parameter "enable_sort"

Did you mean: "enable_fsst_vectors"


SELECT * FROM foo ORDER BY f1
RESULT: 
	[(1,), (3,), (7,), (10,), (42,), (None,), (None,)]

SELECT * FROM foo ORDER BY f1 NULLS FIRST
RESULT: 
	[(None,), (None,), (1,), (3,), (7,), (10,), (42,)]

SELECT * FROM foo ORDER BY f1 DESC
RESULT: 
	[(42,), (10,), (7,), (3,), (1,), (None,), (None,)]

SELECT * FROM foo ORDER BY f1 DESC NULLS LAST
RESULT: 
	[(42,), (10,), (7,), (3,), (1,), (None,), (None,)]


DROP INDEX fooi

CREATE INDEX fooi ON foo (f1 DESC)


SELECT * FROM foo ORDER BY f1
RESULT: 
	[(1,), (3,), (7,), (10,), (42,), (None,), (None,)]

SELECT * FROM foo ORDER BY f1 NULLS FIRST
RESULT: 
	[(None,), (None,), (1,), (3,), (7,), (10,), (42,)]

SELECT * FROM foo ORDER BY f1 DESC
RESULT: 
	[(42,), (10,), (7,), (3,), (1,), (None,), (None,)]

SELECT * FROM foo ORDER BY f1 DESC NULLS LAST
RESULT: 
	[(42,), (10,), (7,), (3,), (1,), (None,), (None,)]


DROP INDEX fooi

CREATE INDEX fooi ON foo (f1 DESC NULLS LAST)


SELECT * FROM foo ORDER BY f1
RESULT: 
	[(1,), (3,), (7,), (10,), (42,), (None,), (None,)]

SELECT * FROM foo ORDER BY f1 NULLS FIRST
RESULT: 
	[(None,), (None,), (1,), (3,), (7,), (10,), (42,)]

SELECT * FROM foo ORDER BY f1 DESC
RESULT: 
	[(42,), (10,), (7,), (3,), (1,), (None,), (None,)]

SELECT * FROM foo ORDER BY f1 DESC NULLS LAST
RESULT: 
	[(42,), (10,), (7,), (3,), (1,), (None,), (None,)]


--
-- Test planning of some cases with partial indexes
--

-- partial index is usable
explain (costs off)
select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA'
ERROR: 

--
-- Test planning of some cases with partial indexes
--

-- partial index is usable
explain (costs off)
select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA'

Not implemented Error: Unimplemented explain type: costs

select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA'
ERROR: 
select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA'

Catalog Error: Table with name onek2 does not exist!
Did you mean "foo"?

-- actually run the query with an analyze to use the partial index
explain (costs off, analyze on, timing off, summary off)
select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA'
ERROR: 
-- actually run the query with an analyze to use the partial index
explain (costs off, analyze on, timing off, summary off)
select * from onek2 where unique2 = 11 and stringu1 = 'ATAAAA'

Not implemented Error: Unimplemented explain type: costs

explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA'
ERROR: 
explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA'

Not implemented Error: Unimplemented explain type: costs

select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA'
ERROR: 
select unique2 from onek2 where unique2 = 11 and stringu1 = 'ATAAAA'

Catalog Error: Table with name onek2 does not exist!
Did you mean "foo"?

-- partial index predicate implies clause, so no need for retest
explain (costs off)
select * from onek2 where unique2 = 11 and stringu1 < 'B'
ERROR: 
-- partial index predicate implies clause, so no need for retest
explain (costs off)
select * from onek2 where unique2 = 11 and stringu1 < 'B'

Not implemented Error: Unimplemented explain type: costs

select * from onek2 where unique2 = 11 and stringu1 < 'B'
ERROR: 
select * from onek2 where unique2 = 11 and stringu1 < 'B'

Catalog Error: Table with name onek2 does not exist!
Did you mean "foo"?

explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B'
ERROR: 
explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B'

Not implemented Error: Unimplemented explain type: costs

select unique2 from onek2 where unique2 = 11 and stringu1 < 'B'
ERROR: 
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B'

Catalog Error: Table with name onek2 does not exist!
Did you mean "foo"?

-- but if it''s an update target, must retest anyway
explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update
ERROR: 
-- but if it''s an update target, must retest anyway
explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update

Not implemented Error: Unimplemented explain type: costs

select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update
ERROR: 
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B' for update

Parser Error: SELECT locking clause is not supported!

-- partial index is not applicable
explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'C'
ERROR: 
-- partial index is not applicable
explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'C'

Not implemented Error: Unimplemented explain type: costs

select unique2 from onek2 where unique2 = 11 and stringu1 < 'C'
ERROR: 
select unique2 from onek2 where unique2 = 11 and stringu1 < 'C'

Catalog Error: Table with name onek2 does not exist!
Did you mean "foo"?

-- partial index implies clause, but bitmap scan must recheck predicate anyway
SET enable_indexscan TO off
ERROR: 
-- partial index implies clause, but bitmap scan must recheck predicate anyway
SET enable_indexscan TO off

Catalog Error: unrecognized configuration parameter "enable_indexscan"

Did you mean: "Calendar"

explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B'
ERROR: 
explain (costs off)
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B'

Not implemented Error: Unimplemented explain type: costs

select unique2 from onek2 where unique2 = 11 and stringu1 < 'B'
ERROR: 
select unique2 from onek2 where unique2 = 11 and stringu1 < 'B'

Catalog Error: Table with name onek2 does not exist!
Did you mean "foo"?

RESET enable_indexscan
ERROR: 
RESET enable_indexscan

Catalog Error: unrecognized configuration parameter "enable_indexscan"

Did you mean: "Calendar"

-- check multi-index cases too
explain (costs off)
select unique1, unique2 from onek2
  where (unique2 = 11 or unique1 = 0) and stringu1 < 'B'
ERROR: 
-- check multi-index cases too
explain (costs off)
select unique1, unique2 from onek2
  where (unique2 = 11 or unique1 = 0) and stringu1 < 'B'

Not implemented Error: Unimplemented explain type: costs

select unique1, unique2 from onek2
  where (unique2 = 11 or unique1 = 0) and stringu1 < 'B'
ERROR: 
select unique1, unique2 from onek2
  where (unique2 = 11 or unique1 = 0) and stringu1 < 'B'

Catalog Error: Table with name onek2 does not exist!
Did you mean "foo"?

explain (costs off)
select unique1, unique2 from onek2
  where (unique2 = 11 and stringu1 < 'B') or unique1 = 0
ERROR: 
explain (costs off)
select unique1, unique2 from onek2
  where (unique2 = 11 and stringu1 < 'B') or unique1 = 0

Not implemented Error: Unimplemented explain type: costs

select unique1, unique2 from onek2
  where (unique2 = 11 and stringu1 < 'B') or unique1 = 0
ERROR: 
select unique1, unique2 from onek2
  where (unique2 = 11 and stringu1 < 'B') or unique1 = 0

Catalog Error: Table with name onek2 does not exist!
Did you mean "foo"?


--
-- Test some corner cases that have been known to confuse the planner
--

-- ORDER BY on a constant doesn''t really need any sorting
SELECT 1 AS x ORDER BY x
RESULT: 
	[(1,)]


-- But ORDER BY on a set-valued expression does
create function sillysrf(int) returns setof int as
  'values (1),(10),(2),($1)' language sql immutable
ERROR: 

-- But ORDER BY on a set-valued expression does
create function sillysrf(int) returns setof int as
  'values (1),(10),(2),($1)' language sql immutable

Parser Error: syntax error at or near "returns"


select sillysrf(42)
ERROR: 

select sillysrf(42)

Catalog Error: Scalar Function with name sillysrf does not exist!
Did you mean "instr"?

select sillysrf(-1) order by 1
ERROR: 
select sillysrf(-1) order by 1

Catalog Error: Scalar Function with name sillysrf does not exist!
Did you mean "instr"?


drop function sillysrf(int)
ERROR: 

drop function sillysrf(int)

Parser Error: syntax error at or near "("


-- X = X isn''t a no-op, it''s effectively X IS NOT NULL assuming = is strict
-- (see bug #5084)
select * from (values (2),(null),(1)) v(k) where k = k order by k
RESULT: 
	[(1,), (2,)]

select * from (values (2),(null),(1)) v(k) where k = k
RESULT: 
	[(2,), (1,)]


-- Test partitioned tables with no partitions, which should be handled the
-- same as the non-inheritance case when expanding its RTE.
create table list_parted_tbl (a int,b int) partition by list (a)
ERROR: 

-- Test partitioned tables with no partitions, which should be handled the
-- same as the non-inheritance case when expanding its RTE.
create table list_parted_tbl (a int,b int) partition by list (a)

Parser Error: syntax error at or near "partition"

create table list_parted_tbl1 partition of list_parted_tbl
  for values in (1) partition by list(b)
ERROR: 
create table list_parted_tbl1 partition of list_parted_tbl
  for values in (1) partition by list(b)

Parser Error: syntax error at or near "partition"

explain (costs off) select * from list_parted_tbl
ERROR: 
explain (costs off) select * from list_parted_tbl

Not implemented Error: Unimplemented explain type: costs

drop table list_parted_tbl
ERROR: 
drop table list_parted_tbl

Catalog Error: Table with name list_parted_tbl does not exist!
Did you mean "CHAR_TBL"?


