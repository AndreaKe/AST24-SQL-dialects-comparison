
-----------
QUERY:
--
-- SELECT_DISTINCT
--

--
-- awk /* REPLACED */''{print $3 /* REPLACED */,}/* REPLACED */'' onek.data | sort -n | uniq
--
SELECT DISTINCT two FROM onek ORDER BY 1
RESULT:
	postgres: [(0,), (1,)]

-----------
QUERY:
--
-- awk /* REPLACED */''{print $5 /* REPLACED */,}/* REPLACED */'' onek.data | sort -n | uniq
--
SELECT DISTINCT ten FROM onek ORDER BY 1
RESULT:
	postgres: [(0,), (1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,), (9,)]

-----------
QUERY:
--
-- awk /* REPLACED */''{print $16 /* REPLACED */,}/* REPLACED */'' onek.data | sort -d | uniq
--
SELECT DISTINCT string4 FROM onek ORDER BY 1
RESULT:
	postgres: [('AAAAxx',), ('HHHHxx',), ('OOOOxx',), ('VVVVxx',)]

-----------
QUERY:
--
-- awk /* REPLACED */''{print $3,$16,$5 /* REPLACED */,}/* REPLACED */'' onek.data | sort -d | uniq |
-- sort +0n -1 +1d -2 +2n -3
--
SELECT DISTINCT two, string4, ten
   FROM onek
   ORDER BY two using <, string4 using <, ten using <
RESULT:
	postgres: [(0, 'AAAAxx', 0), (0, 'AAAAxx', 2), (0, 'AAAAxx', 4), (0, 'AAAAxx', 6), (0, 'AAAAxx', 8), (0, 'HHHHxx', 0), (0, 'HHHHxx', 2), (0, 'HHHHxx', 4), (0, 'HHHHxx', 6), (0, 'HHHHxx', 8), (0, 'OOOOxx', 0), (0, 'OOOOxx', 2), (0, 'OOOOxx', 4), (0, 'OOOOxx', 6), (0, 'OOOOxx', 8), (0, 'VVVVxx', 0), (0, 'VVVVxx', 2), (0, 'VVVVxx', 4), (0, 'VVVVxx', 6), (0, 'VVVVxx', 8), (1, 'AAAAxx', 1), (1, 'AAAAxx', 3), (1, 'AAAAxx', 5), (1, 'AAAAxx', 7), (1, 'AAAAxx', 9), (1, 'HHHHxx', 1), (1, 'HHHHxx', 3), (1, 'HHHHxx', 5), (1, 'HHHHxx', 7), (1, 'HHHHxx', 9), (1, 'OOOOxx', 1), (1, 'OOOOxx', 3), (1, 'OOOOxx', 5), (1, 'OOOOxx', 7), (1, 'OOOOxx', 9), (1, 'VVVVxx', 1), (1, 'VVVVxx', 3), (1, 'VVVVxx', 5), (1, 'VVVVxx', 7), (1, 'VVVVxx', 9)]

-----------
QUERY:
--
-- awk /* REPLACED */''{print $2 /* REPLACED */,}/* REPLACED */'' person.data |
-- awk /* REPLACED */''{if(NF!=1){print $2 /* REPLACED */,}else{print /* REPLACED */,}}/* REPLACED */'' - emp.data |
-- awk /* REPLACED */''{if(NF!=1){print $2 /* REPLACED */,}else{print /* REPLACED */,}}/* REPLACED */'' - student.data |
-- awk /* REPLACED */''BEGIN{FS=/* REPLACED */''      /* REPLACED */'' /* REPLACED */,}{if(NF!=1){print $5 /* REPLACED */,}else{print /* REPLACED */,}}/* REPLACED */'' - stud_emp.data |
-- sort -n -r | uniq
--
SELECT DISTINCT p.age FROM person* p ORDER BY age using >
RESULT:
	postgres: [(98,), (88,), (78,), (68,), (60,), (58,), (50,), (48,), (40,), (38,), (34,), (30,), (28,), (25,), (24,), (23,), (20,), (19,), (18,), (8,)]

-----------
QUERY:
--
-- Check mentioning same column more than once
--

EXPLAIN (VERBOSE, COSTS OFF)
SELECT count(*) FROM
  (SELECT DISTINCT two, four, two FROM tenk1) ss
RESULT:
	postgres: [('Aggregate',), ('  Output: count(*)',), ('  ->  HashAggregate',), ('        Output: tenk1.two, tenk1.four, tenk1.two',), ('        Group Key: tenk1.two, tenk1.four',), ('        ->  Seq Scan on public.tenk1',), ('              Output: tenk1.two, tenk1.four, tenk1.two',)]

-----------
QUERY:
SELECT count(*) FROM
  (SELECT DISTINCT two, four, two FROM tenk1) ss
RESULT:
	postgres: [(4,)]

-----------
QUERY:
--
-- Compare results between plans using sorting and plans using hash
-- aggregation. Force spilling in both cases by setting work_mem low.
--

SET work_mem='64kB'
RESULT:
	postgres: None

-----------
QUERY:
-- Produce results with sorting.

SET enable_hashagg=FALSE
RESULT:
	postgres: None

-----------
QUERY:
SET jit_above_cost=0
RESULT:
	postgres: None

-----------
QUERY:
EXPLAIN (costs off)
SELECT DISTINCT g%1000 FROM generate_series(0,9999) g
RESULT:
	postgres: [('Unique',), ('  ->  Sort',), ('        Sort Key: ((g % 1000))',), ('        ->  Function Scan on generate_series g',)]

-----------
QUERY:
CREATE TABLE distinct_group_1 AS
SELECT DISTINCT g%1000 FROM generate_series(0,9999) g
RESULT:
	postgres: None

-----------
QUERY:
SET jit_above_cost TO DEFAULT
RESULT:
	postgres: None

-----------
QUERY:
CREATE TABLE distinct_group_2 AS
SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g
RESULT:
	postgres: None

-----------
QUERY:
SET enable_seqscan = 0
RESULT:
	postgres: None

-----------
QUERY:
-- Check to see we get an incremental sort plan
EXPLAIN (costs off)
SELECT DISTINCT hundred, two FROM tenk1
RESULT:
	postgres: [('Unique',), ('  ->  Incremental Sort',), ('        Sort Key: hundred, two',), ('        Presorted Key: hundred',), ('        ->  Index Scan using tenk1_hundred on tenk1',)]

-----------
QUERY:
RESET enable_seqscan
RESULT:
	postgres: None

-----------
QUERY:
SET enable_hashagg=TRUE
RESULT:
	postgres: None

-----------
QUERY:
-- Produce results with hash aggregation.

SET enable_sort=FALSE
RESULT:
	postgres: None

-----------
QUERY:
SET jit_above_cost=0
RESULT:
	postgres: None

-----------
QUERY:
EXPLAIN (costs off)
SELECT DISTINCT g%1000 FROM generate_series(0,9999) g
RESULT:
	postgres: [('HashAggregate',), ('  Group Key: (g % 1000)',), ('  ->  Function Scan on generate_series g',)]

-----------
QUERY:
CREATE TABLE distinct_hash_1 AS
SELECT DISTINCT g%1000 FROM generate_series(0,9999) g
RESULT:
	postgres: None

-----------
QUERY:
SET jit_above_cost TO DEFAULT
RESULT:
	postgres: None

-----------
QUERY:
CREATE TABLE distinct_hash_2 AS
SELECT DISTINCT (g%1000)::text FROM generate_series(0,9999) g
RESULT:
	postgres: None

-----------
QUERY:
SET enable_sort=TRUE
RESULT:
	postgres: None

-----------
QUERY:
SET work_mem TO DEFAULT
RESULT:
	postgres: None

-----------
QUERY:
-- Compare results

(SELECT * FROM distinct_hash_1 EXCEPT SELECT * FROM distinct_group_1)
  UNION ALL
(SELECT * FROM distinct_group_1 EXCEPT SELECT * FROM distinct_hash_1)
RESULT:
	postgres: []

-----------
QUERY:
(SELECT * FROM distinct_hash_1 EXCEPT SELECT * FROM distinct_group_1)
  UNION ALL
(SELECT * FROM distinct_group_1 EXCEPT SELECT * FROM distinct_hash_1)
RESULT:
	postgres: []

-----------
QUERY:
DROP TABLE distinct_hash_1
RESULT:
	postgres: None

-----------
QUERY:
DROP TABLE distinct_hash_2
RESULT:
	postgres: None

-----------
QUERY:
DROP TABLE distinct_group_1
RESULT:
	postgres: None

-----------
QUERY:
DROP TABLE distinct_group_2
RESULT:
	postgres: None

-----------
QUERY:
-- Test parallel DISTINCT
SET parallel_tuple_cost=0
RESULT:
	postgres: None

-----------
QUERY:
SET parallel_setup_cost=0
RESULT:
	postgres: None

-----------
QUERY:
SET min_parallel_table_scan_size=0
RESULT:
	postgres: None

-----------
QUERY:
SET max_parallel_workers_per_gather=2
RESULT:
	postgres: None

-----------
QUERY:
-- Ensure we get a parallel plan
EXPLAIN (costs off)
SELECT DISTINCT four FROM tenk1
RESULT:
	postgres: [('Unique',), ('  ->  Gather Merge',), ('        Workers Planned: 2',), ('        ->  Sort',), ('              Sort Key: four',), ('              ->  HashAggregate',), ('                    Group Key: four',), ('                    ->  Parallel Seq Scan on tenk1',)]

-----------
QUERY:
-- Ensure the parallel plan produces the correct results
SELECT DISTINCT four FROM tenk1
RESULT:
	postgres: [(0,), (1,), (2,), (3,)]

-----------
QUERY:
CREATE OR REPLACE FUNCTION distinct_func(a INT) RETURNS INT AS $$
  BEGIN
    RETURN a;
  END;
$$ LANGUAGE plpgsql PARALLEL UNSAFE
RESULT:
	postgres: None

-----------
QUERY:
-- Ensure we don/* REPLACED */''t do parallel distinct with a parallel unsafe function
EXPLAIN (COSTS OFF)
SELECT DISTINCT distinct_func(1) FROM tenk1
RESULT:
	postgres: [('Unique',), ('  ->  Sort',), ('        Sort Key: (distinct_func(1))',), ('        ->  Index Only Scan using tenk1_hundred on tenk1',)]

-----------
QUERY:
-- make the function parallel safe
CREATE OR REPLACE FUNCTION distinct_func(a INT) RETURNS INT AS $$
  BEGIN
    RETURN a;
  END;
$$ LANGUAGE plpgsql PARALLEL SAFE
RESULT:
	postgres: None

-----------
QUERY:
-- Ensure we do parallel distinct now that the function is parallel safe
EXPLAIN (COSTS OFF)
SELECT DISTINCT distinct_func(1) FROM tenk1
RESULT:
	postgres: [('Unique',), ('  ->  Gather Merge',), ('        Workers Planned: 2',), ('        ->  Unique',), ('              ->  Sort',), ('                    Sort Key: (distinct_func(1))',), ('                    ->  Parallel Seq Scan on tenk1',)]

-----------
QUERY:
RESET max_parallel_workers_per_gather
RESULT:
	postgres: None

-----------
QUERY:
RESET min_parallel_table_scan_size
RESULT:
	postgres: None

-----------
QUERY:
RESET parallel_setup_cost
RESULT:
	postgres: None

-----------
QUERY:
RESET parallel_tuple_cost
RESULT:
	postgres: None

-----------
QUERY:
--
-- Test the planner/* REPLACED */''s ability to use a LIMIT 1 instead of a Unique node when
-- all of the distinct_pathkeys have been marked as redundant
--

-- Ensure we get a plan with a Limit 1
EXPLAIN (COSTS OFF)
SELECT DISTINCT four FROM tenk1 WHERE four = 0
RESULT:
	postgres: [('Limit',), ('  ->  Seq Scan on tenk1',), ('        Filter: (four = 0)',)]

-----------
QUERY:
-- Ensure the above gives us the correct result
SELECT DISTINCT four FROM tenk1 WHERE four = 0
RESULT:
	postgres: [(0,)]

-----------
QUERY:
-- Ensure we get a plan with a Limit 1
EXPLAIN (COSTS OFF)
SELECT DISTINCT four FROM tenk1 WHERE four = 0 AND two <> 0
RESULT:
	postgres: [('Limit',), ('  ->  Seq Scan on tenk1',), ('        Filter: ((two <> 0) AND (four = 0))',)]

-----------
QUERY:
-- Ensure no rows are returned
SELECT DISTINCT four FROM tenk1 WHERE four = 0 AND two <> 0
RESULT:
	postgres: []

-----------
QUERY:
-- Ensure we get a plan with a Limit 1 when the SELECT list contains constants
EXPLAIN (COSTS OFF)
SELECT DISTINCT four,1,2,3 FROM tenk1 WHERE four = 0
RESULT:
	postgres: [('Limit',), ('  ->  Seq Scan on tenk1',), ('        Filter: (four = 0)',)]

-----------
QUERY:
-- Ensure we only get 1 row
SELECT DISTINCT four,1,2,3 FROM tenk1 WHERE four = 0
RESULT:
	postgres: [(0, 1, 2, 3)]

-----------
QUERY:
SET parallel_setup_cost=0
RESULT:
	postgres: None

-----------
QUERY:
SET min_parallel_table_scan_size=0
RESULT:
	postgres: None

-----------
QUERY:
SET max_parallel_workers_per_gather=2
RESULT:
	postgres: None

-----------
QUERY:
-- Ensure we get a plan with a Limit 1 in both partial distinct and final
-- distinct
EXPLAIN (COSTS OFF)
SELECT DISTINCT four FROM tenk1 WHERE four = 10
RESULT:
	postgres: [('Limit',), ('  ->  Gather',), ('        Workers Planned: 2',), ('        ->  Limit',), ('              ->  Parallel Seq Scan on tenk1',), ('                    Filter: (four = 10)',)]

-----------
QUERY:
RESET max_parallel_workers_per_gather
RESULT:
	postgres: None

-----------
QUERY:
RESET min_parallel_table_scan_size
RESULT:
	postgres: None

-----------
QUERY:
RESET parallel_setup_cost
RESULT:
	postgres: None

-----------
QUERY:
--
-- Also, some tests of IS DISTINCT FROM, which doesn/* REPLACED */''t quite deserve its
-- very own regression file.
--

CREATE TEMP TABLE disttable (f1 integer)
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO DISTTABLE VALUES(1)
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO DISTTABLE VALUES(2)
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO DISTTABLE VALUES(3)
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO DISTTABLE VALUES(NULL)
RESULT:
	postgres: None

-----------
QUERY:
-- basic cases
SELECT f1, f1 IS DISTINCT FROM 2 as "not 2" FROM disttable
RESULT:
	postgres: [(1, True), (2, False), (3, True), (None, True)]

-----------
QUERY:
SELECT f1, f1 IS DISTINCT FROM NULL as "not null" FROM disttable
RESULT:
	postgres: [(1, True), (2, True), (3, True), (None, False)]

-----------
QUERY:
SELECT f1, f1 IS DISTINCT FROM f1 as "false" FROM disttable
RESULT:
	postgres: [(1, False), (2, False), (3, False), (None, False)]

-----------
QUERY:
SELECT f1, f1 IS DISTINCT FROM f1+1 as "not null" FROM disttable
RESULT:
	postgres: [(1, True), (2, True), (3, True), (None, False)]

-----------
QUERY:
-- check that optimizer constant-folds it properly
SELECT 1 IS DISTINCT FROM 2 as "yes"
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT 2 IS DISTINCT FROM 2 as "no"
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT 2 IS DISTINCT FROM null as "yes"
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT null IS DISTINCT FROM null as "no"
RESULT:
	postgres: [(False,)]

-----------
QUERY:
-- negated form
SELECT 1 IS NOT DISTINCT FROM 2 as "no"
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT 2 IS NOT DISTINCT FROM 2 as "yes"
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT 2 IS NOT DISTINCT FROM null as "no"
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT null IS NOT DISTINCT FROM null as "yes"
RESULT:
	postgres: [(True,)]
