-- START setup from test_setup 
--
-- TEST_SETUP --- prepare environment expected by regression test scripts
--
-- directory paths and dlsuffix are passed to us in environment variables
\getenv abs_srcdir PG_ABS_SRCDIR
\getenv libdir PG_LIBDIR
\getenv dlsuffix PG_DLSUFFIX
\set regresslib :libdir '/regress' :dlsuffix
--
-- synchronous_commit=off delays when hint bits may be set. Some plans change
-- depending on the number of all-visible pages, which in turn can be
-- influenced by the delayed hint bits. Force synchronous_commit=on to avoid
-- that source of variability.
--
SET synchronous_commit = on;
--
-- Postgres formerly made the public schema read/write by default,
-- and most of the core regression tests still expect that.
--
GRANT ALL ON SCHEMA public TO public;
-- Create a tablespace we can use in tests.
SET allow_in_place_tablespaces = true;
CREATE TABLESPACE regress_tblspace LOCATION '';
--
-- These tables have traditionally been referenced by many tests,
-- so create and populate them.  Insert only non-error values here.
-- (Some subsequent tests try to insert erroneous values.  That's okay
-- because the table won't actually change.  Do not change the contents
-- of these tables in later tests, as it may affect other tests.)
--
CREATE TABLE CHAR_TBL(f1 char(4));
INSERT INTO CHAR_TBL (f1) VALUES
  ('a'),
  ('ab'),
  ('abcd'),
  ('abcd    ');
VACUUM CHAR_TBL;
CREATE TABLE FLOAT8_TBL(f1 float8);
INSERT INTO FLOAT8_TBL(f1) VALUES
  ('0.0'),
  ('-34.84'),
  ('-1004.30'),
  ('-1.2345678901234e+200'),
  ('-1.2345678901234e-200');
VACUUM FLOAT8_TBL;
CREATE TABLE INT2_TBL(f1 int2);
INSERT INTO INT2_TBL(f1) VALUES
  ('0   '),
  ('  1234 '),
  ('    -1234'),
  ('32767'),  -- largest and smallest values
  ('-32767');
VACUUM INT2_TBL;
CREATE TABLE INT4_TBL(f1 int4);
INSERT INTO INT4_TBL(f1) VALUES
  ('   0  '),
  ('123456     '),
  ('    -123456'),
  ('2147483647'),  -- largest and smallest values
  ('-2147483647');
VACUUM INT4_TBL;
CREATE TABLE INT8_TBL(q1 int8, q2 int8);
INSERT INTO INT8_TBL VALUES
  ('  123   ','  456'),
  ('123   ','4567890123456789'),
  ('4567890123456789','123'),
  (+4567890123456789,'4567890123456789'),
  ('+4567890123456789','-4567890123456789');
VACUUM INT8_TBL;
CREATE TABLE POINT_TBL(f1 point);
INSERT INTO POINT_TBL(f1) VALUES
  ('(0.0,0.0)'),
  ('(-10.0,0.0)'),
  ('(-3.0,4.0)'),
  ('(5.1, 34.5)'),
  ('(-5.0,-12.0)'),
  ('(1e-300,-1e-300)'),  -- To underflow
  ('(1e+300,Inf)'),  -- To overflow
  ('(Inf,1e+300)'),  -- Transposed
  (' ( Nan , NaN ) '),
  ('10.0,10.0');
-- We intentionally don't vacuum point_tbl here; geometry depends on that
CREATE TABLE TEXT_TBL (f1 text);
INSERT INTO TEXT_TBL VALUES
  ('doh!'),
  ('hi de ho neighbor');
VACUUM TEXT_TBL;
CREATE TABLE VARCHAR_TBL(f1 varchar(4));
INSERT INTO VARCHAR_TBL (f1) VALUES
  ('a'),
  ('ab'),
  ('abcd'),
  ('abcd    ');
VACUUM VARCHAR_TBL;
CREATE TABLE onek (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
\set filename :abs_srcdir '/data/onek.data'
COPY onek FROM :'filename';
VACUUM ANALYZE onek;
CREATE TABLE onek2 AS SELECT * FROM onek;
VACUUM ANALYZE onek2;
CREATE TABLE tenk1 (
	unique1		int4,
	unique2		int4,
	two			int4,
	four		int4,
	ten			int4,
	twenty		int4,
	hundred		int4,
	thousand	int4,
	twothousand	int4,
	fivethous	int4,
	tenthous	int4,
	odd			int4,
	even		int4,
	stringu1	name,
	stringu2	name,
	string4		name
);
\set filename :abs_srcdir '/data/tenk.data'
COPY tenk1 FROM :'filename';
VACUUM ANALYZE tenk1;
CREATE TABLE tenk2 AS SELECT * FROM tenk1;
VACUUM ANALYZE tenk2;
CREATE TABLE person (
	name 		text,
	age			int4,
	location 	point
);
\set filename :abs_srcdir '/data/person.data'
COPY person FROM :'filename';
VACUUM ANALYZE person;
CREATE TABLE emp (
	salary 		int4,
	manager 	name
) INHERITS (person);
\set filename :abs_srcdir '/data/emp.data'
COPY emp FROM :'filename';
VACUUM ANALYZE emp;
CREATE TABLE student (
	gpa 		float8
) INHERITS (person);
\set filename :abs_srcdir '/data/student.data'
COPY student FROM :'filename';
VACUUM ANALYZE student;
CREATE TABLE stud_emp (
	percent 	int4
) INHERITS (emp, student);
NOTICE:  merging multiple inherited definitions of column "name"
NOTICE:  merging multiple inherited definitions of column "age"
NOTICE:  merging multiple inherited definitions of column "location"
\set filename :abs_srcdir '/data/stud_emp.data'
COPY stud_emp FROM :'filename';
VACUUM ANALYZE stud_emp;
CREATE TABLE road (
	name		text,
	thepath 	path
);
\set filename :abs_srcdir '/data/streets.data'
COPY road FROM :'filename';
VACUUM ANALYZE road;
CREATE TABLE ihighway () INHERITS (road);
INSERT INTO ihighway
   SELECT *
   FROM ONLY road
   WHERE name ~ 'I- .*';
VACUUM ANALYZE ihighway;
CREATE TABLE shighway (
	surface		text
) INHERITS (road);
INSERT INTO shighway
   SELECT *, 'asphalt'
   FROM ONLY road
   WHERE name ~ 'State Hwy.*';
VACUUM ANALYZE shighway;
--
-- We must have some enum type in the database for opr_sanity and type_sanity.
--
create type stoplight as enum ('red', 'yellow', 'green');
--
-- Also create some non-built-in range types.
--
create type float8range as range (subtype = float8, subtype_diff = float8mi);
create type textrange as range (subtype = text, collation = "C");
--
-- Create some C functions that will be used by various tests.
--
CREATE FUNCTION binary_coercible(oid, oid)
    RETURNS bool
    AS :'regresslib', 'binary_coercible'
    LANGUAGE C STRICT STABLE PARALLEL SAFE;
CREATE FUNCTION ttdummy ()
    RETURNS trigger
    AS :'regresslib'
    LANGUAGE C;
-- Use hand-rolled hash functions and operator classes to get predictable
-- result on different machines.  The hash function for int4 simply returns
-- the sum of the values passed to it and the one for text returns the length
-- of the non-empty string value passed to it or 0.
create function part_hashint4_noop(value int4, seed int8)
    returns int8 as $$
    select value + seed;
    $$ language sql strict immutable parallel safe;
create operator class part_test_int4_ops for type int4 using hash as
    operator 1 =,
    function 2 part_hashint4_noop(int4, int8);
create function part_hashtext_length(value text, seed int8)
    returns int8 as $$
    select length(coalesce(value, ''))::int8
    $$ language sql strict immutable parallel safe;
create operator class part_test_text_ops for type text using hash as
    operator 1 =,
    function 2 part_hashtext_length(text, int8);
--
-- These functions are used in tests that used to use md5(), which we now
-- mostly avoid so that the tests will pass in FIPS mode.
--
create function fipshash(bytea)
    returns text
    strict immutable parallel safe leakproof
    return substr(encode(sha256($1), 'hex'), 1, 32);
create function fipshash(text)
    returns text
    strict immutable parallel safe leakproof
    return substr(encode(sha256($1::bytea), 'hex'), 1, 32);
-- END setup from test_setup 
-- START setup from create_index 
--
-- CREATE_INDEX
-- Create ancillary data structures (i.e. indices)
--
-- directory paths are passed to us in environment variables
\getenv abs_srcdir PG_ABS_SRCDIR
--
-- BTREE
--
CREATE INDEX onek_unique1 ON onek USING btree(unique1 int4_ops);
CREATE INDEX IF NOT EXISTS onek_unique1 ON onek USING btree(unique1 int4_ops);
NOTICE:  relation "onek_unique1" already exists, skipping
CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops);
ERROR:  syntax error at or near "ON"
LINE 1: CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_...
                                   ^
CREATE INDEX onek_unique2 ON onek USING btree(unique2 int4_ops);
CREATE INDEX onek_hundred ON onek USING btree(hundred int4_ops);
CREATE INDEX onek_stringu1 ON onek USING btree(stringu1 name_ops);
CREATE INDEX tenk1_unique1 ON tenk1 USING btree(unique1 int4_ops);
CREATE INDEX tenk1_unique2 ON tenk1 USING btree(unique2 int4_ops);
CREATE INDEX tenk1_hundred ON tenk1 USING btree(hundred int4_ops);
CREATE INDEX tenk1_thous_tenthous ON tenk1 (thousand, tenthous);
CREATE INDEX tenk2_unique1 ON tenk2 USING btree(unique1 int4_ops);
CREATE INDEX tenk2_unique2 ON tenk2 USING btree(unique2 int4_ops);
CREATE INDEX tenk2_hundred ON tenk2 USING btree(hundred int4_ops);
CREATE INDEX rix ON road USING btree (name text_ops);
CREATE INDEX iix ON ihighway USING btree (name text_ops);
CREATE INDEX six ON shighway USING btree (name text_ops);
-- test comments
COMMENT ON INDEX six_wrong IS 'bad index';
ERROR:  relation "six_wrong" does not exist
COMMENT ON INDEX six IS 'good index';
COMMENT ON INDEX six IS NULL;
--
-- BTREE partial indices
--
CREATE INDEX onek2_u1_prtl ON onek2 USING btree(unique1 int4_ops)
	where unique1 < 20 or unique1 > 980;
CREATE INDEX onek2_u2_prtl ON onek2 USING btree(unique2 int4_ops)
	where stringu1 < 'B';
CREATE INDEX onek2_stu1_prtl ON onek2 USING btree(stringu1 name_ops)
	where onek2.stringu1 >= 'J' and onek2.stringu1 < 'K';
--
-- GiST (rtree-equivalent opclasses only)
--
CREATE TABLE slow_emp4000 (
	home_base	 box
);
CREATE TABLE fast_emp4000 (
	home_base	 box
);
\set filename :abs_srcdir '/data/rect.data'
COPY slow_emp4000 FROM :'filename';
INSERT INTO fast_emp4000 SELECT * FROM slow_emp4000;
ANALYZE slow_emp4000;
ANALYZE fast_emp4000;
CREATE INDEX grect2ind ON fast_emp4000 USING gist (home_base);
-- we want to work with a point_tbl that includes a null
CREATE TEMP TABLE point_tbl AS SELECT * FROM public.point_tbl;
INSERT INTO POINT_TBL(f1) VALUES (NULL);
CREATE INDEX gpointind ON point_tbl USING gist (f1);
CREATE TEMP TABLE gpolygon_tbl AS
    SELECT polygon(home_base) AS f1 FROM slow_emp4000;
INSERT INTO gpolygon_tbl VALUES ( '(1000,0,0,1000)' );
INSERT INTO gpolygon_tbl VALUES ( '(0,1000,1000,1000)' );
CREATE TEMP TABLE gcircle_tbl AS
    SELECT circle(home_base) AS f1 FROM slow_emp4000;
CREATE INDEX ggpolygonind ON gpolygon_tbl USING gist (f1);
CREATE INDEX ggcircleind ON gcircle_tbl USING gist (f1);
--
-- Test GiST indexes
--
-- get non-indexed results for comparison purposes
SET enable_seqscan = ON;
SET enable_indexscan = OFF;
SET enable_bitmapscan = OFF;
SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
       home_base       
-----------------------
 (337,455),(240,359)
 (1444,403),(1346,344)
(2 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
 count 
-------
     2
(1 row)

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
 count 
-------
   278
(1 row)

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
 count 
-------
     2
(1 row)

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
 count 
-------
     2
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
 count 
-------
     5
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
 count 
-------
     1
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
 count 
-------
     4
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
 count 
-------
     1
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
 count 
-------
     5
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
 count 
-------
     1
(1 row)

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (Infinity,1e+300)
 (1e+300,Infinity)
 (NaN,NaN)
 
(11 rows)

SELECT * FROM point_tbl WHERE f1 IS NULL;
 f1 
----
 
(1 row)

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (1e+300,Infinity)
 (Infinity,1e+300)
 (NaN,NaN)
(10 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                       f1                        
-------------------------------------------------
 ((240,359),(240,455),(337,455),(337,359))
 ((662,163),(662,187),(759,187),(759,163))
 ((1000,0),(0,1000))
 ((0,1000),(1000,1000))
 ((1346,344),(1346,403),(1444,403),(1444,344))
 ((278,1409),(278,1457),(369,1457),(369,1409))
 ((907,1156),(907,1201),(948,1201),(948,1156))
 ((1517,971),(1517,1043),(1594,1043),(1594,971))
 ((175,1820),(175,1850),(259,1850),(259,1820))
 ((2424,81),(2424,160),(2424,160),(2424,81))
(10 rows)

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 circle_center  | radius 
----------------+--------
 (288.5,407)    |     68
 (710.5,175)    |     50
 (323.5,1433)   |     51
 (927.5,1178.5) |     30
 (1395,373.5)   |     57
 (1555.5,1007)  |     53
 (217,1835)     |     45
 (489,2421.5)   |     22
 (2424,120.5)   |     40
 (751.5,2655)   |     20
(10 rows)

-- Now check the results from plain indexscan
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
EXPLAIN (COSTS OFF)
SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
                           QUERY PLAN                            
-----------------------------------------------------------------
 Sort
   Sort Key: ((home_base[0])[0])
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base <@ '(2000,1000),(200,200)'::box)
(4 rows)

SELECT * FROM fast_emp4000
    WHERE home_base <@ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
       home_base       
-----------------------
 (337,455),(240,359)
 (1444,403),(1346,344)
(2 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
                         QUERY PLAN                          
-------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base && '(1000,1000),(0,0)'::box)
(3 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Only Scan using grect2ind on fast_emp4000
         Index Cond: (home_base IS NULL)
(3 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
 count 
-------
   278
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
                         QUERY PLAN                         
------------------------------------------------------------
 Aggregate
   ->  Index Scan using ggpolygonind on gpolygon_tbl
         Index Cond: (f1 && '((1000,1000),(0,0))'::polygon)
(3 rows)

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Index Scan using ggcircleind on gcircle_tbl
         Index Cond: (f1 && '<(500,500),500>'::circle)
(3 rows)

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '(100,100),(0,0)'::box)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '(100,100),(0,0)'::box)
(3 rows)

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
                                       QUERY PLAN                                       
----------------------------------------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '((0,0),(0,100),(100,100),(50,50),(100,0),(0,0))'::polygon)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
 count 
-------
     4
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
                     QUERY PLAN                     
----------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl
         Index Cond: (f1 <@ '<(50,50),50>'::circle)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 << '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 >> '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
 count 
-------
     4
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 <<| '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 <<| '(0.0, 0.0)';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 |>> '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 |>> '(0.0, 0.0)';
 count 
-------
     5
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Only Scan using gpointind on point_tbl p
         Index Cond: (f1 ~= '(-5,-12)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Order By: (f1 <-> '(0,1)'::point)
(2 rows)

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (Infinity,1e+300)
 (1e+300,Infinity)
 (NaN,NaN)
 
(11 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NULL;
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 IS NULL)
(2 rows)

SELECT * FROM point_tbl WHERE f1 IS NULL;
 f1 
----
 
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
                  QUERY PLAN                  
----------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 IS NOT NULL)
   Order By: (f1 <-> '(0,1)'::point)
(3 rows)

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (Infinity,1e+300)
 (1e+300,Infinity)
 (NaN,NaN)
(10 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
                   QUERY PLAN                   
------------------------------------------------
 Index Only Scan using gpointind on point_tbl
   Index Cond: (f1 <@ '(10,10),(-10,-10)'::box)
   Order By: (f1 <-> '(0,1)'::point)
(3 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                     QUERY PLAN                      
-----------------------------------------------------
 Limit
   ->  Index Scan using ggpolygonind on gpolygon_tbl
         Order By: (f1 <-> '(0,0)'::point)
(3 rows)

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                       f1                        
-------------------------------------------------
 ((240,359),(240,455),(337,455),(337,359))
 ((662,163),(662,187),(759,187),(759,163))
 ((1000,0),(0,1000))
 ((0,1000),(1000,1000))
 ((1346,344),(1346,403),(1444,403),(1444,344))
 ((278,1409),(278,1457),(369,1457),(369,1409))
 ((907,1156),(907,1201),(948,1201),(948,1156))
 ((1517,971),(1517,1043),(1594,1043),(1594,971))
 ((175,1820),(175,1850),(259,1850),(259,1820))
 ((2424,81),(2424,160),(2424,160),(2424,81))
(10 rows)

EXPLAIN (COSTS OFF)
SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
                    QUERY PLAN                     
---------------------------------------------------
 Limit
   ->  Index Scan using ggcircleind on gcircle_tbl
         Order By: (f1 <-> '(200,300)'::point)
(3 rows)

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 circle_center  | radius 
----------------+--------
 (288.5,407)    |     68
 (710.5,175)    |     50
 (323.5,1433)   |     51
 (927.5,1178.5) |     30
 (1395,373.5)   |     57
 (1555.5,1007)  |     53
 (217,1835)     |     45
 (489,2421.5)   |     22
 (2424,120.5)   |     40
 (751.5,2655)   |     20
(10 rows)

EXPLAIN (COSTS OFF)
SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Function Scan on generate_series x
   SubPlan 1
     ->  Limit
           ->  Index Scan using ggpolygonind on gpolygon_tbl
                 Order By: (f1 <-> point((x.x)::double precision, (x.x)::double precision))
(5 rows)

SELECT point(x,x), (SELECT f1 FROM gpolygon_tbl ORDER BY f1 <-> point(x,x) LIMIT 1) as c FROM generate_series(0,10,1) x;
  point  |                     c                     
---------+-------------------------------------------
 (0,0)   | ((240,359),(240,455),(337,455),(337,359))
 (1,1)   | ((240,359),(240,455),(337,455),(337,359))
 (2,2)   | ((240,359),(240,455),(337,455),(337,359))
 (3,3)   | ((240,359),(240,455),(337,455),(337,359))
 (4,4)   | ((240,359),(240,455),(337,455),(337,359))
 (5,5)   | ((240,359),(240,455),(337,455),(337,359))
 (6,6)   | ((240,359),(240,455),(337,455),(337,359))
 (7,7)   | ((240,359),(240,455),(337,455),(337,359))
 (8,8)   | ((240,359),(240,455),(337,455),(337,359))
 (9,9)   | ((240,359),(240,455),(337,455),(337,359))
 (10,10) | ((240,359),(240,455),(337,455),(337,359))
(11 rows)

-- Now check the results from bitmap indexscan
SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: ((f1 <-> '(0,1)'::point))
   ->  Bitmap Heap Scan on point_tbl
         Recheck Cond: (f1 <@ '(10,10),(-10,-10)'::box)
         ->  Bitmap Index Scan on gpointind
               Index Cond: (f1 <@ '(10,10),(-10,-10)'::box)
(6 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
--
-- GIN over int[] and text[]
--
-- Note: GIN currently supports only bitmap scans, not plain indexscans
--
CREATE TABLE array_index_op_test (
	seqno		int4,
	i			int4[],
	t			text[]
);
\set filename :abs_srcdir '/data/array.data'
COPY array_index_op_test FROM :'filename';
ANALYZE array_index_op_test;
SELECT * FROM array_index_op_test WHERE i = '{NULL}' ORDER BY seqno;
 seqno |   i    |   t    
-------+--------+--------
   102 | {NULL} | {NULL}
(1 row)

SELECT * FROM array_index_op_test WHERE i @> '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i && '{NULL}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{NULL}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
CREATE INDEX intarrayidx ON array_index_op_test USING gin (i);
explain (costs off)
SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
                     QUERY PLAN                     
----------------------------------------------------
 Sort
   Sort Key: seqno
   ->  Bitmap Heap Scan on array_index_op_test
         Recheck Cond: (i @> '{32}'::integer[])
         ->  Bitmap Index Scan on intarrayidx
               Index Cond: (i @> '{32}'::integer[])
(6 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE i @> '{17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
(8 rows)

SELECT * FROM array_index_op_test WHERE i && '{17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
(8 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32,17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
(3 rows)

SELECT * FROM array_index_op_test WHERE i && '{32,17}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(11 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{38,34,32,89}' ORDER BY seqno;
 seqno |       i       |                                                             t                                                              
-------+---------------+----------------------------------------------------------------------------------------------------------------------------
    40 | {34}          | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
    74 | {32}          | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    98 | {38,34,32,89} | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   101 | {}            | {}
(4 rows)

SELECT * FROM array_index_op_test WHERE i = '{47,77}' ORDER BY seqno;
 seqno |    i    |                                                        t                                                        
-------+---------+-----------------------------------------------------------------------------------------------------------------
    95 | {47,77} | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
(1 row)

SELECT * FROM array_index_op_test WHERE i = '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

SELECT * FROM array_index_op_test WHERE i @> '{}' ORDER BY seqno;
 seqno |                i                |                                                                                                       t                                                                                                        
-------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
     2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
     3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
     4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
     5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
     7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
     8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
     9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
    10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
    11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
    14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    16 | {14,63,85,11}                   | {AAAAAA66777}
    17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
    18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
    21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
    22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
    23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
    24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
    25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
    26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
    27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
    28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
    29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
    30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
    32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
    33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
    34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
    35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
    36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
    37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
    38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
    39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
    40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
    41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
    42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
    43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
    44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
    45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
    47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
    48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
    49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
    50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
    51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
    52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
    55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
    56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
    57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
    58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
    59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
    60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
    61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
    62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
    63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
    64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
    67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
    68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
    69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
    70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
    71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
    72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
    76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
    79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
    81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
    82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
    84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
    85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
    86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
    87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
    88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
    91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
    92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
    93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
    94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
    95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
    96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
    97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
    99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
   101 | {}                              | {}
   102 | {NULL}                          | {NULL}
(102 rows)

SELECT * FROM array_index_op_test WHERE i && '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE i <@ '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

CREATE INDEX textarrayidx ON array_index_op_test USING gin (t);
explain (costs off)
SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: seqno
   ->  Bitmap Heap Scan on array_index_op_test
         Recheck Cond: (t @> '{AAAAAAAA72908}'::text[])
         ->  Bitmap Index Scan on textarrayidx
               Index Cond: (t @> '{AAAAAAAA72908}'::text[])
(6 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908}' ORDER BY seqno;
 seqno |           i           |                                                                     t                                                                      
-------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
(4 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908}' ORDER BY seqno;
 seqno |           i           |                                                                     t                                                                      
-------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
(4 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAAAA646}' ORDER BY seqno;
 seqno |        i         |                                 t                                  
-------+------------------+--------------------------------------------------------------------
    15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
    79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
(3 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAAAA646}' ORDER BY seqno;
 seqno |        i         |                                 t                                  
-------+------------------+--------------------------------------------------------------------
    15 | {17,14,16,63,67} | {AA6416,AAAAAAAAAA646,AAAAA95309}
    79 | {45}             | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    96 | {23,97,43}       | {AAAAAAAAAA646,A87088}
(3 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
 seqno |  i   |                                 t                                  
-------+------+--------------------------------------------------------------------
    79 | {45} | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
(1 row)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAAA72908,AAAAAAAAAA646}' ORDER BY seqno;
 seqno |           i           |                                                                     t                                                                      
-------+-----------------------+--------------------------------------------------------------------------------------------------------------------------------------------
    15 | {17,14,16,63,67}      | {AA6416,AAAAAAAAAA646,AAAAA95309}
    22 | {11,6,56,62,53,30}    | {AAAAAAAA72908}
    45 | {99,45}               | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    72 | {22,1,16,78,20,91,83} | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    79 | {45}                  | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    96 | {23,97,43}            | {AAAAAAAAAA646,A87088}
(6 rows)

SELECT * FROM array_index_op_test WHERE t <@ '{AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}' ORDER BY seqno;
 seqno |         i          |                                                     t                                                     
-------+--------------------+-----------------------------------------------------------------------------------------------------------
    22 | {11,6,56,62,53,30} | {AAAAAAAA72908}
    45 | {99,45}            | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
   101 | {}                 | {}
(3 rows)

SELECT * FROM array_index_op_test WHERE t = '{AAAAAAAAAA646,A87088}' ORDER BY seqno;
 seqno |     i      |           t            
-------+------------+------------------------
    96 | {23,97,43} | {AAAAAAAAAA646,A87088}
(1 row)

SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

SELECT * FROM array_index_op_test WHERE t @> '{}' ORDER BY seqno;
 seqno |                i                |                                                                                                       t                                                                                                        
-------+---------------------------------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
     1 | {92,75,71,52,64,83}             | {AAAAAAAA44066,AAAAAA1059,AAAAAAAAAAA176,AAAAAAA48038}
     2 | {3,6}                           | {AAAAAA98232,AAAAAAAA79710,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAAAAAAA55798,AAAAAAAAA12793}
     3 | {37,64,95,43,3,41,13,30,11,43}  | {AAAAAAAAAA48845,AAAAA75968,AAAAA95309,AAA54451,AAAAAAAAAA22292,AAAAAAA99836,A96617,AA17009,AAAAAAAAAAAAAA95246}
     4 | {71,39,99,55,33,75,45}          | {AAAAAAAAA53663,AAAAAAAAAAAAAAA67062,AAAAAAAAAA64777,AAA99043,AAAAAAAAAAAAAAAAAAA91804,39557}
     5 | {50,42,77,50,4}                 | {AAAAAAAAAAAAAAAAA26540,AAAAAAA79710,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA176,AAAAA95309,AAAAAAAAAAA46154,AAAAAA66777,AAAAAAAAA27249,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA70104}
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
     7 | {12,51,88,64,8}                 | {AAAAAAAAAAAAAAAAAA12591,AAAAAAAAAAAAAAAAA50407,AAAAAAAAAAAA67946}
     8 | {60,84}                         | {AAAAAAA81898,AAAAAA1059,AAAAAAAAAAAA81511,AAAAA961,AAAAAAAAAAAAAAAA31334,AAAAA64741,AA6416,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAA50407}
     9 | {56,52,35,27,80,44,81,22}       | {AAAAAAAAAAAAAAA73034,AAAAAAAAAAAAA7929,AAAAAAA66161,AA88409,39557,A27153,AAAAAAAA9523,AAAAAAAAAAA99000}
    10 | {71,5,45}                       | {AAAAAAAAAAA21658,AAAAAAAAAAAA21089,AAA54451,AAAAAAAAAAAAAAAAAA54141,AAAAAAAAAAAAAA28620,AAAAAAAAAAA21658,AAAAAAAAAAA74076,AAAAAAAAA27249}
    11 | {41,86,74,48,22,74,47,50}       | {AAAAAAAA9523,AAAAAAAAAAAA37562,AAAAAAAAAAAAAAAA14047,AAAAAAAAAAA46154,AAAA41702,AAAAAAAAAAAAAAAAA764,AAAAA62737,39557}
    12 | {17,99,18,52,91,72,0,43,96,23}  | {AAAAA33250,AAAAAAAAAAAAAAAAAAA85420,AAAAAAAAAAA33576}
    13 | {3,52,34,23}                    | {AAAAAA98232,AAAA49534,AAAAAAAAAAA21658}
    14 | {78,57,19}                      | {AAAA8857,AAAAAAAAAAAAAAA73034,AAAAAAAA81587,AAAAAAAAAAAAAAA68526,AAAAA75968,AAAAAAAAAAAAAA65909,AAAAAAAAA10012,AAAAAAAAAAAAAA65909}
    15 | {17,14,16,63,67}                | {AA6416,AAAAAAAAAA646,AAAAA95309}
    16 | {14,63,85,11}                   | {AAAAAA66777}
    17 | {7,10,81,85}                    | {AAAAAA43678,AAAAAAA12144,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAAAAA15356}
    18 | {1}                             | {AAAAAAAAAAA33576,AAAAA95309,64261,AAA59323,AAAAAAAAAAAAAA95246,55847,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAAAA64374}
    19 | {52,82,17,74,23,46,69,51,75}    | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    20 | {72,89,70,51,54,37,8,49,79}     | {AAAAAA58494}
    21 | {2,8,65,10,5,79,43}             | {AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAAAAA91804,AAAAA64669,AAAAAAAAAAAAAAAA1443,AAAAAAAAAAAAAAAA23657,AAAAA12179,AAAAAAAAAAAAAAAAA88852,AAAAAAAAAAAAAAAA31334,AAAAAAAAAAAAAAAA41303,AAAAAAAAAAAAAAAAAAA85420}
    22 | {11,6,56,62,53,30}              | {AAAAAAAA72908}
    23 | {40,90,5,38,72,40,30,10,43,55}  | {A6053,AAAAAAAAAAA6119,AA44673,AAAAAAAAAAAAAAAAA764,AA17009,AAAAA17383,AAAAA70514,AAAAA33250,AAAAA95309,AAAAAAAAAAAA37562}
    24 | {94,61,99,35,48}                | {AAAAAAAAAAA50956,AAAAAAAAAAA15165,AAAA85070,AAAAAAAAAAAAAAA36627,AAAAA961,AAAAAAAAAA55219}
    25 | {31,1,10,11,27,79,38}           | {AAAAAAAAAAAAAAAAAA59334,45449}
    26 | {71,10,9,69,75}                 | {47735,AAAAAAA21462,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA91804,AAAAAAAAA72121,AAAAAAAAAAAAAAAAAAA1205,AAAAA41597,AAAA8857,AAAAAAAAAAAAAAAAAAA15356,AA17009}
    27 | {94}                            | {AA6416,A6053,AAAAAAA21462,AAAAAAA57334,AAAAAAAAAAAAAAAAAA12591,AA88409,AAAAAAAAAAAAA70254}
    28 | {14,33,6,34,14}                 | {AAAAAAAAAAAAAAA13198,AAAAAAAA69452,AAAAAAAAAAA82945,AAAAAAA12144,AAAAAAAAA72121,AAAAAAAAAA18601}
    29 | {39,21}                         | {AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAAAAA38885,AAAA85070,AAAAAAAAAAAAAAAAAAA70104,AAAAA66674,AAAAAAAAAAAAA62007,AAAAAAAA69452,AAAAAAA1242,AAAAAAAAAAAAAAAA1729,AAAA35194}
    30 | {26,81,47,91,34}                | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    31 | {80,24,18,21,54}                | {AAAAAAAAAAAAAAA13198,AAAAAAAAAAAAAAAAAAA70415,A27153,AAAAAAAAA53663,AAAAAAAAAAAAAAAAA50407,A68938}
    32 | {58,79,82,80,67,75,98,10,41}    | {AAAAAAAAAAAAAAAAAA61286,AAA54451,AAAAAAAAAAAAAAAAAAA87527,A96617,51533}
    33 | {74,73}                         | {A85417,AAAAAAA56483,AAAAA17383,AAAAAAAAAAAAA62159,AAAAAAAAAAAA52814,AAAAAAAAAAAAA85723,AAAAAAAAAAAAAAAAAA55796}
    34 | {70,45}                         | {AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAA28620,AAAAAAAAAA55219,AAAAAAAA23648,AAAAAAAAAA22292,AAAAAAA1242}
    35 | {23,40}                         | {AAAAAAAAAAAA52814,AAAA48949,AAAAAAAAA34727,AAAA8857,AAAAAAAAAAAAAAAAAAA62179,AAAAAAAAAAAAAAA68526,AAAAAAA99836,AAAAAAAA50094,AAAA91194,AAAAAAAAAAAAA73084}
    36 | {79,82,14,52,30,5,79}           | {AAAAAAAAA53663,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA89194,AA88409,AAAAAAAAAAAAAAA81326,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAA33598}
    37 | {53,11,81,39,3,78,58,64,74}     | {AAAAAAAAAAAAAAAAAAA17075,AAAAAAA66161,AAAAAAAA23648,AAAAAAAAAAAAAA10611}
    38 | {59,5,4,95,28}                  | {AAAAAAAAAAA82945,A96617,47735,AAAAA12179,AAAAA64669,AAAAAA99807,AA74433,AAAAAAAAAAAAAAAAA59387}
    39 | {82,43,99,16,74}                | {AAAAAAAAAAAAAAA67062,AAAAAAA57334,AAAAAAAAAAAAAA65909,A27153,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAA64777,AAAAAAAAAAAA81511,AAAAAAAAAAAAAA65909,AAAAAAAAAAAAAA28620}
    40 | {34}                            | {AAAAAAAAAAAAAA10611,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAA50956,AAAAAAAAAAAAAAAA31334,AAAAA70466,AAAAAAAA81587,AAAAAAA74623}
    41 | {19,26,63,12,93,73,27,94}       | {AAAAAAA79710,AAAAAAAAAA55219,AAAA41702,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA71621,AAAAAAAAAAAAAAAAA63050,AAAAAAA99836,AAAAAAAAAAAAAA8666}
    42 | {15,76,82,75,8,91}              | {AAAAAAAAAAA176,AAAAAA38063,45449,AAAAAA54032,AAAAAAA81898,AA6416,AAAAAAAAAAAAAAAAAAA62179,45449,AAAAA60038,AAAAAAAA81587}
    43 | {39,87,91,97,79,28}             | {AAAAAAAAAAA74076,A96617,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAAAAA55796,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAA67946}
    44 | {40,58,68,29,54}                | {AAAAAAA81898,AAAAAA66777,AAAAAA98232}
    45 | {99,45}                         | {AAAAAAAA72908,AAAAAAAAAAAAAAAAAAA17075,AA88409,AAAAAAAAAAAAAAAAAA36842,AAAAAAA48038,AAAAAAAAAAAAAA10611}
    46 | {53,24}                         | {AAAAAAAAAAA53908,AAAAAA54032,AAAAA17383,AAAA48949,AAAAAAAAAA18601,AAAAA64669,45449,AAAAAAAAAAA98051,AAAAAAAAAAAAAAAAAA71621}
    47 | {98,23,64,12,75,61}             | {AAA59323,AAAAA95309,AAAAAAAAAAAAAAAA31334,AAAAAAAAA27249,AAAAA17383,AAAAAAAAAAAA37562,AAAAAA1059,A84822,55847,AAAAA70466}
    48 | {76,14}                         | {AAAAAAAAAAAAA59671,AAAAAAAAAAAAAAAAAAA91804,AAAAAA66777,AAAAAAAAAAAAAAAAAAA89194,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAA73084,AAAAAAA79710,AAAAAAAAAAAAAAA40402,AAAAAAAAAAAAAAAAAAA65037}
    49 | {56,5,54,37,49}                 | {AA21643,AAAAAAAAAAA92631,AAAAAAAA81587}
    50 | {20,12,37,64,93}                | {AAAAAAAAAA5483,AAAAAAAAAAAAAAAAAAA1205,AA6416,AAAAAAAAAAAAAAAAA63050,AAAAAAAAAAAAAAAAAA47955}
    51 | {47}                            | {AAAAAAAAAAAAAA96505,AAAAAAAAAAAAAAAAAA36842,AAAAA95309,AAAAAAAA81587,AA6416,AAAA91194,AAAAAA58494,AAAAAA1059,AAAAAAAA69452}
    52 | {89,0}                          | {AAAAAAAAAAAAAAAAAA47955,AAAAAAA48038,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAA73084,AAAAA70466,AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA46154,AA66862}
    53 | {38,17}                         | {AAAAAAAAAAA21658}
    54 | {70,47}                         | {AAAAAAAAAAAAAAAAAA54141,AAAAA40681,AAAAAAA48038,AAAAAAAAAAAAAAAA29150,AAAAA41597,AAAAAAAAAAAAAAAAAA59334,AA15322}
    55 | {47,79,47,64,72,25,71,24,93}    | {AAAAAAAAAAAAAAAAAA55796,AAAAA62737}
    56 | {33,7,60,54,93,90,77,85,39}     | {AAAAAAAAAAAAAAAAAA32918,AA42406}
    57 | {23,45,10,42,36,21,9,96}        | {AAAAAAAAAAAAAAAAAAA70415}
    58 | {92}                            | {AAAAAAAAAAAAAAAA98414,AAAAAAAA23648,AAAAAAAAAAAAAAAAAA55796,AA25381,AAAAAAAAAAA6119}
    59 | {9,69,46,77}                    | {39557,AAAAAAA89932,AAAAAAAAAAAAAAAAA43052,AAAAAAAAAAAAAAAAA26540,AAA20874,AA6416,AAAAAAAAAAAAAAAAAA47955}
    60 | {62,2,59,38,89}                 | {AAAAAAA89932,AAAAAAAAAAAAAAAAAAA15356,AA99927,AA17009,AAAAAAAAAAAAAAA35875}
    61 | {72,2,44,95,54,54,13}           | {AAAAAAAAAAAAAAAAAAA91804}
    62 | {83,72,29,73}                   | {AAAAAAAAAAAAA15097,AAAA8857,AAAAAAAAAAAA35809,AAAAAAAAAAAA52814,AAAAAAAAAAAAAAAAAAA38885,AAAAAAAAAAAAAAAAAA24183,AAAAAA43678,A96617}
    63 | {11,4,61,87}                    | {AAAAAAAAA27249,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAA13198,AAA20874,39557,51533,AAAAAAAAAAA53908,AAAAAAAAAAAAAA96505,AAAAAAAA78938}
    64 | {26,19,34,24,81,78}             | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    65 | {61,5,76,59,17}                 | {AAAAAA99807,AAAAA64741,AAAAAAAAAAA53908,AA21643,AAAAAAAAA10012}
    66 | {31,23,70,52,4,33,48,25}        | {AAAAAAAAAAAAAAAAA69675,AAAAAAAA50094,AAAAAAAAAAA92631,AAAA35194,39557,AAAAAAA99836}
    67 | {31,94,7,10}                    | {AAAAAA38063,A96617,AAAA35194,AAAAAAAAAAAA67946}
    68 | {90,43,38}                      | {AA75092,AAAAAAAAAAAAAAAAA69675,AAAAAAAAAAA92631,AAAAAAAAA10012,AAAAAAAAAAAAA7929,AA21643}
    69 | {67,35,99,85,72,86,44}          | {AAAAAAAAAAAAAAAAAAA1205,AAAAAAAA50094,AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAAAAAAA47955}
    70 | {56,70,83}                      | {AAAA41702,AAAAAAAAAAA82945,AA21643,AAAAAAAAAAA99000,A27153,AA25381,AAAAAAAAAAAAAA96505,AAAAAAA1242}
    71 | {74,26}                         | {AAAAAAAAAAA50956,AA74433,AAAAAAA21462,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAA36627,AAAAAAAAAAAAA70254,AAAAAAAAAA43419,39557}
    72 | {22,1,16,78,20,91,83}           | {47735,AAAAAAA56483,AAAAAAAAAAAAA93788,AA42406,AAAAAAAAAAAAA73084,AAAAAAAA72908,AAAAAAAAAAAAAAAAAA61286,AAAAA66674,AAAAAAAAAAAAAAAAA50407}
    73 | {88,25,96,78,65,15,29,19}       | {AAA54451,AAAAAAAAA27249,AAAAAAA9228,AAAAAAAAAAAAAAA67062,AAAAAAAAAAAAAAAAAAA70415,AAAAA17383,AAAAAAAAAAAAAAAA33598}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    75 | {12,96,83,24,71,89,55}          | {AAAA48949,AAAAAAAA29716,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA67946,AAAAAAAAAAAAAAAA29150,AAA28075,AAAAAAAAAAAAAAAAA43052}
    76 | {92,55,10,7}                    | {AAAAAAAAAAAAAAA67062}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    78 | {55,89,44,84,34}                | {AAAAAAAAAAA6119,AAAAAAAAAAAAAA8666,AA99927,AA42406,AAAAAAA81898,AAAAAAA9228,AAAAAAAAAAA92631,AA21643,AAAAAAAAAAAAAA28620}
    79 | {45}                            | {AAAAAAAAAA646,AAAAAAAAAAAAAAAAAAA70415,AAAAAA43678,AAAAAAAA72908}
    80 | {74,89,44,80,0}                 | {AAAA35194,AAAAAAAA79710,AAA20874,AAAAAAAAAAAAAAAAAAA70104,AAAAAAAAAAAAA73084,AAAAAAA57334,AAAAAAA9228,AAAAAAAAAAAAA62007}
    81 | {63,77,54,48,61,53,97}          | {AAAAAAAAAAAAAAA81326,AAAAAAAAAA22292,AA25381,AAAAAAAAAAA74076,AAAAAAA81898,AAAAAAAAA72121}
    82 | {34,60,4,79,78,16,86,89,42,50}  | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    83 | {14,10}                         | {AAAAAAAAAA22292,AAAAAAAAAAAAA70254,AAAAAAAAAAA6119}
    84 | {11,83,35,13,96,94}             | {AAAAA95309,AAAAAAAAAAAAAAAAAA32918,AAAAAAAAAAAAAAAAAA24183}
    85 | {39,60}                         | {AAAAAAAAAAAAAAAA55798,AAAAAAAAAA22292,AAAAAAA66161,AAAAAAA21462,AAAAAAAAAAAAAAAAAA12591,55847,AAAAAA98232,AAAAAAAAAAA46154}
    86 | {33,81,72,74,45,36,82}          | {AAAAAAAA81587,AAAAAAAAAAAAAA96505,45449,AAAA80176}
    87 | {57,27,50,12,97,68}             | {AAAAAAAAAAAAAAAAA26540,AAAAAAAAA10012,AAAAAAAAAAAA35809,AAAAAAAAAAAAAAAA29150,AAAAAAAAAAA82945,AAAAAA66777,31228,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAA96505}
    88 | {41,90,77,24,6,24}              | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    90 | {88,75}                         | {AAAAA60038,AAAAAAAA23648,AAAAAAAAAAA99000,AAAA41702,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAA68526}
    91 | {78}                            | {AAAAAAAAAAAAA62007,AAA99043}
    92 | {85,63,49,45}                   | {AAAAAAA89932,AAAAAAAAAAAAA22860,AAAAAAAAAAAAAAAAAAA1205,AAAAAAAAAAAA21089}
    93 | {11}                            | {AAAAAAAAAAA176,AAAAAAAAAAAAAA8666,AAAAAAAAAAAAAAA453,AAAAAAAAAAAAA85723,A68938,AAAAAAAAAAAAA9821,AAAAAAA48038,AAAAAAAAAAAAAAAAA59387,AA99927,AAAAA17383}
    94 | {98,9,85,62,88,91,60,61,38,86}  | {AAAAAAAA81587,AAAAA17383,AAAAAAAA81587}
    95 | {47,77}                         | {AAAAAAAAAAAAAAAAA764,AAAAAAAAAAA74076,AAAAAAAAAA18107,AAAAA40681,AAAAAAAAAAAAAAA35875,AAAAA60038,AAAAAAA56483}
    96 | {23,97,43}                      | {AAAAAAAAAA646,A87088}
    97 | {54,2,86,65}                    | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
    99 | {37,86}                         | {AAAAAAAAAAAAAAAAAA32918,AAAAA70514,AAAAAAAAA10012,AAAAAAAAAAAAAAAAA59387,AAAAAAAAAA64777,AAAAAAAAAAAAAAAAAAA15356}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
   101 | {}                              | {}
   102 | {NULL}                          | {NULL}
(102 rows)

SELECT * FROM array_index_op_test WHERE t && '{}' ORDER BY seqno;
 seqno | i | t 
-------+---+---
(0 rows)

SELECT * FROM array_index_op_test WHERE t <@ '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

-- And try it with a multicolumn GIN index
DROP INDEX intarrayidx, textarrayidx;
CREATE INDEX botharrayidx ON array_index_op_test USING gin (i, t);
SELECT * FROM array_index_op_test WHERE i @> '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE i && '{32}' ORDER BY seqno;
 seqno |                i                |                                                                 t                                                                  
-------+---------------------------------+------------------------------------------------------------------------------------------------------------------------------------
     6 | {39,35,5,94,17,92,60,32}        | {AAAAAAAAAAAAAAA35875,AAAAAAAAAAAAAAAA23657}
    74 | {32}                            | {AAAAAAAAAAAAAAAA1729,AAAAAAAAAAAAA22860,AAAAAA99807,AAAAA17383,AAAAAAAAAAAAAAA67062,AAAAAAAAAAA15165,AAAAAAAAAAA50956}
    77 | {97,15,32,17,55,59,18,37,50,39} | {AAAAAAAAAAAA67946,AAAAAA54032,AAAAAAAA81587,55847,AAAAAAAAAAAAAA28620,AAAAAAAAAAAAAAAAA43052,AAAAAA75463,AAAA49534,AAAAAAAA44066}
    89 | {40,32,17,6,30,88}              | {AA44673,AAAAAAAAAAA6119,AAAAAAAAAAAAAAAA23657,AAAAAAAAAAAAAAAAAA47955,AAAAAAAAAAAAAAAA33598,AAAAAAAAAAA33576,AA44673}
    98 | {38,34,32,89}                   | {AAAAAAAAAAAAAAAAAA71621,AAAA8857,AAAAAAAAAAAAAAAAAAA65037,AAAAAAAAAAAAAAAA31334,AAAAAAAAAA48845}
   100 | {85,32,57,39,49,84,32,3,30}     | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(6 rows)

SELECT * FROM array_index_op_test WHERE t @> '{AAAAAAA80240}' ORDER BY seqno;
 seqno |               i                |                                                                              t                                                                              
-------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
    19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
   100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(7 rows)

SELECT * FROM array_index_op_test WHERE t && '{AAAAAAA80240}' ORDER BY seqno;
 seqno |               i                |                                                                              t                                                                              
-------+--------------------------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------
    19 | {52,82,17,74,23,46,69,51,75}   | {AAAAAAAAAAAAA73084,AAAAA75968,AAAAAAAAAAAAAAAA14047,AAAAAAA80240,AAAAAAAAAAAAAAAAAAA1205,A68938}
    30 | {26,81,47,91,34}               | {AAAAAAAAAAAAAAAAAAA70104,AAAAAAA80240}
    64 | {26,19,34,24,81,78}            | {A96617,AAAAAAAAAAAAAAAAAAA70104,A68938,AAAAAAAAAAA53908,AAAAAAAAAAAAAAA453,AA17009,AAAAAAA80240}
    82 | {34,60,4,79,78,16,86,89,42,50} | {AAAAA40681,AAAAAAAAAAAAAAAAAA12591,AAAAAAA80240,AAAAAAAAAAAAAAAA55798,AAAAAAAAAAAAAAAAAAA70104}
    88 | {41,90,77,24,6,24}             | {AAAA35194,AAAA35194,AAAAAAA80240,AAAAAAAAAAA46154,AAAAAA58494,AAAAAAAAAAAAAAAAAAA17075,AAAAAAAAAAAAAAAAAA59334,AAAAAAAAAAAAAAAAAAA91804,AA74433}
    97 | {54,2,86,65}                   | {47735,AAAAAAA99836,AAAAAAAAAAAAAAAAA6897,AAAAAAAAAAAAAAAA29150,AAAAAAA80240,AAAAAAAAAAAAAAAA98414,AAAAAAA56483,AAAAAAAAAAAAAAAA29150,AAAAAAA39692,AA21643}
   100 | {85,32,57,39,49,84,32,3,30}    | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(7 rows)

SELECT * FROM array_index_op_test WHERE i @> '{32}' AND t && '{AAAAAAA80240}' ORDER BY seqno;
 seqno |              i              |                                      t                                       
-------+-----------------------------+------------------------------------------------------------------------------
   100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(1 row)

SELECT * FROM array_index_op_test WHERE i && '{32}' AND t @> '{AAAAAAA80240}' ORDER BY seqno;
 seqno |              i              |                                      t                                       
-------+-----------------------------+------------------------------------------------------------------------------
   100 | {85,32,57,39,49,84,32,3,30} | {AAAAAAA80240,AAAAAAAAAAAAAAAA1729,AAAAA60038,AAAAAAAAAAA92631,AAAAAAAA9523}
(1 row)

SELECT * FROM array_index_op_test WHERE t = '{}' ORDER BY seqno;
 seqno | i  | t  
-------+----+----
   101 | {} | {}
(1 row)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
--
-- Try a GIN index with a lot of items with same key. (GIN creates a posting
-- tree when there are enough duplicates)
--
CREATE TABLE array_gin_test (a int[]);
INSERT INTO array_gin_test SELECT ARRAY[1, g%5, g] FROM generate_series(1, 10000) g;
CREATE INDEX array_gin_test_idx ON array_gin_test USING gin (a);
SELECT COUNT(*) FROM array_gin_test WHERE a @> '{2}';
 count 
-------
  2000
(1 row)

DROP TABLE array_gin_test;
--
-- Test GIN index's reloptions
--
CREATE INDEX gin_relopts_test ON array_index_op_test USING gin (i)
  WITH (FASTUPDATE=on, GIN_PENDING_LIST_LIMIT=128);
\d+ gin_relopts_test
                Index "public.gin_relopts_test"
 Column |  Type   | Key? | Definition | Storage | Stats target 
--------+---------+------+------------+---------+--------------
 i      | integer | yes  | i          | plain   | 
gin, for table "public.array_index_op_test"
Options: fastupdate=on, gin_pending_list_limit=128

--
-- HASH
--
CREATE UNLOGGED TABLE unlogged_hash_table (id int4);
CREATE INDEX unlogged_hash_index ON unlogged_hash_table USING hash (id int4_ops);
DROP TABLE unlogged_hash_table;
-- CREATE INDEX hash_ovfl_index ON hash_ovfl_heap USING hash (x int4_ops);
-- Test hash index build tuplesorting.  Force hash tuplesort using low
-- maintenance_work_mem setting and fillfactor:
SET maintenance_work_mem = '1MB';
CREATE INDEX hash_tuplesort_idx ON tenk1 USING hash (stringu1 name_ops) WITH (fillfactor = 10);
EXPLAIN (COSTS OFF)
SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
                      QUERY PLAN                       
-------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on tenk1
         Recheck Cond: (stringu1 = 'TVAAAA'::name)
         ->  Bitmap Index Scan on hash_tuplesort_idx
               Index Cond: (stringu1 = 'TVAAAA'::name)
(5 rows)

SELECT count(*) FROM tenk1 WHERE stringu1 = 'TVAAAA';
 count 
-------
    14
(1 row)

DROP INDEX hash_tuplesort_idx;
RESET maintenance_work_mem;
--
-- Test unique null behavior
--
CREATE TABLE unique_tbl (i int, t text);
CREATE UNIQUE INDEX unique_idx1 ON unique_tbl (i) NULLS DISTINCT;
CREATE UNIQUE INDEX unique_idx2 ON unique_tbl (i) NULLS NOT DISTINCT;
INSERT INTO unique_tbl VALUES (1, 'one');
INSERT INTO unique_tbl VALUES (2, 'two');
INSERT INTO unique_tbl VALUES (3, 'three');
INSERT INTO unique_tbl VALUES (4, 'four');
INSERT INTO unique_tbl VALUES (5, 'one');
INSERT INTO unique_tbl (t) VALUES ('six');
INSERT INTO unique_tbl (t) VALUES ('seven');  -- error from unique_idx2
ERROR:  duplicate key value violates unique constraint "unique_idx2"
DETAIL:  Key (i)=(null) already exists.
DROP INDEX unique_idx1, unique_idx2;
INSERT INTO unique_tbl (t) VALUES ('seven');
-- build indexes on filled table
CREATE UNIQUE INDEX unique_idx3 ON unique_tbl (i) NULLS DISTINCT;  -- ok
CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;  -- error
ERROR:  could not create unique index "unique_idx4"
DETAIL:  Key (i)=(null) is duplicated.
DELETE FROM unique_tbl WHERE t = 'seven';
CREATE UNIQUE INDEX unique_idx4 ON unique_tbl (i) NULLS NOT DISTINCT;  -- ok now
\d unique_tbl
             Table "public.unique_tbl"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 i      | integer |           |          | 
 t      | text    |           |          | 
Indexes:
    "unique_idx3" UNIQUE, btree (i)
    "unique_idx4" UNIQUE, btree (i) NULLS NOT DISTINCT

\d unique_idx3
      Index "public.unique_idx3"
 Column |  Type   | Key? | Definition 
--------+---------+------+------------
 i      | integer | yes  | i
unique, btree, for table "public.unique_tbl"

\d unique_idx4
      Index "public.unique_idx4"
 Column |  Type   | Key? | Definition 
--------+---------+------+------------
 i      | integer | yes  | i
unique nulls not distinct, btree, for table "public.unique_tbl"

SELECT pg_get_indexdef('unique_idx3'::regclass);
                           pg_get_indexdef                            
----------------------------------------------------------------------
 CREATE UNIQUE INDEX unique_idx3 ON public.unique_tbl USING btree (i)
(1 row)

SELECT pg_get_indexdef('unique_idx4'::regclass);
                                     pg_get_indexdef                                     
-----------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX unique_idx4 ON public.unique_tbl USING btree (i) NULLS NOT DISTINCT
(1 row)

DROP TABLE unique_tbl;
--
-- Test functional index
--
CREATE TABLE func_index_heap (f1 text, f2 text);
CREATE UNIQUE INDEX func_index_index on func_index_heap (textcat(f1,f2));
INSERT INTO func_index_heap VALUES('ABC','DEF');
INSERT INTO func_index_heap VALUES('AB','CDEFG');
INSERT INTO func_index_heap VALUES('QWE','RTY');
-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
ERROR:  duplicate key value violates unique constraint "func_index_index"
DETAIL:  Key (textcat(f1, f2))=(ABCDEF) already exists.
-- but this shouldn't:
INSERT INTO func_index_heap VALUES('QWERTY');
-- while we're here, see that the metadata looks sane
\d func_index_heap
         Table "public.func_index_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "func_index_index" UNIQUE, btree (textcat(f1, f2))

\d func_index_index
     Index "public.func_index_index"
 Column  | Type | Key? |   Definition    
---------+------+------+-----------------
 textcat | text | yes  | textcat(f1, f2)
unique, btree, for table "public.func_index_heap"

--
-- Same test, expressional index
--
DROP TABLE func_index_heap;
CREATE TABLE func_index_heap (f1 text, f2 text);
CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
INSERT INTO func_index_heap VALUES('ABC','DEF');
INSERT INTO func_index_heap VALUES('AB','CDEFG');
INSERT INTO func_index_heap VALUES('QWE','RTY');
-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
ERROR:  duplicate key value violates unique constraint "func_index_index"
DETAIL:  Key ((f1 || f2))=(ABCDEF) already exists.
-- but this shouldn't:
INSERT INTO func_index_heap VALUES('QWERTY');
-- while we're here, see that the metadata looks sane
\d func_index_heap
         Table "public.func_index_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "func_index_index" UNIQUE, btree ((f1 || f2))

\d func_index_index
  Index "public.func_index_index"
 Column | Type | Key? | Definition 
--------+------+------+------------
 expr   | text | yes  | (f1 || f2)
unique, btree, for table "public.func_index_heap"

-- this should fail because of unsafe column type (anonymous record)
create index on func_index_heap ((f1 || f2), (row(f1, f2)));
ERROR:  column "row" has pseudo-type record
--
-- Test unique index with included columns
--
CREATE TABLE covering_index_heap (f1 int, f2 int, f3 text);
CREATE UNIQUE INDEX covering_index_index on covering_index_heap (f1,f2) INCLUDE(f3);
INSERT INTO covering_index_heap VALUES(1,1,'AAA');
INSERT INTO covering_index_heap VALUES(1,2,'AAA');
-- this should fail because of unique index on f1,f2:
INSERT INTO covering_index_heap VALUES(1,2,'BBB');
ERROR:  duplicate key value violates unique constraint "covering_index_index"
DETAIL:  Key (f1, f2)=(1, 2) already exists.
-- and this shouldn't:
INSERT INTO covering_index_heap VALUES(1,4,'AAA');
-- Try to build index on table that already contains data
CREATE UNIQUE INDEX covering_pkey on covering_index_heap (f1,f2) INCLUDE(f3);
-- Try to use existing covering index as primary key
ALTER TABLE covering_index_heap ADD CONSTRAINT covering_pkey PRIMARY KEY USING INDEX
covering_pkey;
DROP TABLE covering_index_heap;
--
-- Try some concurrent index builds
--
-- Unfortunately this only tests about half the code paths because there are
-- no concurrent updates happening to the table at the same time.
CREATE TABLE concur_heap (f1 text, f2 text);
-- empty table
CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
NOTICE:  relation "concur_index1" already exists, skipping
INSERT INTO concur_heap VALUES  ('a','b');
INSERT INTO concur_heap VALUES  ('b','b');
-- unique index
CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
NOTICE:  relation "concur_index2" already exists, skipping
-- check if constraint is set up properly to be enforced
INSERT INTO concur_heap VALUES ('b','x');
ERROR:  duplicate key value violates unique constraint "concur_index2"
DETAIL:  Key (f1)=(b) already exists.
-- check if constraint is enforced properly at build time
CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
ERROR:  could not create unique index "concur_index3"
DETAIL:  Key (f2)=(b) is duplicated.
-- test that expression indexes and partial indexes work concurrently
CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
-- here we also check that you can default the index name
CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
-- You can't do a concurrent index build in a transaction
BEGIN;
CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- test where predicate is able to do a transactional update during
-- a concurrent build before switching pg_index state flags.
CREATE FUNCTION predicate_stable() RETURNS bool IMMUTABLE
LANGUAGE plpgsql AS $$
BEGIN
  EXECUTE 'SELECT txid_current()';
  RETURN true;
END; $$;
CREATE INDEX CONCURRENTLY concur_index8 ON concur_heap (f1)
  WHERE predicate_stable();
DROP INDEX concur_index8;
DROP FUNCTION predicate_stable();
-- But you can do a regular index build in a transaction
BEGIN;
CREATE INDEX std_index on concur_heap(f2);
COMMIT;
-- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
VACUUM FULL concur_heap;
REINDEX TABLE concur_heap;
ERROR:  could not create unique index "concur_index3"
DETAIL:  Key (f2)=(b) is duplicated.
DELETE FROM concur_heap WHERE f1 = 'b';
VACUUM FULL concur_heap;
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "concur_heap_expr_idx" btree ((f2 || f1))
    "concur_index1" btree (f2, f1)
    "concur_index2" UNIQUE, btree (f1)
    "concur_index3" UNIQUE, btree (f2) INVALID
    "concur_index4" btree (f2) WHERE f1 = 'a'::text
    "concur_index5" btree (f2) WHERE f1 = 'x'::text
    "std_index" btree (f2)

REINDEX TABLE concur_heap;
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "concur_heap_expr_idx" btree ((f2 || f1))
    "concur_index1" btree (f2, f1)
    "concur_index2" UNIQUE, btree (f1)
    "concur_index3" UNIQUE, btree (f2)
    "concur_index4" btree (f2) WHERE f1 = 'a'::text
    "concur_index5" btree (f2) WHERE f1 = 'x'::text
    "std_index" btree (f2)

-- Temporary tables with concurrent builds and on-commit actions
-- CONCURRENTLY used with CREATE INDEX and DROP INDEX is ignored.
-- PRESERVE ROWS, the default.
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
DROP INDEX CONCURRENTLY concur_temp_ind;
DROP TABLE concur_temp;
-- ON COMMIT DROP
BEGIN;
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT DROP;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
-- Fails when running in a transaction.
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- ON COMMIT DELETE ROWS
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT DELETE ROWS;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
DROP INDEX CONCURRENTLY concur_temp_ind;
DROP TABLE concur_temp;
--
-- Try some concurrent index drops
--
DROP INDEX CONCURRENTLY "concur_index2";				-- works
DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
NOTICE:  index "concur_index2" does not exist, skipping
-- failures
DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
BEGIN;
DROP INDEX CONCURRENTLY "concur_index5";
ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
ROLLBACK;
-- successes
DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
DROP INDEX CONCURRENTLY "concur_index4";
DROP INDEX CONCURRENTLY "concur_index5";
DROP INDEX CONCURRENTLY "concur_index1";
DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "std_index" btree (f2)

DROP TABLE concur_heap;
--
-- Test ADD CONSTRAINT USING INDEX
--
CREATE TABLE cwi_test( a int , b varchar(10), c char);
-- add some data so that all tests have something to work with.
INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
\d cwi_test
                     Table "public.cwi_test"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           | not null | 
 b      | character varying(10) |           | not null | 
 c      | character(1)          |           |          | 
Indexes:
    "cwi_uniq_idx" PRIMARY KEY, btree (a, b)

\d cwi_uniq_idx
            Index "public.cwi_uniq_idx"
 Column |         Type          | Key? | Definition 
--------+-----------------------+------+------------
 a      | integer               | yes  | a
 b      | character varying(10) | yes  | b
primary key, btree, for table "public.cwi_test"

CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
		USING INDEX cwi_uniq2_idx;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
\d cwi_test
                     Table "public.cwi_test"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           | not null | 
 b      | character varying(10) |           | not null | 
 c      | character(1)          |           |          | 
Indexes:
    "cwi_replaced_pkey" PRIMARY KEY, btree (b, a)

\d cwi_replaced_pkey
          Index "public.cwi_replaced_pkey"
 Column |         Type          | Key? | Definition 
--------+-----------------------+------+------------
 b      | character varying(10) | yes  | b
 a      | integer               | yes  | a
primary key, btree, for table "public.cwi_test"

DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
-- Check that non-default index options are rejected
CREATE UNIQUE INDEX cwi_uniq3_idx ON cwi_test(a desc);
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;  -- fail
ERROR:  index "cwi_uniq3_idx" column number 1 does not have default sorting behavior
LINE 1: ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq3_idx;
                                 ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
CREATE UNIQUE INDEX cwi_uniq4_idx ON cwi_test(b collate "POSIX");
ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;  -- fail
ERROR:  index "cwi_uniq4_idx" column number 1 does not have default sorting behavior
LINE 1: ALTER TABLE cwi_test ADD UNIQUE USING INDEX cwi_uniq4_idx;
                                 ^
DETAIL:  Cannot create a primary key or unique constraint using such an index.
DROP TABLE cwi_test;
-- ADD CONSTRAINT USING INDEX is forbidden on partitioned tables
CREATE TABLE cwi_test(a int) PARTITION BY hash (a);
create unique index on cwi_test (a);
alter table cwi_test add primary key using index cwi_test_a_idx ;
ERROR:  ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables
DROP TABLE cwi_test;
-- PRIMARY KEY constraint cannot be backed by a NULLS NOT DISTINCT index
CREATE TABLE cwi_test(a int, b int);
CREATE UNIQUE INDEX cwi_a_nnd ON cwi_test (a) NULLS NOT DISTINCT;
ALTER TABLE cwi_test ADD PRIMARY KEY USING INDEX cwi_a_nnd;
ERROR:  primary keys cannot use NULLS NOT DISTINCT indexes
DROP TABLE cwi_test;
--
-- Check handling of indexes on system columns
--
CREATE TABLE syscol_table (a INT);
-- System columns cannot be indexed
CREATE INDEX ON syscolcol_table (ctid);
ERROR:  relation "syscolcol_table" does not exist
-- nor used in expressions
CREATE INDEX ON syscol_table ((ctid >= '(1000,0)'));
ERROR:  index creation on system columns is not supported
-- nor used in predicates
CREATE INDEX ON syscol_table (a) WHERE ctid >= '(1000,0)';
ERROR:  index creation on system columns is not supported
DROP TABLE syscol_table;
--
-- Tests for IS NULL/IS NOT NULL with b-tree indexes
--
CREATE TABLE onek_with_null AS SELECT unique1, unique2 FROM onek;
INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = ON;
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
-- Check initial-positioning logic too
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
     147 |       0
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
     147 |       0
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
     147 |       0
     931 |       1
(2 rows)

SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
         |        
     278 |     999
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
     278 |     999
       0 |     998
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
       0 |     998
     744 |     997
(2 rows)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
DROP TABLE onek_with_null;
--
-- Check bitmap index path planning
--
EXPLAIN (COSTS OFF)
SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Bitmap Heap Scan on tenk1
   Recheck Cond: (((thousand = 42) AND (tenthous = 1)) OR ((thousand = 42) AND (tenthous = 3)) OR ((thousand = 42) AND (tenthous = 42)))
   ->  BitmapOr
         ->  Bitmap Index Scan on tenk1_thous_tenthous
               Index Cond: ((thousand = 42) AND (tenthous = 1))
         ->  Bitmap Index Scan on tenk1_thous_tenthous
               Index Cond: ((thousand = 42) AND (tenthous = 3))
         ->  Bitmap Index Scan on tenk1_thous_tenthous
               Index Cond: ((thousand = 42) AND (tenthous = 42))
(9 rows)

SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
      42 |    5530 |   0 |    2 |   2 |      2 |      42 |       42 |          42 |        42 |       42 |  84 |   85 | QBAAAA   | SEIAAA   | OOOOxx
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on tenk1
         Recheck Cond: ((hundred = 42) AND ((thousand = 42) OR (thousand = 99)))
         ->  BitmapAnd
               ->  Bitmap Index Scan on tenk1_hundred
                     Index Cond: (hundred = 42)
               ->  BitmapOr
                     ->  Bitmap Index Scan on tenk1_thous_tenthous
                           Index Cond: (thousand = 42)
                     ->  Bitmap Index Scan on tenk1_thous_tenthous
                           Index Cond: (thousand = 99)
(11 rows)

SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
 count 
-------
    10
(1 row)

--
-- Check behavior with duplicate index column contents
--
CREATE TABLE dupindexcols AS
  SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
ANALYZE dupindexcols;
EXPLAIN (COSTS OFF)
  SELECT count(*) FROM dupindexcols
    WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Bitmap Heap Scan on dupindexcols
         Recheck Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
         ->  Bitmap Index Scan on dupindexcols_i
               Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
(5 rows)

SELECT count(*) FROM dupindexcols
  WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
 count 
-------
    97
(1 row)

--
-- Check ordering of =ANY indexqual results (bug in 9.2.0)
--
explain (costs off)
SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
                      QUERY PLAN                       
-------------------------------------------------------
 Index Only Scan using tenk1_unique1 on tenk1
   Index Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
(2 rows)

SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
 unique1 
---------
       1
       7
      42
(3 rows)

explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
                      QUERY PLAN                       
-------------------------------------------------------
 Index Only Scan using tenk1_thous_tenthous on tenk1
   Index Cond: (thousand < 2)
   Filter: (tenthous = ANY ('{1001,3000}'::integer[]))
(3 rows)

SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

SET enable_indexonlyscan = OFF;
explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
                                      QUERY PLAN                                      
--------------------------------------------------------------------------------------
 Sort
   Sort Key: thousand
   ->  Index Scan using tenk1_thous_tenthous on tenk1
         Index Cond: ((thousand < 2) AND (tenthous = ANY ('{1001,3000}'::integer[])))
(4 rows)

SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

RESET enable_indexonlyscan;
--
-- Check elimination of constant-NULL subexpressions
--
explain (costs off)
  select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
                      QUERY PLAN                      
------------------------------------------------------
 Index Scan using tenk1_thous_tenthous on tenk1
   Index Cond: ((thousand = 1) AND (tenthous = 1001))
(2 rows)

--
-- Check matching of boolean index columns to WHERE conditions and sort keys
--
create temp table boolindex (b bool, i int, unique(b, i), junk float);
explain (costs off)
  select * from boolindex order by b, i limit 10;
                      QUERY PLAN                       
-------------------------------------------------------
 Limit
   ->  Index Scan using boolindex_b_i_key on boolindex
(2 rows)

explain (costs off)
  select * from boolindex where b order by i limit 10;
                      QUERY PLAN                       
-------------------------------------------------------
 Limit
   ->  Index Scan using boolindex_b_i_key on boolindex
         Index Cond: (b = true)
(3 rows)

explain (costs off)
  select * from boolindex where b = true order by i desc limit 10;
                           QUERY PLAN                           
----------------------------------------------------------------
 Limit
   ->  Index Scan Backward using boolindex_b_i_key on boolindex
         Index Cond: (b = true)
(3 rows)

explain (costs off)
  select * from boolindex where not b order by i limit 10;
                      QUERY PLAN                       
-------------------------------------------------------
 Limit
   ->  Index Scan using boolindex_b_i_key on boolindex
         Index Cond: (b = false)
(3 rows)

explain (costs off)
  select * from boolindex where b is true order by i desc limit 10;
                           QUERY PLAN                           
----------------------------------------------------------------
 Limit
   ->  Index Scan Backward using boolindex_b_i_key on boolindex
         Index Cond: (b = true)
(3 rows)

explain (costs off)
  select * from boolindex where b is false order by i desc limit 10;
                           QUERY PLAN                           
----------------------------------------------------------------
 Limit
   ->  Index Scan Backward using boolindex_b_i_key on boolindex
         Index Cond: (b = false)
(3 rows)

--
-- REINDEX (VERBOSE)
--
CREATE TABLE reindex_verbose(id integer primary key);
\set VERBOSITY terse \\ -- suppress machine-dependent details
REINDEX (VERBOSE) TABLE reindex_verbose;
INFO:  index "reindex_verbose_pkey" was reindexed
\set VERBOSITY default
DROP TABLE reindex_verbose;
--
-- REINDEX CONCURRENTLY
--
CREATE TABLE concur_reindex_tab (c1 int);
-- REINDEX
REINDEX TABLE concur_reindex_tab; -- notice
NOTICE:  table "concur_reindex_tab" has no indexes to reindex
REINDEX (CONCURRENTLY) TABLE concur_reindex_tab; -- notice
NOTICE:  table "concur_reindex_tab" has no indexes that can be reindexed concurrently
ALTER TABLE concur_reindex_tab ADD COLUMN c2 text; -- add toast index
-- Normal index with integer column
CREATE UNIQUE INDEX concur_reindex_ind1 ON concur_reindex_tab(c1);
-- Normal index with text column
CREATE INDEX concur_reindex_ind2 ON concur_reindex_tab(c2);
-- UNIQUE index with expression
CREATE UNIQUE INDEX concur_reindex_ind3 ON concur_reindex_tab(abs(c1));
-- Duplicate column names
CREATE INDEX concur_reindex_ind4 ON concur_reindex_tab(c1, c1, c2);
-- Create table for check on foreign key dependence switch with indexes swapped
ALTER TABLE concur_reindex_tab ADD PRIMARY KEY USING INDEX concur_reindex_ind1;
CREATE TABLE concur_reindex_tab2 (c1 int REFERENCES concur_reindex_tab);
INSERT INTO concur_reindex_tab VALUES  (1, 'a');
INSERT INTO concur_reindex_tab VALUES  (2, 'a');
-- Reindex concurrently of exclusion constraint currently not supported
CREATE TABLE concur_reindex_tab3 (c1 int, c2 int4range, EXCLUDE USING gist (c2 WITH &&));
INSERT INTO concur_reindex_tab3 VALUES  (3, '[1,2]');
REINDEX INDEX CONCURRENTLY  concur_reindex_tab3_c2_excl;  -- error
ERROR:  concurrent index creation for exclusion constraints is not supported
REINDEX TABLE CONCURRENTLY concur_reindex_tab3;  -- succeeds with warning
WARNING:  cannot reindex exclusion constraint index "public.concur_reindex_tab3_c2_excl" concurrently, skipping
INSERT INTO concur_reindex_tab3 VALUES  (4, '[2,4]');
ERROR:  conflicting key value violates exclusion constraint "concur_reindex_tab3_c2_excl"
DETAIL:  Key (c2)=([2,5)) conflicts with existing key (c2)=([1,3)).
-- Check materialized views
CREATE MATERIALIZED VIEW concur_reindex_matview AS SELECT * FROM concur_reindex_tab;
-- Dependency lookup before and after the follow-up REINDEX commands.
-- These should remain consistent.
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_tab'::regclass,
            'concur_reindex_ind1'::regclass,
	    'concur_reindex_ind2'::regclass,
	    'concur_reindex_ind3'::regclass,
	    'concur_reindex_ind4'::regclass,
	    'concur_reindex_matview'::regclass)
  ORDER BY 1, 2;
                   obj                    |                           objref                           | deptype 
------------------------------------------+------------------------------------------------------------+---------
 index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
 index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | table concur_reindex_tab                                   | a
 index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
 materialized view concur_reindex_matview | schema public                                              | n
 table concur_reindex_tab                 | schema public                                              | n
(8 rows)

REINDEX INDEX CONCURRENTLY concur_reindex_ind1;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
REINDEX TABLE CONCURRENTLY concur_reindex_matview;
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_tab'::regclass,
            'concur_reindex_ind1'::regclass,
	    'concur_reindex_ind2'::regclass,
	    'concur_reindex_ind3'::regclass,
	    'concur_reindex_ind4'::regclass,
	    'concur_reindex_matview'::regclass)
  ORDER BY 1, 2;
                   obj                    |                           objref                           | deptype 
------------------------------------------+------------------------------------------------------------+---------
 index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
 index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | table concur_reindex_tab                                   | a
 index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
 materialized view concur_reindex_matview | schema public                                              | n
 table concur_reindex_tab                 | schema public                                              | n
(8 rows)

-- Check that comments are preserved
CREATE TABLE testcomment (i int);
CREATE INDEX testcomment_idx1 ON testcomment (i);
COMMENT ON INDEX testcomment_idx1 IS 'test comment';
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

REINDEX TABLE testcomment;
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

REINDEX TABLE CONCURRENTLY testcomment ;
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

DROP TABLE testcomment;
-- Check that indisclustered updates are preserved
CREATE TABLE concur_clustered(i int);
CREATE INDEX concur_clustered_i_idx ON concur_clustered(i);
ALTER TABLE concur_clustered CLUSTER ON concur_clustered_i_idx;
REINDEX TABLE CONCURRENTLY concur_clustered;
SELECT indexrelid::regclass, indisclustered FROM pg_index
  WHERE indrelid = 'concur_clustered'::regclass;
       indexrelid       | indisclustered 
------------------------+----------------
 concur_clustered_i_idx | t
(1 row)

DROP TABLE concur_clustered;
-- Check that indisreplident updates are preserved.
CREATE TABLE concur_replident(i int NOT NULL);
CREATE UNIQUE INDEX concur_replident_i_idx ON concur_replident(i);
ALTER TABLE concur_replident REPLICA IDENTITY
  USING INDEX concur_replident_i_idx;
SELECT indexrelid::regclass, indisreplident FROM pg_index
  WHERE indrelid = 'concur_replident'::regclass;
       indexrelid       | indisreplident 
------------------------+----------------
 concur_replident_i_idx | t
(1 row)

REINDEX TABLE CONCURRENTLY concur_replident;
SELECT indexrelid::regclass, indisreplident FROM pg_index
  WHERE indrelid = 'concur_replident'::regclass;
       indexrelid       | indisreplident 
------------------------+----------------
 concur_replident_i_idx | t
(1 row)

DROP TABLE concur_replident;
-- Check that opclass parameters are preserved
CREATE TABLE concur_appclass_tab(i tsvector, j tsvector, k tsvector);
CREATE INDEX concur_appclass_ind on concur_appclass_tab
  USING gist (i tsvector_ops (siglen='1000'), j tsvector_ops (siglen='500'));
CREATE INDEX concur_appclass_ind_2 on concur_appclass_tab
  USING gist (k tsvector_ops (siglen='300'), j tsvector_ops);
REINDEX TABLE CONCURRENTLY concur_appclass_tab;
\d concur_appclass_tab
         Table "public.concur_appclass_tab"
 Column |   Type   | Collation | Nullable | Default 
--------+----------+-----------+----------+---------
 i      | tsvector |           |          | 
 j      | tsvector |           |          | 
 k      | tsvector |           |          | 
Indexes:
    "concur_appclass_ind" gist (i tsvector_ops (siglen='1000'), j tsvector_ops (siglen='500'))
    "concur_appclass_ind_2" gist (k tsvector_ops (siglen='300'), j)

DROP TABLE concur_appclass_tab;
-- Partitions
-- Create some partitioned tables
CREATE TABLE concur_reindex_part (c1 int, c2 int) PARTITION BY RANGE (c1);
CREATE TABLE concur_reindex_part_0 PARTITION OF concur_reindex_part
  FOR VALUES FROM (0) TO (10) PARTITION BY list (c2);
CREATE TABLE concur_reindex_part_0_1 PARTITION OF concur_reindex_part_0
  FOR VALUES IN (1);
CREATE TABLE concur_reindex_part_0_2 PARTITION OF concur_reindex_part_0
  FOR VALUES IN (2);
-- This partitioned table will have no partitions.
CREATE TABLE concur_reindex_part_10 PARTITION OF concur_reindex_part
  FOR VALUES FROM (10) TO (20) PARTITION BY list (c2);
-- Create some partitioned indexes
CREATE INDEX concur_reindex_part_index ON ONLY concur_reindex_part (c1);
CREATE INDEX concur_reindex_part_index_0 ON ONLY concur_reindex_part_0 (c1);
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_0;
-- This partitioned index will have no partitions.
CREATE INDEX concur_reindex_part_index_10 ON ONLY concur_reindex_part_10 (c1);
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_10;
CREATE INDEX concur_reindex_part_index_0_1 ON ONLY concur_reindex_part_0_1 (c1);
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_1;
CREATE INDEX concur_reindex_part_index_0_2 ON ONLY concur_reindex_part_0_2 (c1);
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

-- REINDEX should preserve dependencies of partition tree.
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_part'::regclass,
            'concur_reindex_part_0'::regclass,
            'concur_reindex_part_0_1'::regclass,
            'concur_reindex_part_0_2'::regclass,
            'concur_reindex_part_index'::regclass,
            'concur_reindex_part_index_0'::regclass,
            'concur_reindex_part_index_0_1'::regclass,
            'concur_reindex_part_index_0_2'::regclass)
  ORDER BY 1, 2;
                   obj                    |                   objref                   | deptype 
------------------------------------------+--------------------------------------------+---------
 column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
 column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
 index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
 index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
 index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
 index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
 index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
 index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
 index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
 index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
 table concur_reindex_part                | schema public                              | n
 table concur_reindex_part_0              | schema public                              | n
 table concur_reindex_part_0              | table concur_reindex_part                  | a
 table concur_reindex_part_0_1            | schema public                              | n
 table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
 table concur_reindex_part_0_2            | schema public                              | n
 table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
(19 rows)

REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1;
REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2;
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_part'::regclass,
            'concur_reindex_part_0'::regclass,
            'concur_reindex_part_0_1'::regclass,
            'concur_reindex_part_0_2'::regclass,
            'concur_reindex_part_index'::regclass,
            'concur_reindex_part_index_0'::regclass,
            'concur_reindex_part_index_0_1'::regclass,
            'concur_reindex_part_index_0_2'::regclass)
  ORDER BY 1, 2;
                   obj                    |                   objref                   | deptype 
------------------------------------------+--------------------------------------------+---------
 column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
 column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
 index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
 index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
 index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
 index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
 index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
 index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
 index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
 index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
 table concur_reindex_part                | schema public                              | n
 table concur_reindex_part_0              | schema public                              | n
 table concur_reindex_part_0              | table concur_reindex_part                  | a
 table concur_reindex_part_0_1            | schema public                              | n
 table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
 table concur_reindex_part_0_2            | schema public                              | n
 table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
(19 rows)

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

-- REINDEX for partitioned indexes
-- REINDEX TABLE fails for partitioned indexes
-- Top-most parent index
REINDEX TABLE concur_reindex_part_index; -- error
ERROR:  "concur_reindex_part_index" is not a table or materialized view
REINDEX TABLE CONCURRENTLY concur_reindex_part_index; -- error
ERROR:  "concur_reindex_part_index" is not a table or materialized view
-- Partitioned index with no leaves
REINDEX TABLE concur_reindex_part_index_10; -- error
ERROR:  "concur_reindex_part_index_10" is not a table or materialized view
REINDEX TABLE CONCURRENTLY concur_reindex_part_index_10; -- error
ERROR:  "concur_reindex_part_index_10" is not a table or materialized view
-- Cannot run in a transaction block
BEGIN;
REINDEX INDEX concur_reindex_part_index;
ERROR:  REINDEX INDEX cannot run inside a transaction block
CONTEXT:  while reindexing partitioned index "public.concur_reindex_part_index"
ROLLBACK;
-- Helper functions to track changes of relfilenodes in a partition tree.
-- Create a table tracking the relfilenode state.
CREATE OR REPLACE FUNCTION create_relfilenode_part(relname text, indname text)
  RETURNS VOID AS
  $func$
  BEGIN
  EXECUTE format('
    CREATE TABLE %I AS
      SELECT oid, relname, relfilenode, relkind, reltoastrelid
      FROM pg_class
      WHERE oid IN
         (SELECT relid FROM pg_partition_tree(''%I''));',
	 relname, indname);
  END
  $func$ LANGUAGE plpgsql;
CREATE OR REPLACE FUNCTION compare_relfilenode_part(tabname text)
  RETURNS TABLE (relname name, relkind "char", state text) AS
  $func$
  BEGIN
    RETURN QUERY EXECUTE
      format(
        'SELECT  b.relname,
                 b.relkind,
                 CASE WHEN a.relfilenode = b.relfilenode THEN ''relfilenode is unchanged''
                 ELSE ''relfilenode has changed'' END
           -- Do not join with OID here as CONCURRENTLY changes it.
           FROM %I b JOIN pg_class a ON b.relname = a.relname
           ORDER BY 1;', tabname);
  END
  $func$ LANGUAGE plpgsql;
--  Check that expected relfilenodes are changed, non-concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX INDEX concur_reindex_part_index;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
-- concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX INDEX CONCURRENTLY concur_reindex_part_index;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
-- REINDEX for partitioned tables
-- REINDEX INDEX fails for partitioned tables
-- Top-most parent
REINDEX INDEX concur_reindex_part; -- error
ERROR:  "concur_reindex_part" is not an index
REINDEX INDEX CONCURRENTLY concur_reindex_part; -- error
ERROR:  "concur_reindex_part" is not an index
-- Partitioned with no leaves
REINDEX INDEX concur_reindex_part_10; -- error
ERROR:  "concur_reindex_part_10" is not an index
REINDEX INDEX CONCURRENTLY concur_reindex_part_10; -- error
ERROR:  "concur_reindex_part_10" is not an index
-- Cannot run in a transaction block
BEGIN;
REINDEX TABLE concur_reindex_part;
ERROR:  REINDEX TABLE cannot run inside a transaction block
CONTEXT:  while reindexing partitioned table "public.concur_reindex_part"
ROLLBACK;
-- Check that expected relfilenodes are changed, non-concurrent case.
-- Note that the partition tree changes of the *indexes* need to be checked.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX TABLE concur_reindex_part;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
-- concurrent case.
SELECT create_relfilenode_part('reindex_index_status', 'concur_reindex_part_index');
 create_relfilenode_part 
-------------------------
 
(1 row)

REINDEX TABLE CONCURRENTLY concur_reindex_part;
SELECT * FROM compare_relfilenode_part('reindex_index_status');
            relname            | relkind |          state           
-------------------------------+---------+--------------------------
 concur_reindex_part_index     | I       | relfilenode is unchanged
 concur_reindex_part_index_0   | I       | relfilenode is unchanged
 concur_reindex_part_index_0_1 | i       | relfilenode has changed
 concur_reindex_part_index_0_2 | i       | relfilenode has changed
 concur_reindex_part_index_10  | I       | relfilenode is unchanged
(5 rows)

DROP TABLE reindex_index_status;
DROP FUNCTION create_relfilenode_part;
DROP FUNCTION compare_relfilenode_part;
-- Cleanup of partition tree used for REINDEX test.
DROP TABLE concur_reindex_part;
-- Check errors
-- Cannot run inside a transaction block
BEGIN;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
REINDEX TABLE CONCURRENTLY pg_class; -- no catalog relation
ERROR:  cannot reindex system catalogs concurrently
REINDEX INDEX CONCURRENTLY pg_class_oid_index; -- no catalog index
ERROR:  cannot reindex system catalogs concurrently
-- These are the toast table and index of pg_authid.
REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260; -- no catalog toast table
ERROR:  cannot reindex system catalogs concurrently
REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index; -- no catalog toast index
ERROR:  cannot reindex system catalogs concurrently
REINDEX SYSTEM CONCURRENTLY postgres; -- not allowed for SYSTEM
ERROR:  cannot reindex system catalogs concurrently
REINDEX (CONCURRENTLY) SYSTEM postgres; -- ditto
ERROR:  cannot reindex system catalogs concurrently
REINDEX (CONCURRENTLY) SYSTEM;  -- ditto
ERROR:  cannot reindex system catalogs concurrently
-- Warns about catalog relations
REINDEX SCHEMA CONCURRENTLY pg_catalog;
WARNING:  cannot reindex system catalogs concurrently, skipping all
-- Not the current database
REINDEX DATABASE not_current_database;
ERROR:  can only reindex the currently open database
-- Check the relation status, there should not be invalid indexes
\d concur_reindex_tab
         Table "public.concur_reindex_tab"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           | not null | 
 c2     | text    |           |          | 
Indexes:
    "concur_reindex_ind1" PRIMARY KEY, btree (c1)
    "concur_reindex_ind2" btree (c2)
    "concur_reindex_ind3" UNIQUE, btree (abs(c1))
    "concur_reindex_ind4" btree (c1, c1, c2)
Referenced by:
    TABLE "concur_reindex_tab2" CONSTRAINT "concur_reindex_tab2_c1_fkey" FOREIGN KEY (c1) REFERENCES concur_reindex_tab(c1)

DROP MATERIALIZED VIEW concur_reindex_matview;
DROP TABLE concur_reindex_tab, concur_reindex_tab2, concur_reindex_tab3;
-- Check handling of invalid indexes
CREATE TABLE concur_reindex_tab4 (c1 int);
INSERT INTO concur_reindex_tab4 VALUES (1), (1), (2);
-- This trick creates an invalid index.
CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
ERROR:  could not create unique index "concur_reindex_ind5"
DETAIL:  Key (c1)=(1) is duplicated.
-- Reindexing concurrently this index fails with the same failure.
-- The extra index created is itself invalid, and can be dropped.
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
ERROR:  could not create unique index "concur_reindex_ind5_ccnew"
DETAIL:  Key (c1)=(1) is duplicated.
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 
Indexes:
    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID
    "concur_reindex_ind5_ccnew" UNIQUE, btree (c1) INVALID

DROP INDEX concur_reindex_ind5_ccnew;
-- This makes the previous failure go away, so the index can become valid.
DELETE FROM concur_reindex_tab4 WHERE c1 = 1;
-- The invalid index is not processed when running REINDEX TABLE.
REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
WARNING:  skipping reindex of invalid index "public.concur_reindex_ind5"
HINT:  Use DROP INDEX or REINDEX INDEX.
NOTICE:  table "concur_reindex_tab4" has no indexes that can be reindexed concurrently
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 
Indexes:
    "concur_reindex_ind5" UNIQUE, btree (c1) INVALID

-- But it is fixed with REINDEX INDEX.
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 
Indexes:
    "concur_reindex_ind5" UNIQUE, btree (c1)

DROP TABLE concur_reindex_tab4;
-- Check handling of indexes with expressions and predicates.  The
-- definitions of the rebuilt indexes should match the original
-- definitions.
CREATE TABLE concur_exprs_tab (c1 int , c2 boolean);
INSERT INTO concur_exprs_tab (c1, c2) VALUES (1369652450, FALSE),
  (414515746, TRUE),
  (897778963, FALSE);
CREATE UNIQUE INDEX concur_exprs_index_expr
  ON concur_exprs_tab ((c1::text COLLATE "C"));
CREATE UNIQUE INDEX concur_exprs_index_pred ON concur_exprs_tab (c1)
  WHERE (c1::text > 500000000::text COLLATE "C");
CREATE UNIQUE INDEX concur_exprs_index_pred_2
  ON concur_exprs_tab ((1 / c1))
  WHERE ('-H') >= (c2::TEXT) COLLATE "C";
ALTER INDEX concur_exprs_index_expr ALTER COLUMN 1 SET STATISTICS 100;
ANALYZE concur_exprs_tab;
SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
  'concur_exprs_index_expr'::regclass,
  'concur_exprs_index_pred'::regclass,
  'concur_exprs_index_pred_2'::regclass)
  GROUP BY starelid ORDER BY starelid::regclass::text;
        starelid         | count 
-------------------------+-------
 concur_exprs_index_expr |     1
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                                 pg_get_indexdef                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
(1 row)

REINDEX TABLE CONCURRENTLY concur_exprs_tab;
SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                                 pg_get_indexdef                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
(1 row)

-- ALTER TABLE recreates the indexes, which should keep their collations.
ALTER TABLE concur_exprs_tab ALTER c2 TYPE TEXT;
SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                             pg_get_indexdef                                                              
------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= (c2 COLLATE "C"))
(1 row)

-- Statistics should remain intact.
SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
  'concur_exprs_index_expr'::regclass,
  'concur_exprs_index_pred'::regclass,
  'concur_exprs_index_pred_2'::regclass)
  GROUP BY starelid ORDER BY starelid::regclass::text;
        starelid         | count 
-------------------------+-------
 concur_exprs_index_expr |     1
(1 row)

-- attstattarget should remain intact
SELECT attrelid::regclass, attnum, attstattarget
  FROM pg_attribute WHERE attrelid IN (
    'concur_exprs_index_expr'::regclass,
    'concur_exprs_index_pred'::regclass,
    'concur_exprs_index_pred_2'::regclass)
  ORDER BY attrelid::regclass::text, attnum;
         attrelid          | attnum | attstattarget 
---------------------------+--------+---------------
 concur_exprs_index_expr   |      1 |           100
 concur_exprs_index_pred   |      1 |              
 concur_exprs_index_pred_2 |      1 |              
(3 rows)

DROP TABLE concur_exprs_tab;
-- Temporary tables and on-commit actions, where CONCURRENTLY is ignored.
-- ON COMMIT PRESERVE ROWS, the default.
CREATE TEMP TABLE concur_temp_tab_1 (c1 int, c2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp_tab_1 VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX concur_temp_ind_1 ON concur_temp_tab_1(c2);
REINDEX TABLE CONCURRENTLY concur_temp_tab_1;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
-- Still fails in transaction blocks
BEGIN;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- ON COMMIT DELETE ROWS
CREATE TEMP TABLE concur_temp_tab_2 (c1 int, c2 text)
  ON COMMIT DELETE ROWS;
CREATE INDEX concur_temp_ind_2 ON concur_temp_tab_2(c2);
REINDEX TABLE CONCURRENTLY concur_temp_tab_2;
REINDEX INDEX CONCURRENTLY concur_temp_ind_2;
-- ON COMMIT DROP
BEGIN;
CREATE TEMP TABLE concur_temp_tab_3 (c1 int, c2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp_tab_3 VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX concur_temp_ind_3 ON concur_temp_tab_3(c2);
-- Fails when running in a transaction
REINDEX INDEX CONCURRENTLY concur_temp_ind_3;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- REINDEX SCHEMA processes all temporary relations
CREATE TABLE reindex_temp_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
  FROM pg_class
  WHERE relname IN ('concur_temp_ind_1', 'concur_temp_ind_2');
SELECT pg_my_temp_schema()::regnamespace as temp_schema_name \gset
REINDEX SCHEMA CONCURRENTLY :temp_schema_name;
SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_temp_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
      relname      | relkind |          case           
-------------------+---------+-------------------------
 concur_temp_ind_1 | i       | relfilenode has changed
 concur_temp_ind_2 | i       | relfilenode has changed
(2 rows)

DROP TABLE concur_temp_tab_1, concur_temp_tab_2, reindex_temp_before;
--
-- REINDEX SCHEMA
--
REINDEX SCHEMA schema_to_reindex; -- failure, schema does not exist
ERROR:  schema "schema_to_reindex" does not exist
CREATE SCHEMA schema_to_reindex;
SET search_path = 'schema_to_reindex';
CREATE TABLE table1(col1 SERIAL PRIMARY KEY);
INSERT INTO table1 SELECT generate_series(1,400);
CREATE TABLE table2(col1 SERIAL PRIMARY KEY, col2 TEXT NOT NULL);
INSERT INTO table2 SELECT generate_series(1,400), 'abc';
CREATE INDEX ON table2(col2);
CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
CREATE INDEX ON matview(col1);
CREATE VIEW view AS SELECT col2 FROM table2;
CREATE TABLE reindex_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelid
FROM pg_class WHERE oid IN
	(SELECT reltoastrelid FROM reindex_before WHERE reltoastrelid > 0);
INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE_index', relfilenode, relkind, reltoastrelid
FROM pg_class where oid in
	(select indexrelid from pg_index where indrelid in
		(select reltoastrelid from reindex_before where reltoastrelid > 0));
REINDEX SCHEMA schema_to_reindex;
CREATE TABLE reindex_after AS SELECT oid, relname, relfilenode, relkind
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
       relname        | relkind |           case           
----------------------+---------+--------------------------
 matview              | m       | relfilenode is unchanged
 matview_col1_idx     | i       | relfilenode has changed
 pg_toast_TABLE       | t       | relfilenode is unchanged
 pg_toast_TABLE_index | i       | relfilenode has changed
 table1               | r       | relfilenode is unchanged
 table1_col1_seq      | S       | relfilenode is unchanged
 table1_pkey          | i       | relfilenode has changed
 table2               | r       | relfilenode is unchanged
 table2_col1_seq      | S       | relfilenode is unchanged
 table2_col2_idx      | i       | relfilenode has changed
 table2_pkey          | i       | relfilenode has changed
 view                 | v       | relfilenode is unchanged
(12 rows)

REINDEX SCHEMA schema_to_reindex;
BEGIN;
REINDEX SCHEMA schema_to_reindex; -- failure, cannot run in a transaction
ERROR:  REINDEX SCHEMA cannot run inside a transaction block
END;
-- concurrently
REINDEX SCHEMA CONCURRENTLY schema_to_reindex;
-- Failure for unauthorized user
CREATE ROLE regress_reindexuser NOLOGIN;
SET SESSION ROLE regress_reindexuser;
REINDEX SCHEMA schema_to_reindex;
ERROR:  must be owner of schema schema_to_reindex
-- Permission failures with toast tables and indexes (pg_authid here)
RESET ROLE;
GRANT USAGE ON SCHEMA pg_toast TO regress_reindexuser;
SET SESSION ROLE regress_reindexuser;
REINDEX TABLE pg_toast.pg_toast_1260;
ERROR:  permission denied for table pg_toast_1260
REINDEX INDEX pg_toast.pg_toast_1260_index;
ERROR:  permission denied for index pg_toast_1260_index
-- Clean up
RESET ROLE;
REVOKE USAGE ON SCHEMA pg_toast FROM regress_reindexuser;
DROP ROLE regress_reindexuser;
DROP SCHEMA schema_to_reindex CASCADE;
NOTICE:  drop cascades to 6 other objects
DETAIL:  drop cascades to table table1
drop cascades to table table2
drop cascades to materialized view matview
drop cascades to view view
drop cascades to table reindex_before
drop cascades to table reindex_after
-- END setup from create_index 
-- START setup from  create_view
 
--
-- CREATE_VIEW
-- Virtual class definitions
--	(this also tests the query rewrite system)
--
-- directory paths and dlsuffix are passed to us in environment variables
\getenv abs_srcdir PG_ABS_SRCDIR
\getenv libdir PG_LIBDIR
\getenv dlsuffix PG_DLSUFFIX
\set regresslib :libdir '/regress' :dlsuffix
CREATE FUNCTION interpt_pp(path, path)
    RETURNS point
    AS :'regresslib'
    LANGUAGE C STRICT;
ERROR:  no schema has been selected to create in
CREATE TABLE real_city (
	pop			int4,
	cname		text,
	outline 	path
);
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE real_city (
                     ^
\set filename :abs_srcdir '/data/real_city.data'
COPY real_city FROM :'filename';
ERROR:  relation "real_city" does not exist
ANALYZE real_city;
ERROR:  relation "real_city" does not exist
SELECT *
   INTO TABLE ramp
   FROM ONLY road
   WHERE name ~ '.*Ramp';
ERROR:  relation "road" does not exist
LINE 3:    FROM ONLY road
                     ^
CREATE VIEW street AS
   SELECT r.name, r.thepath, c.cname AS cname
   FROM ONLY road r, real_city c
   WHERE c.outline ?# r.thepath;
ERROR:  relation "road" does not exist
LINE 3:    FROM ONLY road r, real_city c
                     ^
CREATE VIEW iexit AS
   SELECT ih.name, ih.thepath,
	interpt_pp(ih.thepath, r.thepath) AS exit
   FROM ihighway ih, ramp r
   WHERE ih.thepath ?# r.thepath;
ERROR:  relation "ihighway" does not exist
LINE 4:    FROM ihighway ih, ramp r
                ^
CREATE VIEW toyemp AS
   SELECT name, age, location, 12*salary AS annualsal
   FROM emp;
ERROR:  relation "emp" does not exist
LINE 3:    FROM emp;
                ^
-- Test comments
COMMENT ON VIEW noview IS 'no view';
ERROR:  relation "noview" does not exist
COMMENT ON VIEW toyemp IS 'is a view';
ERROR:  relation "toyemp" does not exist
COMMENT ON VIEW toyemp IS NULL;
ERROR:  relation "toyemp" does not exist
-- These views are left around mainly to exercise special cases in pg_dump.
CREATE TABLE view_base_table (key int PRIMARY KEY, data varchar(20));
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE view_base_table (key int PRIMARY KEY, data varc...
                     ^
CREATE VIEW key_dependent_view AS
   SELECT * FROM view_base_table GROUP BY key;
ERROR:  relation "view_base_table" does not exist
LINE 2:    SELECT * FROM view_base_table GROUP BY key;
                         ^
ALTER TABLE view_base_table DROP CONSTRAINT view_base_table_pkey;  -- fails
ERROR:  relation "view_base_table" does not exist
CREATE VIEW key_dependent_view_no_cols AS
   SELECT FROM view_base_table GROUP BY key HAVING length(data) > 0;
ERROR:  relation "view_base_table" does not exist
LINE 2:    SELECT FROM view_base_table GROUP BY key HAVING length(da...
                       ^
--
-- CREATE OR REPLACE VIEW
--
CREATE TABLE viewtest_tbl (a int, b int, c numeric(10,1), d text COLLATE "C");
ERROR:  no schema has been selected to create in
LINE 1: CREATE TABLE viewtest_tbl (a int, b int, c numeric(10,1), d ...
                     ^
COPY viewtest_tbl FROM stdin;
ERROR:  relation "viewtest_tbl" does not exist
5	10	1.1	xy
10	15	2.2	xyz
15	20	3.3	xyzz
20	25	4.4	xyzzy
\.
invalid command \.
CREATE OR REPLACE VIEW viewtest AS
	SELECT * FROM viewtest_tbl;
ERROR:  syntax error at or near "5"
LINE 1: 5 10 1.1 xy
        ^
CREATE OR REPLACE VIEW viewtest AS
	SELECT * FROM viewtest_tbl WHERE a > 10;
ERROR:  relation "viewtest_tbl" does not exist
LINE 2:  SELECT * FROM viewtest_tbl WHERE a > 10;
                       ^
SELECT * FROM viewtest;
ERROR:  relation "viewtest" does not exist
LINE 1: SELECT * FROM viewtest;
                      ^
CREATE OR REPLACE VIEW viewtest AS
	SELECT a, b, c, d FROM viewtest_tbl WHERE a > 5 ORDER BY b DESC;
ERROR:  relation "viewtest_tbl" does not exist
LINE 2:  SELECT a, b, c, d FROM viewtest_tbl WHERE a > 5 ORDER BY b ...
                                ^
SELECT * FROM viewtest;
ERROR:  relation "viewtest" does not exist
LINE 1: SELECT * FROM viewtest;
                      ^
-- should fail
CREATE OR REPLACE VIEW viewtest AS
	SELECT a FROM viewtest_tbl WHERE a <> 20;
ERROR:  relation "viewtest_tbl" does not exist
LINE 2:  SELECT a FROM viewtest_tbl WHERE a <> 20;
                       ^
-- should fail
CREATE OR REPLACE VIEW viewtest AS
	SELECT 1, * FROM viewtest_tbl;
ERROR:  relation "viewtest_tbl" does not exist
LINE 2:  SELECT 1, * FROM viewtest_tbl;
                          ^
-- should fail
CREATE OR REPLACE VIEW viewtest AS
	SELECT a, b::numeric, c, d FROM viewtest_tbl;
ERROR:  relation "viewtest_tbl" does not exist
LINE 2:  SELECT a, b::numeric, c, d FROM viewtest_tbl;
                                         ^
-- should fail
CREATE OR REPLACE VIEW viewtest AS
	SELECT a, b, c::numeric(10,2), d FROM viewtest_tbl;
ERROR:  relation "viewtest_tbl" does not exist
LINE 2:  SELECT a, b, c::numeric(10,2), d FROM viewtest_tbl;
                                               ^
-- should fail
CREATE OR REPLACE VIEW viewtest AS
	SELECT a, b, c, d COLLATE "POSIX" FROM viewtest_tbl;
ERROR:  relation "viewtest_tbl" does not exist
LINE 2:  SELECT a, b, c, d COLLATE "POSIX" FROM viewtest_tbl;
                                                ^
-- should work
CREATE OR REPLACE VIEW viewtest AS
	SELECT a, b, c, d, 0 AS e FROM viewtest_tbl;
ERROR:  relation "viewtest_tbl" does not exist
LINE 2:  SELECT a, b, c, d, 0 AS e FROM viewtest_tbl;
                                        ^
DROP VIEW viewtest;
ERROR:  view "viewtest" does not exist
DROP TABLE viewtest_tbl;
ERROR:  table "viewtest_tbl" does not exist
-- tests for temporary views
CREATE SCHEMA temp_view_test
    CREATE TABLE base_table (a int, id int)
    CREATE TABLE base_table2 (a int, id int);
SET search_path TO temp_view_test, public;
CREATE TEMPORARY TABLE temp_table (a int, id int);
-- should be created in temp_view_test schema
CREATE VIEW v1 AS SELECT * FROM base_table;
-- should be created in temp object schema
CREATE VIEW v1_temp AS SELECT * FROM temp_table;
NOTICE:  view "v1_temp" will be a temporary view
-- should be created in temp object schema
CREATE TEMP VIEW v2_temp AS SELECT * FROM base_table;
-- should be created in temp_views schema
CREATE VIEW temp_view_test.v2 AS SELECT * FROM base_table;
-- should fail
CREATE VIEW temp_view_test.v3_temp AS SELECT * FROM temp_table;
NOTICE:  view "v3_temp" will be a temporary view
ERROR:  cannot create temporary relation in non-temporary schema
-- should fail
CREATE SCHEMA test_view_schema
    CREATE TEMP VIEW testview AS SELECT 1;
ERROR:  cannot create temporary relation in non-temporary schema
-- joins: if any of the join relations are temporary, the view
-- should also be temporary
-- should be non-temp
CREATE VIEW v3 AS
    SELECT t1.a AS t1_a, t2.a AS t2_a
    FROM base_table t1, base_table2 t2
    WHERE t1.id = t2.id;
-- should be temp (one join rel is temp)
CREATE VIEW v4_temp AS
    SELECT t1.a AS t1_a, t2.a AS t2_a
    FROM base_table t1, temp_table t2
    WHERE t1.id = t2.id;
NOTICE:  view "v4_temp" will be a temporary view
-- should be temp
CREATE VIEW v5_temp AS
    SELECT t1.a AS t1_a, t2.a AS t2_a, t3.a AS t3_a
    FROM base_table t1, base_table2 t2, temp_table t3
    WHERE t1.id = t2.id and t2.id = t3.id;
NOTICE:  view "v5_temp" will be a temporary view
-- subqueries
CREATE VIEW v4 AS SELECT * FROM base_table WHERE id IN (SELECT id FROM base_table2);
CREATE VIEW v5 AS SELECT t1.id, t2.a FROM base_table t1, (SELECT * FROM base_table2) t2;
CREATE VIEW v6 AS SELECT * FROM base_table WHERE EXISTS (SELECT 1 FROM base_table2);
CREATE VIEW v7 AS SELECT * FROM base_table WHERE NOT EXISTS (SELECT 1 FROM base_table2);
CREATE VIEW v8 AS SELECT * FROM base_table WHERE EXISTS (SELECT 1);
CREATE VIEW v6_temp AS SELECT * FROM base_table WHERE id IN (SELECT id FROM temp_table);
NOTICE:  view "v6_temp" will be a temporary view
CREATE VIEW v7_temp AS SELECT t1.id, t2.a FROM base_table t1, (SELECT * FROM temp_table) t2;
NOTICE:  view "v7_temp" will be a temporary view
CREATE VIEW v8_temp AS SELECT * FROM base_table WHERE EXISTS (SELECT 1 FROM temp_table);
NOTICE:  view "v8_temp" will be a temporary view
CREATE VIEW v9_temp AS SELECT * FROM base_table WHERE NOT EXISTS (SELECT 1 FROM temp_table);
NOTICE:  view "v9_temp" will be a temporary view
-- a view should also be temporary if it references a temporary view
CREATE VIEW v10_temp AS SELECT * FROM v7_temp;
NOTICE:  view "v10_temp" will be a temporary view
CREATE VIEW v11_temp AS SELECT t1.id, t2.a FROM base_table t1, v10_temp t2;
NOTICE:  view "v11_temp" will be a temporary view
CREATE VIEW v12_temp AS SELECT true FROM v11_temp;
NOTICE:  view "v12_temp" will be a temporary view
-- a view should also be temporary if it references a temporary sequence
CREATE SEQUENCE seq1;
CREATE TEMPORARY SEQUENCE seq1_temp;
CREATE VIEW v9 AS SELECT seq1.is_called FROM seq1;
CREATE VIEW v13_temp AS SELECT seq1_temp.is_called FROM seq1_temp;
NOTICE:  view "v13_temp" will be a temporary view
SELECT relname FROM pg_class
    WHERE relname LIKE 'v_'
    AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'temp_view_test')
    ORDER BY relname;
 relname 
---------
 v1
 v2
 v3
 v4
 v5
 v6
 v7
 v8
 v9
(9 rows)

SELECT relname FROM pg_class
    WHERE relname LIKE 'v%'
    AND relnamespace IN (SELECT oid FROM pg_namespace WHERE nspname LIKE 'pg_temp%')
    ORDER BY relname;
 relname  
----------
 v10_temp
 v11_temp
 v12_temp
 v13_temp
 v1_temp
 v2_temp
 v4_temp
 v5_temp
 v6_temp
 v7_temp
 v8_temp
 v9_temp
(12 rows)

CREATE SCHEMA testviewschm2;
SET search_path TO testviewschm2, public;
CREATE TABLE t1 (num int, name text);
CREATE TABLE t2 (num2 int, value text);
CREATE TEMP TABLE tt (num2 int, value text);
CREATE VIEW nontemp1 AS SELECT * FROM t1 CROSS JOIN t2;
CREATE VIEW temporal1 AS SELECT * FROM t1 CROSS JOIN tt;
NOTICE:  view "temporal1" will be a temporary view
CREATE VIEW nontemp2 AS SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num2;
CREATE VIEW temporal2 AS SELECT * FROM t1 INNER JOIN tt ON t1.num = tt.num2;
NOTICE:  view "temporal2" will be a temporary view
CREATE VIEW nontemp3 AS SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num2;
CREATE VIEW temporal3 AS SELECT * FROM t1 LEFT JOIN tt ON t1.num = tt.num2;
NOTICE:  view "temporal3" will be a temporary view
CREATE VIEW nontemp4 AS SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num2 AND t2.value = 'xxx';
CREATE VIEW temporal4 AS SELECT * FROM t1 LEFT JOIN tt ON t1.num = tt.num2 AND tt.value = 'xxx';
NOTICE:  view "temporal4" will be a temporary view
SELECT relname FROM pg_class
    WHERE relname LIKE 'nontemp%'
    AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'testviewschm2')
    ORDER BY relname;
 relname  
----------
 nontemp1
 nontemp2
 nontemp3
 nontemp4
(4 rows)

SELECT relname FROM pg_class
    WHERE relname LIKE 'temporal%'
    AND relnamespace IN (SELECT oid FROM pg_namespace WHERE nspname LIKE 'pg_temp%')
    ORDER BY relname;
  relname  
-----------
 temporal1
 temporal2
 temporal3
 temporal4
(4 rows)

CREATE TABLE tbl1 ( a int, b int);
CREATE TABLE tbl2 (c int, d int);
CREATE TABLE tbl3 (e int, f int);
CREATE TABLE tbl4 (g int, h int);
CREATE TEMP TABLE tmptbl (i int, j int);
--Should be in testviewschm2
CREATE   VIEW  pubview AS SELECT * FROM tbl1 WHERE tbl1.a
BETWEEN (SELECT d FROM tbl2 WHERE c = 1) AND (SELECT e FROM tbl3 WHERE f = 2)
AND EXISTS (SELECT g FROM tbl4 LEFT JOIN tbl3 ON tbl4.h = tbl3.f);
SELECT count(*) FROM pg_class where relname = 'pubview'
AND relnamespace IN (SELECT OID FROM pg_namespace WHERE nspname = 'testviewschm2');
 count 
-------
     1
(1 row)

--Should be in temp object schema
CREATE   VIEW  mytempview AS SELECT * FROM tbl1 WHERE tbl1.a
BETWEEN (SELECT d FROM tbl2 WHERE c = 1) AND (SELECT e FROM tbl3 WHERE f = 2)
AND EXISTS (SELECT g FROM tbl4 LEFT JOIN tbl3 ON tbl4.h = tbl3.f)
AND NOT EXISTS (SELECT g FROM tbl4 LEFT JOIN tmptbl ON tbl4.h = tmptbl.j);
NOTICE:  view "mytempview" will be a temporary view
SELECT count(*) FROM pg_class where relname LIKE 'mytempview'
And relnamespace IN (SELECT OID FROM pg_namespace WHERE nspname LIKE 'pg_temp%');
 count 
-------
     1
(1 row)

--
-- CREATE VIEW and WITH(...) clause
--
CREATE VIEW mysecview1
       AS SELECT * FROM tbl1 WHERE a = 0;
CREATE VIEW mysecview2 WITH (security_barrier=true)
       AS SELECT * FROM tbl1 WHERE a > 0;
CREATE VIEW mysecview3 WITH (security_barrier=false)
       AS SELECT * FROM tbl1 WHERE a < 0;
CREATE VIEW mysecview4 WITH (security_barrier)
       AS SELECT * FROM tbl1 WHERE a <> 0;
CREATE VIEW mysecview5 WITH (security_barrier=100)	-- Error
       AS SELECT * FROM tbl1 WHERE a > 100;
ERROR:  invalid value for boolean option "security_barrier": 100
CREATE VIEW mysecview6 WITH (invalid_option)		-- Error
       AS SELECT * FROM tbl1 WHERE a < 100;
ERROR:  unrecognized parameter "invalid_option"
CREATE VIEW mysecview7 WITH (security_invoker=true)
       AS SELECT * FROM tbl1 WHERE a = 100;
CREATE VIEW mysecview8 WITH (security_invoker=false, security_barrier=true)
       AS SELECT * FROM tbl1 WHERE a > 100;
CREATE VIEW mysecview9 WITH (security_invoker)
       AS SELECT * FROM tbl1 WHERE a < 100;
CREATE VIEW mysecview10 WITH (security_invoker=100)	-- Error
       AS SELECT * FROM tbl1 WHERE a <> 100;
ERROR:  invalid value for boolean option "security_invoker": 100
SELECT relname, relkind, reloptions FROM pg_class
       WHERE oid in ('mysecview1'::regclass, 'mysecview2'::regclass,
                     'mysecview3'::regclass, 'mysecview4'::regclass,
                     'mysecview7'::regclass, 'mysecview8'::regclass,
                     'mysecview9'::regclass)
       ORDER BY relname;
  relname   | relkind |                   reloptions                   
------------+---------+------------------------------------------------
 mysecview1 | v       | 
 mysecview2 | v       | {security_barrier=true}
 mysecview3 | v       | {security_barrier=false}
 mysecview4 | v       | {security_barrier=true}
 mysecview7 | v       | {security_invoker=true}
 mysecview8 | v       | {security_invoker=false,security_barrier=true}
 mysecview9 | v       | {security_invoker=true}
(7 rows)

CREATE OR REPLACE VIEW mysecview1
       AS SELECT * FROM tbl1 WHERE a = 256;
CREATE OR REPLACE VIEW mysecview2
       AS SELECT * FROM tbl1 WHERE a > 256;
CREATE OR REPLACE VIEW mysecview3 WITH (security_barrier=true)
       AS SELECT * FROM tbl1 WHERE a < 256;
CREATE OR REPLACE VIEW mysecview4 WITH (security_barrier=false)
       AS SELECT * FROM tbl1 WHERE a <> 256;
CREATE OR REPLACE VIEW mysecview7
       AS SELECT * FROM tbl1 WHERE a > 256;
CREATE OR REPLACE VIEW mysecview8 WITH (security_invoker=true)
       AS SELECT * FROM tbl1 WHERE a < 256;
CREATE OR REPLACE VIEW mysecview9 WITH (security_invoker=false, security_barrier=true)
       AS SELECT * FROM tbl1 WHERE a <> 256;
SELECT relname, relkind, reloptions FROM pg_class
       WHERE oid in ('mysecview1'::regclass, 'mysecview2'::regclass,
                     'mysecview3'::regclass, 'mysecview4'::regclass,
                     'mysecview7'::regclass, 'mysecview8'::regclass,
                     'mysecview9'::regclass)
       ORDER BY relname;
  relname   | relkind |                   reloptions                   
------------+---------+------------------------------------------------
 mysecview1 | v       | 
 mysecview2 | v       | 
 mysecview3 | v       | {security_barrier=true}
 mysecview4 | v       | {security_barrier=false}
 mysecview7 | v       | 
 mysecview8 | v       | {security_invoker=true}
 mysecview9 | v       | {security_invoker=false,security_barrier=true}
(7 rows)

-- Check that unknown literals are converted to "text" in CREATE VIEW,
-- so that we don't end up with unknown-type columns.
CREATE VIEW unspecified_types AS
  SELECT 42 as i, 42.5 as num, 'foo' as u, 'foo'::unknown as u2, null as n;
\d+ unspecified_types
                   View "testviewschm2.unspecified_types"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 i      | integer |           |          |         | plain    | 
 num    | numeric |           |          |         | main     | 
 u      | text    |           |          |         | extended | 
 u2     | text    |           |          |         | extended | 
 n      | text    |           |          |         | extended | 
View definition:
 SELECT 42 AS i,
    42.5 AS num,
    'foo'::text AS u,
    'foo'::text AS u2,
    NULL::text AS n;

SELECT * FROM unspecified_types;
 i  | num  |  u  | u2  | n 
----+------+-----+-----+---
 42 | 42.5 | foo | foo | 
(1 row)

-- This test checks that proper typmods are assigned in a multi-row VALUES
CREATE VIEW tt1 AS
  SELECT * FROM (
    VALUES
       ('abc'::varchar(3), '0123456789', 42, 'abcd'::varchar(4)),
       ('0123456789', 'abc'::varchar(3), 42.12, 'abc'::varchar(4))
  ) vv(a,b,c,d);
\d+ tt1
                                View "testviewschm2.tt1"
 Column |         Type         | Collation | Nullable | Default | Storage  | Description 
--------+----------------------+-----------+----------+---------+----------+-------------
 a      | character varying    |           |          |         | extended | 
 b      | character varying    |           |          |         | extended | 
 c      | numeric              |           |          |         | main     | 
 d      | character varying(4) |           |          |         | extended | 
View definition:
 SELECT a,
    b,
    c,
    d
   FROM ( VALUES ('abc'::character varying(3),'0123456789'::character varying,42,'abcd'::character varying(4)), ('0123456789'::character varying,'abc'::character varying(3),42.12,'abc'::character varying(4))) vv(a, b, c, d);

SELECT * FROM tt1;
     a      |     b      |   c   |  d   
------------+------------+-------+------
 abc        | 0123456789 |    42 | abcd
 0123456789 | abc        | 42.12 | abc
(2 rows)

SELECT a::varchar(3) FROM tt1;
  a  
-----
 abc
 012
(2 rows)

DROP VIEW tt1;
-- Test view decompilation in the face of relation renaming conflicts
CREATE TABLE tt1 (f1 int, f2 int, f3 text);
CREATE TABLE tx1 (x1 int, x2 int, x3 text);
CREATE TABLE temp_view_test.tt1 (y1 int, f2 int, f3 text);
CREATE VIEW aliased_view_1 AS
  select * from tt1
    where exists (select 1 from tx1 where tt1.f1 = tx1.x1);
CREATE VIEW aliased_view_2 AS
  select * from tt1 a1
    where exists (select 1 from tx1 where a1.f1 = tx1.x1);
CREATE VIEW aliased_view_3 AS
  select * from tt1
    where exists (select 1 from tx1 a2 where tt1.f1 = a2.x1);
CREATE VIEW aliased_view_4 AS
  select * from temp_view_test.tt1
    where exists (select 1 from tt1 where temp_view_test.tt1.y1 = tt1.f1);
\d+ aliased_view_1
                    View "testviewschm2.aliased_view_1"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM tt1
  WHERE (EXISTS ( SELECT 1
           FROM tx1
          WHERE tt1.f1 = tx1.x1));

\d+ aliased_view_2
                    View "testviewschm2.aliased_view_2"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM tt1 a1
  WHERE (EXISTS ( SELECT 1
           FROM tx1
          WHERE a1.f1 = tx1.x1));

\d+ aliased_view_3
                    View "testviewschm2.aliased_view_3"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM tt1
  WHERE (EXISTS ( SELECT 1
           FROM tx1 a2
          WHERE tt1.f1 = a2.x1));

\d+ aliased_view_4
                    View "testviewschm2.aliased_view_4"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 y1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT y1,
    f2,
    f3
   FROM temp_view_test.tt1
  WHERE (EXISTS ( SELECT 1
           FROM tt1 tt1_1
          WHERE tt1.y1 = tt1_1.f1));

ALTER TABLE tx1 RENAME TO a1;
\d+ aliased_view_1
                    View "testviewschm2.aliased_view_1"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM tt1
  WHERE (EXISTS ( SELECT 1
           FROM a1
          WHERE tt1.f1 = a1.x1));

\d+ aliased_view_2
                    View "testviewschm2.aliased_view_2"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM tt1 a1
  WHERE (EXISTS ( SELECT 1
           FROM a1 a1_1
          WHERE a1.f1 = a1_1.x1));

\d+ aliased_view_3
                    View "testviewschm2.aliased_view_3"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM tt1
  WHERE (EXISTS ( SELECT 1
           FROM a1 a2
          WHERE tt1.f1 = a2.x1));

\d+ aliased_view_4
                    View "testviewschm2.aliased_view_4"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 y1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT y1,
    f2,
    f3
   FROM temp_view_test.tt1
  WHERE (EXISTS ( SELECT 1
           FROM tt1 tt1_1
          WHERE tt1.y1 = tt1_1.f1));

ALTER TABLE tt1 RENAME TO a2;
\d+ aliased_view_1
                    View "testviewschm2.aliased_view_1"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM a2
  WHERE (EXISTS ( SELECT 1
           FROM a1
          WHERE a2.f1 = a1.x1));

\d+ aliased_view_2
                    View "testviewschm2.aliased_view_2"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM a2 a1
  WHERE (EXISTS ( SELECT 1
           FROM a1 a1_1
          WHERE a1.f1 = a1_1.x1));

\d+ aliased_view_3
                    View "testviewschm2.aliased_view_3"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM a2
  WHERE (EXISTS ( SELECT 1
           FROM a1 a2_1
          WHERE a2.f1 = a2_1.x1));

\d+ aliased_view_4
                    View "testviewschm2.aliased_view_4"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 y1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT y1,
    f2,
    f3
   FROM temp_view_test.tt1
  WHERE (EXISTS ( SELECT 1
           FROM a2
          WHERE tt1.y1 = a2.f1));

ALTER TABLE a1 RENAME TO tt1;
\d+ aliased_view_1
                    View "testviewschm2.aliased_view_1"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM a2
  WHERE (EXISTS ( SELECT 1
           FROM tt1
          WHERE a2.f1 = tt1.x1));

\d+ aliased_view_2
                    View "testviewschm2.aliased_view_2"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM a2 a1
  WHERE (EXISTS ( SELECT 1
           FROM tt1
          WHERE a1.f1 = tt1.x1));

\d+ aliased_view_3
                    View "testviewschm2.aliased_view_3"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM a2
  WHERE (EXISTS ( SELECT 1
           FROM tt1 a2_1
          WHERE a2.f1 = a2_1.x1));

\d+ aliased_view_4
                    View "testviewschm2.aliased_view_4"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 y1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT y1,
    f2,
    f3
   FROM temp_view_test.tt1
  WHERE (EXISTS ( SELECT 1
           FROM a2
          WHERE tt1.y1 = a2.f1));

ALTER TABLE a2 RENAME TO tx1;
ALTER TABLE tx1 SET SCHEMA temp_view_test;
\d+ aliased_view_1
                    View "testviewschm2.aliased_view_1"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM temp_view_test.tx1
  WHERE (EXISTS ( SELECT 1
           FROM tt1
          WHERE tx1.f1 = tt1.x1));

\d+ aliased_view_2
                    View "testviewschm2.aliased_view_2"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM temp_view_test.tx1 a1
  WHERE (EXISTS ( SELECT 1
           FROM tt1
          WHERE a1.f1 = tt1.x1));

\d+ aliased_view_3
                    View "testviewschm2.aliased_view_3"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM temp_view_test.tx1
  WHERE (EXISTS ( SELECT 1
           FROM tt1 a2
          WHERE tx1.f1 = a2.x1));

\d+ aliased_view_4
                    View "testviewschm2.aliased_view_4"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 y1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT y1,
    f2,
    f3
   FROM temp_view_test.tt1
  WHERE (EXISTS ( SELECT 1
           FROM temp_view_test.tx1
          WHERE tt1.y1 = tx1.f1));

ALTER TABLE temp_view_test.tt1 RENAME TO tmp1;
ALTER TABLE temp_view_test.tmp1 SET SCHEMA testviewschm2;
ALTER TABLE tmp1 RENAME TO tx1;
\d+ aliased_view_1
                    View "testviewschm2.aliased_view_1"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM temp_view_test.tx1
  WHERE (EXISTS ( SELECT 1
           FROM tt1
          WHERE tx1.f1 = tt1.x1));

\d+ aliased_view_2
                    View "testviewschm2.aliased_view_2"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM temp_view_test.tx1 a1
  WHERE (EXISTS ( SELECT 1
           FROM tt1
          WHERE a1.f1 = tt1.x1));

\d+ aliased_view_3
                    View "testviewschm2.aliased_view_3"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 f1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT f1,
    f2,
    f3
   FROM temp_view_test.tx1
  WHERE (EXISTS ( SELECT 1
           FROM tt1 a2
          WHERE tx1.f1 = a2.x1));

\d+ aliased_view_4
                    View "testviewschm2.aliased_view_4"
 Column |  Type   | Collation | Nullable | Default | Storage  | Description 
--------+---------+-----------+----------+---------+----------+-------------
 y1     | integer |           |          |         | plain    | 
 f2     | integer |           |          |         | plain    | 
 f3     | text    |           |          |         | extended | 
View definition:
 SELECT y1,
    f2,
    f3
   FROM tx1
  WHERE (EXISTS ( SELECT 1
           FROM temp_view_test.tx1 tx1_1
          WHERE tx1.y1 = tx1_1.f1));

-- Test aliasing of joins
create view view_of_joins as
select * from
  (select * from (tbl1 cross join tbl2) same) ss,
  (tbl3 cross join tbl4) same;
\d+ view_of_joins
                    View "testviewschm2.view_of_joins"
 Column |  Type   | Collation | Nullable | Default | Storage | Description 
--------+---------+-----------+----------+---------+---------+-------------
 a      | integer |           |          |         | plain   | 
 b      | integer |           |          |         | plain   | 
 c      | integer |           |          |         | plain   | 
 d      | integer |           |          |         | plain   | 
 e      | integer |           |          |         | plain   | 
 f      | integer |           |          |         | plain   | 
 g      | integer |           |          |         | plain   | 
 h      | integer |           |          |         | plain   | 
View definition:
 SELECT ss.a,
    ss.b,
    ss.c,
    ss.d,
    same.e,
    same.f,
    same.g,
    same.h
   FROM ( SELECT same_1.a,
            same_1.b,
            same_1.c,
            same_1.d
           FROM (tbl1
             CROSS JOIN tbl2) same_1) ss,
    (tbl3
     CROSS JOIN tbl4) same;

create table tbl1a (a int, c int);
create view view_of_joins_2a as select * from tbl1 join tbl1a using (a);
create view view_of_joins_2b as select * from tbl1 join tbl1a using (a) as x;
create view view_of_joins_2c as select * from (tbl1 join tbl1a using (a)) as y;
create view view_of_joins_2d as select * from (tbl1 join tbl1a using (a) as x) as y;
select pg_get_viewdef('view_of_joins_2a', true);
       pg_get_viewdef       
----------------------------
  SELECT tbl1.a,           +
     tbl1.b,               +
     tbl1a.c               +
    FROM tbl1              +
      JOIN tbl1a USING (a);
(1 row)

select pg_get_viewdef('view_of_joins_2b', true);
         pg_get_viewdef          
---------------------------------
  SELECT tbl1.a,                +
     tbl1.b,                    +
     tbl1a.c                    +
    FROM tbl1                   +
      JOIN tbl1a USING (a) AS x;
(1 row)

select pg_get_viewdef('view_of_joins_2c', true);
        pg_get_viewdef         
-------------------------------
  SELECT y.a,                 +
     y.b,                     +
     y.c                      +
    FROM (tbl1                +
      JOIN tbl1a USING (a)) y;
(1 row)

select pg_get_viewdef('view_of_joins_2d', true);
           pg_get_viewdef           
------------------------------------
  SELECT y.a,                      +
     y.b,                          +
     y.c                           +
    FROM (tbl1                     +
      JOIN tbl1a USING (a) AS x) y;
(1 row)

-- Test view decompilation in the face of column addition/deletion/renaming
create table tt2 (a int, b int, c int);
create table tt3 (ax int8, b int2, c numeric);
create table tt4 (ay int, b int, q int);
create view v1 as select * from tt2 natural join tt3;
create view v1a as select * from (tt2 natural join tt3) j;
create view v2 as select * from tt2 join tt3 using (b,c) join tt4 using (b);
create view v2a as select * from (tt2 join tt3 using (b,c) join tt4 using (b)) j;
create view v3 as select * from tt2 join tt3 using (b,c) full join tt4 using (b);
select pg_get_viewdef('v1', true);
       pg_get_viewdef        
-----------------------------
  SELECT tt2.b,             +
     tt3.c,                 +
     tt2.a,                 +
     tt3.ax                 +
    FROM tt2                +
      JOIN tt3 USING (b, c);
(1 row)

select pg_get_viewdef('v1a', true);
         pg_get_viewdef         
--------------------------------
  SELECT j.b,                  +
     j.c,                      +
     j.a,                      +
     j.ax                      +
    FROM (tt2                  +
      JOIN tt3 USING (b, c)) j;
(1 row)

select pg_get_viewdef('v2', true);
       pg_get_viewdef       
----------------------------
  SELECT tt2.b,            +
     tt3.c,                +
     tt2.a,                +
     tt3.ax,               +
     tt4.ay,               +
     tt4.q                 +
    FROM tt2               +
      JOIN tt3 USING (b, c)+
      JOIN tt4 USING (b);
(1 row)

select pg_get_viewdef('v2a', true);
       pg_get_viewdef        
-----------------------------
  SELECT j.b,               +
     j.c,                   +
     j.a,                   +
     j.ax,                  +
     j.ay,                  +
     j.q                    +
    FROM (tt2               +
      JOIN tt3 USING (b, c) +
      JOIN tt4 USING (b)) j;
(1 row)

select pg_get_viewdef('v3', true);
        pg_get_viewdef         
-------------------------------
  SELECT b,                   +
     tt3.c,                   +
     tt2.a,                   +
     tt3.ax,                  +
     tt4.ay,                  +
     tt4.q                    +
    FROM tt2                  +
      JOIN tt3 USING (b, c)   +
      FULL JOIN tt4 USING (b);
(1 row)

alter table tt2 add column d int;
alter table tt2 add column e int;
select pg_get_viewdef('v1', true);
       pg_get_viewdef        
-----------------------------
  SELECT tt2.b,             +
     tt3.c,                 +
     tt2.a,                 +
     tt3.ax                 +
    FROM tt2                +
      JOIN tt3 USING (b, c);
(1 row)

select pg_get_viewdef('v1a', true);
         pg_get_viewdef         
--------------------------------
  SELECT j.b,                  +
     j.c,                      +
     j.a,                      +
     j.ax                      +
    FROM (tt2                  +
      JOIN tt3 USING (b, c)) j;
(1 row)

select pg_get_viewdef('v2', true);
       pg_get_viewdef       
----------------------------
  SELECT tt2.b,            +
     tt3.c,                +
     tt2.a,                +
     tt3.ax,               +
     tt4.ay,               +
     tt4.q                 +
    FROM tt2               +
      JOIN tt3 USING (b, c)+
      JOIN tt4 USING (b);
(1 row)

select pg_get_viewdef('v2a', true);
       pg_get_viewdef        
-----------------------------
  SELECT j.b,               +
     j.c,                   +
     j.a,                   +
     j.ax,                  +
     j.ay,                  +
     j.q                    +
    FROM (tt2               +
      JOIN tt3 USING (b, c) +
      JOIN tt4 USING (b)) j;
(1 row)

select pg_get_viewdef('v3', true);
        pg_get_viewdef         
-------------------------------
  SELECT b,                   +
     tt3.c,                   +
     tt2.a,                   +
     tt3.ax,                  +
     tt4.ay,                  +
     tt4.q                    +
    FROM tt2                  +
      JOIN tt3 USING (b, c)   +
      FULL JOIN tt4 USING (b);
(1 row)

alter table tt3 rename c to d;
select pg_get_viewdef('v1', true);
              pg_get_viewdef               
-------------------------------------------
  SELECT tt2.b,                           +
     tt3.c,                               +
     tt2.a,                               +
     tt3.ax                               +
    FROM tt2                              +
      JOIN tt3 tt3(ax, b, c) USING (b, c);
(1 row)

select pg_get_viewdef('v1a', true);
                pg_get_viewdef                
----------------------------------------------
  SELECT j.b,                                +
     j.c,                                    +
     j.a,                                    +
     j.ax                                    +
    FROM (tt2                                +
      JOIN tt3 tt3(ax, b, c) USING (b, c)) j;
(1 row)

select pg_get_viewdef('v2', true);
              pg_get_viewdef              
------------------------------------------
  SELECT tt2.b,                          +
     tt3.c,                              +
     tt2.a,                              +
     tt3.ax,                             +
     tt4.ay,                             +
     tt4.q                               +
    FROM tt2                             +
      JOIN tt3 tt3(ax, b, c) USING (b, c)+
      JOIN tt4 USING (b);
(1 row)

select pg_get_viewdef('v2a', true);
              pg_get_viewdef              
------------------------------------------
  SELECT j.b,                            +
     j.c,                                +
     j.a,                                +
     j.ax,                               +
     j.ay,                               +
     j.q                                 +
    FROM (tt2                            +
      JOIN tt3 tt3(ax, b, c) USING (b, c)+
      JOIN tt4 USING (b)) j;
(1 row)

select pg_get_viewdef('v3', true);
              pg_get_viewdef              
------------------------------------------
  SELECT b,                              +
     tt3.c,                              +
     tt2.a,                              +
     tt3.ax,                             +
     tt4.ay,                             +
     tt4.q                               +
    FROM tt2                             +
      JOIN tt3 tt3(ax, b, c) USING (b, c)+
      FULL JOIN tt4 USING (b);
(1 row)

alter table tt3 add column c int;
alter table tt3 add column e int;
select pg_get_viewdef('v1', true);
                  pg_get_viewdef                   
---------------------------------------------------
  SELECT tt2.b,                                   +
     tt3.c,                                       +
     tt2.a,                                       +
     tt3.ax                                       +
    FROM tt2                                      +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c);
(1 row)

select pg_get_viewdef('v1a', true);
                                  pg_get_viewdef                                   
-----------------------------------------------------------------------------------
  SELECT j.b,                                                                     +
     j.c,                                                                         +
     j.a,                                                                         +
     j.ax                                                                         +
    FROM (tt2                                                                     +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)) j(b, c, a, d, e, ax, c_1, e_1);
(1 row)

select pg_get_viewdef('v2', true);
                  pg_get_viewdef                  
--------------------------------------------------
  SELECT tt2.b,                                  +
     tt3.c,                                      +
     tt2.a,                                      +
     tt3.ax,                                     +
     tt4.ay,                                     +
     tt4.q                                       +
    FROM tt2                                     +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)+
      JOIN tt4 USING (b);
(1 row)

select pg_get_viewdef('v2a', true);
                         pg_get_viewdef                          
-----------------------------------------------------------------
  SELECT j.b,                                                   +
     j.c,                                                       +
     j.a,                                                       +
     j.ax,                                                      +
     j.ay,                                                      +
     j.q                                                        +
    FROM (tt2                                                   +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)               +
      JOIN tt4 USING (b)) j(b, c, a, d, e, ax, c_1, e_1, ay, q);
(1 row)

select pg_get_viewdef('v3', true);
                  pg_get_viewdef                  
--------------------------------------------------
  SELECT b,                                      +
     tt3.c,                                      +
     tt2.a,                                      +
     tt3.ax,                                     +
     tt4.ay,                                     +
     tt4.q                                       +
    FROM tt2                                     +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)+
      FULL JOIN tt4 USING (b);
(1 row)

alter table tt2 drop column d;
select pg_get_viewdef('v1', true);
                  pg_get_viewdef                   
---------------------------------------------------
  SELECT tt2.b,                                   +
     tt3.c,                                       +
     tt2.a,                                       +
     tt3.ax                                       +
    FROM tt2                                      +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c);
(1 row)

select pg_get_viewdef('v1a', true);
                                 pg_get_viewdef                                 
--------------------------------------------------------------------------------
  SELECT j.b,                                                                  +
     j.c,                                                                      +
     j.a,                                                                      +
     j.ax                                                                      +
    FROM (tt2                                                                  +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)) j(b, c, a, e, ax, c_1, e_1);
(1 row)

select pg_get_viewdef('v2', true);
                  pg_get_viewdef                  
--------------------------------------------------
  SELECT tt2.b,                                  +
     tt3.c,                                      +
     tt2.a,                                      +
     tt3.ax,                                     +
     tt4.ay,                                     +
     tt4.q                                       +
    FROM tt2                                     +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)+
      JOIN tt4 USING (b);
(1 row)

select pg_get_viewdef('v2a', true);
                        pg_get_viewdef                        
--------------------------------------------------------------
  SELECT j.b,                                                +
     j.c,                                                    +
     j.a,                                                    +
     j.ax,                                                   +
     j.ay,                                                   +
     j.q                                                     +
    FROM (tt2                                                +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)            +
      JOIN tt4 USING (b)) j(b, c, a, e, ax, c_1, e_1, ay, q);
(1 row)

select pg_get_viewdef('v3', true);
                  pg_get_viewdef                  
--------------------------------------------------
  SELECT b,                                      +
     tt3.c,                                      +
     tt2.a,                                      +
     tt3.ax,                                     +
     tt4.ay,                                     +
     tt4.q                                       +
    FROM tt2                                     +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)+
      FULL JOIN tt4 USING (b);
(1 row)

create table tt5 (a int, b int);
create table tt6 (c int, d int);
create view vv1 as select * from (tt5 cross join tt6) j(aa,bb,cc,dd);
select pg_get_viewdef('vv1', true);
             pg_get_viewdef              
-----------------------------------------
  SELECT j.aa,                          +
     j.bb,                              +
     j.cc,                              +
     j.dd                               +
    FROM (tt5                           +
      CROSS JOIN tt6) j(aa, bb, cc, dd);
(1 row)

alter table tt5 add column c int;
select pg_get_viewdef('vv1', true);
               pg_get_viewdef               
--------------------------------------------
  SELECT j.aa,                             +
     j.bb,                                 +
     j.cc,                                 +
     j.dd                                  +
    FROM (tt5                              +
      CROSS JOIN tt6) j(aa, bb, c, cc, dd);
(1 row)

alter table tt5 add column cc int;
select pg_get_viewdef('vv1', true);
                  pg_get_viewdef                  
--------------------------------------------------
  SELECT j.aa,                                   +
     j.bb,                                       +
     j.cc,                                       +
     j.dd                                        +
    FROM (tt5                                    +
      CROSS JOIN tt6) j(aa, bb, c, cc_1, cc, dd);
(1 row)

alter table tt5 drop column c;
select pg_get_viewdef('vv1', true);
                pg_get_viewdef                 
-----------------------------------------------
  SELECT j.aa,                                +
     j.bb,                                    +
     j.cc,                                    +
     j.dd                                     +
    FROM (tt5                                 +
      CROSS JOIN tt6) j(aa, bb, cc_1, cc, dd);
(1 row)

create view v4 as select * from v1;
alter view v1 rename column a to x;
select pg_get_viewdef('v1', true);
                  pg_get_viewdef                   
---------------------------------------------------
  SELECT tt2.b,                                   +
     tt3.c,                                       +
     tt2.a AS x,                                  +
     tt3.ax                                       +
    FROM tt2                                      +
      JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c);
(1 row)

select pg_get_viewdef('v4', true);
 pg_get_viewdef 
----------------
  SELECT b,    +
     c,        +
     x AS a,   +
     ax        +
    FROM v1;
(1 row)

-- Unnamed FULL JOIN USING is lots of fun too
create table tt7 (x int, xx int, y int);
alter table tt7 drop column xx;
create table tt8 (x int, z int);
create view vv2 as
select * from (values(1,2,3,4,5)) v(a,b,c,d,e)
union all
select * from tt7 full join tt8 using (x), tt8 tt8x;
select pg_get_viewdef('vv2', true);
                 pg_get_viewdef                 
------------------------------------------------
  SELECT v.a,                                  +
     v.b,                                      +
     v.c,                                      +
     v.d,                                      +
     v.e                                       +
    FROM ( VALUES (1,2,3,4,5)) v(a, b, c, d, e)+
 UNION ALL                                     +
  SELECT x AS a,                               +
     tt7.y AS b,                               +
     tt8.z AS c,                               +
     tt8x.x_1 AS d,                            +
     tt8x.z AS e                               +
    FROM tt7                                   +
      FULL JOIN tt8 USING (x),                 +
     tt8 tt8x(x_1, z);
(1 row)

create view vv3 as
select * from (values(1,2,3,4,5,6)) v(a,b,c,x,e,f)
union all
select * from
  tt7 full join tt8 using (x),
  tt7 tt7x full join tt8 tt8x using (x);
select pg_get_viewdef('vv3', true);
                   pg_get_viewdef                    
-----------------------------------------------------
  SELECT v.a,                                       +
     v.b,                                           +
     v.c,                                           +
     v.x,                                           +
     v.e,                                           +
     v.f                                            +
    FROM ( VALUES (1,2,3,4,5,6)) v(a, b, c, x, e, f)+
 UNION ALL                                          +
  SELECT x AS a,                                    +
     tt7.y AS b,                                    +
     tt8.z AS c,                                    +
     x_1 AS x,                                      +
     tt7x.y AS e,                                   +
     tt8x.z AS f                                    +
    FROM tt7                                        +
      FULL JOIN tt8 USING (x),                      +
     tt7 tt7x(x_1, y)                               +
      FULL JOIN tt8 tt8x(x_1, z) USING (x_1);
(1 row)

create view vv4 as
select * from (values(1,2,3,4,5,6,7)) v(a,b,c,x,e,f,g)
union all
select * from
  tt7 full join tt8 using (x),
  tt7 tt7x full join tt8 tt8x using (x) full join tt8 tt8y using (x);
select pg_get_viewdef('vv4', true);
                      pg_get_viewdef                      
----------------------------------------------------------
  SELECT v.a,                                            +
     v.b,                                                +
     v.c,                                                +
     v.x,                                                +
     v.e,                                                +
     v.f,                                                +
     v.g                                                 +
    FROM ( VALUES (1,2,3,4,5,6,7)) v(a, b, c, x, e, f, g)+
 UNION ALL                                               +
  SELECT x AS a,                                         +
     tt7.y AS b,                                         +
     tt8.z AS c,                                         +
     x_1 AS x,                                           +
     tt7x.y AS e,                                        +
     tt8x.z AS f,                                        +
     tt8y.z AS g                                         +
    FROM tt7                                             +
      FULL JOIN tt8 USING (x),                           +
     tt7 tt7x(x_1, y)                                    +
      FULL JOIN tt8 tt8x(x_1, z) USING (x_1)             +
      FULL JOIN tt8 tt8y(x_1, z) USING (x_1);
(1 row)

alter table tt7 add column zz int;
alter table tt7 add column z int;
alter table tt7 drop column zz;
alter table tt8 add column z2 int;
select pg_get_viewdef('vv2', true);
                 pg_get_viewdef                 
------------------------------------------------
  SELECT v.a,                                  +
     v.b,                                      +
     v.c,                                      +
     v.d,                                      +
     v.e                                       +
    FROM ( VALUES (1,2,3,4,5)) v(a, b, c, d, e)+
 UNION ALL                                     +
  SELECT x AS a,                               +
     tt7.y AS b,                               +
     tt8.z AS c,                               +
     tt8x.x_1 AS d,                            +
     tt8x.z AS e                               +
    FROM tt7                                   +
      FULL JOIN tt8 USING (x),                 +
     tt8 tt8x(x_1, z, z2);
(1 row)

select pg_get_viewdef('vv3', true);
                   pg_get_viewdef                    
-----------------------------------------------------
  SELECT v.a,                                       +
     v.b,                                           +
     v.c,                                           +
     v.x,                                           +
     v.e,                                           +
     v.f                                            +
    FROM ( VALUES (1,2,3,4,5,6)) v(a, b, c, x, e, f)+
 UNION ALL                                          +
  SELECT x AS a,                                    +
     tt7.y AS b,                                    +
     tt8.z AS c,                                    +
     x_1 AS x,                                      +
     tt7x.y AS e,                                   +
     tt8x.z AS f                                    +
    FROM tt7                                        +
      FULL JOIN tt8 USING (x),                      +
     tt7 tt7x(x_1, y, z)                            +
      FULL JOIN tt8 tt8x(x_1, z, z2) USING (x_1);
(1 row)

select pg_get_viewdef('vv4', true);
                      pg_get_viewdef                      
----------------------------------------------------------
  SELECT v.a,                                            +
     v.b,                                                +
     v.c,                                                +
     v.x,                                                +
     v.e,                                                +
     v.f,                                                +
     v.g                                                 +
    FROM ( VALUES (1,2,3,4,5,6,7)) v(a, b, c, x, e, f, g)+
 UNION ALL                                               +
  SELECT x AS a,                                         +
     tt7.y AS b,                                         +
     tt8.z AS c,                                         +
     x_1 AS x,                                           +
     tt7x.y AS e,                                        +
     tt8x.z AS f,                                        +
     tt8y.z AS g                                         +
    FROM tt7                                             +
      FULL JOIN tt8 USING (x),                           +
     tt7 tt7x(x_1, y, z)                                 +
      FULL JOIN tt8 tt8x(x_1, z, z2) USING (x_1)         +
      FULL JOIN tt8 tt8y(x_1, z, z2) USING (x_1);
(1 row)

-- Implicit coercions in a JOIN USING create issues similar to FULL JOIN
create table tt7a (x date, xx int, y int);
alter table tt7a drop column xx;
create table tt8a (x timestamptz, z int);
create view vv2a as
select * from (values(now(),2,3,now(),5)) v(a,b,c,d,e)
union all
select * from tt7a left join tt8a using (x), tt8a tt8ax;
select pg_get_viewdef('vv2a', true);
                     pg_get_viewdef                     
--------------------------------------------------------
  SELECT v.a,                                          +
     v.b,                                              +
     v.c,                                              +
     v.d,                                              +
     v.e                                               +
    FROM ( VALUES (now(),2,3,now(),5)) v(a, b, c, d, e)+
 UNION ALL                                             +
  SELECT x AS a,                                       +
     tt7a.y AS b,                                      +
     tt8a.z AS c,                                      +
     tt8ax.x_1 AS d,                                   +
     tt8ax.z AS e                                      +
    FROM tt7a                                          +
      LEFT JOIN tt8a USING (x),                        +
     tt8a tt8ax(x_1, z);
(1 row)

--
-- Also check dropping a column that existed when the view was made
--
create table tt9 (x int, xx int, y int);
create table tt10 (x int, z int);
create view vv5 as select x,y,z from tt9 join tt10 using(x);
select pg_get_viewdef('vv5', true);
      pg_get_viewdef       
---------------------------
  SELECT tt9.x,           +
     tt9.y,               +
     tt10.z               +
    FROM tt9              +
      JOIN tt10 USING (x);
(1 row)

alter table tt9 drop column xx;
select pg_get_viewdef('vv5', true);
      pg_get_viewdef       
---------------------------
  SELECT tt9.x,           +
     tt9.y,               +
     tt10.z               +
    FROM tt9              +
      JOIN tt10 USING (x);
(1 row)

--
-- Another corner case is that we might add a column to a table below a
-- JOIN USING, and thereby make the USING column name ambiguous
--
create table tt11 (x int, y int);
create table tt12 (x int, z int);
create table tt13 (z int, q int);
create view vv6 as select x,y,z,q from
  (tt11 join tt12 using(x)) join tt13 using(z);
select pg_get_viewdef('vv6', true);
      pg_get_viewdef       
---------------------------
  SELECT tt11.x,          +
     tt11.y,              +
     tt12.z,              +
     tt13.q               +
    FROM tt11             +
      JOIN tt12 USING (x) +
      JOIN tt13 USING (z);
(1 row)

alter table tt11 add column z int;
select pg_get_viewdef('vv6', true);
        pg_get_viewdef        
------------------------------
  SELECT tt11.x,             +
     tt11.y,                 +
     tt12.z,                 +
     tt13.q                  +
    FROM tt11 tt11(x, y, z_1)+
      JOIN tt12 USING (x)    +
      JOIN tt13 USING (z);
(1 row)

--
-- Check cases involving dropped/altered columns in a function's rowtype result
--
create table tt14t (f1 text, f2 text, f3 text, f4 text);
insert into tt14t values('foo', 'bar', 'baz', '42');
alter table tt14t drop column f2;
create function tt14f() returns setof tt14t as
$$
declare
    rec1 record;
begin
    for rec1 in select * from tt14t
    loop
        return next rec1;
    end loop;
end;
$$
language plpgsql;
create view tt14v as select t.* from tt14f() t;
select pg_get_viewdef('tt14v', true);
         pg_get_viewdef         
--------------------------------
  SELECT f1,                   +
     f3,                       +
     f4                        +
    FROM tt14f() t(f1, f3, f4);
(1 row)

select * from tt14v;
 f1  | f3  | f4 
-----+-----+----
 foo | baz | 42
(1 row)

alter table tt14t drop column f3;  -- fail, view has explicit reference to f3
ERROR:  cannot drop column f3 of table tt14t because other objects depend on it
DETAIL:  view tt14v depends on column f3 of table tt14t
HINT:  Use DROP ... CASCADE to drop the dependent objects too.
-- We used to have a bug that would allow the above to succeed, posing
-- hazards for later execution of the view.  Check that the internal
-- defenses for those hazards haven't bit-rotted, in case some other
-- bug with similar symptoms emerges.
begin;
-- destroy the dependency entry that prevents the DROP:
delete from pg_depend where
  objid = (select oid from pg_rewrite
           where ev_class = 'tt14v'::regclass and rulename = '_RETURN')
  and refobjsubid = 3
returning pg_describe_object(classid, objid, objsubid) as obj,
          pg_describe_object(refclassid, refobjid, refobjsubid) as ref,
          deptype;
            obj             |           ref            | deptype 
----------------------------+--------------------------+---------
 rule _RETURN on view tt14v | column f3 of table tt14t | n
(1 row)

-- this will now succeed:
alter table tt14t drop column f3;
-- column f3 is still in the view, sort of ...
select pg_get_viewdef('tt14v', true);
        pg_get_viewdef         
-------------------------------
  SELECT f1,                  +
     "?dropped?column?" AS f3,+
     f4                       +
    FROM tt14f() t(f1, f4);
(1 row)

-- ... and you can even EXPLAIN it ...
explain (verbose, costs off) select * from tt14v;
               QUERY PLAN               
----------------------------------------
 Function Scan on testviewschm2.tt14f t
   Output: t.f1, t.f3, t.f4
   Function Call: tt14f()
(3 rows)

-- but it will fail at execution
select f1, f4 from tt14v;
 f1  | f4 
-----+----
 foo | 42
(1 row)

select * from tt14v;
ERROR:  attribute 3 of type record has been dropped
rollback;
-- likewise, altering a referenced column's type is prohibited ...
alter table tt14t alter column f4 type integer using f4::integer;  -- fail
ERROR:  cannot alter type of a column used by a view or rule
DETAIL:  rule _RETURN on view tt14v depends on column "f4"
-- ... but some bug might let it happen, so check defenses
begin;
-- destroy the dependency entry that prevents the ALTER:
delete from pg_depend where
  objid = (select oid from pg_rewrite
           where ev_class = 'tt14v'::regclass and rulename = '_RETURN')
  and refobjsubid = 4
returning pg_describe_object(classid, objid, objsubid) as obj,
          pg_describe_object(refclassid, refobjid, refobjsubid) as ref,
          deptype;
            obj             |           ref            | deptype 
----------------------------+--------------------------+---------
 rule _RETURN on view tt14v | column f4 of table tt14t | n
(1 row)

-- this will now succeed:
alter table tt14t alter column f4 type integer using f4::integer;
-- f4 is still in the view ...
select pg_get_viewdef('tt14v', true);
         pg_get_viewdef         
--------------------------------
  SELECT f1,                   +
     f3,                       +
     f4                        +
    FROM tt14f() t(f1, f3, f4);
(1 row)

-- but will fail at execution
select f1, f3 from tt14v;
 f1  | f3  
-----+-----
 foo | baz
(1 row)

select * from tt14v;
ERROR:  attribute 4 of type record has wrong type
DETAIL:  Table has type integer, but query expects text.
rollback;
drop view tt14v;
create view tt14v as select t.f1, t.f4 from tt14f() t;
select pg_get_viewdef('tt14v', true);
         pg_get_viewdef         
--------------------------------
  SELECT f1,                   +
     f4                        +
    FROM tt14f() t(f1, f3, f4);
(1 row)

select * from tt14v;
 f1  | f4 
-----+----
 foo | 42
(1 row)

alter table tt14t drop column f3;  -- ok
select pg_get_viewdef('tt14v', true);
       pg_get_viewdef       
----------------------------
  SELECT f1,               +
     f4                    +
    FROM tt14f() t(f1, f4);
(1 row)

explain (verbose, costs off) select * from tt14v;
               QUERY PLAN               
----------------------------------------
 Function Scan on testviewschm2.tt14f t
   Output: t.f1, t.f4
   Function Call: tt14f()
(3 rows)

select * from tt14v;
 f1  | f4 
-----+----
 foo | 42
(1 row)

-- check display of whole-row variables in some corner cases
create type nestedcomposite as (x int8_tbl);
create view tt15v as select row(i)::nestedcomposite from int8_tbl i;
select * from tt15v;
                   row                    
------------------------------------------
 ("(123,456)")
 ("(123,4567890123456789)")
 ("(4567890123456789,123)")
 ("(4567890123456789,4567890123456789)")
 ("(4567890123456789,-4567890123456789)")
(5 rows)

select pg_get_viewdef('tt15v', true);
                    pg_get_viewdef                    
------------------------------------------------------
  SELECT ROW(i.*::int8_tbl)::nestedcomposite AS "row"+
    FROM int8_tbl i;
(1 row)

select row(i.*::int8_tbl)::nestedcomposite from int8_tbl i;
                   row                    
------------------------------------------
 ("(123,456)")
 ("(123,4567890123456789)")
 ("(4567890123456789,123)")
 ("(4567890123456789,4567890123456789)")
 ("(4567890123456789,-4567890123456789)")
(5 rows)

create view tt16v as select * from int8_tbl i, lateral(values(i)) ss;
select * from tt16v;
        q1        |        q2         |               column1                
------------------+-------------------+--------------------------------------
              123 |               456 | (123,456)
              123 |  4567890123456789 | (123,4567890123456789)
 4567890123456789 |               123 | (4567890123456789,123)
 4567890123456789 |  4567890123456789 | (4567890123456789,4567890123456789)
 4567890123456789 | -4567890123456789 | (4567890123456789,-4567890123456789)
(5 rows)

select pg_get_viewdef('tt16v', true);
              pg_get_viewdef               
-------------------------------------------
  SELECT i.q1,                            +
     i.q2,                                +
     ss.column1                           +
    FROM int8_tbl i,                      +
     LATERAL ( VALUES (i.*::int8_tbl)) ss;
(1 row)

select * from int8_tbl i, lateral(values(i.*::int8_tbl)) ss;
        q1        |        q2         |               column1                
------------------+-------------------+--------------------------------------
              123 |               456 | (123,456)
              123 |  4567890123456789 | (123,4567890123456789)
 4567890123456789 |               123 | (4567890123456789,123)
 4567890123456789 |  4567890123456789 | (4567890123456789,4567890123456789)
 4567890123456789 | -4567890123456789 | (4567890123456789,-4567890123456789)
(5 rows)

create view tt17v as select * from int8_tbl i where i in (values(i));
select * from tt17v;
        q1        |        q2         
------------------+-------------------
              123 |               456
              123 |  4567890123456789
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(5 rows)

select pg_get_viewdef('tt17v', true);
               pg_get_viewdef                
---------------------------------------------
  SELECT q1,                                +
     q2                                     +
    FROM int8_tbl i                         +
   WHERE (i.* IN ( VALUES (i.*::int8_tbl)));
(1 row)

select * from int8_tbl i where i.* in (values(i.*::int8_tbl));
        q1        |        q2         
------------------+-------------------
              123 |               456
              123 |  4567890123456789
 4567890123456789 |               123
 4567890123456789 |  4567890123456789
 4567890123456789 | -4567890123456789
(5 rows)

create table tt15v_log(o tt15v, n tt15v, incr bool);
create rule updlog as on update to tt15v do also
  insert into tt15v_log values(old, new, row(old,old) < row(new,new));
\d+ tt15v
                             View "testviewschm2.tt15v"
 Column |      Type       | Collation | Nullable | Default | Storage  | Description 
--------+-----------------+-----------+----------+---------+----------+-------------
 row    | nestedcomposite |           |          |         | extended | 
View definition:
 SELECT ROW(i.*::int8_tbl)::nestedcomposite AS "row"
   FROM int8_tbl i;
Rules:
 updlog AS
    ON UPDATE TO tt15v DO  INSERT INTO tt15v_log (o, n, incr)
  VALUES (old.*::tt15v, new.*::tt15v, (ROW(old.*::tt15v, old.*::tt15v) < ROW(new.*::tt15v, new.*::tt15v)))

-- check unique-ification of overlength names
create view tt18v as
  select * from int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy
  union all
  select * from int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz;
NOTICE:  identifier "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy" will be truncated to "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
NOTICE:  identifier "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz" will be truncated to "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx"
select pg_get_viewdef('tt18v', true);
                                  pg_get_viewdef                                   
-----------------------------------------------------------------------------------
  SELECT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q1,      +
     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q2           +
    FROM int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx +
 UNION ALL                                                                        +
  SELECT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q1,      +
     xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q2           +
    FROM int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;
(1 row)

explain (costs off) select * from tt18v;
                                         QUERY PLAN                                         
--------------------------------------------------------------------------------------------
 Append
   ->  Seq Scan on int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx
   ->  Seq Scan on int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx_1
(3 rows)

-- check display of ScalarArrayOp with a sub-select
select 'foo'::text = any(array['abc','def','foo']::text[]);
 ?column? 
----------
 t
(1 row)

select 'foo'::text = any((select array['abc','def','foo']::text[]));  -- fail
ERROR:  operator does not exist: text = text[]
LINE 1: select 'foo'::text = any((select array['abc','def','foo']::t...
                           ^
HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.
select 'foo'::text = any((select array['abc','def','foo']::text[])::text[]);
 ?column? 
----------
 t
(1 row)

create view tt19v as
select 'foo'::text = any(array['abc','def','foo']::text[]) c1,
       'foo'::text = any((select array['abc','def','foo']::text[])::text[]) c2;
select pg_get_viewdef('tt19v', true);
                                               pg_get_viewdef                                               
------------------------------------------------------------------------------------------------------------
  SELECT 'foo'::text = ANY (ARRAY['abc'::text, 'def'::text, 'foo'::text]) AS c1,                           +
     'foo'::text = ANY ((( SELECT ARRAY['abc'::text, 'def'::text, 'foo'::text] AS "array"))::text[]) AS c2;
(1 row)

-- check display of assorted RTE_FUNCTION expressions
create view tt20v as
select * from
  coalesce(1,2) as c,
  collation for ('x'::text) col,
  current_date as d,
  localtimestamp(3) as t,
  cast(1+2 as int4) as i4,
  cast(1+2 as int8) as i8;
select pg_get_viewdef('tt20v', true);
               pg_get_viewdef                
---------------------------------------------
  SELECT c.c,                               +
     col.col,                               +
     d.d,                                   +
     t.t,                                   +
     i4.i4,                                 +
     i8.i8                                  +
    FROM COALESCE(1, 2) c(c),               +
     COLLATION FOR ('x'::text) col(col),    +
     CURRENT_DATE d(d),                     +
     LOCALTIMESTAMP(3) t(t),                +
     CAST(1 + 2 AS integer) i4(i4),         +
     CAST((1 + 2)::bigint AS bigint) i8(i8);
(1 row)

-- reverse-listing of various special function syntaxes required by SQL
create view tt201v as
select
  ('2022-12-01'::date + '1 day'::interval) at time zone 'UTC' as atz,
  extract(day from now()) as extr,
  (now(), '1 day'::interval) overlaps
    (current_timestamp(2), '1 day'::interval) as o,
  'foo' is normalized isn,
  'foo' is nfkc normalized isnn,
  normalize('foo') as n,
  normalize('foo', nfkd) as nfkd,
  overlay('foo' placing 'bar' from 2) as ovl,
  overlay('foo' placing 'bar' from 2 for 3) as ovl2,
  position('foo' in 'foobar') as p,
  substring('foo' from 2 for 3) as s,
  substring('foo' similar 'f' escape '#') as ss,
  substring('foo' from 'oo') as ssf,  -- historically-permitted abuse
  trim(' ' from ' foo ') as bt,
  trim(leading ' ' from ' foo ') as lt,
  trim(trailing ' foo ') as rt,
  trim(E'\\000'::bytea from E'\\000Tom\\000'::bytea) as btb,
  trim(leading E'\\000'::bytea from E'\\000Tom\\000'::bytea) as ltb,
  trim(trailing E'\\000'::bytea from E'\\000Tom\\000'::bytea) as rtb,
  CURRENT_DATE as cd,
  (select * from CURRENT_DATE) as cd2,
  CURRENT_TIME as ct,
  (select * from CURRENT_TIME) as ct2,
  CURRENT_TIME (1) as ct3,
  (select * from CURRENT_TIME (1)) as ct4,
  CURRENT_TIMESTAMP as ct5,
  (select * from CURRENT_TIMESTAMP) as ct6,
  CURRENT_TIMESTAMP (1) as ct7,
  (select * from CURRENT_TIMESTAMP (1)) as ct8,
  LOCALTIME as lt1,
  (select * from LOCALTIME) as lt2,
  LOCALTIME (1) as lt3,
  (select * from LOCALTIME (1)) as lt4,
  LOCALTIMESTAMP as lt5,
  (select * from LOCALTIMESTAMP) as lt6,
  LOCALTIMESTAMP (1) as lt7,
  (select * from LOCALTIMESTAMP (1)) as lt8,
  CURRENT_CATALOG as ca,
  (select * from CURRENT_CATALOG) as ca2,
  CURRENT_ROLE as cr,
  (select * from CURRENT_ROLE) as cr2,
  CURRENT_SCHEMA as cs,
  (select * from CURRENT_SCHEMA) as cs2,
  CURRENT_USER as cu,
  (select * from CURRENT_USER) as cu2,
  USER as us,
  (select * from USER) as us2,
  SESSION_USER seu,
  (select * from SESSION_USER) as seu2,
  SYSTEM_USER as su,
  (select * from SYSTEM_USER) as su2;
select pg_get_viewdef('tt201v', true);
                                        pg_get_viewdef                                         
-----------------------------------------------------------------------------------------------
  SELECT (('12-01-2022'::date + '@ 1 day'::interval) AT TIME ZONE 'UTC'::text) AS atz,        +
     EXTRACT(day FROM now()) AS extr,                                                         +
     ((now(), '@ 1 day'::interval) OVERLAPS (CURRENT_TIMESTAMP(2), '@ 1 day'::interval)) AS o,+
     ('foo'::text IS NORMALIZED) AS isn,                                                      +
     ('foo'::text IS NFKC NORMALIZED) AS isnn,                                                +
     NORMALIZE('foo'::text) AS n,                                                             +
     NORMALIZE('foo'::text, NFKD) AS nfkd,                                                    +
     OVERLAY('foo'::text PLACING 'bar'::text FROM 2) AS ovl,                                  +
     OVERLAY('foo'::text PLACING 'bar'::text FROM 2 FOR 3) AS ovl2,                           +
     POSITION(('foo'::text) IN ('foobar'::text)) AS p,                                        +
     SUBSTRING('foo'::text FROM 2 FOR 3) AS s,                                                +
     SUBSTRING('foo'::text SIMILAR 'f'::text ESCAPE '#'::text) AS ss,                         +
     "substring"('foo'::text, 'oo'::text) AS ssf,                                             +
     TRIM(BOTH ' '::text FROM ' foo '::text) AS bt,                                           +
     TRIM(LEADING ' '::text FROM ' foo '::text) AS lt,                                        +
     TRIM(TRAILING FROM ' foo '::text) AS rt,                                                 +
     TRIM(BOTH '\x00'::bytea FROM '\x00546f6d00'::bytea) AS btb,                              +
     TRIM(LEADING '\x00'::bytea FROM '\x00546f6d00'::bytea) AS ltb,                           +
     TRIM(TRAILING '\x00'::bytea FROM '\x00546f6d00'::bytea) AS rtb,                          +
     CURRENT_DATE AS cd,                                                                      +
     ( SELECT "current_date"."current_date"                                                   +
            FROM CURRENT_DATE "current_date"("current_date")) AS cd2,                         +
     CURRENT_TIME AS ct,                                                                      +
     ( SELECT "current_time"."current_time"                                                   +
            FROM CURRENT_TIME "current_time"("current_time")) AS ct2,                         +
     CURRENT_TIME(1) AS ct3,                                                                  +
     ( SELECT "current_time"."current_time"                                                   +
            FROM CURRENT_TIME(1) "current_time"("current_time")) AS ct4,                      +
     CURRENT_TIMESTAMP AS ct5,                                                                +
     ( SELECT "current_timestamp"."current_timestamp"                                         +
            FROM CURRENT_TIMESTAMP "current_timestamp"("current_timestamp")) AS ct6,          +
     CURRENT_TIMESTAMP(1) AS ct7,                                                             +
     ( SELECT "current_timestamp"."current_timestamp"                                         +
            FROM CURRENT_TIMESTAMP(1) "current_timestamp"("current_timestamp")) AS ct8,       +
     LOCALTIME AS lt1,                                                                        +
     ( SELECT "localtime"."localtime"                                                         +
            FROM LOCALTIME "localtime"("localtime")) AS lt2,                                  +
     LOCALTIME(1) AS lt3,                                                                     +
     ( SELECT "localtime"."localtime"                                                         +
            FROM LOCALTIME(1) "localtime"("localtime")) AS lt4,                               +
     LOCALTIMESTAMP AS lt5,                                                                   +
     ( SELECT "localtimestamp"."localtimestamp"                                               +
            FROM LOCALTIMESTAMP "localtimestamp"("localtimestamp")) AS lt6,                   +
     LOCALTIMESTAMP(1) AS lt7,                                                                +
     ( SELECT "localtimestamp"."localtimestamp"                                               +
            FROM LOCALTIMESTAMP(1) "localtimestamp"("localtimestamp")) AS lt8,                +
     CURRENT_CATALOG AS ca,                                                                   +
     ( SELECT "current_catalog"."current_catalog"                                             +
            FROM CURRENT_CATALOG "current_catalog"("current_catalog")) AS ca2,                +
     CURRENT_ROLE AS cr,                                                                      +
     ( SELECT "current_role"."current_role"                                                   +
            FROM CURRENT_ROLE "current_role"("current_role")) AS cr2,                         +
     CURRENT_SCHEMA AS cs,                                                                    +
     ( SELECT "current_schema"."current_schema"                                               +
            FROM CURRENT_SCHEMA "current_schema"("current_schema")) AS cs2,                   +
     CURRENT_USER AS cu,                                                                      +
     ( SELECT "current_user"."current_user"                                                   +
            FROM CURRENT_USER "current_user"("current_user")) AS cu2,                         +
     USER AS us,                                                                              +
     ( SELECT "user"."user"                                                                   +
            FROM USER "user"("user")) AS us2,                                                 +
     SESSION_USER AS seu,                                                                     +
     ( SELECT "session_user"."session_user"                                                   +
            FROM SESSION_USER "session_user"("session_user")) AS seu2,                        +
     SYSTEM_USER AS su,                                                                       +
     ( SELECT "system_user"."system_user"                                                     +
            FROM SYSTEM_USER "system_user"("system_user")) AS su2;
(1 row)

-- corner cases with empty join conditions
create view tt21v as
select * from tt5 natural inner join tt6;
select pg_get_viewdef('tt21v', true);
    pg_get_viewdef    
----------------------
  SELECT tt5.a,      +
     tt5.b,          +
     tt5.cc,         +
     tt6.c,          +
     tt6.d           +
    FROM tt5         +
      CROSS JOIN tt6;
(1 row)

create view tt22v as
select * from tt5 natural left join tt6;
select pg_get_viewdef('tt22v', true);
       pg_get_viewdef        
-----------------------------
  SELECT tt5.a,             +
     tt5.b,                 +
     tt5.cc,                +
     tt6.c,                 +
     tt6.d                  +
    FROM tt5                +
      LEFT JOIN tt6 ON TRUE;
(1 row)

-- check handling of views with immediately-renamed columns
create view tt23v (col_a, col_b) as
select q1 as other_name1, q2 as other_name2 from int8_tbl
union
select 42, 43;
select pg_get_viewdef('tt23v', true);
        pg_get_viewdef         
-------------------------------
  SELECT int8_tbl.q1 AS col_a,+
     int8_tbl.q2 AS col_b     +
    FROM int8_tbl             +
 UNION                        +
  SELECT 42 AS col_a,         +
     43 AS col_b;
(1 row)

select pg_get_ruledef(oid, true) from pg_rewrite
  where ev_class = 'tt23v'::regclass and ev_type = '1';
                         pg_get_ruledef                          
-----------------------------------------------------------------
 CREATE RULE "_RETURN" AS                                       +
     ON SELECT TO tt23v DO INSTEAD  SELECT int8_tbl.q1 AS col_a,+
     int8_tbl.q2 AS col_b                                       +
    FROM int8_tbl                                               +
 UNION                                                          +
  SELECT 42 AS col_a,                                           +
     43 AS col_b;
(1 row)

-- test extraction of FieldSelect field names (get_name_for_var_field)
create view tt24v as
with cte as materialized (select r from (values(1,2),(3,4)) r)
select (r).column2 as col_a, (rr).column2 as col_b from
  cte join (select rr from (values(1,7),(3,8)) rr limit 2) ss
  on (r).column1 = (rr).column1;
select pg_get_viewdef('tt24v', true);
                       pg_get_viewdef                       
------------------------------------------------------------
  WITH cte AS MATERIALIZED (                               +
          SELECT r.*::record AS r                          +
            FROM ( VALUES (1,2), (3,4)) r                  +
         )                                                 +
  SELECT (cte.r).column2 AS col_a,                         +
     (ss.rr).column2 AS col_b                              +
    FROM cte                                               +
      JOIN ( SELECT rr.*::record AS rr                     +
            FROM ( VALUES (1,7), (3,8)) rr                 +
          LIMIT 2) ss ON (cte.r).column1 = (ss.rr).column1;
(1 row)

create view tt25v as
with cte as materialized (select pg_get_keywords() k)
select (k).word from cte;
select pg_get_viewdef('tt25v', true);
             pg_get_viewdef             
----------------------------------------
  WITH cte AS MATERIALIZED (           +
          SELECT pg_get_keywords() AS k+
         )                             +
  SELECT (k).word AS word              +
    FROM cte;
(1 row)

-- also check cases seen only in EXPLAIN
explain (verbose, costs off)
select * from tt24v;
                                        QUERY PLAN                                        
------------------------------------------------------------------------------------------
 Hash Join
   Output: (cte.r).column2, ((ROW("*VALUES*".column1, "*VALUES*".column2))).column2
   Hash Cond: ((cte.r).column1 = ((ROW("*VALUES*".column1, "*VALUES*".column2))).column1)
   CTE cte
     ->  Values Scan on "*VALUES*_1"
           Output: ROW("*VALUES*_1".column1, "*VALUES*_1".column2)
   ->  CTE Scan on cte
         Output: cte.r
   ->  Hash
         Output: (ROW("*VALUES*".column1, "*VALUES*".column2))
         ->  Limit
               Output: (ROW("*VALUES*".column1, "*VALUES*".column2))
               ->  Values Scan on "*VALUES*"
                     Output: ROW("*VALUES*".column1, "*VALUES*".column2)
(14 rows)

explain (verbose, costs off)
select (r).column2 from (select r from (values(1,2),(3,4)) r limit 1) ss;
                            QUERY PLAN                             
-------------------------------------------------------------------
 Subquery Scan on ss
   Output: (ss.r).column2
   ->  Limit
         Output: (ROW("*VALUES*".column1, "*VALUES*".column2))
         ->  Values Scan on "*VALUES*"
               Output: ROW("*VALUES*".column1, "*VALUES*".column2)
(6 rows)

-- test pretty-print parenthesization rules, and SubLink deparsing
create view tt26v as
select x + y + z as c1,
       (x * y) + z as c2,
       x + (y * z) as c3,
       (x + y) * z as c4,
       x * (y + z) as c5,
       x + (y + z) as c6,
       x + (y # z) as c7,
       (x > y) AND (y > z OR x > z) as c8,
       (x > y) OR (y > z AND NOT (x > z)) as c9,
       (x,y) <> ALL (values(1,2),(3,4)) as c10,
       (x,y) <= ANY (values(1,2),(3,4)) as c11
from (values(1,2,3)) v(x,y,z);
select pg_get_viewdef('tt26v', true);
                   pg_get_viewdef                   
----------------------------------------------------
  SELECT x + y + z AS c1,                          +
     x * y + z AS c2,                              +
     x + y * z AS c3,                              +
     (x + y) * z AS c4,                            +
     x * (y + z) AS c5,                            +
     x + (y + z) AS c6,                            +
     x + (y # z) AS c7,                            +
     x > y AND (y > z OR x > z) AS c8,             +
     x > y OR y > z AND NOT x > z AS c9,           +
     ((x, y) <> ALL ( VALUES (1,2), (3,4))) AS c10,+
     ((x, y) <= ANY ( VALUES (1,2), (3,4))) AS c11 +
    FROM ( VALUES (1,2,3)) v(x, y, z);
(1 row)

-- clean up all the random objects we made above
DROP SCHEMA temp_view_test CASCADE;
NOTICE:  drop cascades to 27 other objects
DETAIL:  drop cascades to table temp_view_test.base_table
drop cascades to view v2_temp
drop cascades to view v4_temp
drop cascades to view v6_temp
drop cascades to view v7_temp
drop cascades to view v10_temp
drop cascades to view v8_temp
drop cascades to view v9_temp
drop cascades to view v11_temp
drop cascades to view v12_temp
drop cascades to table temp_view_test.base_table2
drop cascades to view v5_temp
drop cascades to view temp_view_test.v1
drop cascades to view temp_view_test.v2
drop cascades to view temp_view_test.v3
drop cascades to view temp_view_test.v4
drop cascades to view temp_view_test.v5
drop cascades to view temp_view_test.v6
drop cascades to view temp_view_test.v7
drop cascades to view temp_view_test.v8
drop cascades to sequence temp_view_test.seq1
drop cascades to view temp_view_test.v9
drop cascades to table temp_view_test.tx1
drop cascades to view aliased_view_1
drop cascades to view aliased_view_2
drop cascades to view aliased_view_3
drop cascades to view aliased_view_4
DROP SCHEMA testviewschm2 CASCADE;
NOTICE:  drop cascades to 77 other objects
DETAIL:  drop cascades to table t1
drop cascades to view temporal1
drop cascades to view temporal2
drop cascades to view temporal3
drop cascades to view temporal4
drop cascades to table t2
drop cascades to view nontemp1
drop cascades to view nontemp2
drop cascades to view nontemp3
drop cascades to view nontemp4
drop cascades to table tbl1
drop cascades to table tbl2
drop cascades to table tbl3
drop cascades to table tbl4
drop cascades to view mytempview
drop cascades to view pubview
drop cascades to view mysecview1
drop cascades to view mysecview2
drop cascades to view mysecview3
drop cascades to view mysecview4
drop cascades to view mysecview7
drop cascades to view mysecview8
drop cascades to view mysecview9
drop cascades to view unspecified_types
drop cascades to table tt1
drop cascades to table tx1
drop cascades to view view_of_joins
drop cascades to table tbl1a
drop cascades to view view_of_joins_2a
drop cascades to view view_of_joins_2b
drop cascades to view view_of_joins_2c
drop cascades to view view_of_joins_2d
drop cascades to table tt2
drop cascades to table tt3
drop cascades to table tt4
drop cascades to view v1
drop cascades to view v1a
drop cascades to view v2
drop cascades to view v2a
drop cascades to view v3
drop cascades to table tt5
drop cascades to table tt6
drop cascades to view vv1
drop cascades to view v4
drop cascades to table tt7
drop cascades to table tt8
drop cascades to view vv2
drop cascades to view vv3
drop cascades to view vv4
drop cascades to table tt7a
drop cascades to table tt8a
drop cascades to view vv2a
drop cascades to table tt9
drop cascades to table tt10
drop cascades to view vv5
drop cascades to table tt11
drop cascades to table tt12
drop cascades to table tt13
drop cascades to view vv6
drop cascades to table tt14t
drop cascades to function tt14f()
drop cascades to view tt14v
drop cascades to type nestedcomposite
drop cascades to view tt15v
drop cascades to view tt16v
drop cascades to view tt17v
drop cascades to table tt15v_log
drop cascades to view tt18v
drop cascades to view tt19v
drop cascades to view tt20v
drop cascades to view tt201v
drop cascades to view tt21v
drop cascades to view tt22v
drop cascades to view tt23v
drop cascades to view tt24v
drop cascades to view tt25v
drop cascades to view tt26v
-- END setup from  create_view
 
