-- JSON_EXISTS
SELECT JSON_EXISTS(NULL::jsonb, '$')
RESULT: 
	[(None,)]

SELECT JSON_EXISTS(jsonb '[]', '$')
RESULT: 
	[(True,)]

SELECT JSON_EXISTS(JSON_OBJECT(RETURNING jsonb), '$')
RESULT: 
	[(True,)]


SELECT JSON_EXISTS(jsonb '1', '$')
RESULT: 
	[(True,)]

SELECT JSON_EXISTS(jsonb 'null', '$')
RESULT: 
	[(True,)]

SELECT JSON_EXISTS(jsonb '[]', '$')
RESULT: 
	[(True,)]


SELECT JSON_EXISTS(jsonb '1', '$.a')
RESULT: 
	[(False,)]

SELECT JSON_EXISTS(jsonb '1', 'strict $.a')
RESULT: 
	[(False,)]
 -- FALSE on error
SELECT JSON_EXISTS(jsonb '1', 'strict $.a' ERROR ON ERROR)
ERROR:  -- FALSE on error
SELECT JSON_EXISTS(jsonb '1', 'strict $.a' ERROR ON ERROR)

jsonpath member accessor can only be applied to an object


SELECT JSON_EXISTS(jsonb 'null', '$.a')
RESULT: 
	[(False,)]

SELECT JSON_EXISTS(jsonb '[]', '$.a')
RESULT: 
	[(False,)]

SELECT JSON_EXISTS(jsonb '[1, "aaa", {"a": 1}]', 'strict $.a')
RESULT: 
	[(False,)]
 -- FALSE on error
SELECT JSON_EXISTS(jsonb '[1, "aaa", {"a": 1}]', 'lax $.a')
RESULT: 
	[(True,)]

SELECT JSON_EXISTS(jsonb '{}', '$.a')
RESULT: 
	[(False,)]

SELECT JSON_EXISTS(jsonb '{"b": 1, "a": 2}', '$.a')
RESULT: 
	[(True,)]


SELECT JSON_EXISTS(jsonb '1', '$.a.b')
RESULT: 
	[(False,)]

SELECT JSON_EXISTS(jsonb '{"a": {"b": 1}}', '$.a.b')
RESULT: 
	[(True,)]

SELECT JSON_EXISTS(jsonb '{"a": 1, "b": 2}', '$.a.b')
RESULT: 
	[(False,)]


SELECT JSON_EXISTS(jsonb '{"a": 1, "b": 2}', '$.* ? (@ > $x)' PASSING 1 AS x)
RESULT: 
	[(True,)]

SELECT JSON_EXISTS(jsonb '{"a": 1, "b": 2}', '$.* ? (@ > $x)' PASSING '1' AS x)
RESULT: 
	[(False,)]

SELECT JSON_EXISTS(jsonb '{"a": 1, "b": 2}', '$.* ? (@ > $x && @ < $y)' PASSING 0 AS x, 2 AS y)
RESULT: 
	[(True,)]

SELECT JSON_EXISTS(jsonb '{"a": 1, "b": 2}', '$.* ? (@ > $x && @ < $y)' PASSING 0 AS x, 1 AS y)
RESULT: 
	[(False,)]


-- extension: boolean expressions
SELECT JSON_EXISTS(jsonb '1', '$ > 2')
RESULT: 
	[(True,)]

SELECT JSON_EXISTS(jsonb '1', '$.a > 2' ERROR ON ERROR)
RESULT: 
	[(True,)]


-- JSON_VALUE
SELECT JSON_VALUE(NULL::jsonb, '$')
RESULT: 
	[(None,)]


SELECT JSON_VALUE(jsonb 'null', '$')
RESULT: 
	[(None,)]

SELECT JSON_VALUE(jsonb 'null', '$' RETURNING int)
RESULT: 
	[(None,)]


SELECT JSON_VALUE(jsonb 'true', '$')
RESULT: 
	[('t',)]

SELECT JSON_VALUE(jsonb 'true', '$' RETURNING bool)
RESULT: 
	[(True,)]


SELECT JSON_VALUE(jsonb '123', '$')
RESULT: 
	[('123',)]

SELECT JSON_VALUE(jsonb '123', '$' RETURNING int) + 234
RESULT: 
	[(357,)]

SELECT JSON_VALUE(jsonb '123', '$' RETURNING text)
RESULT: 
	[('123',)]

/* jsonb bytea ??? */
SELECT JSON_VALUE(jsonb '123', '$' RETURNING bytea ERROR ON ERROR)
RESULT: 
	[(<memory at 0x73c231cc4d00>,)]


SELECT JSON_VALUE(jsonb '1.23', '$')
RESULT: 
	[('1.23',)]

SELECT JSON_VALUE(jsonb '1.23', '$' RETURNING int)
RESULT: 
	[(None,)]

SELECT JSON_VALUE(jsonb '"1.23"', '$' RETURNING numeric)
RESULT: 
	[(Decimal('1.23'),)]

SELECT JSON_VALUE(jsonb '"1.23"', '$' RETURNING int ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb '"1.23"', '$' RETURNING int ERROR ON ERROR)

invalid input syntax for type integer: "1.23"



SELECT JSON_VALUE(jsonb '"aaa"', '$')
RESULT: 
	[('aaa',)]

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING text)
RESULT: 
	[('aaa',)]

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING char(5))
RESULT: 
	[('aaa  ',)]

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING char(2))
RESULT: 
	[('aa',)]

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING json)
RESULT: 
	[('aaa',)]

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING jsonb)
RESULT: 
	[('aaa',)]

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING json ERROR ON ERROR)
RESULT: 
	[('aaa',)]

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING jsonb ERROR ON ERROR)
RESULT: 
	[('aaa',)]

SELECT JSON_VALUE(jsonb '"\"aaa\""', '$' RETURNING json)
RESULT: 
	[('"aaa"',)]

SELECT JSON_VALUE(jsonb '"\"aaa\""', '$' RETURNING jsonb)
RESULT: 
	[('"aaa"',)]

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING int)
RESULT: 
	[(None,)]

SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING int ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING int ERROR ON ERROR)

invalid input syntax for type integer: "aaa"


SELECT JSON_VALUE(jsonb '"aaa"', '$' RETURNING int DEFAULT 111 ON ERROR)
RESULT: 
	[(111,)]

SELECT JSON_VALUE(jsonb '"123"', '$' RETURNING int) + 234
RESULT: 
	[(357,)]


SELECT JSON_VALUE(jsonb '"2017-02-20"', '$' RETURNING date) + 9
RESULT: 
	[(datetime.date(2017, 3, 1),)]


-- Test NULL checks execution in domain types
CREATE DOMAIN sqljsonb_int_not_null AS int NOT NULL

SELECT JSON_VALUE(jsonb 'null', '$' RETURNING sqljsonb_int_not_null)
RESULT: 
	[(None,)]

SELECT JSON_VALUE(jsonb 'null', '$' RETURNING sqljsonb_int_not_null ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb 'null', '$' RETURNING sqljsonb_int_not_null ERROR ON ERROR)

domain sqljsonb_int_not_null does not allow null values


SELECT JSON_VALUE(jsonb 'null', '$' RETURNING sqljsonb_int_not_null DEFAULT 2 ON EMPTY ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb 'null', '$' RETURNING sqljsonb_int_not_null DEFAULT 2 ON EMPTY ERROR ON ERROR)

domain sqljsonb_int_not_null does not allow null values


SELECT JSON_VALUE(jsonb '1',  '$.a' RETURNING sqljsonb_int_not_null DEFAULT 2 ON EMPTY ERROR ON ERROR)
RESULT: 
	[(2,)]

SELECT JSON_VALUE(jsonb '1',  '$.a' RETURNING sqljsonb_int_not_null DEFAULT NULL ON EMPTY ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb '1',  '$.a' RETURNING sqljsonb_int_not_null DEFAULT NULL ON EMPTY ERROR ON ERROR)

domain sqljsonb_int_not_null does not allow null values


CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple')

CREATE DOMAIN rgb AS rainbow CHECK (VALUE IN ('red', 'green', 'blue'))

SELECT JSON_VALUE('"purple"'::jsonb, 'lax $[*]' RETURNING rgb)
RESULT: 
	[(None,)]

SELECT JSON_VALUE('"purple"'::jsonb, 'lax $[*]' RETURNING rgb ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE('"purple"'::jsonb, 'lax $[*]' RETURNING rgb ERROR ON ERROR)

value for domain rgb violates check constraint "rgb_check"



SELECT JSON_VALUE(jsonb '[]', '$')
RESULT: 
	[(None,)]

SELECT JSON_VALUE(jsonb '[]', '$' ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb '[]', '$' ERROR ON ERROR)

JSON path expression in JSON_VALUE should return singleton scalar item


SELECT JSON_VALUE(jsonb '{}', '$')
RESULT: 
	[(None,)]

SELECT JSON_VALUE(jsonb '{}', '$' ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb '{}', '$' ERROR ON ERROR)

JSON path expression in JSON_VALUE should return singleton scalar item



SELECT JSON_VALUE(jsonb '1', '$.a')
RESULT: 
	[(None,)]

SELECT JSON_VALUE(jsonb '1', 'strict $.a' ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb '1', 'strict $.a' ERROR ON ERROR)

jsonpath member accessor can only be applied to an object


SELECT JSON_VALUE(jsonb '1', 'strict $.a' DEFAULT 'error' ON ERROR)
RESULT: 
	[('error',)]

SELECT JSON_VALUE(jsonb '1', 'lax $.a' ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb '1', 'lax $.a' ERROR ON ERROR)

no SQL/JSON item


SELECT JSON_VALUE(jsonb '1', 'lax $.a' ERROR ON EMPTY ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb '1', 'lax $.a' ERROR ON EMPTY ERROR ON ERROR)

no SQL/JSON item


SELECT JSON_VALUE(jsonb '1', 'strict $.a' DEFAULT 2 ON ERROR)
RESULT: 
	[('2',)]

SELECT JSON_VALUE(jsonb '1', 'lax $.a' DEFAULT 2 ON ERROR)
RESULT: 
	[('2',)]

SELECT JSON_VALUE(jsonb '1', 'lax $.a' DEFAULT '2' ON ERROR)
RESULT: 
	[('2',)]

SELECT JSON_VALUE(jsonb '1', 'lax $.a' NULL ON EMPTY DEFAULT '2' ON ERROR)
RESULT: 
	[(None,)]

SELECT JSON_VALUE(jsonb '1', 'lax $.a' DEFAULT '2' ON EMPTY DEFAULT '3' ON ERROR)
RESULT: 
	[('2',)]

SELECT JSON_VALUE(jsonb '1', 'lax $.a' ERROR ON EMPTY DEFAULT '3' ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb '1', 'lax $.a' ERROR ON EMPTY DEFAULT '3' ON ERROR)

no SQL/JSON item



SELECT JSON_VALUE(jsonb '[1,2]', '$[*]' ERROR ON ERROR)
ERROR: 

SELECT JSON_VALUE(jsonb '[1,2]', '$[*]' ERROR ON ERROR)

JSON path expression in JSON_VALUE should return singleton scalar item


SELECT JSON_VALUE(jsonb '[1,2]', '$[*]' DEFAULT '0' ON ERROR)
RESULT: 
	[('0',)]

SELECT JSON_VALUE(jsonb '[" "]', '$[*]' RETURNING int ERROR ON ERROR)
ERROR: 
SELECT JSON_VALUE(jsonb '[" "]', '$[*]' RETURNING int ERROR ON ERROR)

invalid input syntax for type integer: " "


SELECT JSON_VALUE(jsonb '[" "]', '$[*]' RETURNING int DEFAULT 2 + 3 ON ERROR)
RESULT: 
	[(5,)]

SELECT JSON_VALUE(jsonb '["1"]', '$[*]' RETURNING int DEFAULT 2 + 3 ON ERROR)
RESULT: 
	[(1,)]

SELECT JSON_VALUE(jsonb '["1"]', '$[*]' RETURNING int FORMAT JSON)
ProgrammingError: 
SELECT JSON_VALUE(jsonb '["1"]', '$[*]' RETURNING int FORMAT JSON)

cannot specify FORMAT JSON in RETURNING clause of JSON_VALUE()
LINE 2: ...CT JSON_VALUE(jsonb '["1"]', '$[*]' RETURNING int FORMAT JSO...
                                                             ^

 -- RETURNING FORMAT not allowed

-- RETUGNING pseudo-types not allowed
SELECT JSON_VALUE(jsonb '["1"]', '$[*]' RETURNING record)
ERROR:  -- RETURNING FORMAT not allowed

-- RETUGNING pseudo-types not allowed
SELECT JSON_VALUE(jsonb '["1"]', '$[*]' RETURNING record)

returning pseudo-types is not supported in SQL/JSON functions



SELECT
	x,
	JSON_VALUE(
		jsonb '{"a": 1, "b": 2}',
		'$.* ? (@ > $x)' PASSING x AS x
		RETURNING int
		DEFAULT -1 ON EMPTY
		DEFAULT -2 ON ERROR
	) y
FROM
	generate_series(0, 2) x
RESULT: 
	[(0, -2), (1, 2), (2, -1)]


SELECT JSON_VALUE(jsonb 'null', '$a' PASSING point ' (1, 2 )' AS a)
RESULT: 
	[('(1,2)',)]

SELECT JSON_VALUE(jsonb 'null', '$a' PASSING point ' (1, 2 )' AS a RETURNING point)
RESULT: 
	[('(1,2)',)]

SELECT JSON_VALUE(jsonb 'null', '$a' PASSING point ' (1, 2 )' AS a RETURNING point ERROR ON ERROR)
RESULT: 
	[('(1,2)',)]


-- Test PASSING and RETURNING date/time types
SELECT JSON_VALUE(jsonb 'null', '$ts' PASSING timestamptz '2018-02-21 12:34:56 +10' AS ts)
RESULT: 
	[('2018-02-21 03:34:56+01',)]

SELECT JSON_VALUE(jsonb 'null', '$ts' PASSING timestamptz '2018-02-21 12:34:56 +10' AS ts RETURNING timestamptz)
RESULT: 
	[(datetime.datetime(2018, 2, 21, 3, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=3600))),)]

SELECT JSON_VALUE(jsonb 'null', '$ts' PASSING timestamptz '2018-02-21 12:34:56 +10' AS ts RETURNING timestamp)
RESULT: 
	[(datetime.datetime(2018, 2, 21, 3, 34, 56),)]

SELECT JSON_VALUE(jsonb 'null', '$ts' PASSING date '2018-02-21 12:34:56 +10' AS ts RETURNING date)
RESULT: 
	[(datetime.date(2018, 2, 21),)]

SELECT JSON_VALUE(jsonb 'null', '$ts' PASSING time '2018-02-21 12:34:56 +10' AS ts RETURNING time)
RESULT: 
	[(datetime.time(12, 34, 56),)]

SELECT JSON_VALUE(jsonb 'null', '$ts' PASSING timetz '2018-02-21 12:34:56 +10' AS ts RETURNING timetz)
RESULT: 
	[(datetime.time(12, 34, 56, tzinfo=datetime.timezone(datetime.timedelta(seconds=36000))),)]

SELECT JSON_VALUE(jsonb 'null', '$ts' PASSING timestamp '2018-02-21 12:34:56 +10' AS ts RETURNING timestamp)
RESULT: 
	[(datetime.datetime(2018, 2, 21, 12, 34, 56),)]


-- Also test RETURNING json[b]
SELECT JSON_VALUE(jsonb 'null', '$ts' PASSING timestamptz '2018-02-21 12:34:56 +10' AS ts RETURNING json)
RESULT: 
	[('2018-02-21T02:34:56+00:00',)]

SELECT JSON_VALUE(jsonb 'null', '$ts' PASSING timestamptz '2018-02-21 12:34:56 +10' AS ts RETURNING jsonb)
RESULT: 
	[('2018-02-21T02:34:56+00:00',)]


-- Test that numeric JSON values are coerced uniformly
select json_value('{"a": 1.234}', '$.a' returning int error on error)
ERROR: 

-- Test that numeric JSON values are coerced uniformly
select json_value('{"a": 1.234}', '$.a' returning int error on error)

invalid input syntax for type integer: "1.234"


select json_value('{"a": "1.234"}', '$.a' returning int error on error)
ERROR: 
select json_value('{"a": "1.234"}', '$.a' returning int error on error)

invalid input syntax for type integer: "1.234"



-- JSON_QUERY

SELECT JSON_VALUE(NULL::jsonb, '$')
RESULT: 
	[(None,)]


SELECT
	JSON_QUERY(js, '$'),
	JSON_QUERY(js, '$' WITHOUT WRAPPER),
	JSON_QUERY(js, '$' WITH CONDITIONAL WRAPPER),
	JSON_QUERY(js, '$' WITH UNCONDITIONAL ARRAY WRAPPER),
	JSON_QUERY(js, '$' WITH ARRAY WRAPPER)
FROM
	(VALUES
		(jsonb 'null'),
		('12.3'),
		('true'),
		('"aaa"'),
		('[1, null, "2"]'),
		('{"a": 1, "b": [2]}')
	) foo(js)
RESULT: 
	[(None, None, [None], [None], [None]), (12.3, 12.3, [12.3], [12.3], [12.3]), (True, True, [True], [True], [True]), ('aaa', 'aaa', ['aaa'], ['aaa'], ['aaa']), ([1, None, '2'], [1, None, '2'], [1, None, '2'], [[1, None, '2']], [[1, None, '2']]), ({'a': 1, 'b': [2]}, {'a': 1, 'b': [2]}, {'a': 1, 'b': [2]}, [{'a': 1, 'b': [2]}], [{'a': 1, 'b': [2]}])]


SELECT
	JSON_QUERY(js, 'strict $[*]') AS "unspec",
	JSON_QUERY(js, 'strict $[*]' WITHOUT WRAPPER) AS "without",
	JSON_QUERY(js, 'strict $[*]' WITH CONDITIONAL WRAPPER) AS "with cond",
	JSON_QUERY(js, 'strict $[*]' WITH UNCONDITIONAL ARRAY WRAPPER) AS "with uncond",
	JSON_QUERY(js, 'strict $[*]' WITH ARRAY WRAPPER) AS "with"
FROM
	(VALUES
		(jsonb '1'),
		('[]'),
		('[null]'),
		('[12.3]'),
		('[true]'),
		('["aaa"]'),
		('[[1, 2, 3]]'),
		('[{"a": 1, "b": [2]}]'),
		('[1, "2", null, [3]]')
	) foo(js)
RESULT: 
	[(None, None, None, None, None), (None, None, None, None, None), (None, None, [None], [None], [None]), (12.3, 12.3, [12.3], [12.3], [12.3]), (True, True, [True], [True], [True]), ('aaa', 'aaa', ['aaa'], ['aaa'], ['aaa']), ([1, 2, 3], [1, 2, 3], [1, 2, 3], [[1, 2, 3]], [[1, 2, 3]]), ({'a': 1, 'b': [2]}, {'a': 1, 'b': [2]}, {'a': 1, 'b': [2]}, [{'a': 1, 'b': [2]}], [{'a': 1, 'b': [2]}]), (None, None, [1, '2', None, [3]], [1, '2', None, [3]], [1, '2', None, [3]])]


SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING text)
RESULT: 
	[('"aaa"',)]

SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING text KEEP QUOTES)
RESULT: 
	[('"aaa"',)]

SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING text KEEP QUOTES ON SCALAR STRING)
RESULT: 
	[('"aaa"',)]

SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING text OMIT QUOTES)
RESULT: 
	[('aaa',)]

SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING text OMIT QUOTES ON SCALAR STRING)
RESULT: 
	[('aaa',)]

SELECT JSON_QUERY(jsonb '"aaa"', '$' OMIT QUOTES ERROR ON ERROR)
ERROR: 
SELECT JSON_QUERY(jsonb '"aaa"', '$' OMIT QUOTES ERROR ON ERROR)

invalid input syntax for type json
DETAIL:  Token "aaa" is invalid.
CONTEXT:  JSON data, line 1: aaa


SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING json OMIT QUOTES ERROR ON ERROR)
ERROR: 
SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING json OMIT QUOTES ERROR ON ERROR)

invalid input syntax for type json
DETAIL:  Token "aaa" is invalid.
CONTEXT:  JSON data, line 1: aaa


SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING bytea FORMAT JSON OMIT QUOTES ERROR ON ERROR)
RESULT: 
	[(<memory at 0x73c231cc6500>,)]


-- Behavior when a RETURNING type has typmod != -1
SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING char(2))
RESULT: 
	[('"a',)]

SELECT JSON_QUERY(jsonb '"aaa"', '$' RETURNING char(2) OMIT QUOTES)
RESULT: 
	[('aa',)]

SELECT JSON_QUERY(jsonb '"aaa"', '$.a' RETURNING char(2) OMIT QUOTES DEFAULT 'bbb' ON EMPTY)
RESULT: 
	[('bb',)]

SELECT JSON_QUERY(jsonb '"aaa"', '$.a' RETURNING char(2) OMIT QUOTES DEFAULT '"bbb"'::jsonb ON EMPTY)
RESULT: 
	[('"b',)]


-- QUOTES behavior should not be specified when WITH WRAPPER used:
-- Should fail
SELECT JSON_QUERY(jsonb '[1]', '$' WITH WRAPPER OMIT QUOTES)
ProgrammingError: 

-- QUOTES behavior should not be specified when WITH WRAPPER used:
-- Should fail
SELECT JSON_QUERY(jsonb '[1]', '$' WITH WRAPPER OMIT QUOTES)

SQL/JSON QUOTES behavior must not be specified when WITH WRAPPER is used
LINE 5: SELECT JSON_QUERY(jsonb '[1]', '$' WITH WRAPPER OMIT QUOTES)
               ^


SELECT JSON_QUERY(jsonb '[1]', '$' WITH WRAPPER KEEP QUOTES)
ProgrammingError: 
SELECT JSON_QUERY(jsonb '[1]', '$' WITH WRAPPER KEEP QUOTES)

SQL/JSON QUOTES behavior must not be specified when WITH WRAPPER is used
LINE 2: SELECT JSON_QUERY(jsonb '[1]', '$' WITH WRAPPER KEEP QUOTES)
               ^


SELECT JSON_QUERY(jsonb '[1]', '$' WITH CONDITIONAL WRAPPER KEEP QUOTES)
ProgrammingError: 
SELECT JSON_QUERY(jsonb '[1]', '$' WITH CONDITIONAL WRAPPER KEEP QUOTES)

SQL/JSON QUOTES behavior must not be specified when WITH WRAPPER is used
LINE 2: SELECT JSON_QUERY(jsonb '[1]', '$' WITH CONDITIONAL WRAPPER ...
               ^


SELECT JSON_QUERY(jsonb '[1]', '$' WITH CONDITIONAL WRAPPER OMIT QUOTES)
ProgrammingError: 
SELECT JSON_QUERY(jsonb '[1]', '$' WITH CONDITIONAL WRAPPER OMIT QUOTES)

SQL/JSON QUOTES behavior must not be specified when WITH WRAPPER is used
LINE 2: SELECT JSON_QUERY(jsonb '[1]', '$' WITH CONDITIONAL WRAPPER ...
               ^


-- Should succeed
SELECT JSON_QUERY(jsonb '[1]', '$' WITHOUT WRAPPER OMIT QUOTES)
RESULT: 
	[([1],)]

SELECT JSON_QUERY(jsonb '[1]', '$' WITHOUT WRAPPER KEEP QUOTES)
RESULT: 
	[([1],)]


-- test QUOTES behavior.
SELECT JSON_QUERY(jsonb'{"rec": "{1,2,3}"}', '$.rec' returning int[] omit quotes)
RESULT: 
	[([1, 2, 3],)]

SELECT JSON_QUERY(jsonb'{"rec": "{1,2,3}"}', '$.rec' returning int[] keep quotes)
RESULT: 
	[(None,)]

SELECT JSON_QUERY(jsonb'{"rec": "{1,2,3}"}', '$.rec' returning int[] keep quotes error on error)
ERROR: 
SELECT JSON_QUERY(jsonb'{"rec": "{1,2,3}"}', '$.rec' returning int[] keep quotes error on error)

expected JSON array


SELECT JSON_QUERY(jsonb'{"rec": "[1,2]"}', '$.rec' returning int4range omit quotes)
RESULT: 
	[(NumericRange(1, 3, '[)'),)]

SELECT JSON_QUERY(jsonb'{"rec": "[1,2]"}', '$.rec' returning int4range keep quotes)
RESULT: 
	[(None,)]

SELECT JSON_QUERY(jsonb'{"rec": "[1,2]"}', '$.rec' 	returning int4range keep quotes error on error)
ERROR: 
SELECT JSON_QUERY(jsonb'{"rec": "[1,2]"}', '$.rec' 	returning int4range keep quotes error on error)

malformed range literal: ""[1,2]""
DETAIL:  Missing left parenthesis or bracket.



SELECT JSON_QUERY(jsonb '[]', '$[*]')
RESULT: 
	[(None,)]

SELECT JSON_QUERY(jsonb '[]', '$[*]' NULL ON EMPTY)
RESULT: 
	[(None,)]

SELECT JSON_QUERY(jsonb '[]', '$[*]' EMPTY ON EMPTY)
RESULT: 
	[([],)]

SELECT JSON_QUERY(jsonb '[]', '$[*]' EMPTY ARRAY ON EMPTY)
RESULT: 
	[([],)]

SELECT JSON_QUERY(jsonb '[]', '$[*]' EMPTY OBJECT ON EMPTY)
RESULT: 
	[({},)]

SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY)
ERROR: 
SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY)

no SQL/JSON item


SELECT JSON_QUERY(jsonb '[]', '$[*]' DEFAULT '"empty"' ON EMPTY)
RESULT: 
	[('empty',)]


SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY NULL ON ERROR)
ERROR: 

SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY NULL ON ERROR)

no SQL/JSON item


SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY EMPTY ARRAY ON ERROR)
ERROR: 
SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY EMPTY ARRAY ON ERROR)

no SQL/JSON item


SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY EMPTY OBJECT ON ERROR)
ERROR: 
SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY EMPTY OBJECT ON ERROR)

no SQL/JSON item


SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY ERROR ON ERROR)
ERROR: 
SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON EMPTY ERROR ON ERROR)

no SQL/JSON item


SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON ERROR)
ERROR: 
SELECT JSON_QUERY(jsonb '[]', '$[*]' ERROR ON ERROR)

no SQL/JSON item



SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' ERROR ON ERROR)
ERROR: 

SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' ERROR ON ERROR)

JSON path expression in JSON_QUERY should return singleton item without wrapper
HINT:  Use WITH WRAPPER clause to wrap SQL/JSON item sequence into array.


SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' DEFAULT '"empty"' ON ERROR)
RESULT: 
	[('empty',)]


SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING json)
RESULT: 
	[([1, 2],)]

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING json FORMAT JSON)
RESULT: 
	[([1, 2],)]

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING jsonb)
RESULT: 
	[([1, 2],)]

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING jsonb FORMAT JSON)
RESULT: 
	[([1, 2],)]

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING text)
RESULT: 
	[('[1, 2]',)]

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING char(10))
RESULT: 
	[('[1, 2]    ',)]

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING char(3))
RESULT: 
	[('[1,',)]

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING text FORMAT JSON)
RESULT: 
	[('[1, 2]',)]

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING bytea)
RESULT: 
	[(<memory at 0x73c231cc5cc0>,)]

SELECT JSON_QUERY(jsonb '[1,2]', '$' RETURNING bytea FORMAT JSON)
RESULT: 
	[(<memory at 0x73c231cc5cc0>,)]


SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING bytea EMPTY OBJECT ON ERROR)
ProgrammingError: 

SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING bytea EMPTY OBJECT ON ERROR)

cannot cast behavior expression of type jsonb to bytea
LINE 3: ... JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING bytea EMPTY OBJE...
                                                             ^


SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING bytea FORMAT JSON EMPTY OBJECT ON ERROR)
ProgrammingError: 
SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING bytea FORMAT JSON EMPTY OBJECT ON ERROR)

cannot cast behavior expression of type jsonb to bytea
LINE 2: ...jsonb '[1,2]', '$[*]' RETURNING bytea FORMAT JSON EMPTY OBJE...
                                                             ^


SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING json EMPTY OBJECT ON ERROR)
RESULT: 
	[({},)]

SELECT JSON_QUERY(jsonb '[1,2]', '$[*]' RETURNING jsonb EMPTY OBJECT ON ERROR)
RESULT: 
	[({},)]

SELECT JSON_QUERY(jsonb '[3,4]', '$[*]' RETURNING bigint[] EMPTY OBJECT ON ERROR)
ProgrammingError: 
SELECT JSON_QUERY(jsonb '[3,4]', '$[*]' RETURNING bigint[] EMPTY OBJECT ON ERROR)

cannot cast behavior expression of type jsonb to bigint[]
LINE 2: ...ON_QUERY(jsonb '[3,4]', '$[*]' RETURNING bigint[] EMPTY OBJE...
                                                             ^


SELECT JSON_QUERY(jsonb '"[3,4]"', '$[*]' RETURNING bigint[] EMPTY OBJECT ON ERROR)
ProgrammingError: 
SELECT JSON_QUERY(jsonb '"[3,4]"', '$[*]' RETURNING bigint[] EMPTY OBJECT ON ERROR)

cannot cast behavior expression of type jsonb to bigint[]
LINE 2: ..._QUERY(jsonb '"[3,4]"', '$[*]' RETURNING bigint[] EMPTY OBJE...
                                                             ^



-- Coercion fails with quotes on
SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING int2 error on error)
ERROR: 

-- Coercion fails with quotes on
SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING int2 error on error)

invalid input syntax for type smallint: ""123.1""


SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING int4 error on error)
ERROR: 
SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING int4 error on error)

invalid input syntax for type integer: ""123.1""


SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING int8 error on error)
ERROR: 
SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING int8 error on error)

invalid input syntax for type bigint: ""123.1""


SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING bool error on error)
ERROR: 
SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING bool error on error)

invalid input syntax for type boolean: ""123.1""


SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING numeric error on error)
ERROR: 
SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING numeric error on error)

invalid input syntax for type numeric: ""123.1""


SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING real error on error)
ERROR: 
SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING real error on error)

invalid input syntax for type real: ""123.1""


SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING float8 error on error)
ERROR: 
SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING float8 error on error)

invalid input syntax for type double precision: ""123.1""


-- Fine with OMIT QUOTES
SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING int2 omit quotes error on error)
ERROR: 
-- Fine with OMIT QUOTES
SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING int2 omit quotes error on error)

invalid input syntax for type smallint: "123.1"


SELECT JSON_QUERY(jsonb '"123.1"', '$' RETURNING float8 omit quotes error on error)
RESULT: 
	[(123.1,)]


-- RETUGNING pseudo-types not allowed
SELECT JSON_QUERY(jsonb '[3,4]', '$[*]' RETURNING anyarray EMPTY OBJECT ON ERROR)
ERROR: 

-- RETUGNING pseudo-types not allowed
SELECT JSON_QUERY(jsonb '[3,4]', '$[*]' RETURNING anyarray EMPTY OBJECT ON ERROR)

returning pseudo-types is not supported in SQL/JSON functions



SELECT
	x, y,
	JSON_QUERY(
		jsonb '[1,2,3,4,5,null]',
		'$[*] ? (@ >= $x && @ <= $y)'
		PASSING x AS x, y AS y
		WITH CONDITIONAL WRAPPER
		EMPTY ARRAY ON EMPTY
	) list
FROM
	generate_series(0, 4) x,
	generate_series(0, 4) y
RESULT: 
	[(0, 0, []), (0, 1, [1]), (0, 2, [1, 2]), (0, 3, [1, 2, 3]), (0, 4, [1, 2, 3, 4]), (1, 0, []), (1, 1, [1]), (1, 2, [1, 2]), (1, 3, [1, 2, 3]), (1, 4, [1, 2, 3, 4]), (2, 0, []), (2, 1, []), (2, 2, [2]), (2, 3, [2, 3]), (2, 4, [2, 3, 4]), (3, 0, []), (3, 1, []), (3, 2, []), (3, 3, [3]), (3, 4, [3, 4]), (4, 0, []), (4, 1, []), (4, 2, []), (4, 3, []), (4, 4, [4])]


-- record type returning with quotes behavior.
CREATE TYPE comp_abc AS (a text, b int, c timestamp)

SELECT JSON_QUERY(jsonb'{"rec": "(abc,42,01.02.2003)"}', '$.rec' returning comp_abc omit quotes)
RESULT: 
	[('(abc,42,"2003-02-01 00:00:00")',)]

SELECT JSON_QUERY(jsonb'{"rec": "(abc,42,01.02.2003)"}', '$.rec' returning comp_abc keep quotes)
RESULT: 
	[(None,)]

SELECT JSON_QUERY(jsonb'{"rec": "(abc,42,01.02.2003)"}', '$.rec' returning comp_abc keep quotes error on error)
ERROR: 
SELECT JSON_QUERY(jsonb'{"rec": "(abc,42,01.02.2003)"}', '$.rec' returning comp_abc keep quotes error on error)

cannot call populate_composite on a scalar


DROP TYPE comp_abc


-- Extension: record types returning
CREATE TYPE sqljsonb_rec AS (a int, t text, js json, jb jsonb, jsa json[])

CREATE TYPE sqljsonb_reca AS (reca sqljsonb_rec[])


SELECT JSON_QUERY(jsonb '[{"a": 1, "b": "foo", "t": "aaa", "js": [1, "2", {}], "jb": {"x": [1, "2", {}]}},  {"a": 2}]', '$[0]' RETURNING sqljsonb_rec)
RESULT: 
	[('(1,aaa,"[1, ""2"", {}]","{""x"": [1, ""2"", {}]}",)',)]

SELECT JSON_QUERY(jsonb '[{"a": "a", "b": "foo", "t": "aaa", "js": [1, "2", {}], "jb": {"x": [1, "2", {}]}},  {"a": 2}]', '$[0]' RETURNING sqljsonb_rec ERROR ON ERROR)
ERROR: 
SELECT JSON_QUERY(jsonb '[{"a": "a", "b": "foo", "t": "aaa", "js": [1, "2", {}], "jb": {"x": [1, "2", {}]}},  {"a": 2}]', '$[0]' RETURNING sqljsonb_rec ERROR ON ERROR)

invalid input syntax for type integer: "a"


SELECT JSON_QUERY(jsonb '[{"a": "a", "b": "foo", "t": "aaa", "js": [1, "2", {}], "jb": {"x": [1, "2", {}]}},  {"a": 2}]', '$[0]' RETURNING sqljsonb_rec)
RESULT: 
	[(None,)]

SELECT * FROM unnest((JSON_QUERY(jsonb '{"jsa":  [{"a": 1, "b": ["foo"]}, {"a": 2, "c": {}}, 123]}', '$' RETURNING sqljsonb_rec)).jsa)
RESULT: 
	[({'a': 1, 'b': ['foo']},), ({'a': 2, 'c': {}},), (123,)]

SELECT * FROM unnest((JSON_QUERY(jsonb '{"reca": [{"a": 1, "t": ["foo", []]}, {"a": 2, "jb": [{}, true]}]}', '$' RETURNING sqljsonb_reca)).reca)
RESULT: 
	[(1, '["foo", []]', None, None, None), (2, None, None, [{}, True], None)]


SELECT JSON_QUERY(jsonb '[{"a": 1, "b": "foo", "t": "aaa", "js": [1, "2", {}], "jb": {"x": [1, "2", {}]}},  {"a": 2}]', '$[0]' RETURNING jsonpath)
RESULT: 
	[(None,)]

SELECT JSON_QUERY(jsonb '[{"a": 1, "b": "foo", "t": "aaa", "js": [1, "2", {}], "jb": {"x": [1, "2", {}]}},  {"a": 2}]', '$[0]' RETURNING jsonpath ERROR ON ERROR)
ProgrammingError: 
SELECT JSON_QUERY(jsonb '[{"a": 1, "b": "foo", "t": "aaa", "js": [1, "2", {}], "jb": {"x": [1, "2", {}]}},  {"a": 2}]', '$[0]' RETURNING jsonpath ERROR ON ERROR)

syntax error at or near "{" of jsonpath input



-- Extension: array types returning
SELECT JSON_QUERY(jsonb '[1,2,null,"3"]', '$[*]' RETURNING int[] WITH WRAPPER)
RESULT: 
	[([1, 2, None, 3],)]

SELECT JSON_QUERY(jsonb '[1,2,null,"a"]', '$[*]' RETURNING int[] WITH WRAPPER ERROR ON ERROR)
ERROR: 
SELECT JSON_QUERY(jsonb '[1,2,null,"a"]', '$[*]' RETURNING int[] WITH WRAPPER ERROR ON ERROR)

invalid input syntax for type integer: "a"


SELECT JSON_QUERY(jsonb '[1,2,null,"a"]', '$[*]' RETURNING int[] WITH WRAPPER)
RESULT: 
	[(None,)]

SELECT * FROM unnest(JSON_QUERY(jsonb '[{"a": 1, "t": ["foo", []]}, {"a": 2, "jb": [{}, true]}]', '$' RETURNING sqljsonb_rec[]))
RESULT: 
	[(1, '["foo", []]', None, None, None), (2, None, None, [{}, True], None)]


-- Extension: domain types returning
SELECT JSON_QUERY(jsonb '{"a": 1}', '$.a' RETURNING sqljsonb_int_not_null)
RESULT: 
	[(1,)]

SELECT JSON_QUERY(jsonb '{"a": 1}', '$.b' RETURNING sqljsonb_int_not_null)
RESULT: 
	[(None,)]

SELECT JSON_QUERY(jsonb '{"a": 1}', '$.b' RETURNING sqljsonb_int_not_null ERROR ON ERROR)
ERROR: 
SELECT JSON_QUERY(jsonb '{"a": 1}', '$.b' RETURNING sqljsonb_int_not_null ERROR ON ERROR)

no SQL/JSON item



-- Test timestamptz passing and output
SELECT JSON_QUERY(jsonb 'null', '$ts' PASSING timestamptz '2018-02-21 12:34:56 +10' AS ts)
RESULT: 
	[('2018-02-21T02:34:56+00:00',)]

SELECT JSON_QUERY(jsonb 'null', '$ts' PASSING timestamptz '2018-02-21 12:34:56 +10' AS ts RETURNING json)
RESULT: 
	[('2018-02-21T02:34:56+00:00',)]

SELECT JSON_QUERY(jsonb 'null', '$ts' PASSING timestamptz '2018-02-21 12:34:56 +10' AS ts RETURNING jsonb)
RESULT: 
	[('2018-02-21T02:34:56+00:00',)]


-- Test constraints

CREATE TABLE test_jsonb_constraints (
	js text,
	i int,
	x jsonb DEFAULT JSON_QUERY(jsonb '[1,2]', '$[*]' WITH WRAPPER)
	CONSTRAINT test_jsonb_constraint1
		CHECK (js IS JSON)
	CONSTRAINT test_jsonb_constraint2
		CHECK (JSON_EXISTS(js::jsonb, '$.a' PASSING i + 5 AS int, i::text AS txt, array[1,2,3] as arr))
	CONSTRAINT test_jsonb_constraint3
		CHECK (JSON_VALUE(js::jsonb, '$.a' RETURNING int DEFAULT '12' ON EMPTY ERROR ON ERROR) > i)
	CONSTRAINT test_jsonb_constraint4
		CHECK (JSON_QUERY(js::jsonb, '$.a' WITH CONDITIONAL WRAPPER EMPTY OBJECT ON ERROR) < jsonb '[10]')
	CONSTRAINT test_jsonb_constraint5
		CHECK (JSON_QUERY(js::jsonb, '$.a' RETURNING char(5) OMIT QUOTES EMPTY ARRAY ON EMPTY) >  'a' COLLATE "C")
)


-- \d test_jsonb_constraints

SELECT check_clause
FROM information_schema.check_constraints
WHERE constraint_name LIKE 'test_jsonb_constraint%'
ORDER BY 1
RESULT: 
	[('(JSON_QUERY((js)::jsonb, \'$."a"\' RETURNING character(5) OMIT QUOTES EMPTY ARRAY ON EMPTY) > (\'a\'::bpchar COLLATE "C"))',), ('(JSON_QUERY((js)::jsonb, \'$."a"\' RETURNING jsonb WITH CONDITIONAL WRAPPER EMPTY OBJECT ON ERROR) < \'[10]\'::jsonb)',), ('(JSON_VALUE((js)::jsonb, \'$."a"\' RETURNING integer DEFAULT 12 ON EMPTY ERROR ON ERROR) > i)',), ('(js IS JSON)',), ('JSON_EXISTS((js)::jsonb, \'$."a"\' PASSING (i + 5) AS int, (i)::text AS txt, ARRAY[1, 2, 3] AS arr)',)]


SELECT pg_get_expr(adbin, adrelid)
FROM pg_attrdef
WHERE adrelid = 'test_jsonb_constraints'::regclass
ORDER BY 1
RESULT: 
	[("JSON_QUERY('[1, 2]'::jsonb, '$[*]' RETURNING jsonb WITH UNCONDITIONAL WRAPPER)",)]


INSERT INTO test_jsonb_constraints VALUES ('', 1)
ERROR: 

INSERT INTO test_jsonb_constraints VALUES ('', 1)

new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint1"
DETAIL:  Failing row contains (, 1, [1, 2]).


INSERT INTO test_jsonb_constraints VALUES ('1', 1)
ERROR: 
INSERT INTO test_jsonb_constraints VALUES ('1', 1)

new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint2"
DETAIL:  Failing row contains (1, 1, [1, 2]).


INSERT INTO test_jsonb_constraints VALUES ('[]')
ERROR: 
INSERT INTO test_jsonb_constraints VALUES ('[]')

new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint2"
DETAIL:  Failing row contains ([], null, [1, 2]).


INSERT INTO test_jsonb_constraints VALUES ('{"b": 1}', 1)
ERROR: 
INSERT INTO test_jsonb_constraints VALUES ('{"b": 1}', 1)

new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint2"
DETAIL:  Failing row contains ({"b": 1}, 1, [1, 2]).


INSERT INTO test_jsonb_constraints VALUES ('{"a": 1}', 1)
ERROR: 
INSERT INTO test_jsonb_constraints VALUES ('{"a": 1}', 1)

new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint3"
DETAIL:  Failing row contains ({"a": 1}, 1, [1, 2]).


INSERT INTO test_jsonb_constraints VALUES ('{"a": 7}', 1)
ERROR: 
INSERT INTO test_jsonb_constraints VALUES ('{"a": 7}', 1)

new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint5"
DETAIL:  Failing row contains ({"a": 7}, 1, [1, 2]).


INSERT INTO test_jsonb_constraints VALUES ('{"a": 10}', 1)
ERROR: 
INSERT INTO test_jsonb_constraints VALUES ('{"a": 10}', 1)

new row for relation "test_jsonb_constraints" violates check constraint "test_jsonb_constraint4"
DETAIL:  Failing row contains ({"a": 10}, 1, [1, 2]).



DROP TABLE test_jsonb_constraints


-- Test mutabilily of query functions
CREATE TABLE test_jsonb_mutability(js jsonb, b int)

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$'))

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a[0]'))

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.time()'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.time()'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.date()'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.date()'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.time_tz()'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.time_tz()'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.timestamp()'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.timestamp()'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.timestamp_tz()'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.timestamp_tz()'))

functions in index expression must be marked IMMUTABLE



CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.date() < $.time_tz())'))
ProgrammingError: 

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.date() < $.time_tz())'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.date() < $.time())'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.date() < $.time())'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.time() < $.time())'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.time() < $.time())'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.time() < $.time_tz())'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.time() < $.time_tz())'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp() < $.timestamp_tz())'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp() < $.timestamp_tz())'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp_tz() < $.timestamp_tz())'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp_tz() < $.timestamp_tz())'))

functions in index expression must be marked IMMUTABLE



CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.time() < $.datetime("HH:MI TZH"))'))
ProgrammingError: 

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.time() < $.datetime("HH:MI TZH"))'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.date() < $.datetime("HH:MI TZH"))'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.date() < $.datetime("HH:MI TZH"))'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp() < $.datetime("HH:MI TZH"))'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp() < $.datetime("HH:MI TZH"))'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp() < $.datetime("HH:MI"))'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp() < $.datetime("HH:MI"))'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp_tz() < $.datetime("HH:MI TZH"))'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp_tz() < $.datetime("HH:MI TZH"))'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp_tz() < $.datetime("HH:MI"))'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp_tz() < $.datetime("HH:MI"))'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.date() < $x' PASSING '12:34'::timetz AS x))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.date() < $x' PASSING '12:34'::timetz AS x))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.date() < $x' PASSING '1234'::int AS x))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.date() < $x' PASSING '1234'::int AS x))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp(2) < $.timestamp(3))'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.timestamp(2) < $.timestamp(3))'))

functions in index expression must be marked IMMUTABLE



CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.datetime()'))

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@ < $.datetime())'))

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.datetime() < $.datetime())'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.datetime() < $.datetime())'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.datetime() < $.datetime("HH:MI TZH"))'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.datetime() < $.datetime("HH:MI TZH"))'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.datetime("HH:MI TZH") < $.datetime("HH:MI TZH"))'))

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.datetime("HH:MI") < $.datetime("YY-MM-DD HH:MI"))'))

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.datetime("HH:MI TZH") < $.datetime("YY-MM-DD HH:MI"))'))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.a ? (@.datetime("HH:MI TZH") < $.datetime("YY-MM-DD HH:MI"))'))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.datetime("HH:MI TZH") < $x' PASSING '12:34'::timetz AS x))

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.datetime("HH:MI TZH") < $y' PASSING '12:34'::timetz AS x))

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.datetime() < $x' PASSING '12:34'::timetz AS x))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.datetime() < $x' PASSING '12:34'::timetz AS x))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.datetime() < $x' PASSING '1234'::int AS x))

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.datetime() ? (@ == $x)' PASSING '12:34'::time AS x))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.datetime() ? (@ == $x)' PASSING '12:34'::time AS x))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$.datetime("YY-MM-DD") ? (@ == $x)' PASSING '2020-07-14'::date AS x))

CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$[1, $.a ? (@.datetime() == $x)]' PASSING '12:34'::time AS x))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$[1, $.a ? (@.datetime() == $x)]' PASSING '12:34'::time AS x))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$[1, 0 to $.a ? (@.datetime() == $x)]' PASSING '12:34'::time AS x))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$[1, 0 to $.a ? (@.datetime() == $x)]' PASSING '12:34'::time AS x))

functions in index expression must be marked IMMUTABLE


CREATE INDEX ON test_jsonb_mutability (JSON_QUERY(js, '$[1, $.a ? (@.datetime("HH:MI") == $x)]' PASSING '12:34'::time AS x))

CREATE INDEX ON test_jsonb_mutability (JSON_VALUE(js, '$' DEFAULT random()::int ON ERROR))
ProgrammingError: 
CREATE INDEX ON test_jsonb_mutability (JSON_VALUE(js, '$' DEFAULT random()::int ON ERROR))

functions in index expression must be marked IMMUTABLE



-- DEFAULT expression
CREATE OR REPLACE FUNCTION ret_setint() RETURNS SETOF integer AS
$$
BEGIN
    RETURN QUERY EXECUTE 'select 1 union all select 1';
END;
$$
LANGUAGE plpgsql IMMUTABLE

SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT ret_setint() ON ERROR) FROM test_jsonb_mutability
ProgrammingError: 
SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT ret_setint() ON ERROR) FROM test_jsonb_mutability

DEFAULT expression must not return a set
LINE 2: SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT ret_setint(...
                                                         ^


SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT b + 1 ON ERROR) FROM test_jsonb_mutability
ProgrammingError: 
SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT b + 1 ON ERROR) FROM test_jsonb_mutability

DEFAULT expression must not contain column references
LINE 2: SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT b + 1 ON ER...
                                                         ^


SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT sum(1) over() ON ERROR) FROM test_jsonb_mutability
ProgrammingError: 
SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT sum(1) over() ON ERROR) FROM test_jsonb_mutability

can only specify a constant, non-aggregate function, or operator expression for DEFAULT
LINE 2: SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT sum(1) over...
                                                         ^


SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT (SELECT 1) ON ERROR) FROM test_jsonb_mutability
ProgrammingError: 
SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT (SELECT 1) ON ERROR) FROM test_jsonb_mutability

can only specify a constant, non-aggregate function, or operator expression for DEFAULT
LINE 2: SELECT JSON_QUERY(js, '$'  RETURNING int DEFAULT (SELECT 1) ...
                                                         ^


DROP TABLE test_jsonb_mutability

DROP FUNCTION ret_setint


-- Extension: non-constant JSON path
SELECT JSON_EXISTS(jsonb '{"a": 123}', '$' || '.' || 'a')
RESULT: 
	[(True,)]

SELECT JSON_VALUE(jsonb '{"a": 123}', '$' || '.' || 'a')
RESULT: 
	[('123',)]

SELECT JSON_VALUE(jsonb '{"a": 123}', '$' || '.' || 'b' DEFAULT 'foo' ON EMPTY)
RESULT: 
	[('foo',)]

SELECT JSON_QUERY(jsonb '{"a": 123}', '$' || '.' || 'a')
RESULT: 
	[(123,)]

SELECT JSON_QUERY(jsonb '{"a": 123}', '$' || '.' || 'a' WITH WRAPPER)
RESULT: 
	[([123],)]

-- Should fail (invalid path)
SELECT JSON_QUERY(jsonb '{"a": 123}', 'error' || ' ' || 'error')
ProgrammingError: 
-- Should fail (invalid path)
SELECT JSON_QUERY(jsonb '{"a": 123}', 'error' || ' ' || 'error')

syntax error at or near " " of jsonpath input



-- Non-jsonb inputs automatically coerced to jsonb
SELECT JSON_EXISTS(json '{"a": 123}', '$' || '.' || 'a')
RESULT: 
	[(True,)]

SELECT JSON_QUERY(NULL FORMAT JSON, '$')
RESULT: 
	[(None,)]


-- Test non-const jsonpath
CREATE TEMP TABLE jsonpaths (path) AS SELECT '$'

SELECT json_value('"aaa"', path RETURNING json) FROM jsonpaths
RESULT: 
	[('aaa',)]


