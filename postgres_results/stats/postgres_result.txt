
-----------
QUERY:
--
-- Test cumulative stats system
--
-- Must be run after tenk2 has been created (by create_table),
-- populated (by create_misc) and indexed (by create_index).
--

-- conditio sine qua non
SHOW track_counts;
RESULT:
	postgres: [('on',)]

-----------
QUERY:
  -- must be on

-- ensure that both seqscan and indexscan plans are allowed
SET enable_seqscan TO on;
RESULT:
	postgres: None

-----------
QUERY:

SET enable_indexscan TO on;
RESULT:
	postgres: None

-----------
QUERY:

-- for the moment, we don/* REPLACED */''t want index-only scans here
SET enable_indexonlyscan TO off;
RESULT:
	postgres: None

-----------
QUERY:

-- not enabled by default, but we want to test it...
SET track_functions TO 'all';
RESULT:
	postgres: None

-----------
QUERY:


-- record dboid for later use
SELECT oid AS dboid from pg_database where datname = current_database() \gset

-- save counters
BEGIN;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: ...id from pg_database where datname = current_database() \gset
                                                                  ^


-----------
QUERY:

SET LOCAL stats_fetch_consistency = snapshot;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE prevstats AS
SELECT t.seq_scan, t.seq_tup_read, t.idx_scan, t.idx_tup_fetch,
       (b.heap_blks_read + b.heap_blks_hit) AS heap_blks,
       (b.idx_blks_read + b.idx_blks_hit) AS idx_blks,
       pg_stat_get_snapshot_timestamp() as snap_ts
  FROM pg_catalog.pg_stat_user_tables AS t,
       pg_catalog.pg_statio_user_tables AS b
 WHERE t.relname='tenk2' AND b.relname='tenk2';
RESULT:
	postgres: None

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


-- test effects of TRUNCATE on n_live_tup/n_dead_tup counters
CREATE TABLE trunc_stats_test(id serial);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trunc_stats_test1(id serial, stuff text);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trunc_stats_test2(id serial);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trunc_stats_test3(id serial, stuff text);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trunc_stats_test4(id serial);
RESULT:
	postgres: None

-----------
QUERY:


-- check that n_live_tup is reset to 0 after truncate
INSERT INTO trunc_stats_test DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

TRUNCATE trunc_stats_test;
RESULT:
	postgres: None

-----------
QUERY:


-- test involving a truncate in a transaction /* REPLACED */, 4 ins but only 1 live
INSERT INTO trunc_stats_test1 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test1 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test1 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

UPDATE trunc_stats_test1 SET id = id + 10 WHERE id IN (1, 2);
RESULT:
	postgres: None

-----------
QUERY:

DELETE FROM trunc_stats_test1 WHERE id = 3;
RESULT:
	postgres: None

-----------
QUERY:


BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

UPDATE trunc_stats_test1 SET id = id + 100;
RESULT:
	postgres: None

-----------
QUERY:

TRUNCATE trunc_stats_test1;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test1 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


-- use a savepoint: 1 insert, 1 live
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test2 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test2 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

SAVEPOINT p1;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test2 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

TRUNCATE trunc_stats_test2;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test2 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

RELEASE SAVEPOINT p1;
RESULT:
	postgres: None

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


-- rollback a savepoint: this should count 4 inserts and have 2
-- live tuples after commit (and 2 dead ones due to aborted subxact)
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test3 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test3 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

SAVEPOINT p1;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test3 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test3 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

TRUNCATE trunc_stats_test3;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test3 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

ROLLBACK TO SAVEPOINT p1;
RESULT:
	postgres: None

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


-- rollback a truncate: this should count 2 inserts and produce 2 dead tuples
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test4 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test4 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

TRUNCATE trunc_stats_test4;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trunc_stats_test4 DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:


-- do a seqscan
SELECT count(*) FROM tenk2;
RESULT:
	postgres: [(10000,)]

-----------
QUERY:

-- do an indexscan
-- make sure it is not a bitmap scan, which might skip fetching heap tuples
SET enable_bitmapscan TO off;
RESULT:
	postgres: None

-----------
QUERY:

SELECT count(*) FROM tenk2 WHERE unique1 = 1;
RESULT:
	postgres: [(1,)]

-----------
QUERY:

RESET enable_bitmapscan;
RESULT:
	postgres: None

-----------
QUERY:


-- ensure pending stats are flushed
SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:


-- check effects
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL stats_fetch_consistency = snapshot;
RESULT:
	postgres: None

-----------
QUERY:


SELECT relname, n_tup_ins, n_tup_upd, n_tup_del, n_live_tup, n_dead_tup
  FROM pg_stat_user_tables
 WHERE relname like 'trunc_stats_test%' order by relname;
RESULT:
	postgres: [('trunc_stats_test', 3, 0, 0, 0, 0), ('trunc_stats_test1', 4, 2, 1, 1, 0), ('trunc_stats_test2', 1, 0, 0, 1, 0), ('trunc_stats_test3', 4, 0, 0, 2, 2), ('trunc_stats_test4', 2, 0, 0, 0, 2)]

-----------
QUERY:


SELECT st.seq_scan >= pr.seq_scan + 1,
       st.seq_tup_read >= pr.seq_tup_read + cl.reltuples,
       st.idx_scan >= pr.idx_scan + 1,
       st.idx_tup_fetch >= pr.idx_tup_fetch + 1
  FROM pg_stat_user_tables AS st, pg_class AS cl, prevstats AS pr
 WHERE st.relname='tenk2' AND cl.relname='tenk2';
RESULT:
	postgres: [(True, True, True, True)]

-----------
QUERY:


SELECT st.heap_blks_read + st.heap_blks_hit >= pr.heap_blks + cl.relpages,
       st.idx_blks_read + st.idx_blks_hit >= pr.idx_blks + 1
  FROM pg_statio_user_tables AS st, pg_class AS cl, prevstats AS pr
 WHERE st.relname='tenk2' AND cl.relname='tenk2';
RESULT:
	postgres: [(True, True)]

-----------
QUERY:


SELECT pr.snap_ts < pg_stat_get_snapshot_timestamp() as snapshot_newer
FROM prevstats AS pr;
RESULT:
	postgres: [(None,)]

-----------
QUERY:


COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


----
-- Basic tests for track_functions
---
CREATE FUNCTION stats_test_func1() RETURNS VOID LANGUAGE plpgsql AS $$BEGIN END;$$;
RESULT:
	postgres: None

-----------
QUERY:

SELECT 'stats_test_func1()'::regprocedure::oid AS stats_test_func1_oid \gset
CREATE FUNCTION stats_test_func2() RETURNS VOID LANGUAGE plpgsql AS $$BEGIN END;$$;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: ...st_func1()'::regprocedure::oid AS stats_test_func1_oid \gset
                                                                  ^


-----------
QUERY:

SELECT 'stats_test_func2()'::regprocedure::oid AS stats_test_func2_oid \gset

-- test that stats are accumulated
BEGIN;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: ...st_func2()'::regprocedure::oid AS stats_test_func2_oid \gset
                                                                  ^


-----------
QUERY:

SET LOCAL stats_fetch_consistency = none;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
                                          ^


-----------
QUERY:

SELECT pg_stat_get_xact_function_calls(:stats_test_func1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_function_calls(:stats_test_func1_oid...
                                               ^


-----------
QUERY:

SELECT stats_test_func1();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT pg_stat_get_xact_function_calls(:stats_test_func1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_function_calls(:stats_test_func1_oid...
                                               ^


-----------
QUERY:

SELECT stats_test_func1();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT pg_stat_get_xact_function_calls(:stats_test_func1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_function_calls(:stats_test_func1_oid...
                                               ^


-----------
QUERY:

SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
                                          ^


-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


-- Verify that function stats are not transactional

-- rolled back savepoint in committing transaction
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SELECT stats_test_func2();
RESULT:
	postgres: ERROR - function stats_test_func2() does not exist
LINE 2: SELECT stats_test_func2();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SAVEPOINT foo;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

SELECT stats_test_func2();
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK TO SAVEPOINT foo;
RESULT:
	postgres: ERROR - savepoint "foo" does not exist


-----------
QUERY:

SELECT pg_stat_get_xact_function_calls(:stats_test_func2_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_function_calls(:stats_test_func2_oid...
                                               ^


-----------
QUERY:

SELECT stats_test_func2();
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


-- rolled back transaction
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SELECT stats_test_func2();
RESULT:
	postgres: ERROR - function stats_test_func2() does not exist
LINE 2: SELECT stats_test_func2();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:


SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:


-- check collected stats
SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func1_oid;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 4: ... calls FROM pg_stat_user_functions WHERE funcid = :stats_tes...
                                                             ^


-----------
QUERY:

SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func2_oid;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: ... calls FROM pg_stat_user_functions WHERE funcid = :stats_tes...
                                                             ^


-----------
QUERY:



-- check that a rolled back drop function stats leaves stats alive
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func1_oid;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: ... calls FROM pg_stat_user_functions WHERE funcid = :stats_tes...
                                                             ^


-----------
QUERY:

DROP FUNCTION stats_test_func1();
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

-- shouldn/* REPLACED */''t be visible via view
SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func1_oid;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 3: ... calls FROM pg_stat_user_functions WHERE funcid = :stats_tes...
                                                             ^


-----------
QUERY:

-- but still via oid access
SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 3: SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
                                          ^


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:

SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func1_oid;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: ... calls FROM pg_stat_user_functions WHERE funcid = :stats_tes...
                                                             ^


-----------
QUERY:

SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
                                          ^


-----------
QUERY:



-- check that function dropped in main transaction leaves no stats behind
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

DROP FUNCTION stats_test_func1();
RESULT:
	postgres: None

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func1_oid;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: ... calls FROM pg_stat_user_functions WHERE funcid = :stats_tes...
                                                             ^


-----------
QUERY:

SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_function_calls(:stats_test_func1_oid);
                                          ^


-----------
QUERY:


-- check that function dropped in a subtransaction leaves no stats behind
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SELECT stats_test_func2();
RESULT:
	postgres: ERROR - function stats_test_func2() does not exist
LINE 2: SELECT stats_test_func2();
               ^
HINT:  No function matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:

SAVEPOINT a;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

SELECT stats_test_func2();
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

SAVEPOINT b;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

DROP FUNCTION stats_test_func2();
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

SELECT funcname, calls FROM pg_stat_user_functions WHERE funcid = :stats_test_func2_oid;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: ... calls FROM pg_stat_user_functions WHERE funcid = :stats_tes...
                                                             ^


-----------
QUERY:

SELECT pg_stat_get_function_calls(:stats_test_func2_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_function_calls(:stats_test_func2_oid);
                                          ^


-----------
QUERY:



-- Check that stats for relations are dropped. For that we need to access stats
-- by oid after the DROP TABLE. Save oids.
CREATE TABLE drop_stats_test();
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO drop_stats_test DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:

SELECT 'drop_stats_test'::regclass::oid AS drop_stats_test_oid \gset

CREATE TABLE drop_stats_test_xact();
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: ...drop_stats_test'::regclass::oid AS drop_stats_test_oid \gset
                                                                  ^


-----------
QUERY:

INSERT INTO drop_stats_test_xact DEFAULT VALUES;
RESULT:
	postgres: ERROR - relation "drop_stats_test_xact" does not exist
LINE 2: INSERT INTO drop_stats_test_xact DEFAULT VALUES;
                    ^


-----------
QUERY:

SELECT 'drop_stats_test_xact'::regclass::oid AS drop_stats_test_xact_oid \gset

CREATE TABLE drop_stats_test_subxact();
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: ..._test_xact'::regclass::oid AS drop_stats_test_xact_oid \gset
                                                                  ^


-----------
QUERY:

INSERT INTO drop_stats_test_subxact DEFAULT VALUES;
RESULT:
	postgres: ERROR - relation "drop_stats_test_subxact" does not exist
LINE 2: INSERT INTO drop_stats_test_subxact DEFAULT VALUES;
                    ^


-----------
QUERY:

SELECT 'drop_stats_test_subxact'::regclass::oid AS drop_stats_test_subxact_oid \gset

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: ...subxact'::regclass::oid AS drop_stats_test_subxact_oid \gset
                                                                  ^


-----------
QUERY:


SELECT pg_stat_get_live_tuples(:drop_stats_test_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 3: SELECT pg_stat_get_live_tuples(:drop_stats_test_oid);
                                       ^


-----------
QUERY:

DROP TABLE drop_stats_test;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_get_live_tuples(:drop_stats_test_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_live_tuples(:drop_stats_test_oid);
                                       ^


-----------
QUERY:

SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_oid...
                                                ^


-----------
QUERY:


-- check that rollback protects against having stats dropped and that local
-- modifications don/* REPLACED */''t pose a problem
SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 5: SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
                                       ^


-----------
QUERY:

SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid...
                                           ^


-----------
QUERY:

SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xac...
                                                ^


-----------
QUERY:

BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO drop_stats_test_xact DEFAULT VALUES;
RESULT:
	postgres: ERROR - relation "drop_stats_test_xact" does not exist
LINE 2: INSERT INTO drop_stats_test_xact DEFAULT VALUES;
                    ^


-----------
QUERY:

SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xac...
                                                ^


-----------
QUERY:

DROP TABLE drop_stats_test_xact;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xac...
                                                ^


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
                                       ^


-----------
QUERY:

SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid...
                                           ^


-----------
QUERY:


-- transactional drop
SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 4: SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
                                       ^


-----------
QUERY:

SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid...
                                           ^


-----------
QUERY:

BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO drop_stats_test_xact DEFAULT VALUES;
RESULT:
	postgres: ERROR - relation "drop_stats_test_xact" does not exist
LINE 2: INSERT INTO drop_stats_test_xact DEFAULT VALUES;
                    ^


-----------
QUERY:

SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xac...
                                                ^


-----------
QUERY:

DROP TABLE drop_stats_test_xact;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_xac...
                                                ^


-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_live_tuples(:drop_stats_test_xact_oid);
                                       ^


-----------
QUERY:

SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_tuples_inserted(:drop_stats_test_xact_oid...
                                           ^


-----------
QUERY:


-- savepoint rollback (2 levels)
SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 4: SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid)...
                                       ^


-----------
QUERY:

BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO drop_stats_test_subxact DEFAULT VALUES;
RESULT:
	postgres: ERROR - relation "drop_stats_test_subxact" does not exist
LINE 2: INSERT INTO drop_stats_test_subxact DEFAULT VALUES;
                    ^


-----------
QUERY:

SAVEPOINT sp1;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

INSERT INTO drop_stats_test_subxact DEFAULT VALUES;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_subxact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_sub...
                                                ^


-----------
QUERY:

SAVEPOINT sp2;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

DROP TABLE drop_stats_test_subxact;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK TO SAVEPOINT sp2;
RESULT:
	postgres: ERROR - savepoint "sp2" does not exist


-----------
QUERY:

SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_subxact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_xact_tuples_inserted(:drop_stats_test_sub...
                                                ^


-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid)...
                                       ^


-----------
QUERY:


-- savepoint rolback (1 level)
SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 4: SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid)...
                                       ^


-----------
QUERY:

BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SAVEPOINT sp1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE drop_stats_test_subxact;
RESULT:
	postgres: ERROR - table "drop_stats_test_subxact" does not exist


-----------
QUERY:

SAVEPOINT sp2;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK TO SAVEPOINT sp1;
RESULT:
	postgres: None

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid)...
                                       ^


-----------
QUERY:


-- and now actually drop
SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 4: SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid)...
                                       ^


-----------
QUERY:

BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SAVEPOINT sp1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE drop_stats_test_subxact;
RESULT:
	postgres: ERROR - table "drop_stats_test_subxact" does not exist


-----------
QUERY:

SAVEPOINT sp2;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

RELEASE SAVEPOINT sp1;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_get_live_tuples(:drop_stats_test_subxact_oid)...
                                       ^


-----------
QUERY:


DROP TABLE trunc_stats_test, trunc_stats_test1, trunc_stats_test2, trunc_stats_test3, trunc_stats_test4;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE prevstats;
RESULT:
	postgres: None

-----------
QUERY:



-----
-- Test that last_seq_scan, last_idx_scan are correctly maintained
--
-- Perform test using a temporary table. That way autovacuum etc won/* REPLACED */''t
-- interfere. To be able to check that timestamps increase, we sleep for 100ms
-- between tests, assuming that there aren/* REPLACED */''t systems with a coarser timestamp
-- granularity.
-----

BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEMPORARY TABLE test_last_scan(idx_col int primary key, noidx_col int);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO test_last_scan(idx_col, noidx_col) VALUES(1, 1);
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT last_seq_scan, last_idx_scan FROM pg_stat_all_tables WHERE relid = 'test_last_scan'::regclass;
RESULT:
	postgres: [(None, None)]

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


SELECT pg_stat_reset_single_table_counters('test_last_scan'::regclass);
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT seq_scan, idx_scan FROM pg_stat_all_tables WHERE relid = 'test_last_scan'::regclass;
RESULT:
	postgres: [(0, 0)]

-----------
QUERY:


-- ensure we start out with exactly one index and sequential scan
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_seqscan TO on;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_indexscan TO on;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_bitmapscan TO off;
RESULT:
	postgres: None

-----------
QUERY:

EXPLAIN (COSTS off) SELECT count(*) FROM test_last_scan WHERE noidx_col = 1;
RESULT:
	postgres: [('Aggregate',), ('  ->  Seq Scan on test_last_scan',), ('        Filter: (noidx_col = 1)',)]

-----------
QUERY:

SELECT count(*) FROM test_last_scan WHERE noidx_col = 1;
RESULT:
	postgres: [(1,)]

-----------
QUERY:

SET LOCAL enable_seqscan TO off;
RESULT:
	postgres: None

-----------
QUERY:

EXPLAIN (COSTS off) SELECT count(*) FROM test_last_scan WHERE idx_col = 1;
RESULT:
	postgres: [('Aggregate',), ('  ->  Index Scan using test_last_scan_pkey on test_last_scan',), ('        Index Cond: (idx_col = 1)',)]

-----------
QUERY:

SELECT count(*) FROM test_last_scan WHERE idx_col = 1;
RESULT:
	postgres: [(1,)]

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


-- fetch timestamps from before the next test
SELECT last_seq_scan AS test_last_seq, last_idx_scan AS test_last_idx
FROM pg_stat_all_tables WHERE relid = 'test_last_scan'::regclass \gset
SELECT pg_sleep(0.1);
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 5: ...at_all_tables WHERE relid = 'test_last_scan'::regclass \gset
                                                                  ^


-----------
QUERY:
 -- assume a minimum timestamp granularity of 100ms

-- cause one sequential scan
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_seqscan TO on;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_indexscan TO off;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_bitmapscan TO off;
RESULT:
	postgres: None

-----------
QUERY:

EXPLAIN (COSTS off) SELECT count(*) FROM test_last_scan WHERE noidx_col = 1;
RESULT:
	postgres: [('Aggregate',), ('  ->  Seq Scan on test_last_scan',), ('        Filter: (noidx_col = 1)',)]

-----------
QUERY:

SELECT count(*) FROM test_last_scan WHERE noidx_col = 1;
RESULT:
	postgres: [(1,)]

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

-- check that just sequential scan stats were incremented
SELECT seq_scan, :'test_last_seq' < last_seq_scan AS seq_ok, idx_scan, :'test_last_idx' = last_idx_scan AS idx_ok
FROM pg_stat_all_tables WHERE relid = 'test_last_scan'::regclass;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 3: SELECT seq_scan, :'test_last_seq' < last_seq_scan AS seq_ok,...
                         ^


-----------
QUERY:


-- fetch timestamps from before the next test
SELECT last_seq_scan AS test_last_seq, last_idx_scan AS test_last_idx
FROM pg_stat_all_tables WHERE relid = 'test_last_scan'::regclass \gset
SELECT pg_sleep(0.1);
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 5: ...at_all_tables WHERE relid = 'test_last_scan'::regclass \gset
                                                                  ^


-----------
QUERY:


-- cause one index scan
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_seqscan TO off;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_indexscan TO on;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_bitmapscan TO off;
RESULT:
	postgres: None

-----------
QUERY:

EXPLAIN (COSTS off) SELECT count(*) FROM test_last_scan WHERE idx_col = 1;
RESULT:
	postgres: [('Aggregate',), ('  ->  Index Scan using test_last_scan_pkey on test_last_scan',), ('        Index Cond: (idx_col = 1)',)]

-----------
QUERY:

SELECT count(*) FROM test_last_scan WHERE idx_col = 1;
RESULT:
	postgres: [(1,)]

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

-- check that just index scan stats were incremented
SELECT seq_scan, :'test_last_seq' = last_seq_scan AS seq_ok, idx_scan, :'test_last_idx' < last_idx_scan AS idx_ok
FROM pg_stat_all_tables WHERE relid = 'test_last_scan'::regclass;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 3: SELECT seq_scan, :'test_last_seq' = last_seq_scan AS seq_ok,...
                         ^


-----------
QUERY:


-- fetch timestamps from before the next test
SELECT last_seq_scan AS test_last_seq, last_idx_scan AS test_last_idx
FROM pg_stat_all_tables WHERE relid = 'test_last_scan'::regclass \gset
SELECT pg_sleep(0.1);
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 5: ...at_all_tables WHERE relid = 'test_last_scan'::regclass \gset
                                                                  ^


-----------
QUERY:


-- cause one bitmap index scan
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_seqscan TO off;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_indexscan TO off;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_bitmapscan TO on;
RESULT:
	postgres: None

-----------
QUERY:

EXPLAIN (COSTS off) SELECT count(*) FROM test_last_scan WHERE idx_col = 1;
RESULT:
	postgres: [('Aggregate',), ('  ->  Bitmap Heap Scan on test_last_scan',), ('        Recheck Cond: (idx_col = 1)',), ('        ->  Bitmap Index Scan on test_last_scan_pkey',), ('              Index Cond: (idx_col = 1)',)]

-----------
QUERY:

SELECT count(*) FROM test_last_scan WHERE idx_col = 1;
RESULT:
	postgres: [(1,)]

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

-- check that just index scan stats were incremented
SELECT seq_scan, :'test_last_seq' = last_seq_scan AS seq_ok, idx_scan, :'test_last_idx' < last_idx_scan AS idx_ok
FROM pg_stat_all_tables WHERE relid = 'test_last_scan'::regclass;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 3: SELECT seq_scan, :'test_last_seq' = last_seq_scan AS seq_ok,...
                         ^


-----------
QUERY:


-----
-- Test reset of some stats for shared table
-----

-- This updates the comment of the database currently in use in
-- pg_shdescription with a fake value, then sets it back to its
-- original value.
SELECT shobj_description(d.oid, 'pg_database') as description_before
  FROM pg_database d WHERE datname = current_database() \gset

-- force some stats in pg_shdescription.
BEGIN;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 11: ... FROM pg_database d WHERE datname = current_database() \gset
                                                                   ^


-----------
QUERY:

SELECT current_database() as datname \gset
COMMENT ON DATABASE :"datname" IS 'This is a test comment';
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: SELECT current_database() as datname \gset
                                             ^


-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


-- check that the stats are reset.
SELECT (n_tup_ins + n_tup_upd) > 0 AS has_data FROM pg_stat_all_tables
  WHERE relid = 'pg_shdescription'::regclass;
RESULT:
	postgres: [(True,)]

-----------
QUERY:

SELECT pg_stat_reset_single_table_counters('pg_shdescription'::regclass);
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT (n_tup_ins + n_tup_upd) > 0 AS has_data FROM pg_stat_all_tables
  WHERE relid = 'pg_shdescription'::regclass;
RESULT:
	postgres: [(False,)]

-----------
QUERY:


-- set back comment
\if :{?description_before}
  COMMENT ON DATABASE :"datname" IS :'description_before';
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: \if :{?description_before}
        ^


-----------
QUERY:

\else
  COMMENT ON DATABASE :"datname" IS NULL;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: \else
        ^


-----------
QUERY:

\endif

-----
-- Test that various stats views are being properly populated
-----

-- Test that sessions is incremented when a new session is started in pg_stat_database
SELECT sessions AS db_stat_sessions FROM pg_stat_database WHERE datname = (SELECT current_database()) \gset
\c
SELECT pg_stat_force_next_flush();
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: \endif
        ^


-----------
QUERY:

SELECT sessions > :db_stat_sessions FROM pg_stat_database WHERE datname = (SELECT current_database());
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT sessions > :db_stat_sessions FROM pg_stat_database WH...
                          ^


-----------
QUERY:


-- Test pg_stat_checkpointer checkpointer-related stats, together with pg_stat_wal
SELECT num_requested AS rqst_ckpts_before FROM pg_stat_checkpointer \gset

-- Test pg_stat_wal (and make a temp table so our temp schema exists)
SELECT wal_bytes AS wal_bytes_before FROM pg_stat_wal \gset

CREATE TEMP TABLE test_stats_temp AS SELECT 17;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: ...quested AS rqst_ckpts_before FROM pg_stat_checkpointer \gset
                                                                  ^


-----------
QUERY:

DROP TABLE test_stats_temp;
RESULT:
	postgres: ERROR - table "test_stats_temp" does not exist


-----------
QUERY:


-- Checkpoint twice: The checkpointer reports stats after reporting completion
-- of the checkpoint. But after a second checkpoint we/* REPLACED */''ll see at least the
-- results of the first.
CHECKPOINT;
RESULT:
	postgres: None

-----------
QUERY:

CHECKPOINT;
RESULT:
	postgres: None

-----------
QUERY:


SELECT num_requested > :rqst_ckpts_before FROM pg_stat_checkpointer;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 3: SELECT num_requested > :rqst_ckpts_before FROM pg_stat_check...
                               ^


-----------
QUERY:

SELECT wal_bytes > :wal_bytes_before FROM pg_stat_wal;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT wal_bytes > :wal_bytes_before FROM pg_stat_wal;
                           ^


-----------
QUERY:


-- Test pg_stat_get_backend_idset() and some allied functions.
-- In particular, verify that their notion of backend ID matches
-- our temp schema index.
SELECT (current_schemas(true))[1] = ('pg_temp_' || beid::text) AS match
FROM pg_stat_get_backend_idset() beid
WHERE pg_stat_get_backend_pid(beid) = pg_backend_pid();
RESULT:
	postgres: [(True,)]

-----------
QUERY:


-----
-- Test that resetting stats works for reset timestamp
-----

-- Test that reset_slru with a specified SLRU works.
SELECT stats_reset AS slru_commit_ts_reset_ts FROM pg_stat_slru WHERE name = 'commit_timestamp' \gset
SELECT stats_reset AS slru_notify_reset_ts FROM pg_stat_slru WHERE name = 'notify' \gset
SELECT pg_stat_reset_slru('commit_timestamp');
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 8: ...t_ts FROM pg_stat_slru WHERE name = 'commit_timestamp' \gset
                                                                  ^


-----------
QUERY:

SELECT stats_reset > :'slru_commit_ts_reset_ts'::timestamptz FROM pg_stat_slru WHERE name = 'commit_timestamp';
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT stats_reset > :'slru_commit_ts_reset_ts'::timestamptz...
                             ^


-----------
QUERY:

SELECT stats_reset AS slru_commit_ts_reset_ts FROM pg_stat_slru WHERE name = 'commit_timestamp' \gset

-- Test that multiple SLRUs are reset when no specific SLRU provided to reset function
SELECT pg_stat_reset_slru();
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: ...t_ts FROM pg_stat_slru WHERE name = 'commit_timestamp' \gset
                                                                  ^


-----------
QUERY:

SELECT stats_reset > :'slru_commit_ts_reset_ts'::timestamptz FROM pg_stat_slru WHERE name = 'commit_timestamp';
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT stats_reset > :'slru_commit_ts_reset_ts'::timestamptz...
                             ^


-----------
QUERY:

SELECT stats_reset > :'slru_notify_reset_ts'::timestamptz FROM pg_stat_slru WHERE name = 'notify';
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT stats_reset > :'slru_notify_reset_ts'::timestamptz FR...
                             ^


-----------
QUERY:


-- Test that reset_shared with archiver specified as the stats type works
SELECT stats_reset AS archiver_reset_ts FROM pg_stat_archiver \gset
SELECT pg_stat_reset_shared('archiver');
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: ...stats_reset AS archiver_reset_ts FROM pg_stat_archiver \gset
                                                                  ^


-----------
QUERY:

SELECT stats_reset > :'archiver_reset_ts'::timestamptz FROM pg_stat_archiver;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT stats_reset > :'archiver_reset_ts'::timestamptz FROM ...
                             ^


-----------
QUERY:


-- Test that reset_shared with bgwriter specified as the stats type works
SELECT stats_reset AS bgwriter_reset_ts FROM pg_stat_bgwriter \gset
SELECT pg_stat_reset_shared('bgwriter');
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: ...stats_reset AS bgwriter_reset_ts FROM pg_stat_bgwriter \gset
                                                                  ^


-----------
QUERY:

SELECT stats_reset > :'bgwriter_reset_ts'::timestamptz FROM pg_stat_bgwriter;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT stats_reset > :'bgwriter_reset_ts'::timestamptz FROM ...
                             ^


-----------
QUERY:


-- Test that reset_shared with checkpointer specified as the stats type works
SELECT stats_reset AS checkpointer_reset_ts FROM pg_stat_checkpointer \gset
SELECT pg_stat_reset_shared('checkpointer');
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: ...set AS checkpointer_reset_ts FROM pg_stat_checkpointer \gset
                                                                  ^


-----------
QUERY:

SELECT stats_reset > :'checkpointer_reset_ts'::timestamptz FROM pg_stat_checkpointer;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT stats_reset > :'checkpointer_reset_ts'::timestamptz F...
                             ^


-----------
QUERY:


-- Test that reset_shared with recovery_prefetch specified as the stats type works
SELECT stats_reset AS recovery_prefetch_reset_ts FROM pg_stat_recovery_prefetch \gset
SELECT pg_stat_reset_shared('recovery_prefetch');
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: ...overy_prefetch_reset_ts FROM pg_stat_recovery_prefetch \gset
                                                                  ^


-----------
QUERY:

SELECT stats_reset > :'recovery_prefetch_reset_ts'::timestamptz FROM pg_stat_recovery_prefetch;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT stats_reset > :'recovery_prefetch_reset_ts'::timestam...
                             ^


-----------
QUERY:


-- Test that reset_shared with slru specified as the stats type works
SELECT max(stats_reset) AS slru_reset_ts FROM pg_stat_slru \gset
SELECT pg_stat_reset_shared('slru');
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: ...CT max(stats_reset) AS slru_reset_ts FROM pg_stat_slru \gset
                                                                  ^


-----------
QUERY:

SELECT max(stats_reset) > :'slru_reset_ts'::timestamptz FROM pg_stat_slru;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT max(stats_reset) > :'slru_reset_ts'::timestamptz FROM...
                                  ^


-----------
QUERY:


-- Test that reset_shared with wal specified as the stats type works
SELECT stats_reset AS wal_reset_ts FROM pg_stat_wal \gset
SELECT pg_stat_reset_shared('wal');
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: SELECT stats_reset AS wal_reset_ts FROM pg_stat_wal \gset
                                                            ^


-----------
QUERY:

SELECT stats_reset > :'wal_reset_ts'::timestamptz FROM pg_stat_wal;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT stats_reset > :'wal_reset_ts'::timestamptz FROM pg_st...
                             ^


-----------
QUERY:


-- Test error case for reset_shared with unknown stats type
SELECT pg_stat_reset_shared('unknown');
RESULT:
	postgres: ERROR - unrecognized reset target: "unknown"
HINT:  Target must be "archiver", "bgwriter", "checkpointer", "io", "recovery_prefetch", "slru", or "wal".


-----------
QUERY:


-- Test that reset works for pg_stat_database

-- Since pg_stat_database stats_reset starts out as NULL, reset it once first so we have something to compare it to
SELECT pg_stat_reset();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT stats_reset AS db_reset_ts FROM pg_stat_database WHERE datname = (SELECT current_database()) \gset
SELECT pg_stat_reset();
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: ...t_database WHERE datname = (SELECT current_database()) \gset
                                                                  ^


-----------
QUERY:

SELECT stats_reset > :'db_reset_ts'::timestamptz FROM pg_stat_database WHERE datname = (SELECT current_database());
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT stats_reset > :'db_reset_ts'::timestamptz FROM pg_sta...
                             ^


-----------
QUERY:



----
-- pg_stat_get_snapshot_timestamp behavior
----
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL stats_fetch_consistency = snapshot;
RESULT:
	postgres: None

-----------
QUERY:

-- no snapshot yet, return NULL
SELECT pg_stat_get_snapshot_timestamp();
RESULT:
	postgres: [(None,)]

-----------
QUERY:

-- any attempt at accessing stats will build snapshot
SELECT pg_stat_get_function_calls(0);
RESULT:
	postgres: [(None,)]

-----------
QUERY:

SELECT pg_stat_get_snapshot_timestamp() >= NOW();
RESULT:
	postgres: [(True,)]

-----------
QUERY:

-- shows NULL again after clearing
SELECT pg_stat_clear_snapshot();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT pg_stat_get_snapshot_timestamp();
RESULT:
	postgres: [(None,)]

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:


----
-- Changing stats_fetch_consistency in a transaction.
----
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

-- Stats filled under the cache mode
SET LOCAL stats_fetch_consistency = cache;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_get_function_calls(0);
RESULT:
	postgres: [(None,)]

-----------
QUERY:

SELECT pg_stat_get_snapshot_timestamp() IS NOT NULL AS snapshot_ok;
RESULT:
	postgres: [(False,)]

-----------
QUERY:

-- Success in accessing pre-existing snapshot data.
SET LOCAL stats_fetch_consistency = snapshot;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_get_snapshot_timestamp() IS NOT NULL AS snapshot_ok;
RESULT:
	postgres: [(False,)]

-----------
QUERY:

SELECT pg_stat_get_function_calls(0);
RESULT:
	postgres: [(None,)]

-----------
QUERY:

SELECT pg_stat_get_snapshot_timestamp() IS NOT NULL AS snapshot_ok;
RESULT:
	postgres: [(True,)]

-----------
QUERY:

-- Snapshot cleared.
SET LOCAL stats_fetch_consistency = none;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_get_snapshot_timestamp() IS NOT NULL AS snapshot_ok;
RESULT:
	postgres: [(False,)]

-----------
QUERY:

SELECT pg_stat_get_function_calls(0);
RESULT:
	postgres: [(None,)]

-----------
QUERY:

SELECT pg_stat_get_snapshot_timestamp() IS NOT NULL AS snapshot_ok;
RESULT:
	postgres: [(False,)]

-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:


----
-- pg_stat_have_stats behavior
----
-- fixed-numbered stats exist
SELECT pg_stat_have_stats('bgwriter', 0, 0);
RESULT:
	postgres: [(True,)]

-----------
QUERY:

-- unknown stats kinds error out
SELECT pg_stat_have_stats('zaphod', 0, 0);
RESULT:
	postgres: ERROR - invalid statistics kind: "zaphod"


-----------
QUERY:

-- db stats have objoid 0
SELECT pg_stat_have_stats('database', :dboid, 1);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 3: SELECT pg_stat_have_stats('database', :dboid, 1);
                                              ^


-----------
QUERY:

SELECT pg_stat_have_stats('database', :dboid, 0);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_have_stats('database', :dboid, 0);
                                              ^


-----------
QUERY:


-- pg_stat_have_stats returns true for committed index creation
CREATE table stats_test_tab1 as select generate_series(1,10) a;
RESULT:
	postgres: None

-----------
QUERY:

CREATE index stats_test_idx1 on stats_test_tab1(a);
RESULT:
	postgres: None

-----------
QUERY:

SELECT 'stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
SET enable_seqscan TO off;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: ...stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
                                                                  ^


-----------
QUERY:

select a from stats_test_tab1 where a = 3;
RESULT:
	postgres: [(3,)]

-----------
QUERY:

SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_have_stats('relation', :dboid, :stats_test_id...
                                              ^


-----------
QUERY:


-- pg_stat_have_stats returns false for dropped index with stats
SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 4: SELECT pg_stat_have_stats('relation', :dboid, :stats_test_id...
                                              ^


-----------
QUERY:

DROP index stats_test_idx1;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_have_stats('relation', :dboid, :stats_test_id...
                                              ^


-----------
QUERY:


-- pg_stat_have_stats returns false for rolled back index creation
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

CREATE index stats_test_idx1 on stats_test_tab1(a);
RESULT:
	postgres: None

-----------
QUERY:

SELECT 'stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
select a from stats_test_tab1 where a = 3;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: ...stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
                                                                  ^


-----------
QUERY:

SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_have_stats('relation', :dboid, :stats_test_id...
                                              ^


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_have_stats('relation', :dboid, :stats_test_id...
                                              ^


-----------
QUERY:


-- pg_stat_have_stats returns true for reindex CONCURRENTLY
CREATE index stats_test_idx1 on stats_test_tab1(a);
RESULT:
	postgres: None

-----------
QUERY:

SELECT 'stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
select a from stats_test_tab1 where a = 3;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 2: ...stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
                                                                  ^


-----------
QUERY:

SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_have_stats('relation', :dboid, :stats_test_id...
                                              ^


-----------
QUERY:

REINDEX index CONCURRENTLY stats_test_idx1;
RESULT:
	postgres: None

-----------
QUERY:

-- false for previous oid
SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 3: SELECT pg_stat_have_stats('relation', :dboid, :stats_test_id...
                                              ^


-----------
QUERY:

-- true for new oid
SELECT 'stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 3: ...stats_test_idx1'::regclass::oid AS stats_test_idx1_oid \gset
                                                                  ^


-----------
QUERY:


-- pg_stat_have_stats returns true for a rolled back drop index with stats
BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_have_stats('relation', :dboid, :stats_test_id...
                                              ^


-----------
QUERY:

DROP index stats_test_idx1;
RESULT:
	postgres: ERROR - current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_have_stats('relation', :dboid, :stats_test_idx1_oid);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT pg_stat_have_stats('relation', :dboid, :stats_test_id...
                                              ^


-----------
QUERY:


-- put enable_seqscan back to on
SET enable_seqscan TO on;
RESULT:
	postgres: None

-----------
QUERY:


-- ensure that stats accessors handle NULL input correctly
SELECT pg_stat_get_replication_slot(NULL);
RESULT:
	postgres: [(None,)]

-----------
QUERY:

SELECT pg_stat_get_subscription_stats(NULL);
RESULT:
	postgres: [(None,)]

-----------
QUERY:



-- Test that the following operations are tracked in pg_stat_io:
-- - reads of target blocks into shared buffers
-- - writes of shared buffers to permanent storage
-- - extends of relations using shared buffers
-- - fsyncs done to ensure the durability of data dirtying shared buffers
-- - shared buffer hits

-- There is no test for blocks evicted from shared buffers, because we cannot
-- be sure of the state of shared buffers at the point the test is run.

-- Create a regular table and insert some data to generate IOCONTEXT_NORMAL
-- extends.
SELECT sum(extends) AS io_sum_shared_before_extends
  FROM pg_stat_io WHERE context = 'normal' AND object = 'relation' \gset
SELECT sum(writes) AS writes, sum(fsyncs) AS fsyncs
  FROM pg_stat_io
  WHERE object = 'relation' \gset io_sum_shared_before_
CREATE TABLE test_io_shared(a int);
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 17: ...at_io WHERE context = 'normal' AND object = 'relation' \gset
                                                                   ^


-----------
QUERY:

INSERT INTO test_io_shared SELECT i FROM generate_series(1,100)i;
RESULT:
	postgres: ERROR - relation "test_io_shared" does not exist
LINE 2: INSERT INTO test_io_shared SELECT i FROM generate_series(1,1...
                    ^


-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT sum(extends) AS io_sum_shared_after_extends
  FROM pg_stat_io WHERE context = 'normal' AND object = 'relation' \gset
SELECT :io_sum_shared_after_extends > :io_sum_shared_before_extends;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 3: ...at_io WHERE context = 'normal' AND object = 'relation' \gset
                                                                  ^


-----------
QUERY:


-- After a checkpoint, there should be some additional IOCONTEXT_NORMAL writes
-- and fsyncs.
-- See comment above for rationale for two explicit CHECKPOINTs.
CHECKPOINT;
RESULT:
	postgres: None

-----------
QUERY:

CHECKPOINT;
RESULT:
	postgres: None

-----------
QUERY:

SELECT sum(writes) AS writes, sum(fsyncs) AS fsyncs
  FROM pg_stat_io
  WHERE object = 'relation' \gset io_sum_shared_after_
SELECT :io_sum_shared_after_writes > :io_sum_shared_before_writes;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4:   WHERE object = 'relation' \gset io_sum_shared_after_
                                    ^


-----------
QUERY:

SELECT current_setting('fsync') = 'off'
  OR :io_sum_shared_after_fsyncs > :io_sum_shared_before_fsyncs;
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 3:   OR :io_sum_shared_after_fsyncs > :io_sum_shared_before_fsy...
             ^


-----------
QUERY:


-- Change the tablespace so that the table is rewritten directly, then SELECT
-- from it to cause it to be read back into shared buffers.
SELECT sum(reads) AS io_sum_shared_before_reads
  FROM pg_stat_io WHERE context = 'normal' AND object = 'relation' \gset
-- Do this in a transaction to prevent spurious failures due to concurrent accesses to our newly
-- rewritten table, e.g. by autovacuum.
BEGIN;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 6: ...at_io WHERE context = 'normal' AND object = 'relation' \gset
                                                                  ^


-----------
QUERY:

ALTER TABLE test_io_shared SET TABLESPACE regress_tblspace;
RESULT:
	postgres: ERROR - relation "test_io_shared" does not exist


-----------
QUERY:

-- SELECT from the table so that the data is read into shared buffers and
-- context /* REPLACED */''normal/* REPLACED */'', object /* REPLACED */''relation/* REPLACED */'' reads are counted.
SELECT COUNT(*) FROM test_io_shared;
RESULT:
	postgres: ERROR - relation "test_io_shared" does not exist
LINE 4: SELECT COUNT(*) FROM test_io_shared;
                             ^


-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT sum(reads) AS io_sum_shared_after_reads
  FROM pg_stat_io WHERE context = 'normal' AND object = 'relation'  \gset
SELECT :io_sum_shared_after_reads > :io_sum_shared_before_reads;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 3: ...t_io WHERE context = 'normal' AND object = 'relation'  \gset
                                                                  ^


-----------
QUERY:


SELECT sum(hits) AS io_sum_shared_before_hits
  FROM pg_stat_io WHERE context = 'normal' AND object = 'relation' \gset
-- Select from the table again to count hits.
-- Ensure we generate hits by forcing a nested loop self-join with no
-- materialize node. The outer side/* REPLACED */''s buffer will stay pinned, preventing its
-- eviction, while we loop through the inner side and generate hits.
BEGIN;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: ...at_io WHERE context = 'normal' AND object = 'relation' \gset
                                                                  ^


-----------
QUERY:

SET LOCAL enable_nestloop TO on;
RESULT:
	postgres: None

-----------
QUERY:
 SET LOCAL enable_mergejoin TO off;
RESULT:
	postgres: None

-----------
QUERY:

SET LOCAL enable_hashjoin TO off;
RESULT:
	postgres: None

-----------
QUERY:
 SET LOCAL enable_material TO off;
RESULT:
	postgres: None

-----------
QUERY:

-- ensure plan stays as we expect it to
EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM test_io_shared t1 INNER JOIN test_io_shared t2 USING (a);
RESULT:
	postgres: ERROR - relation "test_io_shared" does not exist
LINE 3: EXPLAIN (COSTS OFF) SELECT COUNT(*) FROM test_io_shared t1 I...
                                                 ^


-----------
QUERY:

SELECT COUNT(*) FROM test_io_shared t1 INNER JOIN test_io_shared t2 USING (a);
RESULT:
	postgres: ERROR - relation "test_io_shared" does not exist
LINE 2: SELECT COUNT(*) FROM test_io_shared t1 INNER JOIN test_io_sh...
                             ^


-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT sum(hits) AS io_sum_shared_after_hits
  FROM pg_stat_io WHERE context = 'normal' AND object = 'relation' \gset
SELECT :io_sum_shared_after_hits > :io_sum_shared_before_hits;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 3: ...at_io WHERE context = 'normal' AND object = 'relation' \gset
                                                                  ^


-----------
QUERY:


DROP TABLE test_io_shared;
RESULT:
	postgres: ERROR - table "test_io_shared" does not exist


-----------
QUERY:


-- Test that the follow IOCONTEXT_LOCAL IOOps are tracked in pg_stat_io:
-- - eviction of local buffers in order to reuse them
-- - reads of temporary table blocks into local buffers
-- - writes of local buffers to permanent storage
-- - extends of temporary tables

-- Set temp_buffers to its minimum so that we can trigger writes with fewer
-- inserted tuples. Do so in a new session in case temporary tables have been
-- accessed by previous tests in this session.
\c
SET temp_buffers TO 100;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 12: \c
         ^


-----------
QUERY:

CREATE TEMPORARY TABLE test_io_local(a int, b TEXT);
RESULT:
	postgres: None

-----------
QUERY:

SELECT sum(extends) AS extends, sum(evictions) AS evictions, sum(writes) AS writes
  FROM pg_stat_io
  WHERE context = 'normal' AND object = 'temp relation' \gset io_sum_local_before_
-- Insert tuples into the temporary table, generating extends in the stats.
-- Insert enough values that we need to reuse and write out dirty local
-- buffers, generating evictions and writes.
INSERT INTO test_io_local SELECT generate_series(1, 5000) as id, repeat('a', 200);
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: ...E context = 'normal' AND object = 'temp relation' \gset io_s...
                                                             ^


-----------
QUERY:

-- Ensure the table is large enough to exceed our temp_buffers setting.
SELECT pg_relation_size('test_io_local') / current_setting('block_size')::int8 > 100;
RESULT:
	postgres: [(False,)]

-----------
QUERY:


SELECT sum(reads) AS io_sum_local_before_reads
  FROM pg_stat_io WHERE context = 'normal' AND object = 'temp relation' \gset
-- Read in evicted buffers, generating reads.
SELECT COUNT(*) FROM test_io_local;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 4: ... WHERE context = 'normal' AND object = 'temp relation' \gset
                                                                  ^


-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT sum(evictions) AS evictions,
       sum(reads) AS reads,
       sum(writes) AS writes,
       sum(extends) AS extends
  FROM pg_stat_io
  WHERE context = 'normal' AND object = 'temp relation'  \gset io_sum_local_after_
SELECT :io_sum_local_after_evictions > :io_sum_local_before_evictions,
       :io_sum_local_after_reads > :io_sum_local_before_reads,
       :io_sum_local_after_writes > :io_sum_local_before_writes,
       :io_sum_local_after_extends > :io_sum_local_before_extends;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 7: ... context = 'normal' AND object = 'temp relation'  \gset io_s...
                                                             ^


-----------
QUERY:


-- Change the tablespaces so that the temporary table is rewritten to other
-- local buffers, exercising a different codepath than standard local buffer
-- writes.
ALTER TABLE test_io_local SET TABLESPACE regress_tblspace;
RESULT:
	postgres: None

-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT sum(writes) AS io_sum_local_new_tblspc_writes
  FROM pg_stat_io WHERE context = 'normal' AND object = 'temp relation'  \gset
SELECT :io_sum_local_new_tblspc_writes > :io_sum_local_after_writes;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 3: ...WHERE context = 'normal' AND object = 'temp relation'  \gset
                                                                  ^


-----------
QUERY:

RESET temp_buffers;
RESULT:
	postgres: None

-----------
QUERY:


-- Test that reuse of strategy buffers and reads of blocks into these reused
-- buffers while VACUUMing are tracked in pg_stat_io. If there is sufficient
-- demand for shared buffers from concurrent queries, some buffers may be
-- pinned by other backends before they can be reused. In such cases, the
-- backend will evict a buffer from outside the ring and add it to the
-- ring. This is considered an eviction and not a reuse.

-- Set wal_skip_threshold smaller than the expected size of
-- test_io_vac_strategy so that, even if wal_level is minimal, VACUUM FULL will
-- fsync the newly rewritten test_io_vac_strategy instead of writing it to WAL.
-- Writing it to WAL will result in the newly written relation pages being in
-- shared buffers -- preventing us from testing BAS_VACUUM BufferAccessStrategy
-- reads.
SET wal_skip_threshold = '1 kB';
RESULT:
	postgres: None

-----------
QUERY:

SELECT sum(reuses) AS reuses, sum(reads) AS reads, sum(evictions) AS evictions
  FROM pg_stat_io WHERE context = 'vacuum' \gset io_sum_vac_strategy_before_
CREATE TABLE test_io_vac_strategy(a int, b int) WITH (autovacuum_enabled = 'false');
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 3:   FROM pg_stat_io WHERE context = 'vacuum' \gset io_sum_vac_...
                                                   ^


-----------
QUERY:

INSERT INTO test_io_vac_strategy SELECT i, i from generate_series(1, 4500)i;
RESULT:
	postgres: ERROR - relation "test_io_vac_strategy" does not exist
LINE 2: INSERT INTO test_io_vac_strategy SELECT i, i from generate_s...
                    ^


-----------
QUERY:

-- Ensure that the next VACUUM will need to perform IO by rewriting the table
-- first with VACUUM (FULL).
VACUUM (FULL) test_io_vac_strategy;
RESULT:
	postgres: ERROR - relation "test_io_vac_strategy" does not exist


-----------
QUERY:

-- Use the minimum BUFFER_USAGE_LIMIT to cause reuses or evictions with the
-- smallest table possible.
VACUUM (PARALLEL 0, BUFFER_USAGE_LIMIT 128) test_io_vac_strategy;
RESULT:
	postgres: ERROR - relation "test_io_vac_strategy" does not exist


-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT sum(reuses) AS reuses, sum(reads) AS reads, sum(evictions) AS evictions
  FROM pg_stat_io WHERE context = 'vacuum' \gset io_sum_vac_strategy_after_
SELECT :io_sum_vac_strategy_after_reads > :io_sum_vac_strategy_before_reads;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 3:   FROM pg_stat_io WHERE context = 'vacuum' \gset io_sum_vac_...
                                                   ^


-----------
QUERY:

SELECT (:io_sum_vac_strategy_after_reuses + :io_sum_vac_strategy_after_evictions) >
  (:io_sum_vac_strategy_before_reuses + :io_sum_vac_strategy_before_evictions);
RESULT:
	postgres: ERROR - syntax error at or near ":"
LINE 2: SELECT (:io_sum_vac_strategy_after_reuses + :io_sum_vac_stra...
                ^


-----------
QUERY:

RESET wal_skip_threshold;
RESULT:
	postgres: None

-----------
QUERY:


-- Test that extends done by a CTAS, which uses a BAS_BULKWRITE
-- BufferAccessStrategy, are tracked in pg_stat_io.
SELECT sum(extends) AS io_sum_bulkwrite_strategy_extends_before
  FROM pg_stat_io WHERE context = 'bulkwrite' \gset
CREATE TABLE test_io_bulkwrite_strategy AS SELECT i FROM generate_series(1,100)i;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 6:   FROM pg_stat_io WHERE context = 'bulkwrite' \gset
                                                      ^


-----------
QUERY:

SELECT pg_stat_force_next_flush();
RESULT:
	postgres: [('',)]

-----------
QUERY:

SELECT sum(extends) AS io_sum_bulkwrite_strategy_extends_after
  FROM pg_stat_io WHERE context = 'bulkwrite' \gset
SELECT :io_sum_bulkwrite_strategy_extends_after > :io_sum_bulkwrite_strategy_extends_before;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 3:   FROM pg_stat_io WHERE context = 'bulkwrite' \gset
                                                      ^


-----------
QUERY:


-- Test IO stats reset
SELECT pg_stat_have_stats('io', 0, 0);
RESULT:
	postgres: [(True,)]

-----------
QUERY:

SELECT sum(evictions) + sum(reuses) + sum(extends) + sum(fsyncs) + sum(reads) + sum(writes) + sum(writebacks) + sum(hits) AS io_stats_pre_reset
  FROM pg_stat_io \gset
SELECT pg_stat_reset_shared('io');
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 3:   FROM pg_stat_io \gset
                          ^


-----------
QUERY:

SELECT sum(evictions) + sum(reuses) + sum(extends) + sum(fsyncs) + sum(reads) + sum(writes) + sum(writebacks) + sum(hits) AS io_stats_post_reset
  FROM pg_stat_io \gset
SELECT :io_stats_post_reset < :io_stats_pre_reset;
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 3:   FROM pg_stat_io \gset
                          ^


-----------
QUERY:



-- test BRIN index doesn/* REPLACED */''t block HOT update
CREATE TABLE brin_hot (
  id  integer PRIMARY KEY,
  val integer NOT NULL
) WITH (autovacuum_enabled = off, fillfactor = 70);
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO brin_hot SELECT *, 0 FROM generate_series(1, 235);
RESULT:
	postgres: None

-----------
QUERY:

CREATE INDEX val_brin ON brin_hot using brin(val);
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION wait_for_hot_stats() RETURNS void AS $$
DECLARE
  start_time timestamptz := clock_timestamp();
  updated bool;
BEGIN
  -- we don/* REPLACED */''t want to wait forever /* REPLACED */, loop will exit after 30 seconds
  FOR i IN 1 .. 300 LOOP
    SELECT (pg_stat_get_tuples_hot_updated('brin_hot'::regclass::oid) > 0) INTO updated;
    EXIT WHEN updated;

    -- wait a little
    PERFORM pg_sleep_for('100 milliseconds');
    -- reset stats snapshot so we can test again
    PERFORM pg_stat_clear_snapshot();
  END LOOP;
  -- report time waited in postmaster log (where it won/* REPLACED */''t change test output)
  RAISE log 'wait_for_hot_stats delayed % seconds',
    EXTRACT(epoch FROM clock_timestamp() - start_time);
END
$$ LANGUAGE plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


UPDATE brin_hot SET val = -3 WHERE id = 42;
RESULT:
	postgres: None

-----------
QUERY:


-- We can/* REPLACED */''t just call wait_for_hot_stats() at this point, because we only
-- transmit stats when the session goes idle, and we probably didn/* REPLACED */''t
-- transmit the last couple of counts yet thanks to the rate-limiting logic
-- in pgstat_report_stat().  But instead of waiting for the rate limiter/* REPLACED */''s
-- timeout to elapse, let/* REPLACED */''s just start a new session.  The old one will
-- then send its stats before dying.
\c -

SELECT wait_for_hot_stats();
RESULT:
	postgres: ERROR - syntax error at or near "\"
LINE 9: \c -
        ^


-----------
QUERY:

SELECT pg_stat_get_tuples_hot_updated('brin_hot'::regclass::oid);
RESULT:
	postgres: [(0,)]

-----------
QUERY:


DROP TABLE brin_hot;
RESULT:
	postgres: None

-----------
QUERY:

DROP FUNCTION wait_for_hot_stats();
RESULT:
	postgres: None

-----------
QUERY:


-- Test handling of index predicates - updating attributes in precicates
-- should not block HOT when summarizing indexes are involved. We update
-- a row that was not indexed due to the index predicate, and becomes
-- indexable - the HOT-updated tuple is forwarded to the BRIN index.
CREATE TABLE brin_hot_2 (a int, b int);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO brin_hot_2 VALUES (1, 100);
RESULT:
	postgres: None

-----------
QUERY:

CREATE INDEX ON brin_hot_2 USING brin (b) WHERE a = 2;
RESULT:
	postgres: None

-----------
QUERY:


UPDATE brin_hot_2 SET a = 2;
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (COSTS OFF) SELECT * FROM brin_hot_2 WHERE a = 2 AND b = 100;
RESULT:
	postgres: [('Seq Scan on brin_hot_2',), ('  Filter: ((a = 2) AND (b = 100))',)]

-----------
QUERY:

SELECT COUNT(*) FROM brin_hot_2 WHERE a = 2 AND b = 100;
RESULT:
	postgres: [(1,)]

-----------
QUERY:


SET enable_seqscan = off;
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (COSTS OFF) SELECT * FROM brin_hot_2 WHERE a = 2 AND b = 100;
RESULT:
	postgres: [('Bitmap Heap Scan on brin_hot_2',), ('  Recheck Cond: ((b = 100) AND (a = 2))',), ('  ->  Bitmap Index Scan on brin_hot_2_b_idx',), ('        Index Cond: (b = 100)',)]

-----------
QUERY:

SELECT COUNT(*) FROM brin_hot_2 WHERE a = 2 AND b = 100;
RESULT:
	postgres: [(1,)]

-----------
QUERY:


DROP TABLE brin_hot_2;
RESULT:
	postgres: None

-----------
QUERY:


-- Test that updates to indexed columns are still propagated to the
-- BRIN column.
-- https://postgr.es/m/05ebcb44-f383-86e3-4f31-0a97a55634cf@enterprisedb.com
CREATE TABLE brin_hot_3 (a int, filler text) WITH (fillfactor = 10);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO brin_hot_3 SELECT 1, repeat(' ', 500) FROM generate_series(1, 20);
RESULT:
	postgres: None

-----------
QUERY:

CREATE INDEX ON brin_hot_3 USING brin (a) WITH (pages_per_range = 1);
RESULT:
	postgres: None

-----------
QUERY:

UPDATE brin_hot_3 SET a = 2;
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (COSTS OFF) SELECT * FROM brin_hot_3 WHERE a = 2;
RESULT:
	postgres: [('Bitmap Heap Scan on brin_hot_3',), ('  Recheck Cond: (a = 2)',), ('  ->  Bitmap Index Scan on brin_hot_3_a_idx',), ('        Index Cond: (a = 2)',)]

-----------
QUERY:

SELECT COUNT(*) FROM brin_hot_3 WHERE a = 2;
RESULT:
	postgres: [(20,)]

-----------
QUERY:


DROP TABLE brin_hot_3;
RESULT:
	postgres: None

-----------
QUERY:


SET enable_seqscan = on;
RESULT:
	postgres: None

-----------
QUERY:


-- End of Stats Test

RESULT:
	postgres: ERROR - can't execute an empty query
