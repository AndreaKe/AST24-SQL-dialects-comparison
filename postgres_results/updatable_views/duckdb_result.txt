
-----------
QUERY:
--
-- UPDATABLE VIEWS
--

-- avoid bit-exact output here because operations may not be bit-exact.
SET extra_float_digits = 0;
RESULT:
	duckdb: ERROR - Catalog Error: unrecognized configuration parameter "extra_float_digits"

Did you mean: "threads"

-----------
QUERY:


-- check that non-updatable views and columns are rejected with useful error
-- messages

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW ro_view1 AS SELECT DISTINCT a, b FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:
 -- DISTINCT not supported
CREATE VIEW ro_view2 AS SELECT a, b FROM base_tbl GROUP BY a, b;
RESULT:
	duckdb: []

-----------
QUERY:
 -- GROUP BY not supported
CREATE VIEW ro_view3 AS SELECT 1 FROM base_tbl HAVING max(a) > 0;
RESULT:
	duckdb: []

-----------
QUERY:
 -- HAVING not supported
CREATE VIEW ro_view4 AS SELECT count(*) FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:
 -- Aggregate functions not supported
CREATE VIEW ro_view5 AS SELECT a, rank() OVER() FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:
 -- Window functions not supported
CREATE VIEW ro_view6 AS SELECT a, b FROM base_tbl UNION SELECT -a, b FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:
 -- Set ops not supported
CREATE VIEW ro_view7 AS WITH t AS (SELECT a, b FROM base_tbl) SELECT * FROM t;
RESULT:
	duckdb: []

-----------
QUERY:
 -- WITH not supported
CREATE VIEW ro_view8 AS SELECT a, b FROM base_tbl ORDER BY a OFFSET 1;
RESULT:
	duckdb: []

-----------
QUERY:
 -- OFFSET not supported
CREATE VIEW ro_view9 AS SELECT a, b FROM base_tbl ORDER BY a LIMIT 1;
RESULT:
	duckdb: []

-----------
QUERY:
 -- LIMIT not supported
CREATE VIEW ro_view10 AS SELECT 1 AS a;
RESULT:
	duckdb: []

-----------
QUERY:
 -- No base relations
CREATE VIEW ro_view11 AS SELECT b1.a, b2.b FROM base_tbl b1, base_tbl b2;
RESULT:
	duckdb: []

-----------
QUERY:
 -- Multiple base relations
CREATE VIEW ro_view12 AS SELECT * FROM generate_series(1, 10) AS g(a);
RESULT:
	duckdb: []

-----------
QUERY:
 -- SRF in rangetable
CREATE VIEW ro_view13 AS SELECT a, b FROM (SELECT * FROM base_tbl) AS t;
RESULT:
	duckdb: []

-----------
QUERY:
 -- Subselect in rangetable
CREATE VIEW rw_view14 AS SELECT ctid, a, b FROM base_tbl;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "ctid" not found in FROM clause!
Candidate bindings: "base_tbl.a", "base_tbl.b"
LINE 2: CREATE VIEW rw_view14 AS SELECT ctid, a, b FROM base_tbl;
                                        ^

-----------
QUERY:
 -- System columns may be part of an updatable view
CREATE VIEW rw_view15 AS SELECT a, upper(b) FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:
 -- Expression/function may be part of an updatable view
CREATE VIEW rw_view16 AS SELECT a, b, a AS aa FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:
 -- Repeated column may be part of an updatable view
CREATE VIEW ro_view17 AS SELECT * FROM ro_view1;
RESULT:
	duckdb: []

-----------
QUERY:
 -- Base relation not updatable
CREATE VIEW ro_view18 AS SELECT * FROM (VALUES(1)) AS tmp(a);
RESULT:
	duckdb: []

-----------
QUERY:
 -- VALUES in rangetable
CREATE SEQUENCE uv_seq;
RESULT:
	duckdb: []

-----------
QUERY:

CREATE VIEW ro_view19 AS SELECT * FROM uv_seq;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name uv_seq does not exist!
Did you mean "pg_am"?
LINE 2: CREATE VIEW ro_view19 AS SELECT * FROM uv_seq;
                                               ^

-----------
QUERY:
 -- View based on a sequence
CREATE VIEW ro_view20 AS SELECT a, b, generate_series(1, a) g FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:
 -- SRF in targetlist not supported

SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name;
RESULT:
	duckdb: []

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	duckdb: []

-----------
QUERY:


-- Read-only views
DELETE FROM ro_view1;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

DELETE FROM ro_view2;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

DELETE FROM ro_view3;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

DELETE FROM ro_view4;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

DELETE FROM ro_view5;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

DELETE FROM ro_view6;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

UPDATE ro_view7 SET a=a+1;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

UPDATE ro_view8 SET a=a+1;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

UPDATE ro_view9 SET a=a+1;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

UPDATE ro_view10 SET a=a+1;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

UPDATE ro_view11 SET a=a+1;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

UPDATE ro_view12 SET a=a+1;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

INSERT INTO ro_view13 VALUES (3, 'Row 3');
RESULT:
	duckdb: ERROR - Catalog Error: ro_view13 is not an table

-----------
QUERY:

MERGE INTO ro_view13 AS t USING (VALUES (1, 'Row 1')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:

MERGE INTO ro_view13 AS t USING (VALUES (2, 'Row 2')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = v.b;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:

MERGE INTO ro_view13 AS t USING (VALUES (3, 'Row 3')) AS v(a,b) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a, v.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:

MERGE INTO ro_view13 AS t USING (VALUES (3, 'Row 3')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN DO NOTHING
  WHEN NOT MATCHED THEN DO NOTHING;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should be OK to do nothing
-- Partially updatable view
INSERT INTO rw_view14 VALUES (null, 3, 'Row 3');
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view14 does not exist!
Did you mean "rw_view15"?

-----------
QUERY:
 -- should fail
INSERT INTO rw_view14 (a, b) VALUES (3, 'Row 3');
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view14 does not exist!
Did you mean "rw_view15"?

-----------
QUERY:
 -- should be OK
UPDATE rw_view14 SET ctid=null WHERE a=3;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view14 does not exist!
Did you mean "rw_view15"?
LINE 2: UPDATE rw_view14 SET ctid=null WHERE a=3;
               ^

-----------
QUERY:
 -- should fail
UPDATE rw_view14 SET b='ROW 3' WHERE a=3;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view14 does not exist!
Did you mean "rw_view15"?
LINE 2: UPDATE rw_view14 SET b='ROW 3' WHERE a=3;
               ^

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl;
RESULT:
	duckdb: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:

DELETE FROM rw_view14 WHERE a=3;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view14 does not exist!
Did you mean "rw_view15"?
LINE 2: DELETE FROM rw_view14 WHERE a=3;
                    ^

-----------
QUERY:
 -- should be OK
MERGE INTO rw_view14  AS t
  USING (VALUES (2, 'Merged row 2'), (3, 'Merged row 3')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = v.b  -- should be OK, except...
  WHEN NOT MATCHED THEN INSERT VALUES (null, v.a, v.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should fail
MERGE INTO rw_view14  AS t
  USING (VALUES (2, 'Merged row 2'), (3, 'Merged row 3')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = v.b  -- should be OK
  WHEN NOT MATCHED THEN INSERT (a,b) VALUES (v.a, v.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl ORDER BY a;
RESULT:
	duckdb: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:

MERGE INTO rw_view14  AS t
  USING (VALUES (2, 'Row 2'), (3, 'Row 3')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED AND t.a = 2 THEN UPDATE SET b = v.b  -- should be OK
  WHEN MATCHED AND t.a = 3 THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl ORDER BY a;
RESULT:
	duckdb: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:

-- Partially updatable view
INSERT INTO rw_view15 VALUES (3, 'ROW 3');
RESULT:
	duckdb: ERROR - Catalog Error: rw_view15 is not an table

-----------
QUERY:
 -- should fail
INSERT INTO rw_view15 (a) VALUES (3);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view15 is not an table

-----------
QUERY:
 -- should be OK
INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT DO NOTHING;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view15 is not an table

-----------
QUERY:
 -- succeeds
SELECT * FROM rw_view15;
RESULT:
	duckdb: [(-2, 'ROW -2'), (-1, 'ROW -1'), (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2')]

-----------
QUERY:

INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO NOTHING;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view15 is not an table

-----------
QUERY:
 -- succeeds
SELECT * FROM rw_view15;
RESULT:
	duckdb: [(-2, 'ROW -2'), (-1, 'ROW -1'), (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2')]

-----------
QUERY:

INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set a = excluded.a;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view15 is not an table

-----------
QUERY:
 -- succeeds
SELECT * FROM rw_view15;
RESULT:
	duckdb: [(-2, 'ROW -2'), (-1, 'ROW -1'), (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2')]

-----------
QUERY:

INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set upper = 'blarg';
RESULT:
	duckdb: ERROR - Catalog Error: rw_view15 is not an table

-----------
QUERY:
 -- fails
SELECT * FROM rw_view15;
RESULT:
	duckdb: [(-2, 'ROW -2'), (-1, 'ROW -1'), (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2')]

-----------
QUERY:

SELECT * FROM rw_view15;
RESULT:
	duckdb: [(-2, 'ROW -2'), (-1, 'ROW -1'), (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2')]

-----------
QUERY:

ALTER VIEW rw_view15 ALTER COLUMN upper SET DEFAULT 'NOT SET';
RESULT:
	duckdb: ERROR - Parser Error: Alter column's default is only supported for tables

-----------
QUERY:

INSERT INTO rw_view15 (a) VALUES (4);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view15 is not an table

-----------
QUERY:
 -- should fail
UPDATE rw_view15 SET upper='ROW 3' WHERE a=3;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:
 -- should fail
UPDATE rw_view15 SET upper=DEFAULT WHERE a=3;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:
 -- should fail
UPDATE rw_view15 SET a=4 WHERE a=3;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl;
RESULT:
	duckdb: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:

DELETE FROM rw_view15 WHERE a=4;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:
 -- should be OK
-- Partially updatable view
INSERT INTO rw_view16 VALUES (3, 'Row 3', 3);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view16 is not an table

-----------
QUERY:
 -- should fail
INSERT INTO rw_view16 (a, b) VALUES (3, 'Row 3');
RESULT:
	duckdb: ERROR - Catalog Error: rw_view16 is not an table

-----------
QUERY:
 -- should be OK
UPDATE rw_view16 SET a=3, aa=-3 WHERE a=3;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:
 -- should fail
UPDATE rw_view16 SET aa=-3 WHERE a=3;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl;
RESULT:
	duckdb: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:

DELETE FROM rw_view16 WHERE a=-3;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:
 -- should be OK
-- Read-only views
INSERT INTO ro_view17 VALUES (3, 'ROW 3');
RESULT:
	duckdb: ERROR - Catalog Error: ro_view17 is not an table

-----------
QUERY:

DELETE FROM ro_view18;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

UPDATE ro_view19 SET last_value=1000;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name ro_view19 does not exist!
Did you mean "ro_view1"?
LINE 2: UPDATE ro_view19 SET last_value=1000;
               ^

-----------
QUERY:

UPDATE ro_view20 SET b=upper(b);
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:


-- A view with a conditional INSTEAD rule but no unconditional INSTEAD rules
-- or INSTEAD OF triggers should be non-updatable and generate useful error
-- messages with appropriate detail
CREATE RULE rw_view16_ins_rule AS ON INSERT TO rw_view16
  WHERE NEW.a > 0 DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

CREATE RULE rw_view16_upd_rule AS ON UPDATE TO rw_view16
  WHERE OLD.a > 0 DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

CREATE RULE rw_view16_del_rule AS ON DELETE TO rw_view16
  WHERE OLD.a > 0 DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


INSERT INTO rw_view16 (a, b) VALUES (3, 'Row 3');
RESULT:
	duckdb: ERROR - Catalog Error: rw_view16 is not an table

-----------
QUERY:
 -- should fail
UPDATE rw_view16 SET b='ROW 2' WHERE a=2;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:
 -- should fail
DELETE FROM rw_view16 WHERE a=2;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:
 -- should fail
MERGE INTO rw_view16 AS t USING (VALUES (3, 'Row 3')) AS v(a,b) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a, v.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should fail

DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:

DROP VIEW ro_view10, ro_view12, ro_view18;
RESULT:
	duckdb: ERROR - Not implemented Error: Can only drop one object at a time

-----------
QUERY:

DROP SEQUENCE uv_seq CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- simple updatable view

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0;
RESULT:
	duckdb: []

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name = 'rw_view1';
RESULT:
	duckdb: [('rw_view1', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name = 'rw_view1';
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name = 'rw_view1'
 ORDER BY ordinal_position;
RESULT:
	duckdb: [('rw_view1', 'a', None), ('rw_view1', 'b', None)]

-----------
QUERY:


INSERT INTO rw_view1 VALUES (3, 'Row 3');
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

INSERT INTO rw_view1 (a) VALUES (4);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

UPDATE rw_view1 SET a=5 WHERE a=4;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

DELETE FROM rw_view1 WHERE b='Row 2';
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

SELECT * FROM base_tbl;
RESULT:
	duckdb: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:


MERGE INTO rw_view1 t
  USING (VALUES (0, 'ROW 0'), (1, 'ROW 1'),
                (2, 'ROW 2'), (3, 'ROW 3')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED AND t.a <= 1 THEN UPDATE SET b = v.b
  WHEN MATCHED THEN DELETE
  WHEN NOT MATCHED AND a > 0 THEN INSERT (a) VALUES (v.a)
  RETURNING merge_action(), v.*, t.*;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:

SELECT * FROM base_tbl ORDER BY a;
RESULT:
	duckdb: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:


EXPLAIN (costs off) UPDATE rw_view1 SET a=6 WHERE a=5;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view1 WHERE a=5;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


EXPLAIN (costs off)
MERGE INTO rw_view1 t USING (VALUES (5, 'X')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


EXPLAIN (costs off)
MERGE INTO rw_view1 t
  USING (SELECT * FROM generate_series(1,5)) AS s(a) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = 'Updated';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


EXPLAIN (costs off)
MERGE INTO rw_view1 t
  USING (SELECT * FROM generate_series(1,5)) AS s(a) ON t.a = s.a
  WHEN NOT MATCHED THEN INSERT (a) VALUES (s.a);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


-- it/* REPLACED */''s still updatable if we add a DO ALSO rule

CREATE TABLE base_tbl_hist(ts timestamptz default now(), a int, b text);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE RULE base_tbl_log AS ON INSERT TO rw_view1 DO ALSO
  INSERT INTO base_tbl_hist(a,b) VALUES(new.a, new.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name = 'rw_view1';
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


-- Check behavior with DEFAULTs (bug #17633)

INSERT INTO rw_view1 VALUES (9, DEFAULT), (10, DEFAULT);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

SELECT a, b FROM base_tbl_hist;
RESULT:
	duckdb: []

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE base_tbl_hist;
RESULT:
	duckdb: []

-----------
QUERY:


-- view on top of view

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl WHERE a>0;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT aa AS aaa, bb AS bbb FROM rw_view1 WHERE aa<10;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "aa" not found in FROM clause!
Candidate bindings: "rw_view1.a", "rw_view1.b"
LINE 2: ...a AS aaa, bb AS bbb FROM rw_view1 WHERE aa<10;
                                                  ^

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name = 'rw_view2';
RESULT:
	duckdb: []

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name = 'rw_view2';
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name = 'rw_view2'
 ORDER BY ordinal_position;
RESULT:
	duckdb: []

-----------
QUERY:


INSERT INTO rw_view2 VALUES (3, 'Row 3');
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view2 does not exist!
Did you mean "ro_view2"?

-----------
QUERY:

INSERT INTO rw_view2 (aaa) VALUES (4);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view2 does not exist!
Did you mean "ro_view2"?

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view2 does not exist!
Did you mean "ro_view2"?

-----------
QUERY:

UPDATE rw_view2 SET bbb='Row 4' WHERE aaa=4;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view2 does not exist!
Did you mean "ro_view2"?
LINE 2: UPDATE rw_view2 SET bbb='Row 4' WHERE aaa=4;
               ^

-----------
QUERY:

DELETE FROM rw_view2 WHERE aaa=2;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view2 does not exist!
Did you mean "ro_view2"?
LINE 2: DELETE FROM rw_view2 WHERE aaa=2;
                    ^

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view2 does not exist!
Did you mean "ro_view2"?

-----------
QUERY:


MERGE INTO rw_view2 t
  USING (VALUES (3, 'R3'), (4, 'R4'), (5, 'R5')) AS v(a,b) ON aaa = v.a
  WHEN MATCHED AND aaa = 3 THEN DELETE
  WHEN MATCHED THEN UPDATE SET bbb = v.b
  WHEN NOT MATCHED THEN INSERT (aaa) VALUES (v.a)
  RETURNING merge_action(), v.*, t.*;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:

SELECT * FROM rw_view2 ORDER BY aaa;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view2 does not exist!
Did you mean "ro_view2"?

-----------
QUERY:


EXPLAIN (costs off) UPDATE rw_view2 SET aaa=5 WHERE aaa=4;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view2 WHERE aaa=4;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- view on top of view with rules

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:
 -- not updatable without rules/triggers
CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
RESULT:
	duckdb: []

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: [('rw_view1', 'NO'), ('rw_view15', 'NO'), ('rw_view16', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	duckdb: [('rw_view1', 'a', None), ('rw_view1', 'b', None), ('rw_view15', 'a', None), ('rw_view15', 'upper(b)', None), ('rw_view16', 'a', None), ('rw_view16', 'b', None), ('rw_view16', 'aa', None), ('rw_view2', 'a', None), ('rw_view2', 'b', None)]

-----------
QUERY:


CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b) RETURNING *;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: [('rw_view1', 'NO'), ('rw_view15', 'NO'), ('rw_view16', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	duckdb: [('rw_view1', 'a', None), ('rw_view1', 'b', None), ('rw_view15', 'a', None), ('rw_view15', 'upper(b)', None), ('rw_view16', 'a', None), ('rw_view16', 'b', None), ('rw_view16', 'aa', None), ('rw_view2', 'a', None), ('rw_view2', 'b', None)]

-----------
QUERY:


CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
  DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a RETURNING NEW.*;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: [('rw_view1', 'NO'), ('rw_view15', 'NO'), ('rw_view16', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	duckdb: [('rw_view1', 'a', None), ('rw_view1', 'b', None), ('rw_view15', 'a', None), ('rw_view15', 'upper(b)', None), ('rw_view16', 'a', None), ('rw_view16', 'b', None), ('rw_view16', 'aa', None), ('rw_view2', 'a', None), ('rw_view2', 'b', None)]

-----------
QUERY:


CREATE RULE rw_view1_del_rule AS ON DELETE TO rw_view1
  DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a RETURNING OLD.*;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: [('rw_view1', 'NO'), ('rw_view15', 'NO'), ('rw_view16', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	duckdb: [('rw_view1', 'a', None), ('rw_view1', 'b', None), ('rw_view15', 'a', None), ('rw_view15', 'upper(b)', None), ('rw_view16', 'a', None), ('rw_view16', 'b', None), ('rw_view16', 'aa', None), ('rw_view2', 'a', None), ('rw_view2', 'b', None)]

-----------
QUERY:


INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:

UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: [(1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:

DELETE FROM rw_view2 WHERE a=3 RETURNING *;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: [(1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:


MERGE INTO rw_view2 t USING (VALUES (3, 'Row 3')) AS v(a,b) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a, v.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should fail

EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- view on top of view with triggers

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:
 -- not updatable without rules/triggers
CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view2" already exists!

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: [('rw_view1', 'NO'), ('rw_view15', 'NO'), ('rw_view16', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into,
       is_trigger_updatable, is_trigger_deletable,
       is_trigger_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	duckdb: [('rw_view1', 'a', None), ('rw_view1', 'b', None), ('rw_view15', 'a', None), ('rw_view15', 'upper(b)', None), ('rw_view16', 'a', None), ('rw_view16', 'b', None), ('rw_view16', 'aa', None), ('rw_view2', 'a', None), ('rw_view2', 'b', None)]

-----------
QUERY:


CREATE FUNCTION rw_view1_trig_fn()
RETURNS trigger AS
$$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO base_tbl VALUES (NEW.a, NEW.b);
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    DELETE FROM base_tbl WHERE a=OLD.a;
    RETURN OLD;
  END IF;
END;
$$
LANGUAGE plpgsql;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RETURNS"

-----------
QUERY:


CREATE TRIGGER rw_view1_ins_trig INSTEAD OF INSERT ON rw_view1
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "TRIGGER"

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: [('rw_view1', 'NO'), ('rw_view15', 'NO'), ('rw_view16', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into,
       is_trigger_updatable, is_trigger_deletable,
       is_trigger_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	duckdb: [('rw_view1', 'a', None), ('rw_view1', 'b', None), ('rw_view15', 'a', None), ('rw_view15', 'upper(b)', None), ('rw_view16', 'a', None), ('rw_view16', 'b', None), ('rw_view16', 'aa', None), ('rw_view2', 'a', None), ('rw_view2', 'b', None)]

-----------
QUERY:


CREATE TRIGGER rw_view1_upd_trig INSTEAD OF UPDATE ON rw_view1
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "TRIGGER"

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: [('rw_view1', 'NO'), ('rw_view15', 'NO'), ('rw_view16', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into,
       is_trigger_updatable, is_trigger_deletable,
       is_trigger_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	duckdb: [('rw_view1', 'a', None), ('rw_view1', 'b', None), ('rw_view15', 'a', None), ('rw_view15', 'upper(b)', None), ('rw_view16', 'a', None), ('rw_view16', 'b', None), ('rw_view16', 'aa', None), ('rw_view2', 'a', None), ('rw_view2', 'b', None)]

-----------
QUERY:


CREATE TRIGGER rw_view1_del_trig INSTEAD OF DELETE ON rw_view1
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "TRIGGER"

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: [('rw_view1', 'NO'), ('rw_view15', 'NO'), ('rw_view16', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into,
       is_trigger_updatable, is_trigger_deletable,
       is_trigger_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	duckdb: [('rw_view1', 'a', None), ('rw_view1', 'b', None), ('rw_view15', 'a', None), ('rw_view15', 'upper(b)', None), ('rw_view16', 'a', None), ('rw_view16', 'b', None), ('rw_view16', 'aa', None), ('rw_view2', 'a', None), ('rw_view2', 'b', None)]

-----------
QUERY:


INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:

UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: [(1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:

DELETE FROM rw_view2 WHERE a=3 RETURNING *;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: [(1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:


MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED AND t.a <= 1 THEN DELETE
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b)
  RETURNING merge_action(), s.*, t.*;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:

SELECT * FROM base_tbl ORDER BY a;
RESULT:
	duckdb: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:


EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


EXPLAIN (costs off)
MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED AND t.a <= 1 THEN DELETE
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


-- MERGE with incomplete set of INSTEAD OF triggers
DROP TRIGGER rw_view1_del_trig ON rw_view1;
RESULT:
	duckdb: ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED AND t.a <= 1 THEN DELETE
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should fail
MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok

DROP TRIGGER rw_view1_ins_trig ON rw_view1;
RESULT:
	duckdb: ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should fail
MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = s.b;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok

-- MERGE with INSTEAD OF triggers on auto-updatable view
CREATE TRIGGER rw_view2_upd_trig INSTEAD OF UPDATE ON rw_view2
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "TRIGGER"

-----------
QUERY:

MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should fail
MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = s.b;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
SELECT * FROM base_tbl ORDER BY a;
RESULT:
	duckdb: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:

DROP FUNCTION rw_view1_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "("

-----------
QUERY:


-- update using whole row from view

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:


CREATE FUNCTION rw_view1_aa(x rw_view1)
  RETURNS int AS $$ SELECT x.aa $$ LANGUAGE sql;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "rw_view1"

-----------
QUERY:


UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2
  RETURNING rw_view1_aa(v), v.bb;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

SELECT * FROM base_tbl;
RESULT:
	duckdb: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:


EXPLAIN (costs off)
UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2
  RETURNING rw_view1_aa(v), v.bb;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- permissions checks

CREATE USER regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "USER"

-----------
QUERY:

CREATE USER regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "USER"

-----------
QUERY:

CREATE USER regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "USER"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

CREATE TABLE base_tbl(a int, b text, c float);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:

INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:


GRANT SELECT ON base_tbl TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

GRANT SELECT ON rw_view1 TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

GRANT UPDATE (a,c) ON base_tbl TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

GRANT UPDATE (bb,cc) ON rw_view1 TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view2" already exists!

-----------
QUERY:

SELECT * FROM base_tbl;
RESULT:
	duckdb: [(1, 'Row 1', 1.0)]

-----------
QUERY:
 -- ok
SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- ok
SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- ok

INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
RESULT:
	duckdb: []

-----------
QUERY:
 -- not allowed
INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- not allowed
INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- not allowed

MERGE INTO rw_view1 t
  USING (VALUES ('Row 3', 3.0, 3)) AS v(b,c,a) ON t.aa = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.b, v.c, v.a);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t
  USING (VALUES ('Row 3', 3.0, 3)) AS v(b,c,a) ON t.aa = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.b, v.c, v.a);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

UPDATE base_tbl SET a=a, c=c;
RESULT:
	duckdb: []

-----------
QUERY:
 -- ok
UPDATE base_tbl SET b=b;
RESULT:
	duckdb: []

-----------
QUERY:
 -- not allowed
UPDATE rw_view1 SET bb=bb, cc=cc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET aa=aa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
UPDATE rw_view2 SET aa=aa, cc=cc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- ok
UPDATE rw_view2 SET bb=bb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed

MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET bb = bb, cc = cc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET aa = aa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET aa = aa, cc = cc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET bb = bb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

DELETE FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:
 -- not allowed
DELETE FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
DELETE FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
RESULT:
	duckdb: []

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- not allowed
INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok
DELETE FROM base_tbl WHERE a=1;
RESULT:
	duckdb: []

-----------
QUERY:
 -- ok
DELETE FROM rw_view1 WHERE aa=2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
DELETE FROM rw_view2 WHERE aa=2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED AND bb = 'xxx' THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED AND bb = 'xxx' THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
SELECT * FROM base_tbl;
RESULT:
	duckdb: [(3, 'Row 3', 3.0)]

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "REVOKE"

-----------
QUERY:

GRANT INSERT, DELETE ON rw_view1 TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0);
RESULT:
	duckdb: []

-----------
QUERY:
 -- not allowed
INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- not allowed
DELETE FROM base_tbl WHERE a=3;
RESULT:
	duckdb: []

-----------
QUERY:
 -- not allowed
DELETE FROM rw_view1 WHERE aa=3;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- ok
DELETE FROM rw_view2 WHERE aa=4;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED AND bb = 'xxx' THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED AND bb = 'xxx' THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
SELECT * FROM base_tbl;
RESULT:
	duckdb: [(5, 'Row 5', 5.0)]

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- nested-view permissions

CREATE TABLE base_tbl(a int, b text, c float);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
RESULT:
	duckdb: []

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
SELECT * FROM rw_view1 FOR UPDATE;
RESULT:
	duckdb: ERROR - Parser Error: SELECT locking clause is not supported!

-----------
QUERY:
  -- not allowed
UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	duckdb: ERROR - Parser Error: SELECT locking clause is not supported!

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

GRANT SELECT ON base_tbl TO regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

SELECT * FROM rw_view1 FOR UPDATE;
RESULT:
	duckdb: ERROR - Parser Error: SELECT locking clause is not supported!

-----------
QUERY:
  -- not allowed
UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	duckdb: ERROR - Parser Error: SELECT locking clause is not supported!

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

GRANT SELECT ON rw_view1 TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	duckdb: ERROR - Parser Error: SELECT locking clause is not supported!

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

GRANT UPDATE ON base_tbl TO regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

SELECT * FROM rw_view1 FOR UPDATE;
RESULT:
	duckdb: ERROR - Parser Error: SELECT locking clause is not supported!

-----------
QUERY:

UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	duckdb: ERROR - Parser Error: SELECT locking clause is not supported!

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'bar';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

GRANT UPDATE ON rw_view1 TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	duckdb: ERROR - Parser Error: SELECT locking clause is not supported!

-----------
QUERY:

UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'fud';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

REVOKE UPDATE ON base_tbl FROM regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "REVOKE"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

SELECT * FROM rw_view1 FOR UPDATE;
RESULT:
	duckdb: ERROR - Parser Error: SELECT locking clause is not supported!

-----------
QUERY:
  -- not allowed
UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	duckdb: ERROR - Parser Error: SELECT locking clause is not supported!

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- security invoker view permissions

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

CREATE TABLE base_tbl(a int, b text, c float);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:

ALTER VIEW rw_view1 SET (security_invoker = true);
RESULT:
	duckdb: ERROR - Not implemented Error: No support for that ALTER TABLE option yet!

-----------
QUERY:

INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

GRANT SELECT ON rw_view1 TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

GRANT UPDATE (bb,cc) ON rw_view1 TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM base_tbl;
RESULT:
	duckdb: [(1, 'Row 1', 1.0)]

-----------
QUERY:
 -- not allowed
SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
RESULT:
	duckdb: []

-----------
QUERY:
 -- not allowed
INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- not allowed
UPDATE base_tbl SET a=a;
RESULT:
	duckdb: []

-----------
QUERY:
 -- not allowed
UPDATE rw_view1 SET bb=bb, cc=cc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET bb = bb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
DELETE FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:
 -- not allowed
DELETE FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

GRANT SELECT ON base_tbl TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

GRANT UPDATE (a,c) ON base_tbl TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:
 -- ok
SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- ok
UPDATE base_tbl SET a=a, c=c;
RESULT:
	duckdb: []

-----------
QUERY:
 -- ok
UPDATE base_tbl SET b=b;
RESULT:
	duckdb: []

-----------
QUERY:
 -- not allowed
UPDATE rw_view1 SET cc=cc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET cc = cc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET aa=aa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
UPDATE rw_view1 SET bb=bb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET aa = aa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET bb = bb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
RESULT:
	duckdb: []

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- not allowed
DELETE FROM base_tbl WHERE a=1;
RESULT:
	duckdb: []

-----------
QUERY:
 -- ok
DELETE FROM rw_view1 WHERE aa=2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "REVOKE"

-----------
QUERY:

GRANT INSERT, DELETE ON rw_view1 TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- not allowed
DELETE FROM rw_view1 WHERE aa=2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- ok
DELETE FROM rw_view1 WHERE aa=2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (3)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
SELECT * FROM base_tbl;
RESULT:
	duckdb: [(3, 'Row 3', 3.0)]

-----------
QUERY:
 -- ok

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- ordinary view on top of security invoker view permissions

CREATE TABLE base_tbl(a int, b text, c float);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
RESULT:
	duckdb: []

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:

ALTER VIEW rw_view1 SET (security_invoker = true);
RESULT:
	duckdb: ERROR - Not implemented Error: No support for that ALTER TABLE option yet!

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view1 SET aa=aa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (2, 'Row 2', 2.0)) AS v(a,b,c) ON t.aa = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.b, v.c, v.a);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT cc AS ccc, aa AS aaa, bb AS bbb FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:

GRANT SELECT, UPDATE ON rw_view2 TO regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (2, 'Row 2', 2.0)) AS v(a,b,c) ON t.aaa = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.c, v.a, v.b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


GRANT SELECT ON base_tbl TO regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

GRANT UPDATE (a, b) ON base_tbl TO regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET aa=aa, bb=bb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
UPDATE rw_view1 SET cc=cc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET aa = aa, bb = bb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET cc = cc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

GRANT SELECT ON rw_view1 TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

GRANT UPDATE (bb, cc) ON rw_view1 TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


GRANT SELECT ON base_tbl TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

GRANT UPDATE (a, c) ON base_tbl TO regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok

SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


GRANT SELECT ON base_tbl TO regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:

GRANT UPDATE (a, c) ON base_tbl TO regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "GRANT"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


REVOKE SELECT, UPDATE ON base_tbl FROM regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "REVOKE"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view1 SET aa=aa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET aa = aa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok

SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


REVOKE SELECT, UPDATE ON base_tbl FROM regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "REVOKE"

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, VARCHAR, FLOAT] instead

-----------
QUERY:
  -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok

RESET SESSION AUTHORIZATION;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "AUTHORIZATION"

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


DROP USER regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "USER"

-----------
QUERY:

DROP USER regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "USER"

-----------
QUERY:

DROP USER regress_view_user3;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "USER"

-----------
QUERY:


-- column defaults

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified', c serial);
RESULT:
	duckdb: ERROR - Catalog Error: Type with name serial does not exist!
Did you mean "real"?

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1');
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:

INSERT INTO base_tbl VALUES (2, 'Row 2');
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:

INSERT INTO base_tbl VALUES (3);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 3: ...rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
                                                  ^

-----------
QUERY:

ALTER VIEW rw_view1 ALTER COLUMN bb SET DEFAULT 'View default';
RESULT:
	duckdb: ERROR - Parser Error: Alter column's default is only supported for tables

-----------
QUERY:


INSERT INTO rw_view1 VALUES (4, 'Row 4');
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

INSERT INTO rw_view1 (aa) VALUES (5);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

MERGE INTO rw_view1 t USING (VALUES (6)) AS v(a) ON t.aa = v.a
  WHEN NOT MATCHED THEN INSERT (aa) VALUES (v.a);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


SELECT * FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:


-- Table having triggers

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1');
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES (2, 'Row 2');
RESULT:
	duckdb: []

-----------
QUERY:


CREATE FUNCTION rw_view1_trig_fn()
RETURNS trigger AS
$$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE base_tbl SET b=NEW.b WHERE a=1;
    RETURN NULL;
  END IF;
  RETURN NULL;
END;
$$
LANGUAGE plpgsql;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RETURNS"

-----------
QUERY:


CREATE TRIGGER rw_view1_ins_trig AFTER INSERT ON base_tbl
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "TRIGGER"

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:


INSERT INTO rw_view1 VALUES (3, 'Row 3');
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

select * from base_tbl;
RESULT:
	duckdb: [(1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:


DROP VIEW rw_view1;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TRIGGER rw_view1_ins_trig on base_tbl;
RESULT:
	duckdb: ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

DROP FUNCTION rw_view1_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "("

-----------
QUERY:

DROP TABLE base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:


-- view with ORDER BY

CREATE TABLE base_tbl (a int, b int);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES (1,2), (4,5), (3,-3);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl ORDER BY a+b;
RESULT:
	duckdb: []

-----------
QUERY:


SELECT * FROM rw_view1;
RESULT:
	duckdb: [(3, -3), (1, 2), (4, 5)]

-----------
QUERY:


INSERT INTO rw_view1 VALUES (7,-8);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	duckdb: [(3, -3), (1, 2), (4, 5)]

-----------
QUERY:


EXPLAIN (verbose, costs off) UPDATE rw_view1 SET b = b + 1 RETURNING *;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: verbose

-----------
QUERY:

UPDATE rw_view1 SET b = b + 1 RETURNING *;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	duckdb: [(3, -3), (1, 2), (4, 5)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- multiple array-column updates

CREATE TABLE base_tbl (a int, arr int[]);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES (1,ARRAY[2]), (3,ARRAY[4]);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:


UPDATE rw_view1 SET arr[1] = 42, arr[2] = 77 WHERE a = 3;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a", "base_tbl.arr"

-----------
QUERY:


SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a", "base_tbl.arr"

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- views with updatable and non-updatable columns

CREATE TABLE base_tbl(a float);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl SELECT i/10.0 FROM generate_series(1,10) g(i);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS
  SELECT ctid, sin(a) s, a, cos(a) c
  FROM base_tbl
  WHERE a != 0
  ORDER BY abs(a);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "ctid" not found in FROM clause!
Candidate bindings: "base_tbl.a"
LINE 4:   SELECT ctid, sin(a) s, a, cos(a) c
                 ^

-----------
QUERY:


INSERT INTO rw_view1 VALUES (null, null, 1.1, null);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- should fail
INSERT INTO rw_view1 (s, c, a) VALUES (null, null, 1.1);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- should fail
INSERT INTO rw_view1 (a) VALUES (1.1) RETURNING a, s, c;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- OK
UPDATE rw_view1 SET s = s WHERE a = 1.1;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"

-----------
QUERY:
 -- should fail
UPDATE rw_view1 SET a = 1.05 WHERE a = 1.1 RETURNING s;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"
LINE 2: ...hould fail
UPDATE rw_view1 SET a = 1.05 WHERE a = 1.1 RETURNING s;
                                                  ^

-----------
QUERY:
 -- OK
DELETE FROM rw_view1 WHERE a = 1.05;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"

-----------
QUERY:
 -- OK

CREATE VIEW rw_view2 AS
  SELECT s, c, s/c t, a base_a, ctid
  FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"
LINE 4:   SELECT s, c, s/c t, a base_a, ctid
                                    ^

-----------
QUERY:


INSERT INTO rw_view2 VALUES (null, null, null, 1.1, null);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- should fail
INSERT INTO rw_view2(s, c, base_a) VALUES (null, null, 1.1);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- should fail
INSERT INTO rw_view2(base_a) VALUES (1.1) RETURNING t;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- OK
UPDATE rw_view2 SET s = s WHERE base_a = 1.1;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"

-----------
QUERY:
 -- should fail
UPDATE rw_view2 SET t = t WHERE base_a = 1.1;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"
LINE 2: ...hould fail
UPDATE rw_view2 SET t = t WHERE base_a = 1.1;
                                                  ^

-----------
QUERY:
 -- should fail
UPDATE rw_view2 SET base_a = 1.05 WHERE base_a = 1.1;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"
LINE 2: ...hould fail
UPDATE rw_view2 SET base_a = 1.05 WHERE base_a = 1.1;
                                                  ^

-----------
QUERY:
 -- OK
DELETE FROM rw_view2 WHERE base_a = 1.05 RETURNING base_a, s, c, t;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"
LINE 2: ...FROM rw_view2 WHERE base_a = 1.05 RETURNING base_a, s, c, t;
                                                  ^

-----------
QUERY:
 -- OK

CREATE VIEW rw_view3 AS
  SELECT s, c, s/c t, ctid
  FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"
LINE 5:   FROM rw_view1;
         ^

-----------
QUERY:


INSERT INTO rw_view3 VALUES (null, null, null, null);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view3 does not exist!
Did you mean "ro_view3"?

-----------
QUERY:
 -- should fail
INSERT INTO rw_view3(s) VALUES (null);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view3 does not exist!
Did you mean "ro_view3"?

-----------
QUERY:
 -- should fail
UPDATE rw_view3 SET s = s;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view3 does not exist!
Did you mean "ro_view3"?
LINE 2: UPDATE rw_view3 SET s = s;
               ^

-----------
QUERY:
 -- should fail
DELETE FROM rw_view3 WHERE s = sin(0.1);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view3 does not exist!
Did you mean "ro_view3"?
LINE 2: DELETE FROM rw_view3 WHERE s = sin(0.1);
                    ^

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl ORDER BY a;
RESULT:
	duckdb: [(0.10000000149011612,), (0.20000000298023224,), (0.30000001192092896,), (0.4000000059604645,), (0.5,), (0.6000000238418579,), (0.699999988079071,), (0.800000011920929,), (0.8999999761581421,), (1.0,)]

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name;
RESULT:
	duckdb: []

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	duckdb: []

-----------
QUERY:


SELECT events & 4 != 0 AS upd,
       events & 8 != 0 AS ins,
       events & 16 != 0 AS del
  FROM pg_catalog.pg_relation_is_updatable('rw_view3'::regclass, false) t(events);
RESULT:
	duckdb: ERROR - Catalog Error: Table Function with name pg_relation_is_updatable does not exist!
Did you mean "main.glob"?

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- view on table with GENERATED columns

CREATE TABLE base_tbl (id int, idplus1 int GENERATED ALWAYS AS (id + 1) STORED);
RESULT:
	duckdb: ERROR - Invalid Input Error: Can not create a STORED generated column!

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 2: CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
                                              ^

-----------
QUERY:


INSERT INTO base_tbl (id) VALUES (1);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:

INSERT INTO rw_view1 (id) VALUES (2);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

INSERT INTO base_tbl (id, idplus1) VALUES (3, DEFAULT);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:

INSERT INTO rw_view1 (id, idplus1) VALUES (4, DEFAULT);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

INSERT INTO base_tbl (id, idplus1) VALUES (5, 6);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:
  -- error
INSERT INTO rw_view1 (id, idplus1) VALUES (6, 7);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
  -- error

SELECT * FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:


UPDATE base_tbl SET id = 2000 WHERE id = 2;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 3: UPDATE base_tbl SET id = 2000 WHERE id = 2;
               ^

-----------
QUERY:

UPDATE rw_view1 SET id = 3000 WHERE id = 3;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 2: UPDATE rw_view1 SET id = 3000 WHERE id = 3;
                                               ^

-----------
QUERY:


SELECT * FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:


-- inheritance tests

CREATE TABLE base_tbl_parent (a int);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE TABLE base_tbl_child (CHECK (a > 0)) INHERITS (base_tbl_parent);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "INHERITS"

-----------
QUERY:

INSERT INTO base_tbl_parent SELECT * FROM generate_series(-8, -1);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl_child SELECT * FROM generate_series(1, 8);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl_child does not exist!
Did you mean "base_tbl_parent"?

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl_parent;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT * FROM ONLY base_tbl_parent;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view2" already exists!

-----------
QUERY:


SELECT * FROM rw_view1 ORDER BY a;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:

SELECT * FROM ONLY rw_view1 ORDER BY a;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:

SELECT * FROM rw_view2 ORDER BY a;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:


INSERT INTO rw_view1 VALUES (-100), (100);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:

INSERT INTO rw_view2 VALUES (-200), (200);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:


UPDATE rw_view1 SET a = a*10 WHERE a IN (-1, 1);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 3: UPDATE rw_view1 SET a = a*10 WHERE a IN (-1, 1);
                                              ^

-----------
QUERY:
 -- Should produce -10 and 10
UPDATE ONLY rw_view1 SET a = a*10 WHERE a IN (-2, 2);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 2: UPDATE ONLY rw_view...
                  ^

-----------
QUERY:
 -- Should produce -20 and 20
UPDATE rw_view2 SET a = a*10 WHERE a IN (-3, 3);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 2: UPDATE rw_view2 SET a = a*10 WHERE a IN (-3, 3);
                  ^

-----------
QUERY:
 -- Should produce -30 only
UPDATE ONLY rw_view2 SET a = a*10 WHERE a IN (-4, 4);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 2: UPDATE ONLY rw_view2 SE...
                    ^

-----------
QUERY:
 -- Should produce -40 only

DELETE FROM rw_view1 WHERE a IN (-5, 5);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 3: DELETE FROM rw_view1 WHERE a IN (-5, 5);
                   ^

-----------
QUERY:
 -- Should delete -5 and 5
DELETE FROM ONLY rw_view1 WHERE a IN (-6, 6);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 2: DELETE FROM ONLY rw_view1 WHERE a IN (-6, 6);
                     ^

-----------
QUERY:
 -- Should delete -6 and 6
DELETE FROM rw_view2 WHERE a IN (-7, 7);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 2: DELETE FROM rw_view2 WHERE a IN (-7, 7);
                     ^

-----------
QUERY:
 -- Should delete -7 only
DELETE FROM ONLY rw_view2 WHERE a IN (-8, 8);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 2: DELETE FROM ONLY rw_view2 WHERE a IN (-8, 8);
                      ^

-----------
QUERY:
 -- Should delete -8 only

SELECT * FROM ONLY base_tbl_parent ORDER BY a;
RESULT:
	duckdb: [(-8,), (-7,), (-6,), (-5,), (-4,), (-3,), (-2,), (-1,)]

-----------
QUERY:

SELECT * FROM base_tbl_child ORDER BY a;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl_child does not exist!
Did you mean "base_tbl_parent"?

-----------
QUERY:


MERGE INTO rw_view1 t USING (VALUES (-200), (10)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a+1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- Should produce -199 and 11
MERGE INTO ONLY rw_view1 t USING (VALUES (-100), (20)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a+1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- Should produce -99 and 21
MERGE INTO rw_view2 t USING (VALUES (-40), (3)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a+1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- Should produce -39 only
MERGE INTO ONLY rw_view2 t USING (VALUES (-30), (4)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a+1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- Should produce -29 only

SELECT * FROM ONLY base_tbl_parent ORDER BY a;
RESULT:
	duckdb: [(-8,), (-7,), (-6,), (-5,), (-4,), (-3,), (-2,), (-1,)]

-----------
QUERY:

SELECT * FROM base_tbl_child ORDER BY a;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl_child does not exist!
Did you mean "base_tbl_parent"?

-----------
QUERY:


CREATE TABLE other_tbl_parent (id int);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE TABLE other_tbl_child () INHERITS (other_tbl_parent);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "INHERITS"

-----------
QUERY:

INSERT INTO other_tbl_parent VALUES (7),(200);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO other_tbl_child VALUES (8),(100);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name other_tbl_child does not exist!
Did you mean "CHAR_TBL"?

-----------
QUERY:


EXPLAIN (costs off)
UPDATE rw_view1 SET a = a + 1000 FROM other_tbl_parent WHERE a = id;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

UPDATE rw_view1 SET a = a + 1000 FROM other_tbl_parent WHERE a = id;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl does not exist!
Did you mean "CHAR_TBL"?
LINE 2: UPDATE rw_view1 SET a = a + 1000 FROM other_tbl_parent WHERE a = id;
                                               ^

-----------
QUERY:


SELECT * FROM ONLY base_tbl_parent ORDER BY a;
RESULT:
	duckdb: [(-8,), (-7,), (-6,), (-5,), (-4,), (-3,), (-2,), (-1,)]

-----------
QUERY:

SELECT * FROM base_tbl_child ORDER BY a;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tbl_child does not exist!
Did you mean "base_tbl_parent"?

-----------
QUERY:


DROP TABLE base_tbl_parent, base_tbl_child CASCADE;
RESULT:
	duckdb: ERROR - Not implemented Error: Can only drop one object at a time

-----------
QUERY:

DROP TABLE other_tbl_parent CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- simple WITH CHECK OPTION

CREATE TABLE base_tbl (a int, b int DEFAULT 10);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES (1,2), (2,3), (1,-1);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b
  WITH LOCAL CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:

-- \d+ rw_view1
SELECT * FROM information_schema.views WHERE table_name = 'rw_view1';
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


INSERT INTO rw_view1 VALUES(3,4);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES(4,3);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- should fail
INSERT INTO rw_view1 VALUES(5,null);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- should fail
UPDATE rw_view1 SET b = 5 WHERE a = 3;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET b = -5 WHERE a = 3;
RESULT:
	duckdb: ERROR - Binder Error: Can only update base table!

-----------
QUERY:
 -- should fail
INSERT INTO rw_view1(a) VALUES (9);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view1(a) VALUES (10);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- should fail
SELECT * FROM base_tbl ORDER BY a, b;
RESULT:
	duckdb: [(1, -1), (1, 2), (2, 3)]

-----------
QUERY:


MERGE INTO rw_view1 t USING (VALUES (10)) AS v(a) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a, v.a + 1);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (11)) AS v(a) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a, v.a - 1);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should fail
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a - 1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (2)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a + 1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should fail
SELECT * FROM base_tbl ORDER BY a, b;
RESULT:
	duckdb: [(1, -1), (1, 2), (2, 3)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- WITH LOCAL/CASCADED CHECK OPTION

CREATE TABLE base_tbl (a int);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a > 0;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
  WITH CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:
 -- implicitly cascaded
-- \d+ rw_view2
SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


INSERT INTO rw_view2 VALUES (-5);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- should fail
INSERT INTO rw_view2 VALUES (5);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view2 VALUES (15);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- should fail
SELECT * FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:


UPDATE rw_view2 SET a = a - 10;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"

-----------
QUERY:
 -- should fail
UPDATE rw_view2 SET a = a + 10;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"

-----------
QUERY:
 -- should fail

CREATE OR REPLACE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
  WITH LOCAL CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:

-- \d+ rw_view2
SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


INSERT INTO rw_view2 VALUES (-10);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok, but not in view
INSERT INTO rw_view2 VALUES (20);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- should fail
SELECT * FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:


ALTER VIEW rw_view1 SET (check_option=here);
RESULT:
	duckdb: ERROR - Not implemented Error: No support for that ALTER TABLE option yet!

-----------
QUERY:
 -- invalid
ALTER VIEW rw_view1 SET (check_option=local);
RESULT:
	duckdb: ERROR - Not implemented Error: No support for that ALTER TABLE option yet!

-----------
QUERY:


INSERT INTO rw_view2 VALUES (-20);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- should fail
INSERT INTO rw_view2 VALUES (30);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- should fail

ALTER VIEW rw_view2 RESET (check_option);
RESULT:
	duckdb: ERROR - Not implemented Error: No support for that ALTER TABLE option yet!

-----------
QUERY:

-- \d+ rw_view2
SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:

INSERT INTO rw_view2 VALUES (30);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok, but not in view
SELECT * FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- WITH CHECK OPTION with no local view qual

CREATE TABLE base_tbl (a int);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WITH CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a > 0;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"

-----------
QUERY:

CREATE VIEW rw_view3 AS SELECT * FROM rw_view2 WITH CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:

SELECT * FROM information_schema.views WHERE table_name LIKE E'rw\\_view_' ORDER BY table_name;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


INSERT INTO rw_view1 VALUES (-1);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES (1);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view2 VALUES (-2);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok, but not in view
INSERT INTO rw_view2 VALUES (2);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view3 VALUES (-3);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view3 does not exist!
Did you mean "ro_view3"?

-----------
QUERY:
 -- should fail
INSERT INTO rw_view3 VALUES (3);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view3 does not exist!
Did you mean "ro_view3"?

-----------
QUERY:
 -- ok

DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- WITH CHECK OPTION with scalar array ops

CREATE TABLE base_tbl (a int, b int[]);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a = ANY (b)
  WITH CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:


INSERT INTO rw_view1 VALUES (1, ARRAY[1,2,3]);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES (10, ARRAY[4,5]);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- should fail

UPDATE rw_view1 SET b[2] = -b[2] WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: No function matches the given name and argument types '+(INTEGER, INTEGER[])'. You might need to add explicit type casts.
	Candidate functions:
	+(TINYINT) -> TINYINT
	+(TINYINT, TINYINT) -> TINYINT
	+(SMALLINT) -> SMALLINT
	+(SMALLINT, SMALLINT) -> SMALLINT
	+(INTEGER) -> INTEGER
	+(INTEGER, INTEGER) -> INTEGER
	+(BIGINT) -> BIGINT
	+(BIGINT, BIGINT) -> BIGINT
	+(HUGEINT) -> HUGEINT
	+(HUGEINT, HUGEINT) -> HUGEINT
	+(FLOAT) -> FLOAT
	+(FLOAT, FLOAT) -> FLOAT
	+(DOUBLE) -> DOUBLE
	+(DOUBLE, DOUBLE) -> DOUBLE
	+(DECIMAL) -> DECIMAL
	+(DECIMAL, DECIMAL) -> DECIMAL
	+(UTINYINT) -> UTINYINT
	+(UTINYINT, UTINYINT) -> UTINYINT
	+(USMALLINT) -> USMALLINT
	+(USMALLINT, USMALLINT) -> USMALLINT
	+(UINTEGER) -> UINTEGER
	+(UINTEGER, UINTEGER) -> UINTEGER
	+(UBIGINT) -> UBIGINT
	+(UBIGINT, UBIGINT) -> UBIGINT
	+(UHUGEINT) -> UHUGEINT
	+(UHUGEINT, UHUGEINT) -> UHUGEINT
	+(DATE, INTEGER) -> DATE
	+(INTEGER, DATE) -> DATE
	+(INTERVAL, INTERVAL) -> INTERVAL
	+(DATE, INTERVAL) -> TIMESTAMP
	+(INTERVAL, DATE) -> TIMESTAMP
	+(TIME, INTERVAL) -> TIME
	+(INTERVAL, TIME) -> TIME
	+(TIMESTAMP, INTERVAL) -> TIMESTAMP
	+(INTERVAL, TIMESTAMP) -> TIMESTAMP
	+(TIME WITH TIME ZONE, INTERVAL) -> TIME WITH TIME ZONE
	+(INTERVAL, TIME WITH TIME ZONE) -> TIME WITH TIME ZONE
	+(TIME, DATE) -> TIMESTAMP
	+(DATE, TIME) -> TIMESTAMP
	+(TIME WITH TIME ZONE, DATE) -> TIMESTAMP WITH TIME ZONE
	+(DATE, TIME WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE
	+(ANY[], ANY[]) -> ANY[]
	+(TIMESTAMP WITH TIME ZONE, INTERVAL) -> TIMESTAMP WITH TIME ZONE
	+(INTERVAL, TIMESTAMP WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE

LINE 3: ... should fail

UPDATE rw_view1 SET b[2] = -b[2] WHERE a = 1;
                                                  ^

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET b[1] = -b[1] WHERE a = 1;
RESULT:
	duckdb: ERROR - Binder Error: No function matches the given name and argument types '+(INTEGER, INTEGER[])'. You might need to add explicit type casts.
	Candidate functions:
	+(TINYINT) -> TINYINT
	+(TINYINT, TINYINT) -> TINYINT
	+(SMALLINT) -> SMALLINT
	+(SMALLINT, SMALLINT) -> SMALLINT
	+(INTEGER) -> INTEGER
	+(INTEGER, INTEGER) -> INTEGER
	+(BIGINT) -> BIGINT
	+(BIGINT, BIGINT) -> BIGINT
	+(HUGEINT) -> HUGEINT
	+(HUGEINT, HUGEINT) -> HUGEINT
	+(FLOAT) -> FLOAT
	+(FLOAT, FLOAT) -> FLOAT
	+(DOUBLE) -> DOUBLE
	+(DOUBLE, DOUBLE) -> DOUBLE
	+(DECIMAL) -> DECIMAL
	+(DECIMAL, DECIMAL) -> DECIMAL
	+(UTINYINT) -> UTINYINT
	+(UTINYINT, UTINYINT) -> UTINYINT
	+(USMALLINT) -> USMALLINT
	+(USMALLINT, USMALLINT) -> USMALLINT
	+(UINTEGER) -> UINTEGER
	+(UINTEGER, UINTEGER) -> UINTEGER
	+(UBIGINT) -> UBIGINT
	+(UBIGINT, UBIGINT) -> UBIGINT
	+(UHUGEINT) -> UHUGEINT
	+(UHUGEINT, UHUGEINT) -> UHUGEINT
	+(DATE, INTEGER) -> DATE
	+(INTEGER, DATE) -> DATE
	+(INTERVAL, INTERVAL) -> INTERVAL
	+(DATE, INTERVAL) -> TIMESTAMP
	+(INTERVAL, DATE) -> TIMESTAMP
	+(TIME, INTERVAL) -> TIME
	+(INTERVAL, TIME) -> TIME
	+(TIMESTAMP, INTERVAL) -> TIMESTAMP
	+(INTERVAL, TIMESTAMP) -> TIMESTAMP
	+(TIME WITH TIME ZONE, INTERVAL) -> TIME WITH TIME ZONE
	+(INTERVAL, TIME WITH TIME ZONE) -> TIME WITH TIME ZONE
	+(TIME, DATE) -> TIMESTAMP
	+(DATE, TIME) -> TIMESTAMP
	+(TIME WITH TIME ZONE, DATE) -> TIMESTAMP WITH TIME ZONE
	+(DATE, TIME WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE
	+(ANY[], ANY[]) -> ANY[]
	+(TIMESTAMP WITH TIME ZONE, INTERVAL) -> TIMESTAMP WITH TIME ZONE
	+(INTERVAL, TIMESTAMP WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE


-----------
QUERY:
 -- should fail

PREPARE ins(int, int[]) AS INSERT INTO rw_view1 VALUES($1, $2);
RESULT:
	duckdb: ERROR - Not implemented Error: Prepared statement argument types are not supported, use CAST

-----------
QUERY:

EXECUTE ins(2, ARRAY[1,2,3]);
RESULT:
	duckdb: ERROR - Binder Error: Prepared statement "ins" does not exist

-----------
QUERY:
 -- ok
EXECUTE ins(10, ARRAY[4,5]);
RESULT:
	duckdb: ERROR - Binder Error: Prepared statement "ins" does not exist

-----------
QUERY:
 -- should fail
DEALLOCATE PREPARE ins;
RESULT:
	duckdb: []

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- WITH CHECK OPTION with subquery

CREATE TABLE base_tbl (a int);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE TABLE ref_tbl (a int PRIMARY KEY);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO ref_tbl SELECT * FROM generate_series(1,10);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS
  SELECT * FROM base_tbl b
  WHERE EXISTS(SELECT 1 FROM ref_tbl r WHERE r.a = b.a)
  WITH CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:


INSERT INTO rw_view1 VALUES (5);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES (15);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- should fail

UPDATE rw_view1 SET a = a + 5;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET a = a + 5;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"

-----------
QUERY:
 -- should fail

EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (5);
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off) UPDATE rw_view1 SET a = a + 5;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


DROP TABLE base_tbl, ref_tbl CASCADE;
RESULT:
	duckdb: ERROR - Not implemented Error: Can only drop one object at a time

-----------
QUERY:


-- WITH CHECK OPTION with BEFORE trigger on base table

CREATE TABLE base_tbl (a int, b int);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name "base_tbl" already exists!

-----------
QUERY:


CREATE FUNCTION base_tbl_trig_fn()
RETURNS trigger AS
$$
BEGIN
  NEW.b := 10;
  RETURN NEW;
END;
$$
LANGUAGE plpgsql;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RETURNS"

-----------
QUERY:


CREATE TRIGGER base_tbl_trig BEFORE INSERT OR UPDATE ON base_tbl
  FOR EACH ROW EXECUTE PROCEDURE base_tbl_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "TRIGGER"

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b WITH CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:


INSERT INTO rw_view1 VALUES (5,0);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES (15, 20);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- should fail
UPDATE rw_view1 SET a = 20, b = 30;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "b" not found in FROM clause!
Candidate bindings: "base_tbl.a"

-----------
QUERY:
 -- should fail

DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:

DROP FUNCTION base_tbl_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "("

-----------
QUERY:


-- WITH LOCAL CHECK OPTION with INSTEAD OF trigger on base view

CREATE TABLE base_tbl (a int, b int);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT a FROM base_tbl WHERE a < b;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:


CREATE FUNCTION rw_view1_trig_fn()
RETURNS trigger AS
$$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO base_tbl VALUES (NEW.a, 10);
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    DELETE FROM base_tbl WHERE a=OLD.a;
    RETURN OLD;
  END IF;
END;
$$
LANGUAGE plpgsql;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RETURNS"

-----------
QUERY:


CREATE TRIGGER rw_view1_trig
  INSTEAD OF INSERT OR UPDATE OR DELETE ON rw_view1
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "TRIGGER"

-----------
QUERY:


CREATE VIEW rw_view2 AS
  SELECT * FROM rw_view1 WHERE a > 0 WITH LOCAL CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:


INSERT INTO rw_view2 VALUES (-5);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- should fail
MERGE INTO rw_view2 t USING (VALUES (-5)) AS v(a) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should fail
INSERT INTO rw_view2 VALUES (5);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok
MERGE INTO rw_view2 t USING (VALUES (6)) AS v(a) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok
INSERT INTO rw_view2 VALUES (50);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok, but not in view
MERGE INTO rw_view2 t USING (VALUES (60)) AS v(a) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- ok, but not in view
UPDATE rw_view2 SET a = a - 10;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, INTEGER] instead

-----------
QUERY:
 -- should fail
MERGE INTO rw_view2 t USING (VALUES (6)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a - 10;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:
 -- should fail
SELECT * FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:


-- Check option won/* REPLACED */''t cascade down to base view with INSTEAD OF triggers

ALTER VIEW rw_view2 SET (check_option=cascaded);
RESULT:
	duckdb: ERROR - Not implemented Error: No support for that ALTER TABLE option yet!

-----------
QUERY:

INSERT INTO rw_view2 VALUES (100);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view1/* REPLACED */''s check)
UPDATE rw_view2 SET a = 200 WHERE a = 5;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, INTEGER] instead

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view1/* REPLACED */''s check)
SELECT * FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:


-- Neither local nor cascaded check options work with INSTEAD rules

DROP TRIGGER rw_view1_trig ON rw_view1;
RESULT:
	duckdb: ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, 10);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
  DO INSTEAD UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

INSERT INTO rw_view2 VALUES (-10);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view2/* REPLACED */''s check)
INSERT INTO rw_view2 VALUES (5);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok
INSERT INTO rw_view2 VALUES (20);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view1/* REPLACED */''s check)
UPDATE rw_view2 SET a = 30 WHERE a = 5;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, INTEGER] instead

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view1/* REPLACED */''s check)
INSERT INTO rw_view2 VALUES (5);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok
UPDATE rw_view2 SET a = -5 WHERE a = 5;
RESULT:
	duckdb: ERROR - Binder Error: Contents of view were altered: types don't match! Expected [INTEGER, VARCHAR], but found [INTEGER, INTEGER] instead

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view2/* REPLACED */''s check)
SELECT * FROM base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:

DROP FUNCTION rw_view1_trig_fn();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "("

-----------
QUERY:


CREATE TABLE base_tbl (a int);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT a,10 AS b FROM base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:

CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

CREATE VIEW rw_view2 AS
  SELECT * FROM rw_view1 WHERE a > b WITH LOCAL CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:

INSERT INTO rw_view2 VALUES (2,3);
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view2/* REPLACED */''s check)
DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- security barrier view

CREATE TABLE base_tbl (person text, visibility text);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES ('Tom', 'public'),
                            ('Dick', 'private'),
                            ('Harry', 'public');
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW rw_view1 AS
  SELECT person FROM base_tbl WHERE visibility = 'public';
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:


CREATE FUNCTION snoop(anyelement)
RETURNS boolean AS
$$
BEGIN
  RAISE NOTICE 'snooped value: %', $1;
  RETURN true;
END;
$$
LANGUAGE plpgsql COST 0.000001;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RETURNS"

-----------
QUERY:


CREATE OR REPLACE FUNCTION leakproof(anyelement)
RETURNS boolean AS
$$
BEGIN
  RETURN true;
END;
$$
LANGUAGE plpgsql STRICT IMMUTABLE LEAKPROOF;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RETURNS"

-----------
QUERY:


SELECT * FROM rw_view1 WHERE snoop(person);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.person"

-----------
QUERY:

UPDATE rw_view1 SET person=person WHERE snoop(person);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.person"

-----------
QUERY:

DELETE FROM rw_view1 WHERE NOT snoop(person);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.person"

-----------
QUERY:


ALTER VIEW rw_view1 SET (security_barrier = true);
RESULT:
	duckdb: ERROR - Not implemented Error: No support for that ALTER TABLE option yet!

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name = 'rw_view1';
RESULT:
	duckdb: [('rw_view1', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name = 'rw_view1';
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name = 'rw_view1'
 ORDER BY ordinal_position;
RESULT:
	duckdb: [('rw_view1', 'a', None), ('rw_view1', 'b', None)]

-----------
QUERY:


SELECT * FROM rw_view1 WHERE snoop(person);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.person"

-----------
QUERY:

UPDATE rw_view1 SET person=person WHERE snoop(person);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.person"

-----------
QUERY:

DELETE FROM rw_view1 WHERE NOT snoop(person);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.person"

-----------
QUERY:

MERGE INTO rw_view1 t
  USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS v(person) ON t.person = v.person
  WHEN MATCHED AND snoop(t.person) THEN UPDATE SET person = v.person;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


EXPLAIN (costs off) SELECT * FROM rw_view1 WHERE snoop(person);
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off) UPDATE rw_view1 SET person=person WHERE snoop(person);
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view1 WHERE NOT snoop(person);
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off)
MERGE INTO rw_view1 t
  USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS v(person) ON t.person = v.person
  WHEN MATCHED AND snoop(t.person) THEN UPDATE SET person = v.person;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


-- security barrier view on top of security barrier view

CREATE VIEW rw_view2 WITH (security_barrier = true) AS
  SELECT * FROM rw_view1 WHERE snoop(person);
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW options

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name = 'rw_view2';
RESULT:
	duckdb: [('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name = 'rw_view2';
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name = 'rw_view2'
 ORDER BY ordinal_position;
RESULT:
	duckdb: [('rw_view2', 'a', None), ('rw_view2', 'b', None)]

-----------
QUERY:


SELECT * FROM rw_view2 WHERE snoop(person);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.person"

-----------
QUERY:

UPDATE rw_view2 SET person=person WHERE snoop(person);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.person"

-----------
QUERY:

DELETE FROM rw_view2 WHERE NOT snoop(person);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.person"

-----------
QUERY:

MERGE INTO rw_view2 t
  USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS v(person) ON t.person = v.person
  WHEN MATCHED AND snoop(t.person) THEN UPDATE SET person = v.person;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


EXPLAIN (costs off) SELECT * FROM rw_view2 WHERE snoop(person);
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off) UPDATE rw_view2 SET person=person WHERE snoop(person);
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view2 WHERE NOT snoop(person);
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

EXPLAIN (costs off)
MERGE INTO rw_view2 t
  USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS v(person) ON t.person = v.person
  WHEN MATCHED AND snoop(t.person) THEN UPDATE SET person = v.person;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "MERGE"

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- security barrier view on top of table with rules

CREATE TABLE base_tbl(id int PRIMARY KEY, data text, deleted boolean);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1', false), (2, 'Row 2', true);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE RULE base_tbl_ins_rule AS ON INSERT TO base_tbl
  WHERE EXISTS (SELECT 1 FROM base_tbl t WHERE t.id = new.id)
  DO INSTEAD
    UPDATE base_tbl SET data = new.data, deleted = false WHERE id = new.id;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


CREATE RULE base_tbl_del_rule AS ON DELETE TO base_tbl
  DO INSTEAD
    UPDATE base_tbl SET deleted = true WHERE id = old.id;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:


CREATE VIEW rw_view1 WITH (security_barrier=true) AS
  SELECT id, data FROM base_tbl WHERE NOT deleted;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW options

-----------
QUERY:


SELECT * FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.id", "base_tbl.data"

-----------
QUERY:


EXPLAIN (costs off) DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
RESULT:
	duckdb: ERROR - Binder Error: Referenced column "a" not found in FROM clause!
Candidate bindings: "base_tbl.id", "base_tbl.data"

-----------
QUERY:


EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (2, 'New row 2');
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

INSERT INTO rw_view1 VALUES (2, 'New row 2');
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:


SELECT * FROM base_tbl;
RESULT:
	duckdb: [(1, 'Row 1', False), (2, 'Row 2', True)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	duckdb: []

-----------
QUERY:


-- security barrier view based on inheritance set
CREATE TABLE t1 (a int, b float, c text);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE INDEX t1_a_idx ON t1(a);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO t1
SELECT i,i,'t1' FROM generate_series(1,10) g(i);
RESULT:
	duckdb: []

-----------
QUERY:

ANALYZE t1;
RESULT:
	duckdb: []

-----------
QUERY:


CREATE TABLE t11 (d text) INHERITS (t1);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "INHERITS"

-----------
QUERY:

CREATE INDEX t11_a_idx ON t11(a);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name t11 does not exist!
Did you mean "t1"?

-----------
QUERY:

INSERT INTO t11
SELECT i,i,'t11','t11d' FROM generate_series(1,10) g(i);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name t11 does not exist!
Did you mean "t1"?

-----------
QUERY:

ANALYZE t11;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name t11 does not exist!
Did you mean "t1"?
LINE 2: ANALYZE t11;
                ^

-----------
QUERY:


CREATE TABLE t12 (e int[]) INHERITS (t1);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "INHERITS"

-----------
QUERY:

CREATE INDEX t12_a_idx ON t12(a);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name t12 does not exist!
Did you mean "t1"?

-----------
QUERY:

INSERT INTO t12
SELECT i,i,'t12','{1,2}'::int[] FROM generate_series(1,10) g(i);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name t12 does not exist!
Did you mean "t1"?

-----------
QUERY:

ANALYZE t12;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name t12 does not exist!
Did you mean "t1"?
LINE 2: ANALYZE t12;
                ^

-----------
QUERY:


CREATE TABLE t111 () INHERITS (t11, t12);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "INHERITS"

-----------
QUERY:

CREATE INDEX t111_a_idx ON t111(a);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name t111 does not exist!
Did you mean "t1"?

-----------
QUERY:

INSERT INTO t111
SELECT i,i,'t111','t111d','{1,1,1}'::int[] FROM generate_series(1,10) g(i);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name t111 does not exist!
Did you mean "t1"?

-----------
QUERY:

ANALYZE t111;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name t111 does not exist!
Did you mean "t1"?
LINE 2: ANALYZE t111;
                ^

-----------
QUERY:


CREATE VIEW v1 WITH (security_barrier=true) AS
SELECT *, (SELECT d FROM t11 WHERE t11.a = t1.a LIMIT 1) AS d
FROM t1
WHERE a > 5 AND EXISTS(SELECT 1 FROM t12 WHERE t12.a = t1.a);
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW options

-----------
QUERY:


SELECT * FROM v1 WHERE a=3;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v1 does not exist!
Did you mean "t1"?

-----------
QUERY:
 -- should not see anything
SELECT * FROM v1 WHERE a=8;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v1 does not exist!
Did you mean "t1"?

-----------
QUERY:


EXPLAIN (VERBOSE, COSTS OFF)
UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: VERBOSE

-----------
QUERY:

UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v1 does not exist!
Did you mean "t1"?
LINE 2: UPDATE v1 SET a=100 WHERE snoop(a) AND leakpr...
               ^

-----------
QUERY:


SELECT * FROM v1 WHERE a=100;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v1 does not exist!
Did you mean "t1"?

-----------
QUERY:
 -- Nothing should have been changed to 100
SELECT * FROM t1 WHERE a=100;
RESULT:
	duckdb: []

-----------
QUERY:
 -- Nothing should have been changed to 100

EXPLAIN (VERBOSE, COSTS OFF)
UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: VERBOSE

-----------
QUERY:

UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v1 does not exist!
Did you mean "t1"?
LINE 2: UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakpr...
               ^

-----------
QUERY:


SELECT * FROM v1 WHERE b=8;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v1 does not exist!
Did you mean "t1"?

-----------
QUERY:


DELETE FROM v1 WHERE snoop(a) AND leakproof(a);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v1 does not exist!
Did you mean "t1"?
LINE 3: DELETE FROM v1 WHERE snoop(a) AND leakproof(a);
                    ^

-----------
QUERY:
 -- should not delete everything, just where a>5

TABLE t1;
RESULT:
	duckdb: [(1, 1.0, 't1'), (2, 2.0, 't1'), (3, 3.0, 't1'), (4, 4.0, 't1'), (5, 5.0, 't1'), (6, 6.0, 't1'), (7, 7.0, 't1'), (8, 8.0, 't1'), (9, 9.0, 't1'), (10, 10.0, 't1')]

-----------
QUERY:
 -- verify all a<=5 are intact

DROP TABLE t1, t11, t12, t111 CASCADE;
RESULT:
	duckdb: ERROR - Not implemented Error: Can only drop one object at a time

-----------
QUERY:

DROP FUNCTION snoop(anyelement);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "("

-----------
QUERY:

DROP FUNCTION leakproof(anyelement);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "("

-----------
QUERY:


CREATE TABLE tx1 (a integer);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE TABLE tx2 (b integer);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE TABLE tx3 (c integer);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO vx1 values (1);
RESULT:
	duckdb: ERROR - Catalog Error: vx1 is not an table

-----------
QUERY:

SELECT * FROM tx1;
RESULT:
	duckdb: []

-----------
QUERY:

SELECT * FROM vx1;
RESULT:
	duckdb: []

-----------
QUERY:


DROP VIEW vx1;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE tx1;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE tx2;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE tx3;
RESULT:
	duckdb: []

-----------
QUERY:


CREATE TABLE tx1 (a integer);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE TABLE tx2 (b integer);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE TABLE tx3 (c integer);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO vx1 VALUES (1);
RESULT:
	duckdb: ERROR - Catalog Error: vx1 is not an table

-----------
QUERY:

INSERT INTO vx1 VALUES (1);
RESULT:
	duckdb: ERROR - Catalog Error: vx1 is not an table

-----------
QUERY:

SELECT * FROM tx1;
RESULT:
	duckdb: []

-----------
QUERY:

SELECT * FROM vx1;
RESULT:
	duckdb: []

-----------
QUERY:


DROP VIEW vx1;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE tx1;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE tx2;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE tx3;
RESULT:
	duckdb: []

-----------
QUERY:


CREATE TABLE tx1 (a integer, b integer);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE TABLE tx2 (b integer, c integer);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE TABLE tx3 (c integer, d integer);
RESULT:
	duckdb: []

-----------
QUERY:

ALTER TABLE tx1 DROP COLUMN b;
RESULT:
	duckdb: []

-----------
QUERY:

ALTER TABLE tx2 DROP COLUMN c;
RESULT:
	duckdb: []

-----------
QUERY:

ALTER TABLE tx3 DROP COLUMN d;
RESULT:
	duckdb: []

-----------
QUERY:

CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO vx1 VALUES (1);
RESULT:
	duckdb: ERROR - Catalog Error: vx1 is not an table

-----------
QUERY:

INSERT INTO vx1 VALUES (1);
RESULT:
	duckdb: ERROR - Catalog Error: vx1 is not an table

-----------
QUERY:

SELECT * FROM tx1;
RESULT:
	duckdb: []

-----------
QUERY:

SELECT * FROM vx1;
RESULT:
	duckdb: []

-----------
QUERY:


DROP VIEW vx1;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE tx1;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE tx2;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE tx3;
RESULT:
	duckdb: []

-----------
QUERY:


--
-- Test handling of vars from correlated subqueries in quals from outer
-- security barrier views, per bug #13988
--
CREATE TABLE t1 (a int, b text, c int);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name "t1" already exists!

-----------
QUERY:

INSERT INTO t1 VALUES (1, 'one', 10);
RESULT:
	duckdb: ERROR - Conversion Error: Could not convert string 'one' to FLOAT
LINE 2: INSERT INTO t1 VALUES (1, 'one', 10);
                                  ^

-----------
QUERY:


CREATE TABLE t2 (cc int);
RESULT:
	duckdb: []

-----------
QUERY:

INSERT INTO t2 VALUES (10), (20);
RESULT:
	duckdb: []

-----------
QUERY:


CREATE VIEW v1 WITH (security_barrier = true) AS
  SELECT * FROM t1 WHERE (a > 0)
  WITH CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW options

-----------
QUERY:


CREATE VIEW v2 WITH (security_barrier = true) AS
  SELECT * FROM v1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.cc = v1.c)
  WITH CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW options

-----------
QUERY:


INSERT INTO v2 VALUES (2, 'two', 20);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v2 does not exist!
Did you mean "t2"?

-----------
QUERY:
 -- ok
INSERT INTO v2 VALUES (-2, 'minus two', 20);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v2 does not exist!
Did you mean "t2"?

-----------
QUERY:
 -- not allowed
INSERT INTO v2 VALUES (3, 'three', 30);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v2 does not exist!
Did you mean "t2"?

-----------
QUERY:
 -- not allowed

UPDATE v2 SET b = 'ONE' WHERE a = 1;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v2 does not exist!
Did you mean "t2"?
LINE 3: UPDATE v2 SET b = 'ONE' WHERE a = 1;
               ^

-----------
QUERY:
 -- ok
UPDATE v2 SET a = -1 WHERE a = 1;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v2 does not exist!
Did you mean "t2"?
LINE 2: UPDATE v2 SET a = -1 WHERE a = 1;
               ^

-----------
QUERY:
 -- not allowed
UPDATE v2 SET c = 30 WHERE a = 1;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v2 does not exist!
Did you mean "t2"?
LINE 2: UPDATE v2 SET c = 30 WHERE a = 1;
               ^

-----------
QUERY:
 -- not allowed

DELETE FROM v2 WHERE a = 2;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v2 does not exist!
Did you mean "t2"?
LINE 3: DELETE FROM v2 WHERE a = 2;
                    ^

-----------
QUERY:
 -- ok
SELECT * FROM v2;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name v2 does not exist!
Did you mean "t2"?

-----------
QUERY:


DROP VIEW v2;
RESULT:
	duckdb: ERROR - Catalog Error: View with name v2 does not exist!
Did you mean "t2"?

-----------
QUERY:

DROP VIEW v1;
RESULT:
	duckdb: ERROR - Catalog Error: View with name v1 does not exist!
Did you mean "t1"?

-----------
QUERY:

DROP TABLE t2;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE t1;
RESULT:
	duckdb: []

-----------
QUERY:


--
-- Test sub-select in nested security barrier views, per bug #17972
--
CREATE TABLE t1 (a int);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE VIEW v1 WITH (security_barrier = true) AS
  SELECT * FROM t1;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW options

-----------
QUERY:

CREATE RULE v1_upd_rule AS ON UPDATE TO v1 DO INSTEAD
  UPDATE t1 SET a = NEW.a WHERE a = OLD.a;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "RULE"

-----------
QUERY:

CREATE VIEW v2 WITH (security_barrier = true) AS
  SELECT * FROM v1 WHERE EXISTS (SELECT 1);
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW options

-----------
QUERY:


EXPLAIN (COSTS OFF) UPDATE v2 SET a = 1;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: COSTS

-----------
QUERY:


DROP VIEW v2;
RESULT:
	duckdb: ERROR - Catalog Error: View with name v2 does not exist!
Did you mean "t1"?

-----------
QUERY:

DROP VIEW v1;
RESULT:
	duckdb: ERROR - Catalog Error: View with name v1 does not exist!
Did you mean "t1"?

-----------
QUERY:

DROP TABLE t1;
RESULT:
	duckdb: []

-----------
QUERY:


--
-- Test CREATE OR REPLACE VIEW turning a non-updatable view into an
-- auto-updatable view and adding check options in a single step
--
CREATE TABLE t1 (a int, b text);
RESULT:
	duckdb: []

-----------
QUERY:

CREATE VIEW v1 AS SELECT null::int AS a;
RESULT:
	duckdb: []

-----------
QUERY:

CREATE OR REPLACE VIEW v1 AS SELECT * FROM t1 WHERE a > 0 WITH CHECK OPTION;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:


INSERT INTO v1 VALUES (1, 'ok');
RESULT:
	duckdb: ERROR - Catalog Error: v1 is not an table

-----------
QUERY:
 -- ok
INSERT INTO v1 VALUES (-1, 'invalid');
RESULT:
	duckdb: ERROR - Catalog Error: v1 is not an table

-----------
QUERY:
 -- should fail

DROP VIEW v1;
RESULT:
	duckdb: []

-----------
QUERY:

DROP TABLE t1;
RESULT:
	duckdb: []

-----------
QUERY:


-- check that an auto-updatable view on a partitioned table works correctly
create table uv_pt (a int, b int, v varchar) partition by range (a, b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "partition"

-----------
QUERY:

create table uv_pt1 (b int not null, v varchar, a int not null) partition by range (b);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "partition"

-----------
QUERY:

create table uv_pt11 (like uv_pt1);
RESULT:
	duckdb: ERROR - Not implemented Error: ColumnDef type not handled yet

-----------
QUERY:

alter table uv_pt11 drop a;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name uv_pt11 does not exist!
Did you mean "pg_am"?

-----------
QUERY:

alter table uv_pt11 add a int;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name uv_pt11 does not exist!
Did you mean "pg_am"?

-----------
QUERY:

alter table uv_pt11 drop a;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name uv_pt11 does not exist!
Did you mean "pg_am"?

-----------
QUERY:

alter table uv_pt11 add a int not null;
RESULT:
	duckdb: ERROR - Parser Error: Adding columns with constraints not yet supported

-----------
QUERY:

alter table uv_pt1 attach partition uv_pt11 for values from (2) to (5);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "attach"

-----------
QUERY:

alter table uv_pt attach partition uv_pt1 for values from (1, 2) to (1, 10);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "attach"

-----------
QUERY:


create view uv_ptv as select * from uv_pt;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name uv_pt does not exist!
Did you mean "pg_am"?
LINE 3: create view uv_ptv as select * from uv_pt;
                                            ^

-----------
QUERY:

select events & 4 != 0 AS upd,
       events & 8 != 0 AS ins,
       events & 16 != 0 AS del
  from pg_catalog.pg_relation_is_updatable('uv_pt'::regclass, false) t(events);
RESULT:
	duckdb: ERROR - Catalog Error: Table Function with name pg_relation_is_updatable does not exist!
Did you mean "main.glob"?

-----------
QUERY:

select pg_catalog.pg_column_is_updatable('uv_pt'::regclass, 1::smallint, false);
RESULT:
	duckdb: ERROR - Catalog Error: Scalar Function with name pg_column_is_updatable does not exist!
Did you mean "main.count_star"?

-----------
QUERY:

select pg_catalog.pg_column_is_updatable('uv_pt'::regclass, 2::smallint, false);
RESULT:
	duckdb: ERROR - Catalog Error: Scalar Function with name pg_column_is_updatable does not exist!
Did you mean "main.count_star"?

-----------
QUERY:

select table_name, is_updatable, is_insertable_into
  from information_schema.views where table_name = 'uv_ptv';
RESULT:
	duckdb: ERROR - Catalog Error: Table with name views does not exist!
Did you mean "temp.pg_catalog.pg_views"?

-----------
QUERY:

select table_name, column_name, is_updatable
  from information_schema.columns where table_name = 'uv_ptv' order by column_name;
RESULT:
	duckdb: []

-----------
QUERY:

insert into uv_ptv values (1, 2);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name uv_ptv does not exist!
Did you mean "pg_am"?

-----------
QUERY:

select tableoid::regclass, * from uv_pt;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name uv_pt does not exist!
Did you mean "pg_am"?

-----------
QUERY:

create view uv_ptv_wco as select * from uv_pt where a = 0 with check option;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:

insert into uv_ptv_wco values (1, 2);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name uv_ptv_wco does not exist!
Did you mean "pg_am"?

-----------
QUERY:

merge into uv_ptv t
  using (values (1,2), (1,4)) as v(a,b) on t.a = v.a -- fail: matches 2 src rows
  when matched then update set b = t.b + 1
  when not matched then insert values (v.a, v.b + 1);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "merge"

-----------
QUERY:

merge into uv_ptv t
  using (values (1,2), (1,4)) as v(a,b) on t.a = v.a and t.b = v.b
  when matched then update set b = t.b + 1
  when not matched then insert values (v.a, v.b + 1);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "merge"

-----------
QUERY:
 -- fail: no partition for b=5
merge into uv_ptv t
  using (values (1,2), (1,3)) as v(a,b) on t.a = v.a and t.b = v.b
  when matched then update set b = t.b + 1
  when not matched then insert values (v.a, v.b + 1);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "merge"

-----------
QUERY:
 -- ok
select tableoid::regclass, * from uv_pt order by a, b;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name uv_pt does not exist!
Did you mean "pg_am"?

-----------
QUERY:

drop view uv_ptv, uv_ptv_wco;
RESULT:
	duckdb: ERROR - Not implemented Error: Can only drop one object at a time

-----------
QUERY:

drop table uv_pt, uv_pt1, uv_pt11;
RESULT:
	duckdb: ERROR - Not implemented Error: Can only drop one object at a time

-----------
QUERY:


-- check that wholerow vars appearing in WITH CHECK OPTION constraint expressions
-- work fine with partitioned tables
create table wcowrtest (a int) partition by list (a);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "partition"

-----------
QUERY:

create table wcowrtest1 partition of wcowrtest for values in (1);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "partition"

-----------
QUERY:

create view wcowrtest_v as select * from wcowrtest where wcowrtest = '(2)'::wcowrtest with check option;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:

insert into wcowrtest_v values (1);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name wcowrtest_v does not exist!
Did you mean "TEXT_TBL"?

-----------
QUERY:


alter table wcowrtest add b text;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name wcowrtest does not exist!
Did you mean "temp.information_schema.tables"?

-----------
QUERY:

create table wcowrtest2 (b text, c int, a int);
RESULT:
	duckdb: []

-----------
QUERY:

alter table wcowrtest2 drop c;
RESULT:
	duckdb: []

-----------
QUERY:

alter table wcowrtest attach partition wcowrtest2 for values in (2);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "attach"

-----------
QUERY:


create table sometable (a int, b text);
RESULT:
	duckdb: []

-----------
QUERY:

insert into sometable values (1, 'a'), (2, 'b');
RESULT:
	duckdb: []

-----------
QUERY:

create view wcowrtest_v2 as
    select *
      from wcowrtest r
      where r in (select s from sometable s where r.a = s.a)
with check option;
RESULT:
	duckdb: ERROR - Not implemented Error: VIEW CHECK options

-----------
QUERY:


-- WITH CHECK qual will be processed with wcowrtest2/* REPLACED */''s
-- rowtype after tuple-routing
insert into wcowrtest_v2 values (2, 'no such row in sometable');
RESULT:
	duckdb: ERROR - Catalog Error: Table with name wcowrtest_v2 does not exist!
Did you mean "wcowrtest2"?

-----------
QUERY:


drop view wcowrtest_v, wcowrtest_v2;
RESULT:
	duckdb: ERROR - Not implemented Error: Can only drop one object at a time

-----------
QUERY:

drop table wcowrtest, sometable;
RESULT:
	duckdb: ERROR - Not implemented Error: Can only drop one object at a time

-----------
QUERY:


-- Check INSERT .. ON CONFLICT DO UPDATE works correctly when the view/* REPLACED */''s
-- columns are named and ordered differently than the underlying table/* REPLACED */''s.
create table uv_iocu_tab (a text unique, b float);
RESULT:
	duckdb: []

-----------
QUERY:

insert into uv_iocu_tab values ('xyxyxy', 0);
RESULT:
	duckdb: []

-----------
QUERY:

create view uv_iocu_view as
   select b, b+1 as c, a, '2.0'::text as two from uv_iocu_tab;
RESULT:
	duckdb: []

-----------
QUERY:


insert into uv_iocu_view (a, b) values ('xyxyxy', 1)
   on conflict (a) do update set b = uv_iocu_view.b;
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:

select * from uv_iocu_tab;
RESULT:
	duckdb: [('xyxyxy', 0.0)]

-----------
QUERY:

insert into uv_iocu_view (a, b) values ('xyxyxy', 1)
   on conflict (a) do update set b = excluded.b;
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:

select * from uv_iocu_tab;
RESULT:
	duckdb: [('xyxyxy', 0.0)]

-----------
QUERY:


-- OK to access view columns that are not present in underlying base
-- relation in the ON CONFLICT portion of the query
insert into uv_iocu_view (a, b) values ('xyxyxy', 3)
   on conflict (a) do update set b = cast(excluded.two as float);
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:

select * from uv_iocu_tab;
RESULT:
	duckdb: [('xyxyxy', 0.0)]

-----------
QUERY:


explain (costs off)
insert into uv_iocu_view (a, b) values ('xyxyxy', 3)
   on conflict (a) do update set b = excluded.b where excluded.c > 0;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:


insert into uv_iocu_view (a, b) values ('xyxyxy', 3)
   on conflict (a) do update set b = excluded.b where excluded.c > 0;
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:

select * from uv_iocu_tab;
RESULT:
	duckdb: [('xyxyxy', 0.0)]

-----------
QUERY:


drop view uv_iocu_view;
RESULT:
	duckdb: []

-----------
QUERY:

drop table uv_iocu_tab;
RESULT:
	duckdb: []

-----------
QUERY:


-- Test whole-row references to the view
create table uv_iocu_tab (a int unique, b text);
RESULT:
	duckdb: []

-----------
QUERY:

create view uv_iocu_view as
    select b as bb, a as aa, uv_iocu_tab::text as cc from uv_iocu_tab;
RESULT:
	duckdb: []

-----------
QUERY:


insert into uv_iocu_view (aa,bb) values (1,'x');
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:

explain (costs off)
insert into uv_iocu_view (aa,bb) values (1,'y')
   on conflict (aa) do update set bb = 'Rejected: '||excluded.*
   where excluded.aa > 0
   and excluded.bb != ''
   and excluded.cc is not null;
RESULT:
	duckdb: ERROR - Not implemented Error: Unimplemented explain type: costs

-----------
QUERY:

insert into uv_iocu_view (aa,bb) values (1,'y')
   on conflict (aa) do update set bb = 'Rejected: '||excluded.*
   where excluded.aa > 0
   and excluded.bb != ''
   and excluded.cc is not null;
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:

select * from uv_iocu_view;
RESULT:
	duckdb: []

-----------
QUERY:


-- Test omitting a column of the base relation
delete from uv_iocu_view;
RESULT:
	duckdb: ERROR - Binder Error: Can only delete from base table!

-----------
QUERY:

insert into uv_iocu_view (aa,bb) values (1,'x');
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:

insert into uv_iocu_view (aa) values (1)
   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:

select * from uv_iocu_view;
RESULT:
	duckdb: []

-----------
QUERY:


alter table uv_iocu_tab alter column b set default 'table default';
RESULT:
	duckdb: []

-----------
QUERY:

insert into uv_iocu_view (aa) values (1)
   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:

select * from uv_iocu_view;
RESULT:
	duckdb: []

-----------
QUERY:


alter view uv_iocu_view alter column bb set default 'view default';
RESULT:
	duckdb: ERROR - Parser Error: Alter column's default is only supported for tables

-----------
QUERY:

insert into uv_iocu_view (aa) values (1)
   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:

select * from uv_iocu_view;
RESULT:
	duckdb: []

-----------
QUERY:


-- Should fail to update non-updatable columns
insert into uv_iocu_view (aa) values (1)
   on conflict (aa) do update set cc = 'XXX';
RESULT:
	duckdb: ERROR - Catalog Error: uv_iocu_view is not an table

-----------
QUERY:


drop view uv_iocu_view;
RESULT:
	duckdb: []

-----------
QUERY:

drop table uv_iocu_tab;
RESULT:
	duckdb: []

-----------
QUERY:


-- ON CONFLICT DO UPDATE permissions checks
create user regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "user"

-----------
QUERY:

create user regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "user"

-----------
QUERY:


set session authorization regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "authorization"

-----------
QUERY:

create table base_tbl(a int unique, b text, c float);
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tbl values (1,'xxx',1.0);
RESULT:
	duckdb: []

-----------
QUERY:

create view rw_view1 as select b as bb, c as cc, a as aa from base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view1" already exists!

-----------
QUERY:


grant select (aa,bb) on rw_view1 to regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "grant"

-----------
QUERY:

grant insert on rw_view1 to regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "grant"

-----------
QUERY:

grant update (bb) on rw_view1 to regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "grant"

-----------
QUERY:


set session authorization regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "authorization"

-----------
QUERY:

insert into rw_view1 values ('yyy',2.0,1)
  on conflict (aa) do update set bb = excluded.cc;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- Not allowed
insert into rw_view1 values ('yyy',2.0,1)
  on conflict (aa) do update set bb = rw_view1.cc;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- Not allowed
insert into rw_view1 values ('yyy',2.0,1)
  on conflict (aa) do update set bb = excluded.bb;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- OK
insert into rw_view1 values ('zzz',2.0,1)
  on conflict (aa) do update set bb = rw_view1.bb||'xxx';
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- OK
insert into rw_view1 values ('zzz',2.0,1)
  on conflict (aa) do update set cc = 3.0;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view1 is not an table

-----------
QUERY:
 -- Not allowed
reset session authorization;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "authorization"

-----------
QUERY:

select * from base_tbl;
RESULT:
	duckdb: [(1, 'xxx', 1.0)]

-----------
QUERY:


set session authorization regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "authorization"

-----------
QUERY:

grant select (a,b) on base_tbl to regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "grant"

-----------
QUERY:

grant insert (a,b) on base_tbl to regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "grant"

-----------
QUERY:

grant update (a,b) on base_tbl to regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "grant"

-----------
QUERY:


set session authorization regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "authorization"

-----------
QUERY:

create view rw_view2 as select b as bb, c as cc, a as aa from base_tbl;
RESULT:
	duckdb: ERROR - Catalog Error: View with name "rw_view2" already exists!

-----------
QUERY:

insert into rw_view2 (aa,bb) values (1,'xxx')
  on conflict (aa) do update set bb = excluded.bb;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view2 is not an table

-----------
QUERY:
 -- Not allowed
create view rw_view3 as select b as bb, a as aa from base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:

insert into rw_view3 (aa,bb) values (1,'xxx')
  on conflict (aa) do update set bb = excluded.bb;
RESULT:
	duckdb: ERROR - Catalog Error: rw_view3 is not an table

-----------
QUERY:
 -- OK
reset session authorization;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "authorization"

-----------
QUERY:

select * from base_tbl;
RESULT:
	duckdb: [(1, 'xxx', 1.0)]

-----------
QUERY:


set session authorization regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "authorization"

-----------
QUERY:

create view rw_view4 as select aa, bb, cc FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: No function matches the given name and argument types '+(INTEGER, VARCHAR)'. You might need to add explicit type casts.
	Candidate functions:
	+(TINYINT) -> TINYINT
	+(TINYINT, TINYINT) -> TINYINT
	+(SMALLINT) -> SMALLINT
	+(SMALLINT, SMALLINT) -> SMALLINT
	+(INTEGER) -> INTEGER
	+(INTEGER, INTEGER) -> INTEGER
	+(BIGINT) -> BIGINT
	+(BIGINT, BIGINT) -> BIGINT
	+(HUGEINT) -> HUGEINT
	+(HUGEINT, HUGEINT) -> HUGEINT
	+(FLOAT) -> FLOAT
	+(FLOAT, FLOAT) -> FLOAT
	+(DOUBLE) -> DOUBLE
	+(DOUBLE, DOUBLE) -> DOUBLE
	+(DECIMAL) -> DECIMAL
	+(DECIMAL, DECIMAL) -> DECIMAL
	+(UTINYINT) -> UTINYINT
	+(UTINYINT, UTINYINT) -> UTINYINT
	+(USMALLINT) -> USMALLINT
	+(USMALLINT, USMALLINT) -> USMALLINT
	+(UINTEGER) -> UINTEGER
	+(UINTEGER, UINTEGER) -> UINTEGER
	+(UBIGINT) -> UBIGINT
	+(UBIGINT, UBIGINT) -> UBIGINT
	+(UHUGEINT) -> UHUGEINT
	+(UHUGEINT, UHUGEINT) -> UHUGEINT
	+(DATE, INTEGER) -> DATE
	+(INTEGER, DATE) -> DATE
	+(INTERVAL, INTERVAL) -> INTERVAL
	+(DATE, INTERVAL) -> TIMESTAMP
	+(INTERVAL, DATE) -> TIMESTAMP
	+(TIME, INTERVAL) -> TIME
	+(INTERVAL, TIME) -> TIME
	+(TIMESTAMP, INTERVAL) -> TIMESTAMP
	+(INTERVAL, TIMESTAMP) -> TIMESTAMP
	+(TIME WITH TIME ZONE, INTERVAL) -> TIME WITH TIME ZONE
	+(INTERVAL, TIME WITH TIME ZONE) -> TIME WITH TIME ZONE
	+(TIME, DATE) -> TIMESTAMP
	+(DATE, TIME) -> TIMESTAMP
	+(TIME WITH TIME ZONE, DATE) -> TIMESTAMP WITH TIME ZONE
	+(DATE, TIME WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE
	+(ANY[], ANY[]) -> ANY[]
	+(TIMESTAMP WITH TIME ZONE, INTERVAL) -> TIMESTAMP WITH TIME ZONE
	+(INTERVAL, TIMESTAMP WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE


-----------
QUERY:

insert into rw_view4 (aa,bb) values (1,'yyy')
  on conflict (aa) do update set bb = excluded.bb;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view4 does not exist!
Did you mean "ro_view4"?

-----------
QUERY:
 -- Not allowed
create view rw_view5 as select aa, bb FROM rw_view1;
RESULT:
	duckdb: ERROR - Binder Error: No function matches the given name and argument types '+(INTEGER, VARCHAR)'. You might need to add explicit type casts.
	Candidate functions:
	+(TINYINT) -> TINYINT
	+(TINYINT, TINYINT) -> TINYINT
	+(SMALLINT) -> SMALLINT
	+(SMALLINT, SMALLINT) -> SMALLINT
	+(INTEGER) -> INTEGER
	+(INTEGER, INTEGER) -> INTEGER
	+(BIGINT) -> BIGINT
	+(BIGINT, BIGINT) -> BIGINT
	+(HUGEINT) -> HUGEINT
	+(HUGEINT, HUGEINT) -> HUGEINT
	+(FLOAT) -> FLOAT
	+(FLOAT, FLOAT) -> FLOAT
	+(DOUBLE) -> DOUBLE
	+(DOUBLE, DOUBLE) -> DOUBLE
	+(DECIMAL) -> DECIMAL
	+(DECIMAL, DECIMAL) -> DECIMAL
	+(UTINYINT) -> UTINYINT
	+(UTINYINT, UTINYINT) -> UTINYINT
	+(USMALLINT) -> USMALLINT
	+(USMALLINT, USMALLINT) -> USMALLINT
	+(UINTEGER) -> UINTEGER
	+(UINTEGER, UINTEGER) -> UINTEGER
	+(UBIGINT) -> UBIGINT
	+(UBIGINT, UBIGINT) -> UBIGINT
	+(UHUGEINT) -> UHUGEINT
	+(UHUGEINT, UHUGEINT) -> UHUGEINT
	+(DATE, INTEGER) -> DATE
	+(INTEGER, DATE) -> DATE
	+(INTERVAL, INTERVAL) -> INTERVAL
	+(DATE, INTERVAL) -> TIMESTAMP
	+(INTERVAL, DATE) -> TIMESTAMP
	+(TIME, INTERVAL) -> TIME
	+(INTERVAL, TIME) -> TIME
	+(TIMESTAMP, INTERVAL) -> TIMESTAMP
	+(INTERVAL, TIMESTAMP) -> TIMESTAMP
	+(TIME WITH TIME ZONE, INTERVAL) -> TIME WITH TIME ZONE
	+(INTERVAL, TIME WITH TIME ZONE) -> TIME WITH TIME ZONE
	+(TIME, DATE) -> TIMESTAMP
	+(DATE, TIME) -> TIMESTAMP
	+(TIME WITH TIME ZONE, DATE) -> TIMESTAMP WITH TIME ZONE
	+(DATE, TIME WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE
	+(ANY[], ANY[]) -> ANY[]
	+(TIMESTAMP WITH TIME ZONE, INTERVAL) -> TIMESTAMP WITH TIME ZONE
	+(INTERVAL, TIMESTAMP WITH TIME ZONE) -> TIMESTAMP WITH TIME ZONE

LINE 2: ...Not allowed
create view rw_view5 as select aa, bb FROM rw_view1;
                                                  ^

-----------
QUERY:

insert into rw_view5 (aa,bb) values (1,'yyy')
  on conflict (aa) do update set bb = excluded.bb;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name rw_view5 does not exist!
Did you mean "rw_view15"?

-----------
QUERY:
 -- OK
reset session authorization;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "authorization"

-----------
QUERY:

select * from base_tbl;
RESULT:
	duckdb: [(1, 'xxx', 1.0)]

-----------
QUERY:


drop view rw_view5;
RESULT:
	duckdb: ERROR - Catalog Error: View with name rw_view5 does not exist!
Did you mean "rw_view15"?

-----------
QUERY:

drop view rw_view4;
RESULT:
	duckdb: ERROR - Catalog Error: View with name rw_view4 does not exist!
Did you mean "ro_view4"?

-----------
QUERY:

drop view rw_view3;
RESULT:
	duckdb: []

-----------
QUERY:

drop view rw_view2;
RESULT:
	duckdb: []

-----------
QUERY:

drop view rw_view1;
RESULT:
	duckdb: []

-----------
QUERY:

drop table base_tbl;
RESULT:
	duckdb: []

-----------
QUERY:

drop user regress_view_user1;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "user"

-----------
QUERY:

drop user regress_view_user2;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "user"

-----------
QUERY:


-- Test single- and multi-row inserts with table and view defaults.
-- Table defaults should be used, unless overridden by view defaults.
create table base_tab_def (a int, b text default 'Table default',
                           c text default 'Table default', d text, e text);
RESULT:
	duckdb: []

-----------
QUERY:

create view base_tab_def_view as select * from base_tab_def;
RESULT:
	duckdb: []

-----------
QUERY:

alter view base_tab_def_view alter b set default 'View default';
RESULT:
	duckdb: ERROR - Parser Error: Alter column's default is only supported for tables

-----------
QUERY:

alter view base_tab_def_view alter d set default 'View default';
RESULT:
	duckdb: ERROR - Parser Error: Alter column's default is only supported for tables

-----------
QUERY:

insert into base_tab_def values (1);
RESULT:
	duckdb: ERROR - Binder Error: table base_tab_def has 5 columns but 1 values were supplied

-----------
QUERY:

insert into base_tab_def values (2), (3);
RESULT:
	duckdb: ERROR - Binder Error: table base_tab_def has 5 columns but 1 values were supplied

-----------
QUERY:

insert into base_tab_def values (4, default, default, default, default);
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def values (5, default, default, default, default),
                                (6, default, default, default, default);
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def_view values (11);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (12), (13);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (14, default, default, default, default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (15, default, default, default, default),
                                     (16, default, default, default, default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (17), (default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

select * from base_tab_def order by a;
RESULT:
	duckdb: [(4, 'Table default', 'Table default', None, None), (5, 'Table default', 'Table default', None, None), (6, 'Table default', 'Table default', None, None)]

-----------
QUERY:


-- Adding an INSTEAD OF trigger should cause NULLs to be inserted instead of
-- table defaults, where there are no view defaults.
create function base_tab_def_view_instrig_func() returns trigger
as
$$
begin
  insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
  return new;
end;
$$
language plpgsql;
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "returns"

-----------
QUERY:

create trigger base_tab_def_view_instrig instead of insert on base_tab_def_view
  for each row execute function base_tab_def_view_instrig_func();
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "trigger"

-----------
QUERY:

truncate base_tab_def;
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def values (1);
RESULT:
	duckdb: ERROR - Binder Error: table base_tab_def has 5 columns but 1 values were supplied

-----------
QUERY:

insert into base_tab_def values (2), (3);
RESULT:
	duckdb: ERROR - Binder Error: table base_tab_def has 5 columns but 1 values were supplied

-----------
QUERY:

insert into base_tab_def values (4, default, default, default, default);
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def values (5, default, default, default, default),
                                (6, default, default, default, default);
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def_view values (11);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (12), (13);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (14, default, default, default, default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (15, default, default, default, default),
                                     (16, default, default, default, default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (17), (default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

select * from base_tab_def order by a;
RESULT:
	duckdb: [(4, 'Table default', 'Table default', None, None), (5, 'Table default', 'Table default', None, None), (6, 'Table default', 'Table default', None, None)]

-----------
QUERY:


-- Using an unconditional DO INSTEAD rule should also cause NULLs to be
-- inserted where there are no view defaults.
drop trigger base_tab_def_view_instrig on base_tab_def_view;
RESULT:
	duckdb: ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

drop function base_tab_def_view_instrig_func;
RESULT:
	duckdb: ERROR - Catalog Error: Macro Function with name base_tab_def_view_instrig_func does not exist!
Did you mean "date_trunc"?

-----------
QUERY:

create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view
  do instead insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

truncate base_tab_def;
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def values (1);
RESULT:
	duckdb: ERROR - Binder Error: table base_tab_def has 5 columns but 1 values were supplied

-----------
QUERY:

insert into base_tab_def values (2), (3);
RESULT:
	duckdb: ERROR - Binder Error: table base_tab_def has 5 columns but 1 values were supplied

-----------
QUERY:

insert into base_tab_def values (4, default, default, default, default);
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def values (5, default, default, default, default),
                                (6, default, default, default, default);
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def_view values (11);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (12), (13);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (14, default, default, default, default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (15, default, default, default, default),
                                     (16, default, default, default, default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (17), (default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

select * from base_tab_def order by a;
RESULT:
	duckdb: [(4, 'Table default', 'Table default', None, None), (5, 'Table default', 'Table default', None, None), (6, 'Table default', 'Table default', None, None)]

-----------
QUERY:


-- A DO ALSO rule should cause each row to be inserted twice. The first
-- insert should behave the same as an auto-updatable view (using table
-- defaults, unless overridden by view defaults). The second insert should
-- behave the same as a rule-updatable view (inserting NULLs where there are
-- no view defaults).
drop rule base_tab_def_view_ins_rule on base_tab_def_view;
RESULT:
	duckdb: ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view
  do also insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

truncate base_tab_def;
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def values (1);
RESULT:
	duckdb: ERROR - Binder Error: table base_tab_def has 5 columns but 1 values were supplied

-----------
QUERY:

insert into base_tab_def values (2), (3);
RESULT:
	duckdb: ERROR - Binder Error: table base_tab_def has 5 columns but 1 values were supplied

-----------
QUERY:

insert into base_tab_def values (4, default, default, default, default);
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def values (5, default, default, default, default),
                                (6, default, default, default, default);
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def_view values (11);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (12), (13);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (14, default, default, default, default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (15, default, default, default, default),
                                     (16, default, default, default, default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (17), (default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

select * from base_tab_def order by a, c NULLS LAST;
RESULT:
	duckdb: [(4, 'Table default', 'Table default', None, None), (5, 'Table default', 'Table default', None, None), (6, 'Table default', 'Table default', None, None)]

-----------
QUERY:


-- Test a DO ALSO INSERT ... SELECT rule
drop rule base_tab_def_view_ins_rule on base_tab_def_view;
RESULT:
	duckdb: ERROR - Not implemented Error: Cannot drop this type yet

-----------
QUERY:

create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view
  do also insert into base_tab_def (a, b, e) select new.a, new.b, 'xxx';
RESULT:
	duckdb: ERROR - Parser Error: syntax error at or near "rule"

-----------
QUERY:

truncate base_tab_def;
RESULT:
	duckdb: []

-----------
QUERY:

insert into base_tab_def_view values (1, default, default, default, default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

insert into base_tab_def_view values (2, default, default, default, default),
                                     (3, default, default, default, default);
RESULT:
	duckdb: ERROR - Catalog Error: base_tab_def_view is not an table

-----------
QUERY:

select * from base_tab_def order by a, e nulls first;
RESULT:
	duckdb: []

-----------
QUERY:


drop view base_tab_def_view;
RESULT:
	duckdb: []

-----------
QUERY:

drop table base_tab_def;
RESULT:
	duckdb: []

-----------
QUERY:


-- Test defaults with array assignments
create table base_tab (a serial, b int[], c text, d text default 'Table default');
RESULT:
	duckdb: ERROR - Catalog Error: Type with name serial does not exist!
Did you mean "real"?

-----------
QUERY:

create view base_tab_view as select c, a, b from base_tab;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tab does not exist!
Did you mean "ref_tbl"?
LINE 2: ...ew base_tab_view as select c, a, b from base_tab;
                                                  ^

-----------
QUERY:

alter view base_tab_view alter column c set default 'View default';
RESULT:
	duckdb: ERROR - Parser Error: Alter column's default is only supported for tables

-----------
QUERY:

insert into base_tab_view (b[1], b[2], c, b[5], b[4], a, b[3])
values (1, 2, default, 5, 4, default, 3), (10, 11, 'C value', 14, 13, 100, 12);
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tab_view does not exist!
Did you mean "base_tbl_parent"?

-----------
QUERY:

select * from base_tab order by a;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tab does not exist!
Did you mean "ref_tbl"?

-----------
QUERY:

drop view base_tab_view;
RESULT:
	duckdb: ERROR - Catalog Error: View with name base_tab_view does not exist!
Did you mean "base_tbl_parent"?

-----------
QUERY:

drop table base_tab;
RESULT:
	duckdb: ERROR - Catalog Error: Table with name base_tab does not exist!
Did you mean "ref_tbl"?
