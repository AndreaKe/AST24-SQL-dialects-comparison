
-----------
QUERY:
CREATE TABLE xmltest (
    id int,
    data xml
)
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmltest VALUES (1, '<value>one</value>')
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmltest VALUES (2, '<value>two</value>')
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmltest VALUES (3, '<wrong')
RESULT:
	postgres: invalid XML content
LINE 1: INSERT INTO xmltest VALUES (3, '<wrong')
                                       ^
DETAIL:  line 1: Couldn't find end of Start Tag wrong line 1
<wrong
      ^


-----------
QUERY:
SELECT * FROM xmltest
RESULT:
	postgres: [(1, '<value>one</value>'), (2, '<value>two</value>')]

-----------
QUERY:
-- test non-throwing API, too
SELECT pg_input_is_valid('<value>one</value>', 'xml')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT pg_input_is_valid('<value>one</', 'xml')
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT message FROM pg_input_error_info('<value>one</', 'xml')
RESULT:
	postgres: [('invalid XML content',)]

-----------
QUERY:
SELECT pg_input_is_valid('<?xml version="1.0" standalone="y"?><foo/>', 'xml')
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT message FROM pg_input_error_info('<?xml version="1.0" standalone="y"?><foo/>', 'xml')
RESULT:
	postgres: [('invalid XML content: invalid XML declaration',)]

-----------
QUERY:
SELECT xmlcomment('test')
RESULT:
	postgres: [('<!--test-->',)]

-----------
QUERY:
SELECT xmlcomment('-test')
RESULT:
	postgres: [('<!---test-->',)]

-----------
QUERY:
SELECT xmlcomment('test-')
RESULT:
	postgres: invalid XML comment


-----------
QUERY:
SELECT xmlcomment('--test')
RESULT:
	postgres: invalid XML comment


-----------
QUERY:
SELECT xmlcomment('te st')
RESULT:
	postgres: [('<!--te st-->',)]

-----------
QUERY:
SELECT xmlconcat(xmlcomment('hello'),
                 xmlelement(NAME qux, 'foo'),
                 xmlcomment('world'))
RESULT:
	postgres: [('<!--hello--><qux>foo</qux><!--world-->',)]

-----------
QUERY:
SELECT xmlconcat('hello', 'you')
RESULT:
	postgres: [('helloyou',)]

-----------
QUERY:
SELECT xmlconcat(1, 2)
RESULT:
	postgres: argument of XMLCONCAT must be type xml, not type integer
LINE 1: SELECT xmlconcat(1, 2)
                         ^


-----------
QUERY:
SELECT xmlconcat('bad', '<syntax')
RESULT:
	postgres: invalid XML content
LINE 1: SELECT xmlconcat('bad', '<syntax')
                                ^
DETAIL:  line 1: Couldn't find end of Start Tag syntax line 1
<syntax
       ^


-----------
QUERY:
SELECT xmlconcat('<foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>')
RESULT:
	postgres: [('<foo/><bar/>',)]

-----------
QUERY:
SELECT xmlconcat('<?xml version="1.1"?><foo/>', NULL, '<?xml version="1.1" standalone="no"?><bar/>')
RESULT:
	postgres: [('<?xml version="1.1"?><foo/><bar/>',)]

-----------
QUERY:
SELECT xmlconcat(NULL)
RESULT:
	postgres: [(None,)]

-----------
QUERY:
SELECT xmlconcat(NULL, NULL)
RESULT:
	postgres: [(None,)]

-----------
QUERY:
SELECT xmlelement(name element,
                  xmlattributes (1 as one, 'deuce' as two),
                  'content')
RESULT:
	postgres: [('<element one="1" two="deuce">content</element>',)]

-----------
QUERY:
SELECT xmlelement(name element,
                  xmlattributes ('unnamed and wrong'))
RESULT:
	postgres: unnamed XML attribute value must be a column reference
LINE 2:                   xmlattributes ('unnamed and wrong'))
                                         ^


-----------
QUERY:
SELECT xmlelement(name element, xmlelement(name nested, 'stuff'))
RESULT:
	postgres: [('<element><nested>stuff</nested></element>',)]

-----------
QUERY:
SELECT xmlelement(name employee, xmlforest(name, age, salary as pay)) FROM emp
RESULT:
	postgres: [('<employee><name>sharon</name><age>25</age><pay>1000</pay></employee>',), ('<employee><name>sam</name><age>30</age><pay>2000</pay></employee>',), ('<employee><name>bill</name><age>20</age><pay>1000</pay></employee>',), ('<employee><name>jeff</name><age>23</age><pay>600</pay></employee>',), ('<employee><name>cim</name><age>30</age><pay>400</pay></employee>',), ('<employee><name>linda</name><age>19</age><pay>100</pay></employee>',)]

-----------
QUERY:
SELECT xmlelement(name duplicate, xmlattributes(1 as a, 2 as b, 3 as a))
RESULT:
	postgres: XML attribute name "a" appears more than once
LINE 1: ...ement(name duplicate, xmlattributes(1 as a, 2 as b, 3 as a))
                                                               ^


-----------
QUERY:
SELECT xmlelement(name num, 37)
RESULT:
	postgres: [('<num>37</num>',)]

-----------
QUERY:
SELECT xmlelement(name foo, text 'bar')
RESULT:
	postgres: [('<foo>bar</foo>',)]

-----------
QUERY:
SELECT xmlelement(name foo, xml 'bar')
RESULT:
	postgres: [('<foo>bar</foo>',)]

-----------
QUERY:
SELECT xmlelement(name foo, text 'b<a/>r')
RESULT:
	postgres: [('<foo>b&lt;a/&gt;r</foo>',)]

-----------
QUERY:
SELECT xmlelement(name foo, xml 'b<a/>r')
RESULT:
	postgres: [('<foo>b<a/>r</foo>',)]

-----------
QUERY:
SELECT xmlelement(name foo, array[1, 2, 3])
RESULT:
	postgres: [('<foo><element>1</element><element>2</element><element>3</element></foo>',)]

-----------
QUERY:
SET xmlbinary TO base64
RESULT:
	postgres: None

-----------
QUERY:
SELECT xmlelement(name foo, bytea 'bar')
RESULT:
	postgres: [('<foo>YmFy</foo>',)]

-----------
QUERY:
SET xmlbinary TO hex
RESULT:
	postgres: None

-----------
QUERY:
SELECT xmlelement(name foo, bytea 'bar')
RESULT:
	postgres: [('<foo>626172</foo>',)]

-----------
QUERY:
SELECT xmlelement(name foo, xmlattributes(true as bar))
RESULT:
	postgres: [('<foo bar="true"/>',)]

-----------
QUERY:
SELECT xmlelement(name foo, xmlattributes('2009-04-09 00:24:37'::timestamp as bar))
RESULT:
	postgres: [('<foo bar="2009-04-09T00:24:37"/>',)]

-----------
QUERY:
SELECT xmlelement(name foo, xmlattributes('infinity'::timestamp as bar))
RESULT:
	postgres: timestamp out of range
DETAIL:  XML does not support infinite timestamp values.


-----------
QUERY:
SELECT xmlelement(name foo, xmlattributes('<>&"''' as funny, xml 'b<a/>r' as funnier))
RESULT:
	postgres: [('<foo funny="&lt;&gt;&amp;&quot;\'" funnier="b&lt;a/&gt;r"/>',)]

-----------
QUERY:
SELECT xmlparse(content '')
RESULT:
	postgres: [('',)]

-----------
QUERY:
SELECT xmlparse(content '  ')
RESULT:
	postgres: [('  ',)]

-----------
QUERY:
SELECT xmlparse(content 'abc')
RESULT:
	postgres: [('abc',)]

-----------
QUERY:
SELECT xmlparse(content '<abc>x</abc>')
RESULT:
	postgres: [('<abc>x</abc>',)]

-----------
QUERY:
SELECT xmlparse(content '<invalidentity>&</invalidentity>')
RESULT:
	postgres: invalid XML content
DETAIL:  line 1: xmlParseEntityRef: no name
<invalidentity>&</invalidentity>
                ^
line 1: chunk is not well balanced
<invalidentity>&</invalidentity>
                                ^


-----------
QUERY:
SELECT xmlparse(content '<undefinedentity>&idontexist
RESULT:
	postgres: unterminated quoted string at or near "'<undefinedentity>&idontexist
"
LINE 1: SELECT xmlparse(content '<undefinedentity>&idontexist
                                ^


-----------
QUERY:
</undefinedentity>')
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </undefinedentity>')
        ^


-----------
QUERY:
SELECT xmlparse(content '<invalidns xmlns=''&lt
RESULT:
	postgres: unterminated quoted string at or near "'<invalidns xmlns=''&lt
"
LINE 1: SELECT xmlparse(content '<invalidns xmlns=''&lt
                                ^


-----------
QUERY:
''/>')
RESULT:
	postgres: syntax error at or near "''"
LINE 1: ''/>')
        ^


-----------
QUERY:
SELECT xmlparse(content '<relativens xmlns=''relative''/>')
RESULT:
	postgres: [("<relativens xmlns='relative'/>",)]

-----------
QUERY:
SELECT xmlparse(content '<twoerrors>&idontexist
RESULT:
	postgres: unterminated quoted string at or near "'<twoerrors>&idontexist
"
LINE 1: SELECT xmlparse(content '<twoerrors>&idontexist
                                ^


-----------
QUERY:
</unbalanced>')
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </unbalanced>')
        ^


-----------
QUERY:
SELECT xmlparse(content '<nosuchprefix:tag/>')
RESULT:
	postgres: [('<nosuchprefix:tag/>',)]

-----------
QUERY:
SELECT xmlparse(document '   ')
RESULT:
	postgres: invalid XML document
DETAIL:  line 1: Start tag expected, '<' not found
   
   ^


-----------
QUERY:
SELECT xmlparse(document 'abc')
RESULT:
	postgres: invalid XML document
DETAIL:  line 1: Start tag expected, '<' not found
abc
^


-----------
QUERY:
SELECT xmlparse(document '<abc>x</abc>')
RESULT:
	postgres: [('<abc>x</abc>',)]

-----------
QUERY:
SELECT xmlparse(document '<invalidentity>&</abc>')
RESULT:
	postgres: invalid XML document
DETAIL:  line 1: xmlParseEntityRef: no name
<invalidentity>&</abc>
                ^
line 1: Opening and ending tag mismatch: invalidentity line 1 and abc
<invalidentity>&</abc>
                      ^


-----------
QUERY:
SELECT xmlparse(document '<undefinedentity>&idontexist
RESULT:
	postgres: unterminated quoted string at or near "'<undefinedentity>&idontexist
"
LINE 1: SELECT xmlparse(document '<undefinedentity>&idontexist
                                 ^


-----------
QUERY:
</abc>')
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </abc>')
        ^


-----------
QUERY:
SELECT xmlparse(document '<invalidns xmlns=''&lt
RESULT:
	postgres: unterminated quoted string at or near "'<invalidns xmlns=''&lt
"
LINE 1: SELECT xmlparse(document '<invalidns xmlns=''&lt
                                 ^


-----------
QUERY:
''/>')
RESULT:
	postgres: syntax error at or near "''"
LINE 1: ''/>')
        ^


-----------
QUERY:
SELECT xmlparse(document '<relativens xmlns=''relative''/>')
RESULT:
	postgres: [("<relativens xmlns='relative'/>",)]

-----------
QUERY:
SELECT xmlparse(document '<twoerrors>&idontexist
RESULT:
	postgres: unterminated quoted string at or near "'<twoerrors>&idontexist
"
LINE 1: SELECT xmlparse(document '<twoerrors>&idontexist
                                 ^


-----------
QUERY:
</unbalanced>')
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </unbalanced>')
        ^


-----------
QUERY:
SELECT xmlparse(document '<nosuchprefix:tag/>')
RESULT:
	postgres: [('<nosuchprefix:tag/>',)]

-----------
QUERY:
SELECT xmlpi(name foo)
RESULT:
	postgres: [('<?foo?>',)]

-----------
QUERY:
SELECT xmlpi(name xml)
RESULT:
	postgres: invalid XML processing instruction
DETAIL:  XML processing instruction target name cannot be "xml".


-----------
QUERY:
SELECT xmlpi(name xmlstuff)
RESULT:
	postgres: [('<?xmlstuff?>',)]

-----------
QUERY:
SELECT xmlpi(name foo, 'bar')
RESULT:
	postgres: [('<?foo bar?>',)]

-----------
QUERY:
SELECT xmlpi(name foo, 'in?>valid')
RESULT:
	postgres: invalid XML processing instruction
DETAIL:  XML processing instruction cannot contain "?>".


-----------
QUERY:
SELECT xmlpi(name foo, null)
RESULT:
	postgres: [(None,)]

-----------
QUERY:
SELECT xmlpi(name xml, null)
RESULT:
	postgres: invalid XML processing instruction
DETAIL:  XML processing instruction target name cannot be "xml".


-----------
QUERY:
SELECT xmlpi(name xmlstuff, null)
RESULT:
	postgres: [(None,)]

-----------
QUERY:
SELECT xmlpi(name "xml-stylesheet", 'href="mystyle.css" type="text/css"')
RESULT:
	postgres: [('<?xml-stylesheet href="mystyle.css" type="text/css"?>',)]

-----------
QUERY:
SELECT xmlpi(name foo, '   bar')
RESULT:
	postgres: [('<?foo bar?>',)]

-----------
QUERY:
SELECT xmlroot(xml '<foo/>', version no value, standalone no value)
RESULT:
	postgres: [('<foo/>',)]

-----------
QUERY:
SELECT xmlroot(xml '<foo/>', version '2.0')
RESULT:
	postgres: [('<?xml version="2.0"?><foo/>',)]

-----------
QUERY:
SELECT xmlroot(xml '<foo/>', version no value, standalone yes)
RESULT:
	postgres: [('<?xml version="1.0" standalone="yes"?><foo/>',)]

-----------
QUERY:
SELECT xmlroot(xml '<?xml version="1.1"?><foo/>', version no value, standalone yes)
RESULT:
	postgres: [('<?xml version="1.0" standalone="yes"?><foo/>',)]

-----------
QUERY:
SELECT xmlroot(xmlroot(xml '<foo/>', version '1.0'), version '1.1', standalone no)
RESULT:
	postgres: [('<?xml version="1.1" standalone="no"?><foo/>',)]

-----------
QUERY:
SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no)
RESULT:
	postgres: [('<?xml version="1.0" standalone="no"?><foo/>',)]

-----------
QUERY:
SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value, standalone no value)
RESULT:
	postgres: [('<foo/>',)]

-----------
QUERY:
SELECT xmlroot('<?xml version="1.1" standalone="yes"?><foo/>', version no value)
RESULT:
	postgres: [('<?xml version="1.0" standalone="yes"?><foo/>',)]

-----------
QUERY:
SELECT xmlroot (
  xmlelement (
    name gazonk,
    xmlattributes (
      'val' AS name,
      1 + 1 AS num
    ),
    xmlelement (
      NAME qux,
      'foo'
    )
  ),
  version '1.0',
  standalone yes
)
RESULT:
	postgres: [('<?xml version="1.0" standalone="yes"?><gazonk name="val" num="2"><qux>foo</qux></gazonk>',)]

-----------
QUERY:
SELECT xmlserialize(content data as character varying(20)) FROM xmltest
RESULT:
	postgres: [('<value>one</value>',), ('<value>two</value>',)]

-----------
QUERY:
SELECT xmlserialize(content 'good' as char(10))
RESULT:
	postgres: [('good      ',)]

-----------
QUERY:
SELECT xmlserialize(document 'bad' as text)
RESULT:
	postgres: not an XML document


-----------
QUERY:
-- indent
SELECT xmlserialize(DOCUMENT '<foo><bar><val x="y">42</val></bar></foo>' AS text INDENT)
RESULT:
	postgres: [('<foo>\n  <bar>\n    <val x="y">42</val>\n  </bar>\n</foo>\n',)]

-----------
QUERY:
SELECT xmlserialize(CONTENT  '<foo><bar><val x="y">42</val></bar></foo>' AS text INDENT)
RESULT:
	postgres: [('<foo>\n  <bar>\n    <val x="y">42</val>\n  </bar>\n</foo>',)]

-----------
QUERY:
-- no indent
SELECT xmlserialize(DOCUMENT '<foo><bar><val x="y">42</val></bar></foo>' AS text NO INDENT)
RESULT:
	postgres: [('<foo><bar><val x="y">42</val></bar></foo>',)]

-----------
QUERY:
SELECT xmlserialize(CONTENT  '<foo><bar><val x="y">42</val></bar></foo>' AS text NO INDENT)
RESULT:
	postgres: [('<foo><bar><val x="y">42</val></bar></foo>',)]

-----------
QUERY:
-- indent non singly-rooted xml
SELECT xmlserialize(DOCUMENT '<foo>73</foo><bar><val x="y">42</val></bar>' AS text INDENT)
RESULT:
	postgres: not an XML document


-----------
QUERY:
SELECT xmlserialize(CONTENT  '<foo>73</foo><bar><val x="y">42</val></bar>' AS text INDENT)
RESULT:
	postgres: [('<foo>73</foo>\n<bar>\n  <val x="y">42</val>\n</bar>',)]

-----------
QUERY:
-- indent non singly-rooted xml with mixed contents
SELECT xmlserialize(DOCUMENT 'text node<foo>73</foo>text node<bar><val x="y">42</val></bar>' AS text INDENT)
RESULT:
	postgres: not an XML document


-----------
QUERY:
SELECT xmlserialize(CONTENT  'text node<foo>73</foo>text node<bar><val x="y">42</val></bar>' AS text INDENT)
RESULT:
	postgres: [('text node\n<foo>73</foo>text node\n<bar>\n  <val x="y">42</val>\n</bar>',)]

-----------
QUERY:
-- indent singly-rooted xml with mixed contents
SELECT xmlserialize(DOCUMENT '<foo><bar><val x="y">42</val><val x="y">text node<val>73</val></val></bar></foo>' AS text INDENT)
RESULT:
	postgres: [('<foo>\n  <bar>\n    <val x="y">42</val>\n    <val x="y">text node<val>73</val></val>\n  </bar>\n</foo>\n',)]

-----------
QUERY:
SELECT xmlserialize(CONTENT  '<foo><bar><val x="y">42</val><val x="y">text node<val>73</val></val></bar></foo>' AS text INDENT)
RESULT:
	postgres: [('<foo>\n  <bar>\n    <val x="y">42</val>\n    <val x="y">text node<val>73</val></val>\n  </bar>\n</foo>',)]

-----------
QUERY:
-- indent empty string
SELECT xmlserialize(DOCUMENT '' AS text INDENT)
RESULT:
	postgres: not an XML document


-----------
QUERY:
SELECT xmlserialize(CONTENT  '' AS text INDENT)
RESULT:
	postgres: [('',)]

-----------
QUERY:
-- whitespaces
SELECT xmlserialize(DOCUMENT '  ' AS text INDENT)
RESULT:
	postgres: not an XML document


-----------
QUERY:
SELECT xmlserialize(CONTENT  '  ' AS text INDENT)
RESULT:
	postgres: [('  ',)]

-----------
QUERY:
-- indent null
SELECT xmlserialize(DOCUMENT NULL AS text INDENT)
RESULT:
	postgres: [(None,)]

-----------
QUERY:
SELECT xmlserialize(CONTENT  NULL AS text INDENT)
RESULT:
	postgres: [(None,)]

-----------
QUERY:
-- indent with XML declaration
SELECT xmlserialize(DOCUMENT '<?xml version="1.0" encoding="UTF-8"?><foo><bar><val>73</val></bar></foo>' AS text INDENT)
RESULT:
	postgres: [('<?xml version="1.0" encoding="UTF-8"?>\n<foo>\n  <bar>\n    <val>73</val>\n  </bar>\n</foo>\n',)]

-----------
QUERY:
SELECT xmlserialize(CONTENT  '<?xml version="1.0" encoding="UTF-8"?><foo><bar><val>73</val></bar></foo>' AS text INDENT)
RESULT:
	postgres: [('<foo>\n  <bar>\n    <val>73</val>\n  </bar>\n</foo>',)]

-----------
QUERY:
-- indent containing DOCTYPE declaration
SELECT xmlserialize(DOCUMENT '<!DOCTYPE a><a/>' AS text INDENT)
RESULT:
	postgres: [('<!DOCTYPE a>\n<a/>\n',)]

-----------
QUERY:
SELECT xmlserialize(CONTENT  '<!DOCTYPE a><a/>' AS text INDENT)
RESULT:
	postgres: [('<!DOCTYPE a>\n<a/>\n',)]

-----------
QUERY:
-- indent xml with empty element
SELECT xmlserialize(DOCUMENT '<foo><bar></bar></foo>' AS text INDENT)
RESULT:
	postgres: [('<foo>\n  <bar/>\n</foo>\n',)]

-----------
QUERY:
SELECT xmlserialize(CONTENT  '<foo><bar></bar></foo>' AS text INDENT)
RESULT:
	postgres: [('<foo>\n  <bar/>\n</foo>',)]

-----------
QUERY:
-- /* REPLACED */''no indent/* REPLACED */'' = not using /* REPLACED */''no indent/* REPLACED */''
SELECT xmlserialize(DOCUMENT '<foo><bar><val x="y">42</val></bar></foo>' AS text) = xmlserialize(DOCUMENT '<foo><bar><val x="y">42</val></bar></foo>' AS text NO INDENT)
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xmlserialize(CONTENT  '<foo><bar><val x="y">42</val></bar></foo>' AS text) = xmlserialize(CONTENT '<foo><bar><val x="y">42</val></bar></foo>' AS text NO INDENT)
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xml '<foo>bar</foo>' IS DOCUMENT
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xml '<foo>bar</foo><bar>foo</bar>' IS DOCUMENT
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xml '<abc/>' IS NOT DOCUMENT
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xml 'abc' IS NOT DOCUMENT
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT '<>' IS NOT DOCUMENT
RESULT:
	postgres: invalid XML content
LINE 1: SELECT '<>' IS NOT DOCUMENT
               ^
DETAIL:  line 1: StartTag: invalid element name
<>
 ^


-----------
QUERY:
SELECT xmlagg(data) FROM xmltest
RESULT:
	postgres: [('<value>one</value><value>two</value>',)]

-----------
QUERY:
SELECT xmlagg(data) FROM xmltest WHERE id > 10
RESULT:
	postgres: [(None,)]

-----------
QUERY:
SELECT xmlelement(name employees, xmlagg(xmlelement(name name, name))) FROM emp
RESULT:
	postgres: [('<employees><name>sharon</name><name>sam</name><name>bill</name><name>jeff</name><name>cim</name><name>linda</name></employees>',)]

-----------
QUERY:
-- Check mapping SQL identifier to XML name

SELECT xmlpi(name ":::_xml_abc135.%-&_")
RESULT:
	postgres: [('<?_x003A_::_x005F_xml_abc135._x0025_-_x0026__?>',)]

-----------
QUERY:
SELECT xmlpi(name "123")
RESULT:
	postgres: [('<?_x0031_23?>',)]

-----------
QUERY:
PREPARE foo (xml) AS SELECT xmlconcat('<foo/>', $1)
RESULT:
	postgres: None

-----------
QUERY:
SET XML OPTION DOCUMENT
RESULT:
	postgres: None

-----------
QUERY:
EXECUTE foo ('<bar/>')
RESULT:
	postgres: [('<foo/><bar/>',)]

-----------
QUERY:
EXECUTE foo ('bad')
RESULT:
	postgres: invalid XML document
LINE 1: EXECUTE foo ('bad')
                     ^
DETAIL:  line 1: Start tag expected, '<' not found
bad
^


-----------
QUERY:
SELECT xml '<!DOCTYPE a><a/><b/>'
RESULT:
	postgres: invalid XML document
LINE 1: SELECT xml '<!DOCTYPE a><a/><b/>'
                   ^
DETAIL:  line 1: Extra content at the end of the document
<!DOCTYPE a><a/><b/>
                ^


-----------
QUERY:
SET XML OPTION CONTENT
RESULT:
	postgres: None

-----------
QUERY:
EXECUTE foo ('<bar/>')
RESULT:
	postgres: [('<foo/><bar/>',)]

-----------
QUERY:
EXECUTE foo ('good')
RESULT:
	postgres: [('<foo/>good',)]

-----------
QUERY:
SELECT xml '<!-- in SQL:2006+ a doc is content too--> <?y z?> <!DOCTYPE a><a/>'
RESULT:
	postgres: [('<!-- in SQL:2006+ a doc is content too--> <?y z?> <!DOCTYPE a><a/>',)]

-----------
QUERY:
SELECT xml '<?xml version="1.0"?> <!-- hi--> <!DOCTYPE a><a/>'
RESULT:
	postgres: [(' <!-- hi--> <!DOCTYPE a><a/>',)]

-----------
QUERY:
SELECT xml '<!DOCTYPE a><a/>'
RESULT:
	postgres: [('<!DOCTYPE a><a/>',)]

-----------
QUERY:
SELECT xml '<!-- hi--> oops <!DOCTYPE a><a/>'
RESULT:
	postgres: invalid XML content
LINE 1: SELECT xml '<!-- hi--> oops <!DOCTYPE a><a/>'
                   ^
DETAIL:  line 1: StartTag: invalid element name
<!-- hi--> oops <!DOCTYPE a><a/>
                 ^


-----------
QUERY:
SELECT xml '<!-- hi--> <oops/> <!DOCTYPE a><a/>'
RESULT:
	postgres: invalid XML content
LINE 1: SELECT xml '<!-- hi--> <oops/> <!DOCTYPE a><a/>'
                   ^
DETAIL:  line 1: StartTag: invalid element name
<!-- hi--> <oops/> <!DOCTYPE a><a/>
                    ^


-----------
QUERY:
SELECT xml '<!DOCTYPE a><a/><b/>'
RESULT:
	postgres: invalid XML content
LINE 1: SELECT xml '<!DOCTYPE a><a/><b/>'
                   ^
DETAIL:  line 1: Extra content at the end of the document
<!DOCTYPE a><a/><b/>
                ^


-----------
QUERY:
-- Test backwards parsing

CREATE VIEW xmlview1 AS SELECT xmlcomment('test')
RESULT:
	postgres: None

-----------
QUERY:
CREATE VIEW xmlview2 AS SELECT xmlconcat('hello', 'you')
RESULT:
	postgres: None

-----------
QUERY:
CREATE VIEW xmlview3 AS SELECT xmlelement(name element, xmlattributes (1 as ":one:", 'deuce' as two), 'content&')
RESULT:
	postgres: None

-----------
QUERY:
CREATE VIEW xmlview4 AS SELECT xmlelement(name employee, xmlforest(name, age, salary as pay)) FROM emp
RESULT:
	postgres: None

-----------
QUERY:
CREATE VIEW xmlview5 AS SELECT xmlparse(content '<abc>x</abc>')
RESULT:
	postgres: None

-----------
QUERY:
CREATE VIEW xmlview6 AS SELECT xmlpi(name foo, 'bar')
RESULT:
	postgres: None

-----------
QUERY:
CREATE VIEW xmlview7 AS SELECT xmlroot(xml '<foo/>', version no value, standalone yes)
RESULT:
	postgres: None

-----------
QUERY:
CREATE VIEW xmlview8 AS SELECT xmlserialize(content 'good' as char(10))
RESULT:
	postgres: None

-----------
QUERY:
CREATE VIEW xmlview9 AS SELECT xmlserialize(content 'good' as text)
RESULT:
	postgres: None

-----------
QUERY:
SELECT table_name, view_definition FROM information_schema.views
  WHERE table_name LIKE 'xmlview%' ORDER BY 1
RESULT:
	postgres: [('xmlview1', " SELECT xmlcomment('test'::text) AS xmlcomment;"), ('xmlview2', ' SELECT XMLCONCAT(\'hello\'::xml, \'you\'::xml) AS "xmlconcat";'), ('xmlview3', ' SELECT XMLELEMENT(NAME element, XMLATTRIBUTES(1 AS ":one:", \'deuce\' AS two), \'content&\') AS "xmlelement";'), ('xmlview4', ' SELECT XMLELEMENT(NAME employee, XMLFOREST(name AS name, age AS age, salary AS pay)) AS "xmlelement"\n   FROM emp;'), ('xmlview5', ' SELECT XMLPARSE(CONTENT \'<abc>x</abc>\'::text STRIP WHITESPACE) AS "xmlparse";'), ('xmlview6', ' SELECT XMLPI(NAME foo, \'bar\'::text) AS "xmlpi";'), ('xmlview7', ' SELECT XMLROOT(\'<foo/>\'::xml, VERSION NO VALUE, STANDALONE YES) AS "xmlroot";'), ('xmlview8', ' SELECT (XMLSERIALIZE(CONTENT \'good\'::xml AS character(10)))::character(10) AS "xmlserialize";'), ('xmlview9', ' SELECT XMLSERIALIZE(CONTENT \'good\'::xml AS text) AS "xmlserialize";')]

-----------
QUERY:
-- Text XPath expressions evaluation

SELECT xpath('/value', data) FROM xmltest
RESULT:
	postgres: [('{<value>one</value>}',), ('{<value>two</value>}',)]

-----------
QUERY:
SELECT xpath(NULL, NULL) IS NULL FROM xmltest
RESULT:
	postgres: [(True,), (True,)]

-----------
QUERY:
SELECT xpath('', '<!-- error -->')
RESULT:
	postgres: empty XPath expression
CONTEXT:  SQL function "xpath" statement 1


-----------
QUERY:
SELECT xpath('//text()', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>')
RESULT:
	postgres: [('{"number one"}',)]

-----------
QUERY:
SELECT xpath('//loc:piece/@id', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>', ARRAY[ARRAY['loc', 'http://127.0.0.1']])
RESULT:
	postgres: [('{1,2}',)]

-----------
QUERY:
SELECT xpath('//loc:piece', '<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>', ARRAY[ARRAY['loc', 'http://127.0.0.1']])
RESULT:
	postgres: [('{"<local:piece xmlns:local=\\"http://127.0.0.1\\" id=\\"1\\">number one</local:piece>","<local:piece xmlns:local=\\"http://127.0.0.1\\" id=\\"2\\"/>"}',)]

-----------
QUERY:
SELECT xpath('//loc:piece', '<local:data xmlns:local="http://127.0.0.1" xmlns="http://127.0.0.2"><local:piece id="1"><internal>number one</internal><internal2/></local:piece><local:piece id="2" /></local:data>', ARRAY[ARRAY['loc', 'http://127.0.0.1']])
RESULT:
	postgres: [('{"<local:piece xmlns:local=\\"http://127.0.0.1\\" xmlns=\\"http://127.0.0.2\\" id=\\"1\\"><internal>number one</internal><internal2/></local:piece>","<local:piece xmlns:local=\\"http://127.0.0.1\\" id=\\"2\\"/>"}',)]

-----------
QUERY:
SELECT xpath('//b', '<a>one <b>two</b> three <b>etc</b></a>')
RESULT:
	postgres: [('{<b>two</b>,<b>etc</b>}',)]

-----------
QUERY:
SELECT xpath('//text()', '<root>&lt
RESULT:
	postgres: unterminated quoted string at or near "'<root>&lt
"
LINE 1: SELECT xpath('//text()', '<root>&lt
                                 ^


-----------
QUERY:
</root>')
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </root>')
        ^


-----------
QUERY:
SELECT xpath('//@value', '<root value="&lt
RESULT:
	postgres: unterminated quoted string at or near "'<root value="&lt
"
LINE 1: SELECT xpath('//@value', '<root value="&lt
                                 ^


-----------
QUERY:
"/>')
RESULT:
	postgres: unterminated quoted identifier at or near ""/>')
"
LINE 1: "/>')
        ^


-----------
QUERY:
SELECT xpath('''<<invalid>>''', '<root/>')
RESULT:
	postgres: [('{&lt;&lt;invalid&gt;&gt;}',)]

-----------
QUERY:
SELECT xpath('count(//*)', '<root><sub/><sub/></root>')
RESULT:
	postgres: [('{3}',)]

-----------
QUERY:
SELECT xpath('count(//*)=0', '<root><sub/><sub/></root>')
RESULT:
	postgres: [('{false}',)]

-----------
QUERY:
SELECT xpath('count(//*)=3', '<root><sub/><sub/></root>')
RESULT:
	postgres: [('{true}',)]

-----------
QUERY:
SELECT xpath('name(/*)', '<root><sub/><sub/></root>')
RESULT:
	postgres: [('{root}',)]

-----------
QUERY:
SELECT xpath('/nosuchtag', '<root/>')
RESULT:
	postgres: [('{}',)]

-----------
QUERY:
SELECT xpath('root', '<root/>')
RESULT:
	postgres: [('{<root/>}',)]

-----------
QUERY:
-- Round-trip non-ASCII data through xpath().
DO $$
DECLARE
  xml_declaration text := '<?xml version="1.0" encoding="ISO-8859-1"?>';
  degree_symbol text;
  res xml[];
BEGIN
  -- Per the documentation, except when the server encoding is UTF8, xpath()
  -- may not work on non-ASCII data.  The untranslatable_character and
  -- undefined_function traps below, currently dead code, will become relevant
  -- if we remove this limitation.
  IF current_setting('server_encoding') <> 'UTF8' THEN
    RAISE LOG 'skip: encoding % unsupported for xpath',
      current_setting('server_encoding');
    RETURN;
  END IF;

  degree_symbol := convert_from('\xc2b0', 'UTF8');
  res := xpath('text()', (xml_declaration ||
    '<x>' || degree_symbol || '</x>')::xml);
  IF degree_symbol <> res[1]::text THEN
    RAISE 'expected % (%), got % (%)',
      degree_symbol, convert_to(degree_symbol, 'UTF8'),
      res[1], convert_to(res[1]::text, 'UTF8');
  END IF;
EXCEPTION
  -- character with byte sequence 0xc2 0xb0 in encoding /* REPLACED */''UTF8/* REPLACED */'' has no equivalent in encoding /* REPLACED */''LATIN8/* REPLACED */''
  WHEN untranslatable_character
  -- default conversion function for encoding /* REPLACED */''UTF8/* REPLACED */'' to /* REPLACED */''MULE_INTERNAL/* REPLACED */'' does not exist
  OR undefined_function
  -- unsupported XML feature
  OR feature_not_supported THEN
    RAISE LOG 'skip: %', SQLERRM;
END
$$
RESULT:
	postgres: None

-----------
QUERY:
-- Test xmlexists and xpath_exists
SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>')
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xmlexists('//town[text() = ''Cwmbran'']' PASSING BY REF '<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xmlexists('count(/nosuchtag)' PASSING BY REF '<root/>')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xpath_exists('//town[text() = ''Toronto'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml)
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xpath_exists('//town[text() = ''Cwmbran'']','<towns><town>Bidford-on-Avon</town><town>Cwmbran</town><town>Bristol</town></towns>'::xml)
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xpath_exists('count(/nosuchtag)', '<root/>'::xml)
RESULT:
	postgres: [(True,)]

-----------
QUERY:
INSERT INTO xmltest VALUES (4, '<menu><beers><name>Budvar</name><cost>free</cost><name>Carling</name><cost>lots</cost></beers></menu>'::xml)
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmltest VALUES (5, '<menu><beers><name>Molson</name><cost>free</cost><name>Carling</name><cost>lots</cost></beers></menu>'::xml)
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmltest VALUES (6, '<myns:menu xmlns:myns="http://myns.com"><myns:beers><myns:name>Budvar</myns:name><myns:cost>free</myns:cost><myns:name>Carling</myns:name><myns:cost>lots</myns:cost></myns:beers></myns:menu>'::xml)
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmltest VALUES (7, '<myns:menu xmlns:myns="http://myns.com"><myns:beers><myns:name>Molson</myns:name><myns:cost>free</myns:cost><myns:name>Carling</myns:name><myns:cost>lots</myns:cost></myns:beers></myns:menu>'::xml)
RESULT:
	postgres: None

-----------
QUERY:
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beer' PASSING data)
RESULT:
	postgres: [(0,)]

-----------
QUERY:
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beer' PASSING BY REF data BY REF)
RESULT:
	postgres: [(0,)]

-----------
QUERY:
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beers' PASSING BY REF data)
RESULT:
	postgres: [(2,)]

-----------
QUERY:
SELECT COUNT(id) FROM xmltest WHERE xmlexists('/menu/beers/name[text() = ''Molson'']' PASSING BY REF data)
RESULT:
	postgres: [(1,)]

-----------
QUERY:
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beer',data)
RESULT:
	postgres: [(0,)]

-----------
QUERY:
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers',data)
RESULT:
	postgres: [(2,)]

-----------
QUERY:
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/menu/beers/name[text() = ''Molson'']',data)
RESULT:
	postgres: [(1,)]

-----------
QUERY:
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/myns:menu/myns:beer',data,ARRAY[ARRAY['myns','http://myns.com']])
RESULT:
	postgres: [(0,)]

-----------
QUERY:
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/myns:menu/myns:beers',data,ARRAY[ARRAY['myns','http://myns.com']])
RESULT:
	postgres: [(2,)]

-----------
QUERY:
SELECT COUNT(id) FROM xmltest WHERE xpath_exists('/myns:menu/myns:beers/myns:name[text() = ''Molson'']',data,ARRAY[ARRAY['myns','http://myns.com']])
RESULT:
	postgres: [(1,)]

-----------
QUERY:
CREATE TABLE query ( expr TEXT )
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO query VALUES ('/menu/beers/cost[text() = ''lots'']')
RESULT:
	postgres: None

-----------
QUERY:
SELECT COUNT(id) FROM xmltest, query WHERE xmlexists(expr PASSING BY REF data)
RESULT:
	postgres: [(2,)]

-----------
QUERY:
-- Test xml_is_well_formed and variants

SELECT xml_is_well_formed_document('<foo>bar</foo>')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xml_is_well_formed_document('abc')
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xml_is_well_formed_content('<foo>bar</foo>')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xml_is_well_formed_content('abc')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SET xmloption TO DOCUMENT
RESULT:
	postgres: None

-----------
QUERY:
SELECT xml_is_well_formed('abc')
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xml_is_well_formed('<>')
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xml_is_well_formed('<abc/>')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xml_is_well_formed('<foo>bar</foo>')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xml_is_well_formed('<foo>bar</foo')
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xml_is_well_formed('<foo><bar>baz</foo>')
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xml_is_well_formed('<local:data xmlns:local="http://127.0.0.1"><local:piece id="1">number one</local:piece><local:piece id="2" /></local:data>')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xml_is_well_formed('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</my:foo>')
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xml_is_well_formed('<pg:foo xmlns:pg="http://postgresql.org/stuff">bar</pg:foo>')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xml_is_well_formed('<invalidentity>&</abc>')
RESULT:
	postgres: [(False,)]

-----------
QUERY:
SELECT xml_is_well_formed('<undefinedentity>&idontexist
RESULT:
	postgres: unterminated quoted string at or near "'<undefinedentity>&idontexist
"
LINE 1: SELECT xml_is_well_formed('<undefinedentity>&idontexist
                                  ^


-----------
QUERY:
</abc>')
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </abc>')
        ^


-----------
QUERY:
SELECT xml_is_well_formed('<invalidns xmlns=''&lt
RESULT:
	postgres: unterminated quoted string at or near "'<invalidns xmlns=''&lt
"
LINE 1: SELECT xml_is_well_formed('<invalidns xmlns=''&lt
                                  ^


-----------
QUERY:
''/>')
RESULT:
	postgres: syntax error at or near "''"
LINE 1: ''/>')
        ^


-----------
QUERY:
SELECT xml_is_well_formed('<relativens xmlns=''relative''/>')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
SELECT xml_is_well_formed('<twoerrors>&idontexist
RESULT:
	postgres: unterminated quoted string at or near "'<twoerrors>&idontexist
"
LINE 1: SELECT xml_is_well_formed('<twoerrors>&idontexist
                                  ^


-----------
QUERY:
</unbalanced>')
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </unbalanced>')
        ^


-----------
QUERY:
SET xmloption TO CONTENT
RESULT:
	postgres: None

-----------
QUERY:
SELECT xml_is_well_formed('abc')
RESULT:
	postgres: [(True,)]

-----------
QUERY:
-- Since xpath() deals with namespaces, it/* REPLACED */''s a bit stricter about
-- what/* REPLACED */''s well-formed and what/* REPLACED */''s not. If we don/* REPLACED */''t obey these rules
-- (i.e. ignore namespace-related errors from libxml), xpath()
-- fails in subtle ways. The following would for example produce
-- the xml value
--   <invalidns xmlns=/* REPLACED */''</* REPLACED */''/>
-- which is invalid because /* REPLACED */''</* REPLACED */'' may not appear un-escaped in
-- attribute values.
-- Since different libxml versions emit slightly different
-- error messages, we suppress the DETAIL in this test.
-- \set VERBOSITY terse
SELECT xpath('/*', '<invalidns xmlns=''&lt
RESULT:
	postgres: unterminated quoted string at or near "'<invalidns xmlns=''&lt
"
LINE 12: SELECT xpath('/*', '<invalidns xmlns=''&lt
                            ^


-----------
QUERY:
''/>')
RESULT:
	postgres: syntax error at or near "''"
LINE 1: ''/>')
        ^


-----------
QUERY:
-- \set VERBOSITY default

-- Again, the XML isn/* REPLACED */''t well-formed for namespace purposes
SELECT xpath('/*', '<nosuchprefix:tag/>')
RESULT:
	postgres: could not parse XML document
DETAIL:  line 1: Namespace prefix nosuchprefix on tag is not defined
<nosuchprefix:tag/>
                 ^
CONTEXT:  SQL function "xpath" statement 1


-----------
QUERY:
-- XPath deprecates relative namespaces, but they/* REPLACED */''re not supposed to
-- throw an error, only a warning.
SELECT xpath('/*', '<relativens xmlns=''relative''/>')
RESULT:
	postgres: [('{"<relativens xmlns=\\"relative\\"/>"}',)]

-----------
QUERY:
-- External entity references should not leak filesystem information.
SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/passwd">]><foo>&c
RESULT:
	postgres: unterminated quoted string at or near "'<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/passwd">]><foo>&c
"
LINE 2: SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "...
                                 ^


-----------
QUERY:
</foo>')
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </foo>')
        ^


-----------
QUERY:
SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/no.such.file">]><foo>&c
RESULT:
	postgres: unterminated quoted string at or near "'<!DOCTYPE foo [<!ENTITY c SYSTEM "/etc/no.such.file">]><foo>&c
"
LINE 1: SELECT XMLPARSE(DOCUMENT '<!DOCTYPE foo [<!ENTITY c SYSTEM "...
                                 ^


-----------
QUERY:
</foo>')
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </foo>')
        ^


-----------
QUERY:
-- This might or might not load the requested DTD, but it mustn/* REPLACED */''t throw error.
SELECT XMLPARSE(DOCUMENT '<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"><chapter>&nbsp
RESULT:
	postgres: unterminated quoted string at or near "'<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN" "http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd"><chapter>&nbsp
"
LINE 2: SELECT XMLPARSE(DOCUMENT '<!DOCTYPE chapter PUBLIC "-//OASIS...
                                 ^


-----------
QUERY:
</chapter>')
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </chapter>')
        ^


-----------
QUERY:
-- XMLPATH tests
CREATE TABLE xmldata(data xml)
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmldata VALUES('<ROWS>
<ROW id="1">
  <COUNTRY_ID>AU</COUNTRY_ID>
  <COUNTRY_NAME>Australia</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID>
</ROW>
<ROW id="2">
  <COUNTRY_ID>CN</COUNTRY_ID>
  <COUNTRY_NAME>China</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID>
</ROW>
<ROW id="3">
  <COUNTRY_ID>HK</COUNTRY_ID>
  <COUNTRY_NAME>HongKong</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID>
</ROW>
<ROW id="4">
  <COUNTRY_ID>IN</COUNTRY_ID>
  <COUNTRY_NAME>India</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID>
</ROW>
<ROW id="5">
  <COUNTRY_ID>JP</COUNTRY_ID>
  <COUNTRY_NAME>Japan</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID><PREMIER_NAME>Sinzo Abe</PREMIER_NAME>
</ROW>
<ROW id="6">
  <COUNTRY_ID>SG</COUNTRY_ID>
  <COUNTRY_NAME>Singapore</COUNTRY_NAME>
  <REGION_ID>3</REGION_ID><SIZE unit="km">791</SIZE>
</ROW>
</ROWS>')
RESULT:
	postgres: None

-----------
QUERY:
-- XMLTABLE with columns
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME/text()' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
RESULT:
	postgres: [(1, 1, 'Australia', 'AU', 3, None, None, 'not specified'), (2, 2, 'China', 'CN', 3, None, None, 'not specified'), (3, 3, 'HongKong', 'HK', 3, None, None, 'not specified'), (4, 4, 'India', 'IN', 3, None, None, 'not specified'), (5, 5, 'Japan', 'JP', 3, None, None, 'Sinzo Abe'), (6, 6, 'Singapore', 'SG', 3, 791.0, 'km', 'not specified')]

-----------
QUERY:
CREATE VIEW xmltableview1 AS SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME/text()' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
RESULT:
	postgres: None

-----------
QUERY:
SELECT * FROM xmltableview1
RESULT:
	postgres: [(1, 1, 'Australia', 'AU', 3, None, None, 'not specified'), (2, 2, 'China', 'CN', 3, None, None, 'not specified'), (3, 3, 'HongKong', 'HK', 3, None, None, 'not specified'), (4, 4, 'India', 'IN', 3, None, None, 'not specified'), (5, 5, 'Japan', 'JP', 3, None, None, 'Sinzo Abe'), (6, 6, 'Singapore', 'SG', 3, 791.0, 'km', 'not specified')]

-----------
QUERY:
\sv xmltableview1

EXPLAIN (COSTS OFF) SELECT * FROM xmltableview1
RESULT:
	postgres: syntax error at or near "\"
LINE 1: \sv xmltableview1
        ^


-----------
QUERY:
EXPLAIN (COSTS OFF, VERBOSE) SELECT * FROM xmltableview1
RESULT:
	postgres: [('Nested Loop',), ('  Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name',), ('  ->  Seq Scan on public.xmldata',), ('        Output: xmldata.data',), ('  ->  Table Function Scan on "xmltable"',), ('        Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name',), ("        Table Function Call: XMLTABLE(('/ROWS/ROW'::text) PASSING (xmldata.data) COLUMNS id integer PATH ('@id'::text), _id FOR ORDINALITY, country_name text PATH ('COUNTRY_NAME/text()'::text) NOT NULL, country_id text PATH ('COUNTRY_ID'::text), region_id integer PATH ('REGION_ID'::text), size double precision PATH ('SIZE'::text), unit text PATH ('SIZE/@unit'::text), premier_name text DEFAULT ('not specified'::text) PATH ('PREMIER_NAME'::text))",)]

-----------
QUERY:
-- errors
SELECT * FROM XMLTABLE (ROW () PASSING null COLUMNS v1 timestamp) AS f (v1, v2)
RESULT:
	postgres: XMLTABLE function has 1 columns available but 2 columns specified


-----------
QUERY:
-- XMLNAMESPACES tests
SELECT * FROM XMLTABLE(XMLNAMESPACES('http://x.y' AS zz),
                      '/zz:rows/zz:row'
                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'
                      COLUMNS a int PATH 'zz:a')
RESULT:
	postgres: [(10,)]

-----------
QUERY:
CREATE VIEW xmltableview2 AS SELECT * FROM XMLTABLE(XMLNAMESPACES('http://x.y' AS zz),
                      '/zz:rows/zz:row'
                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'
                      COLUMNS a int PATH 'zz:a')
RESULT:
	postgres: None

-----------
QUERY:
SELECT * FROM xmltableview2
RESULT:
	postgres: [(10,)]

-----------
QUERY:
SELECT * FROM XMLTABLE(XMLNAMESPACES(DEFAULT 'http://x.y'),
                      '/rows/row'
                      PASSING '<rows xmlns="http://x.y"><row><a>10</a></row></rows>'
                      COLUMNS a int PATH 'a')
RESULT:
	postgres: DEFAULT namespace is not supported


-----------
QUERY:
SELECT * FROM XMLTABLE('.'
                       PASSING '<foo/>'
                       COLUMNS a text PATH 'foo/namespace::node()')
RESULT:
	postgres: [('http://www.w3.org/XML/1998/namespace',)]

-----------
QUERY:
-- used in prepare statements
PREPARE pp AS
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
RESULT:
	postgres: None

-----------
QUERY:
EXECUTE pp
RESULT:
	postgres: [(1, 1, 'Australia', 'AU', 3, None, None, 'not specified'), (2, 2, 'China', 'CN', 3, None, None, 'not specified'), (3, 3, 'HongKong', 'HK', 3, None, None, 'not specified'), (4, 4, 'India', 'IN', 3, None, None, 'not specified'), (5, 5, 'Japan', 'JP', 3, None, None, 'Sinzo Abe'), (6, 6, 'Singapore', 'SG', 3, 791.0, 'km', 'not specified')]

-----------
QUERY:
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int)
RESULT:
	postgres: [('India', 3), ('Japan', 3)]

-----------
QUERY:
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id FOR ORDINALITY, "COUNTRY_NAME" text, "REGION_ID" int)
RESULT:
	postgres: [(1, 'India', 3), (2, 'Japan', 3)]

-----------
QUERY:
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int)
RESULT:
	postgres: [(4, 'India', 3), (5, 'Japan', 3)]

-----------
QUERY:
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id')
RESULT:
	postgres: [(4,), (5,)]

-----------
QUERY:
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id FOR ORDINALITY)
RESULT:
	postgres: [(1,), (2,)]

-----------
QUERY:
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int, rawdata xml PATH '.')
RESULT:
	postgres: [(4, 'India', 3, '<ROW id="4">\n  <COUNTRY_ID>IN</COUNTRY_ID>\n  <COUNTRY_NAME>India</COUNTRY_NAME>\n  <REGION_ID>3</REGION_ID>\n</ROW>'), (5, 'Japan', 3, '<ROW id="5">\n  <COUNTRY_ID>JP</COUNTRY_ID>\n  <COUNTRY_NAME>Japan</COUNTRY_NAME>\n  <REGION_ID>3</REGION_ID><PREMIER_NAME>Sinzo Abe</PREMIER_NAME>\n</ROW>')]

-----------
QUERY:
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS id int PATH '@id', "COUNTRY_NAME" text, "REGION_ID" int, rawdata xml PATH './*')
RESULT:
	postgres: [(4, 'India', 3, '<COUNTRY_ID>IN</COUNTRY_ID><COUNTRY_NAME>India</COUNTRY_NAME><REGION_ID>3</REGION_ID>'), (5, 'Japan', 3, '<COUNTRY_ID>JP</COUNTRY_ID><COUNTRY_NAME>Japan</COUNTRY_NAME><REGION_ID>3</REGION_ID><PREMIER_NAME>Sinzo Abe</PREMIER_NAME>')]

-----------
QUERY:
SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text)
RESULT:
	postgres: [('a1aa2a   bbbbxxxcccc',)]

-----------
QUERY:
SELECT * FROM xmltable('/root' passing '<root><element>a1a<!-- aaaa -->a2a<?aaaaa?> <!--z-->  bbbb<x>xxx</x>cccc</element></root>' COLUMNS element text PATH 'element/text()')
RESULT:
	postgres: more than one value returned by column XPath expression


-----------
QUERY:
-- should fail

-- CDATA test
select * from xmltable('d/r' passing '<d><r><c><![CDATA[<hello> &"<>!<a>foo</a>]]></c></r><r><c>2</c></r></d>' columns c text)
RESULT:
	postgres: [('<hello> &"<>!<a>foo</a>',), ('2',)]

-----------
QUERY:
-- XML builtin entities
SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos
RESULT:
	postgres: unterminated quoted string at or near "'<x><a><ent>&apos
"
LINE 2: SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos
                                              ^


-----------
QUERY:
</ent></a><a><ent>&quot
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </ent></a><a><ent>&quot
        ^


-----------
QUERY:
</ent></a><a><ent>&amp
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </ent></a><a><ent>&amp
        ^


-----------
QUERY:
</ent></a><a><ent>&lt
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </ent></a><a><ent>&lt
        ^


-----------
QUERY:
</ent></a><a><ent>&gt
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </ent></a><a><ent>&gt
        ^


-----------
QUERY:
</ent></a></x>' COLUMNS ent text)
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </ent></a></x>' COLUMNS ent text)
        ^


-----------
QUERY:
SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos
RESULT:
	postgres: unterminated quoted string at or near "'<x><a><ent>&apos
"
LINE 1: SELECT * FROM xmltable('/x/a' PASSING '<x><a><ent>&apos
                                              ^


-----------
QUERY:
</ent></a><a><ent>&quot
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </ent></a><a><ent>&quot
        ^


-----------
QUERY:
</ent></a><a><ent>&amp
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </ent></a><a><ent>&amp
        ^


-----------
QUERY:
</ent></a><a><ent>&lt
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </ent></a><a><ent>&lt
        ^


-----------
QUERY:
</ent></a><a><ent>&gt
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </ent></a><a><ent>&gt
        ^


-----------
QUERY:
</ent></a></x>' COLUMNS ent xml)
RESULT:
	postgres: syntax error at or near "</"
LINE 1: </ent></a></x>' COLUMNS ent xml)
        ^


-----------
QUERY:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
RESULT:
	postgres: [('Nested Loop',), ('  Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name',), ('  ->  Seq Scan on public.xmldata',), ('        Output: xmldata.data',), ('  ->  Table Function Scan on "xmltable"',), ('        Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name',), ("        Table Function Call: XMLTABLE(('/ROWS/ROW'::text) PASSING (xmldata.data) COLUMNS id integer PATH ('@id'::text), _id FOR ORDINALITY, country_name text PATH ('COUNTRY_NAME'::text) NOT NULL, country_id text PATH ('COUNTRY_ID'::text), region_id integer PATH ('REGION_ID'::text), size double precision PATH ('SIZE'::text), unit text PATH ('SIZE/@unit'::text), premier_name text DEFAULT ('not specified'::text) PATH ('PREMIER_NAME'::text))",)]

-----------
QUERY:
-- test qual
SELECT xmltable.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) WHERE "COUNTRY_NAME" = 'Japan'
RESULT:
	postgres: [('Japan', 3)]

-----------
QUERY:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT f.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) AS f WHERE "COUNTRY_NAME" = 'Japan'
RESULT:
	postgres: [('Nested Loop',), ('  Output: f."COUNTRY_NAME", f."REGION_ID"',), ('  ->  Seq Scan on public.xmldata',), ('        Output: xmldata.data',), ('  ->  Table Function Scan on "xmltable" f',), ('        Output: f."COUNTRY_NAME", f."REGION_ID"',), ('        Table Function Call: XMLTABLE((\'/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]\'::text) PASSING (xmldata.data) COLUMNS "COUNTRY_NAME" text, "REGION_ID" integer)',), ('        Filter: (f."COUNTRY_NAME" = \'Japan\'::text)',)]

-----------
QUERY:
EXPLAIN (VERBOSE, FORMAT JSON, COSTS OFF)
SELECT f.* FROM xmldata, LATERAL xmltable('/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]' PASSING data COLUMNS "COUNTRY_NAME" text, "REGION_ID" int) AS f WHERE "COUNTRY_NAME" = 'Japan'
RESULT:
	postgres: [([{'Plan': {'Node Type': 'Nested Loop', 'Parallel Aware': False, 'Async Capable': False, 'Join Type': 'Inner', 'Output': ['f."COUNTRY_NAME"', 'f."REGION_ID"'], 'Inner Unique': False, 'Plans': [{'Node Type': 'Seq Scan', 'Parent Relationship': 'Outer', 'Parallel Aware': False, 'Async Capable': False, 'Relation Name': 'xmldata', 'Schema': 'public', 'Alias': 'xmldata', 'Output': ['xmldata.data']}, {'Node Type': 'Table Function Scan', 'Parent Relationship': 'Inner', 'Parallel Aware': False, 'Async Capable': False, 'Table Function Name': 'xmltable', 'Alias': 'f', 'Output': ['f."COUNTRY_NAME"', 'f."REGION_ID"'], 'Table Function Call': 'XMLTABLE((\'/ROWS/ROW[COUNTRY_NAME="Japan" or COUNTRY_NAME="India"]\'::text) PASSING (xmldata.data) COLUMNS "COUNTRY_NAME" text, "REGION_ID" integer)', 'Filter': '(f."COUNTRY_NAME" = \'Japan\'::text)'}]}}],)]

-----------
QUERY:
-- should to work with more data
INSERT INTO xmldata VALUES('<ROWS>
<ROW id="10">
  <COUNTRY_ID>CZ</COUNTRY_ID>
  <COUNTRY_NAME>Czech Republic</COUNTRY_NAME>
  <REGION_ID>2</REGION_ID><PREMIER_NAME>Milos Zeman</PREMIER_NAME>
</ROW>
<ROW id="11">
  <COUNTRY_ID>DE</COUNTRY_ID>
  <COUNTRY_NAME>Germany</COUNTRY_NAME>
  <REGION_ID>2</REGION_ID>
</ROW>
<ROW id="12">
  <COUNTRY_ID>FR</COUNTRY_ID>
  <COUNTRY_NAME>France</COUNTRY_NAME>
  <REGION_ID>2</REGION_ID>
</ROW>
</ROWS>')
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmldata VALUES('<ROWS>
<ROW id="20">
  <COUNTRY_ID>EG</COUNTRY_ID>
  <COUNTRY_NAME>Egypt</COUNTRY_NAME>
  <REGION_ID>1</REGION_ID>
</ROW>
<ROW id="21">
  <COUNTRY_ID>SD</COUNTRY_ID>
  <COUNTRY_NAME>Sudan</COUNTRY_NAME>
  <REGION_ID>1</REGION_ID>
</ROW>
</ROWS>')
RESULT:
	postgres: None

-----------
QUERY:
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
RESULT:
	postgres: [(1, 1, 'Australia', 'AU', 3, None, None, 'not specified'), (2, 2, 'China', 'CN', 3, None, None, 'not specified'), (3, 3, 'HongKong', 'HK', 3, None, None, 'not specified'), (4, 4, 'India', 'IN', 3, None, None, 'not specified'), (5, 5, 'Japan', 'JP', 3, None, None, 'Sinzo Abe'), (6, 6, 'Singapore', 'SG', 3, 791.0, 'km', 'not specified'), (10, 1, 'Czech Republic', 'CZ', 2, None, None, 'Milos Zeman'), (11, 2, 'Germany', 'DE', 2, None, None, 'not specified'), (12, 3, 'France', 'FR', 2, None, None, 'not specified'), (20, 1, 'Egypt', 'EG', 1, None, None, 'not specified'), (21, 2, 'Sudan', 'SD', 1, None, None, 'not specified')]

-----------
QUERY:
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
  WHERE region_id = 2
RESULT:
	postgres: [(10, 1, 'Czech Republic', 'CZ', 2, None, None, 'Milos Zeman'), (11, 2, 'Germany', 'DE', 2, None, None, 'not specified'), (12, 3, 'France', 'FR', 2, None, None, 'not specified')]

-----------
QUERY:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE',
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
  WHERE region_id = 2
RESULT:
	postgres: [('Nested Loop',), ('  Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name',), ('  ->  Seq Scan on public.xmldata',), ('        Output: xmldata.data',), ('  ->  Table Function Scan on "xmltable"',), ('        Output: "xmltable".id, "xmltable"._id, "xmltable".country_name, "xmltable".country_id, "xmltable".region_id, "xmltable".size, "xmltable".unit, "xmltable".premier_name',), ("        Table Function Call: XMLTABLE(('/ROWS/ROW'::text) PASSING (xmldata.data) COLUMNS id integer PATH ('@id'::text), _id FOR ORDINALITY, country_name text PATH ('COUNTRY_NAME'::text) NOT NULL, country_id text PATH ('COUNTRY_ID'::text), region_id integer PATH ('REGION_ID'::text), size double precision PATH ('SIZE'::text), unit text PATH ('SIZE/@unit'::text), premier_name text DEFAULT ('not specified'::text) PATH ('PREMIER_NAME'::text))",), ('        Filter: ("xmltable".region_id = 2)',)]

-----------
QUERY:
-- should fail, NULL value
SELECT  xmltable.*
   FROM (SELECT data FROM xmldata) x,
        LATERAL XMLTABLE('/ROWS/ROW'
                         PASSING data
                         COLUMNS id int PATH '@id',
                                  _id FOR ORDINALITY,
                                  country_name text PATH 'COUNTRY_NAME' NOT NULL,
                                  country_id text PATH 'COUNTRY_ID',
                                  region_id int PATH 'REGION_ID',
                                  size float PATH 'SIZE' NOT NULL,
                                  unit text PATH 'SIZE/@unit',
                                  premier_name text PATH 'PREMIER_NAME' DEFAULT 'not specified')
RESULT:
	postgres: null is not allowed in column "size"


-----------
QUERY:
-- if all is ok, then result is empty
-- one line xml test
WITH
   x AS (SELECT proname, proowner, procost::numeric, pronargs,
                array_to_string(proargnames,',') as proargnames,
                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
           FROM pg_proc WHERE proname = 'f_leak'),
   y AS (SELECT xmlelement(name proc,
                           xmlforest(proname, proowner,
                                     procost, pronargs,
                                     proargnames, proargtypes)) as proc
           FROM x),
   z AS (SELECT xmltable.*
           FROM y,
                LATERAL xmltable('/proc' PASSING proc
                                 COLUMNS proname name,
                                         proowner oid,
                                         procost float,
                                         pronargs int,
                                         proargnames text,
                                         proargtypes text))
   SELECT * FROM z
   EXCEPT SELECT * FROM x
RESULT:
	postgres: []

-----------
QUERY:
-- multi line xml test, result should be empty too
WITH
   x AS (SELECT proname, proowner, procost::numeric, pronargs,
                array_to_string(proargnames,',') as proargnames,
                case when proargtypes <> '' then array_to_string(proargtypes::oid[],',') end as proargtypes
           FROM pg_proc),
   y AS (SELECT xmlelement(name data,
                           xmlagg(xmlelement(name proc,
                                             xmlforest(proname, proowner, procost,
                                                       pronargs, proargnames, proargtypes)))) as doc
           FROM x),
   z AS (SELECT xmltable.*
           FROM y,
                LATERAL xmltable('/data/proc' PASSING doc
                                 COLUMNS proname name,
                                         proowner oid,
                                         procost float,
                                         pronargs int,
                                         proargnames text,
                                         proargtypes text))
   SELECT * FROM z
   EXCEPT SELECT * FROM x
RESULT:
	postgres: []

-----------
QUERY:
CREATE TABLE xmltest2(x xml, _path text)
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmltest2 VALUES('<d><r><ac>1</ac></r></d>', 'A')
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmltest2 VALUES('<d><r><bc>2</bc></r></d>', 'B')
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmltest2 VALUES('<d><r><cc>3</cc></r></d>', 'C')
RESULT:
	postgres: None

-----------
QUERY:
INSERT INTO xmltest2 VALUES('<d><r><dc>2</dc></r></d>', 'D')
RESULT:
	postgres: None

-----------
QUERY:
SELECT xmltable.* FROM xmltest2, LATERAL xmltable('/d/r' PASSING x COLUMNS a int PATH '' || lower(_path) || 'c')
RESULT:
	postgres: [(1,), (2,), (3,), (2,)]

-----------
QUERY:
SELECT xmltable.* FROM xmltest2, LATERAL xmltable(('/d/r/' || lower(_path) || 'c') PASSING x COLUMNS a int PATH '.')
RESULT:
	postgres: [(1,), (2,), (3,), (2,)]

-----------
QUERY:
SELECT xmltable.* FROM xmltest2, LATERAL xmltable(('/d/r/' || lower(_path) || 'c') PASSING x COLUMNS a int PATH 'x' DEFAULT ascii(_path) - 54)
RESULT:
	postgres: [(11,), (12,), (13,), (14,)]

-----------
QUERY:
-- XPath result can be boolean or number too
SELECT * FROM XMLTABLE('*' PASSING '<a>a</a>' COLUMNS a xml PATH '.', b text PATH '.', c text PATH '"hi"', d boolean PATH '. = "a"', e integer PATH 'string-length(.)')
RESULT:
	postgres: [('<a>a</a>', 'a', 'hi', True, 1)]

-----------
QUERY:
\x
SELECT * FROM XMLTABLE('*' PASSING '<e>pre<!--c1--><?pi arg?><![CDATA[&ent1]]><n2>&amp
RESULT:
	postgres: syntax error at or near "\"
LINE 1: \x
        ^


-----------
QUERY:
deep</n2>post</e>' COLUMNS x xml PATH '/e/n2', y xml PATH '/')
RESULT:
	postgres: syntax error at or near "deep"
LINE 1: deep</n2>post</e>' COLUMNS x xml PATH '/e/n2', y xml PATH '/...
        ^


-----------
QUERY:
\x

SELECT * FROM XMLTABLE('.' PASSING XMLELEMENT(NAME a) columns a varchar(20) PATH '"<foo/>"', b xml PATH '"<foo/>"')
RESULT:
	postgres: syntax error at or near "\"
LINE 1: \x
        ^


-----------
QUERY:
SELECT xmltext(NULL)
RESULT:
	postgres: [(None,)]

-----------
QUERY:
SELECT xmltext('')
RESULT:
	postgres: [('',)]

-----------
QUERY:
SELECT xmltext('  ')
RESULT:
	postgres: [('  ',)]

-----------
QUERY:
SELECT xmltext('foo `$_-+?=*^%!|/\()[]{}')
RESULT:
	postgres: [('foo `$_-+?=*^%!|/\\()[]{}',)]

-----------
QUERY:
SELECT xmltext('foo & <"bar">')
RESULT:
	postgres: [('foo &amp; &lt;&quot;bar&quot;&gt;',)]

-----------
QUERY:
SELECT xmltext('x'|| '<P>73</P>'::xml || .42 || true || 'j'::char)
RESULT:
	postgres: [('x&lt;P&gt;73&lt;/P&gt;0.42truej',)]
