
-----------
QUERY:
--
-- Test for ALTER some_object {RENAME TO, OWNER TO, SET SCHEMA}
--

-- directory paths and dlsuffix are passed to us in environment variables
-- \getenv libdir '/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress'
-- \getenv dlsuffix '.so'

-- \set regresslib /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress' '/regress' /* REPLACED */'.so'

CREATE FUNCTION test_opclass_options_func(internal)
    RETURNS void
    AS /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/regress.so', 'test_opclass_options_func'
    LANGUAGE C;
RESULT:
	postgres: None

-----------
QUERY:


-- Clean up in case a prior regression run failed
SET client_min_messages TO 'warning';
RESULT:
	postgres: None

-----------
QUERY:


DROP ROLE IF EXISTS regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:

DROP ROLE IF EXISTS regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:

DROP ROLE IF EXISTS regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:


RESET client_min_messages;
RESULT:
	postgres: None

-----------
QUERY:


CREATE USER regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:

CREATE USER regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE USER regress_alter_generic_user1 IN ROLE regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:


CREATE SCHEMA alt_nsp1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:


GRANT ALL ON SCHEMA alt_nsp1, alt_nsp2 TO public;
RESULT:
	postgres: None

-----------
QUERY:


SET search_path = alt_nsp1, public;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Function and Aggregate
--
SET SESSION AUTHORIZATION regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE FUNCTION alt_func1(int) RETURNS int LANGUAGE sql
  AS 'SELECT $1 + 1';
RESULT:
	postgres: None

-----------
QUERY:

CREATE FUNCTION alt_func2(int) RETURNS int LANGUAGE sql
  AS 'SELECT $1 - 1';
RESULT:
	postgres: None

-----------
QUERY:

CREATE AGGREGATE alt_agg1 (
  sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 0
);
RESULT:
	postgres: None

-----------
QUERY:

CREATE AGGREGATE alt_agg2 (
  sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = 0
);
RESULT:
	postgres: None

-----------
QUERY:

ALTER AGGREGATE alt_func1(int) RENAME TO alt_func3;
RESULT:
	postgres: function alt_func1(integer) is not an aggregate


-----------
QUERY:
  -- failed (not aggregate)
ALTER AGGREGATE alt_func1(int) OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: function alt_func1(integer) is not an aggregate


-----------
QUERY:
  -- failed (not aggregate)
ALTER AGGREGATE alt_func1(int) SET SCHEMA alt_nsp2;
RESULT:
	postgres: function alt_func1(integer) is not an aggregate


-----------
QUERY:
  -- failed (not aggregate)

ALTER FUNCTION alt_func1(int) RENAME TO alt_func2;
RESULT:
	postgres: function alt_func2(integer) already exists in schema "alt_nsp1"


-----------
QUERY:
  -- failed (name conflict)
ALTER FUNCTION alt_func1(int) RENAME TO alt_func3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user2"


-----------
QUERY:
  -- failed (no role membership)
ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp1;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK, already there
ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg2;
RESULT:
	postgres: function alt_agg2(integer) already exists in schema "alt_nsp1"


-----------
QUERY:
   -- failed (name conflict)
ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg3;
RESULT:
	postgres: None

-----------
QUERY:
   -- OK
ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user2"


-----------
QUERY:
  -- failed (no role membership)
ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

SET SESSION AUTHORIZATION regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE FUNCTION alt_func1(int) RETURNS int LANGUAGE sql
  AS 'SELECT $1 + 2';
RESULT:
	postgres: None

-----------
QUERY:

CREATE FUNCTION alt_func2(int) RETURNS int LANGUAGE sql
  AS 'SELECT $1 - 2';
RESULT:
	postgres: None

-----------
QUERY:

CREATE AGGREGATE alt_agg1 (
  sfunc1 = int4pl, basetype = int4, stype1 = int4, initcond = 100
);
RESULT:
	postgres: None

-----------
QUERY:

CREATE AGGREGATE alt_agg2 (
  sfunc1 = int4mi, basetype = int4, stype1 = int4, initcond = -100
);
RESULT:
	postgres: None

-----------
QUERY:


ALTER FUNCTION alt_func3(int) RENAME TO alt_func4;
RESULT:
	postgres: must be owner of function alt_func3


-----------
QUERY:
	-- failed (not owner)
ALTER FUNCTION alt_func1(int) RENAME TO alt_func4;
RESULT:
	postgres: None

-----------
QUERY:
	-- OK
ALTER FUNCTION alt_func3(int) OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be owner of function alt_func3


-----------
QUERY:
	-- failed (not owner)
ALTER FUNCTION alt_func2(int) OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user3"


-----------
QUERY:
	-- failed (no role membership)
ALTER FUNCTION alt_func3(int) SET SCHEMA alt_nsp2;
RESULT:
	postgres: must be owner of function alt_func3


-----------
QUERY:
      -- failed (not owner)
ALTER FUNCTION alt_func2(int) SET SCHEMA alt_nsp2;
RESULT:
	postgres: function alt_func2(integer) already exists in schema "alt_nsp2"


-----------
QUERY:
	-- failed (name conflicts)

ALTER AGGREGATE alt_agg3(int) RENAME TO alt_agg4;
RESULT:
	postgres: must be owner of function alt_agg3


-----------
QUERY:
   -- failed (not owner)
ALTER AGGREGATE alt_agg1(int) RENAME TO alt_agg4;
RESULT:
	postgres: None

-----------
QUERY:
   -- OK
ALTER AGGREGATE alt_agg3(int) OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be owner of function alt_agg3


-----------
QUERY:
  -- failed (not owner)
ALTER AGGREGATE alt_agg2(int) OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user3"


-----------
QUERY:
  -- failed (no role membership)
ALTER AGGREGATE alt_agg3(int) SET SCHEMA alt_nsp2;
RESULT:
	postgres: must be owner of function alt_agg3


-----------
QUERY:
  -- failed (not owner)
ALTER AGGREGATE alt_agg2(int) SET SCHEMA alt_nsp2;
RESULT:
	postgres: function alt_agg2(integer) already exists in schema "alt_nsp2"


-----------
QUERY:
  -- failed (name conflict)

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SELECT n.nspname, proname, prorettype::regtype, prokind, a.rolname
  FROM pg_proc p, pg_namespace n, pg_authid a
  WHERE p.pronamespace = n.oid AND p.proowner = a.oid
    AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
  ORDER BY nspname, proname;
RESULT:
	postgres: [('alt_nsp1', 'alt_agg2', 'integer', 'a', 'regress_alter_generic_user2'), ('alt_nsp1', 'alt_agg3', 'integer', 'a', 'regress_alter_generic_user1'), ('alt_nsp1', 'alt_agg4', 'integer', 'a', 'regress_alter_generic_user2'), ('alt_nsp1', 'alt_func2', 'integer', 'f', 'regress_alter_generic_user2'), ('alt_nsp1', 'alt_func3', 'integer', 'f', 'regress_alter_generic_user1'), ('alt_nsp1', 'alt_func4', 'integer', 'f', 'regress_alter_generic_user2'), ('alt_nsp2', 'alt_agg2', 'integer', 'a', 'regress_alter_generic_user3'), ('alt_nsp2', 'alt_func2', 'integer', 'f', 'regress_alter_generic_user3')]

-----------
QUERY:


--
-- We would test collations here, but it/* REPLACED */''s not possible because the error
-- messages tend to be nonportable.
--

--
-- Conversion
--
SET SESSION AUTHORIZATION regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
RESULT:
	postgres: None

-----------
QUERY:

CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
RESULT:
	postgres: None

-----------
QUERY:


ALTER CONVERSION alt_conv1 RENAME TO alt_conv2;
RESULT:
	postgres: conversion "alt_conv2" already exists in schema "alt_nsp1"


-----------
QUERY:
  -- failed (name conflict)
ALTER CONVERSION alt_conv1 RENAME TO alt_conv3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user2"


-----------
QUERY:
  -- failed (no role membership)
ALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

SET SESSION AUTHORIZATION regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE CONVERSION alt_conv1 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
RESULT:
	postgres: None

-----------
QUERY:

CREATE CONVERSION alt_conv2 FOR 'LATIN1' TO 'UTF8' FROM iso8859_1_to_utf8;
RESULT:
	postgres: None

-----------
QUERY:


ALTER CONVERSION alt_conv3 RENAME TO alt_conv4;
RESULT:
	postgres: must be owner of conversion alt_conv3


-----------
QUERY:
  -- failed (not owner)
ALTER CONVERSION alt_conv1 RENAME TO alt_conv4;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER CONVERSION alt_conv3 OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be owner of conversion alt_conv3


-----------
QUERY:
  -- failed (not owner)
ALTER CONVERSION alt_conv2 OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user3"


-----------
QUERY:
  -- failed (no role membership)
ALTER CONVERSION alt_conv3 SET SCHEMA alt_nsp2;
RESULT:
	postgres: must be owner of conversion alt_conv3


-----------
QUERY:
  -- failed (not owner)
ALTER CONVERSION alt_conv2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: conversion "alt_conv2" already exists in schema "alt_nsp2"


-----------
QUERY:
  -- failed (name conflict)

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SELECT n.nspname, c.conname, a.rolname
  FROM pg_conversion c, pg_namespace n, pg_authid a
  WHERE c.connamespace = n.oid AND c.conowner = a.oid
    AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
  ORDER BY nspname, conname;
RESULT:
	postgres: [('alt_nsp1', 'alt_conv2', 'regress_alter_generic_user2'), ('alt_nsp1', 'alt_conv3', 'regress_alter_generic_user1'), ('alt_nsp1', 'alt_conv4', 'regress_alter_generic_user2'), ('alt_nsp2', 'alt_conv2', 'regress_alter_generic_user3')]

-----------
QUERY:


--
-- Foreign Data Wrapper and Foreign Server
--
CREATE FOREIGN DATA WRAPPER alt_fdw1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE FOREIGN DATA WRAPPER alt_fdw2;
RESULT:
	postgres: None

-----------
QUERY:


CREATE SERVER alt_fserv1 FOREIGN DATA WRAPPER alt_fdw1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE SERVER alt_fserv2 FOREIGN DATA WRAPPER alt_fdw2;
RESULT:
	postgres: None

-----------
QUERY:


ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw2;
RESULT:
	postgres: foreign-data wrapper "alt_fdw2" already exists


-----------
QUERY:
  -- failed (name conflict)
ALTER FOREIGN DATA WRAPPER alt_fdw1 RENAME TO alt_fdw3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

ALTER SERVER alt_fserv1 RENAME TO alt_fserv2;
RESULT:
	postgres: server "alt_fserv2" already exists


-----------
QUERY:
   -- failed (name conflict)
ALTER SERVER alt_fserv1 RENAME TO alt_fserv3;
RESULT:
	postgres: None

-----------
QUERY:
   -- OK

SELECT fdwname FROM pg_foreign_data_wrapper WHERE fdwname like 'alt_fdw%';
RESULT:
	postgres: [('alt_fdw2',), ('alt_fdw3',)]

-----------
QUERY:

SELECT srvname FROM pg_foreign_server WHERE srvname like 'alt_fserv%';
RESULT:
	postgres: [('alt_fserv2',), ('alt_fserv3',)]

-----------
QUERY:


--
-- Procedural Language
--
CREATE LANGUAGE alt_lang1 HANDLER plpgsql_call_handler;
RESULT:
	postgres: None

-----------
QUERY:

CREATE LANGUAGE alt_lang2 HANDLER plpgsql_call_handler;
RESULT:
	postgres: None

-----------
QUERY:


ALTER LANGUAGE alt_lang1 OWNER TO regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER LANGUAGE alt_lang2 OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

SET SESSION AUTHORIZATION regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:

ALTER LANGUAGE alt_lang1 RENAME TO alt_lang2;
RESULT:
	postgres: language "alt_lang2" already exists


-----------
QUERY:
   -- failed (name conflict)
ALTER LANGUAGE alt_lang2 RENAME TO alt_lang3;
RESULT:
	postgres: must be owner of language alt_lang2


-----------
QUERY:
   -- failed (not owner)
ALTER LANGUAGE alt_lang1 RENAME TO alt_lang3;
RESULT:
	postgres: None

-----------
QUERY:
   -- OK

ALTER LANGUAGE alt_lang2 OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: must be owner of language alt_lang2


-----------
QUERY:
  -- failed (not owner)
ALTER LANGUAGE alt_lang3 OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user2"


-----------
QUERY:
  -- failed (no role membership)
ALTER LANGUAGE alt_lang3 OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:

SELECT lanname, a.rolname
  FROM pg_language l, pg_authid a
  WHERE l.lanowner = a.oid AND l.lanname like 'alt_lang%'
  ORDER BY lanname;
RESULT:
	postgres: [('alt_lang2', 'regress_alter_generic_user2'), ('alt_lang3', 'regress_alter_generic_user3')]

-----------
QUERY:


--
-- Operator
--
SET SESSION AUTHORIZATION regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:


CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR @+@ ( leftarg = int4, rightarg = int4, procedure = int4pl );
RESULT:
	postgres: None

-----------
QUERY:


ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user2"


-----------
QUERY:
  -- failed (no role membership)
ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER OPERATOR @-@(int4, int4) SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
           -- OK

SET SESSION AUTHORIZATION regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:


CREATE OPERATOR @-@ ( leftarg = int4, rightarg = int4, procedure = int4mi );
RESULT:
	postgres: None

-----------
QUERY:


ALTER OPERATOR @+@(int4, int4) OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be owner of operator @+@


-----------
QUERY:
  -- failed (not owner)
ALTER OPERATOR @-@(int4, int4) OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user3"


-----------
QUERY:
  -- failed (no role membership)
ALTER OPERATOR @+@(int4, int4) SET SCHEMA alt_nsp2;
RESULT:
	postgres: must be owner of operator @+@


-----------
QUERY:
   -- failed (not owner)
-- can/* REPLACED */''t test this: the error message includes the raw oid of namespace
-- ALTER OPERATOR @-@(int4, int4) SET SCHEMA alt_nsp2 /* REPLACED */,   -- failed (name conflict)

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SELECT n.nspname, oprname, a.rolname,
    oprleft::regtype, oprright::regtype, oprcode::regproc
  FROM pg_operator o, pg_namespace n, pg_authid a
  WHERE o.oprnamespace = n.oid AND o.oprowner = a.oid
    AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
  ORDER BY nspname, oprname;
RESULT:
	postgres: [('alt_nsp1', '@+@', 'regress_alter_generic_user3', 'integer', 'integer', 'int4pl'), ('alt_nsp1', '@-@', 'regress_alter_generic_user2', 'integer', 'integer', 'int4mi'), ('alt_nsp2', '@-@', 'regress_alter_generic_user1', 'integer', 'integer', 'int4mi')]

-----------
QUERY:


--
-- OpFamily and OpClass
--
CREATE OPERATOR FAMILY alt_opf1 USING hash;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR FAMILY alt_opf2 USING hash;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:


CREATE OPERATOR CLASS alt_opc1 FOR TYPE uuid USING hash AS STORAGE uuid;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR CLASS alt_opc2 FOR TYPE uuid USING hash AS STORAGE uuid;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:


ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf2;
RESULT:
	postgres: operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp1"


-----------
QUERY:
  -- failed (name conflict)
ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user2"


-----------
QUERY:
  -- failed (no role membership)
ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc2;
RESULT:
	postgres: operator class "alt_opc2" for access method "hash" already exists in schema "alt_nsp1"


-----------
QUERY:
  -- failed (name conflict)
ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user2"


-----------
QUERY:
  -- failed (no role membership)
ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


CREATE OPERATOR FAMILY alt_opf1 USING hash;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR FAMILY alt_opf2 USING hash;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf1 USING hash OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:


CREATE OPERATOR CLASS alt_opc1 FOR TYPE macaddr USING hash AS STORAGE macaddr;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR CLASS alt_opc2 FOR TYPE macaddr USING hash AS STORAGE macaddr;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR CLASS alt_opc1 USING hash OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:


ALTER OPERATOR FAMILY alt_opf3 USING hash RENAME TO alt_opf4;
RESULT:
	postgres: must be owner of operator family alt_opf3


-----------
QUERY:
	-- failed (not owner)
ALTER OPERATOR FAMILY alt_opf1 USING hash RENAME TO alt_opf4;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER OPERATOR FAMILY alt_opf3 USING hash OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be owner of operator family alt_opf3


-----------
QUERY:
  -- failed (not owner)
ALTER OPERATOR FAMILY alt_opf2 USING hash OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user3"


-----------
QUERY:
  -- failed (no role membership)
ALTER OPERATOR FAMILY alt_opf3 USING hash SET SCHEMA alt_nsp2;
RESULT:
	postgres: must be owner of operator family alt_opf3


-----------
QUERY:
  -- failed (not owner)
ALTER OPERATOR FAMILY alt_opf2 USING hash SET SCHEMA alt_nsp2;
RESULT:
	postgres: operator family "alt_opf2" for access method "hash" already exists in schema "alt_nsp2"


-----------
QUERY:
  -- failed (name conflict)

ALTER OPERATOR CLASS alt_opc3 USING hash RENAME TO alt_opc4;
RESULT:
	postgres: must be owner of operator class alt_opc3


-----------
QUERY:
	-- failed (not owner)
ALTER OPERATOR CLASS alt_opc1 USING hash RENAME TO alt_opc4;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER OPERATOR CLASS alt_opc3 USING hash OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be owner of operator class alt_opc3


-----------
QUERY:
  -- failed (not owner)
ALTER OPERATOR CLASS alt_opc2 USING hash OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user3"


-----------
QUERY:
  -- failed (no role membership)
ALTER OPERATOR CLASS alt_opc3 USING hash SET SCHEMA alt_nsp2;
RESULT:
	postgres: must be owner of operator class alt_opc3


-----------
QUERY:
  -- failed (not owner)
ALTER OPERATOR CLASS alt_opc2 USING hash SET SCHEMA alt_nsp2;
RESULT:
	postgres: operator class "alt_opc2" for access method "hash" already exists in schema "alt_nsp2"


-----------
QUERY:
  -- failed (name conflict)

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SELECT nspname, opfname, amname, rolname
  FROM pg_opfamily o, pg_am m, pg_namespace n, pg_authid a
  WHERE o.opfmethod = m.oid AND o.opfnamespace = n.oid AND o.opfowner = a.oid
    AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
	AND NOT opfname LIKE 'alt_opc%'
  ORDER BY nspname, opfname;
RESULT:
	postgres: [('alt_nsp1', 'alt_opf2', 'hash', 'regress_alter_generic_user2'), ('alt_nsp1', 'alt_opf3', 'hash', 'regress_alter_generic_user1'), ('alt_nsp1', 'alt_opf4', 'hash', 'regress_alter_generic_user2'), ('alt_nsp2', 'alt_opf2', 'hash', 'regress_alter_generic_user3')]

-----------
QUERY:


SELECT nspname, opcname, amname, rolname
  FROM pg_opclass o, pg_am m, pg_namespace n, pg_authid a
  WHERE o.opcmethod = m.oid AND o.opcnamespace = n.oid AND o.opcowner = a.oid
    AND n.nspname IN ('alt_nsp1', 'alt_nsp2')
  ORDER BY nspname, opcname;
RESULT:
	postgres: [('alt_nsp1', 'alt_opc2', 'hash', 'regress_alter_generic_user2'), ('alt_nsp1', 'alt_opc3', 'hash', 'regress_alter_generic_user1'), ('alt_nsp1', 'alt_opc4', 'hash', 'regress_alter_generic_user2'), ('alt_nsp2', 'alt_opc2', 'hash', 'regress_alter_generic_user3')]

-----------
QUERY:


-- ALTER OPERATOR FAMILY ... ADD/DROP

-- Should work. Textbook case of CREATE / ALTER ADD / ALTER DROP / DROP
BEGIN TRANSACTION;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR FAMILY alt_opf4 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf4 USING btree ADD
  -- int4 vs int2
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2);
RESULT:
	postgres: None

-----------
QUERY:


ALTER OPERATOR FAMILY alt_opf4 USING btree DROP
  -- int4 vs int2
  OPERATOR 1 (int4, int2) ,
  OPERATOR 2 (int4, int2) ,
  OPERATOR 3 (int4, int2) ,
  OPERATOR 4 (int4, int2) ,
  OPERATOR 5 (int4, int2) ,
  FUNCTION 1 (int4, int2) ;
RESULT:
	postgres: None

-----------
QUERY:

DROP OPERATOR FAMILY alt_opf4 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. Invalid values for ALTER OPERATOR FAMILY .. ADD / DROP
CREATE OPERATOR FAMILY alt_opf4 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf4 USING invalid_index_method ADD  OPERATOR 1 < (int4, int2);
RESULT:
	postgres: access method "invalid_index_method" does not exist


-----------
QUERY:
 -- invalid indexing_method
ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 6 < (int4, int2);
RESULT:
	postgres: invalid operator number 6, must be between 1 and 5


-----------
QUERY:
 -- operator number should be between 1 and 5
ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 0 < (int4, int2);
RESULT:
	postgres: invalid operator number 0, must be between 1 and 5


-----------
QUERY:
 -- operator number should be between 1 and 5
ALTER OPERATOR FAMILY alt_opf4 USING btree ADD OPERATOR 1 < ;
RESULT:
	postgres: operator argument types must be specified in ALTER OPERATOR FAMILY


-----------
QUERY:
 -- operator without argument types
ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 0 btint42cmp(int4, int2);
RESULT:
	postgres: invalid function number 0, must be between 1 and 5


-----------
QUERY:
 -- invalid options parsing function
ALTER OPERATOR FAMILY alt_opf4 USING btree ADD FUNCTION 6 btint42cmp(int4, int2);
RESULT:
	postgres: invalid function number 6, must be between 1 and 5


-----------
QUERY:
 -- function number should be between 1 and 5
ALTER OPERATOR FAMILY alt_opf4 USING btree ADD STORAGE invalid_storage;
RESULT:
	postgres: STORAGE cannot be specified in ALTER OPERATOR FAMILY


-----------
QUERY:
 -- Ensure STORAGE is not a part of ALTER OPERATOR FAMILY
DROP OPERATOR FAMILY alt_opf4 USING btree;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. Need to be SUPERUSER to do ALTER OPERATOR FAMILY .. ADD / DROP
BEGIN TRANSACTION;
RESULT:
	postgres: None

-----------
QUERY:

CREATE ROLE regress_alter_generic_user5 NOSUPERUSER;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR FAMILY alt_opf5 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

SET ROLE regress_alter_generic_user5;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf5 USING btree ADD OPERATOR 1 < (int4, int2), FUNCTION 1 btint42cmp(int4, int2);
RESULT:
	postgres: must be superuser to alter an operator family


-----------
QUERY:

RESET ROLE;
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

DROP OPERATOR FAMILY alt_opf5 USING btree;
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. Need rights to namespace for ALTER OPERATOR FAMILY .. ADD / DROP
BEGIN TRANSACTION;
RESULT:
	postgres: None

-----------
QUERY:

CREATE ROLE regress_alter_generic_user6;
RESULT:
	postgres: None

-----------
QUERY:

CREATE SCHEMA alt_nsp6;
RESULT:
	postgres: None

-----------
QUERY:

REVOKE ALL ON SCHEMA alt_nsp6 FROM regress_alter_generic_user6;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

SET ROLE regress_alter_generic_user6;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_nsp6.alt_opf6 USING btree ADD OPERATOR 1 < (int4, int2);
RESULT:
	postgres: permission denied for schema alt_nsp6


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. Only two arguments required for ALTER OPERATOR FAMILY ... DROP OPERATOR
CREATE OPERATOR FAMILY alt_opf7 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf7 USING btree ADD OPERATOR 1 < (int4, int2);
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf7 USING btree DROP OPERATOR 1 (int4, int2, int8);
RESULT:
	postgres: one or two argument types must be specified


-----------
QUERY:

DROP OPERATOR FAMILY alt_opf7 USING btree;
RESULT:
	postgres: None

-----------
QUERY:


-- Should work. During ALTER OPERATOR FAMILY ... DROP OPERATOR
-- when left type is the same as right type, a DROP with only one argument type should work
CREATE OPERATOR FAMILY alt_opf8 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf8 USING btree ADD OPERATOR 1 < (int4, int4);
RESULT:
	postgres: None

-----------
QUERY:

DROP OPERATOR FAMILY alt_opf8 USING btree;
RESULT:
	postgres: None

-----------
QUERY:


-- Should work. Textbook case of ALTER OPERATOR FAMILY ... ADD OPERATOR with FOR ORDER BY
CREATE OPERATOR FAMILY alt_opf9 USING gist;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf9 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
RESULT:
	postgres: None

-----------
QUERY:

DROP OPERATOR FAMILY alt_opf9 USING gist;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. Ensure correct ordering methods in ALTER OPERATOR FAMILY ... ADD OPERATOR .. FOR ORDER BY
CREATE OPERATOR FAMILY alt_opf10 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf10 USING btree ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
RESULT:
	postgres: access method "btree" does not support ordering operators


-----------
QUERY:

DROP OPERATOR FAMILY alt_opf10 USING btree;
RESULT:
	postgres: None

-----------
QUERY:


-- Should work. Textbook case of ALTER OPERATOR FAMILY ... ADD OPERATOR with FOR ORDER BY
CREATE OPERATOR FAMILY alt_opf11 USING gist;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf11 USING gist ADD OPERATOR 1 < (int4, int4) FOR ORDER BY float_ops;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf11 USING gist DROP OPERATOR 1 (int4, int4);
RESULT:
	postgres: None

-----------
QUERY:

DROP OPERATOR FAMILY alt_opf11 USING gist;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. btree comparison functions should return INTEGER in ALTER OPERATOR FAMILY ... ADD FUNCTION
BEGIN TRANSACTION;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR FAMILY alt_opf12 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

CREATE FUNCTION fn_opf12  (int4, int2) RETURNS BIGINT AS 'SELECT NULL::BIGINT;
RESULT:
	postgres: unterminated quoted string at or near "'SELECT NULL::BIGINT;"
LINE 2: ...FUNCTION fn_opf12  (int4, int2) RETURNS BIGINT AS 'SELECT NU...
                                                             ^


-----------
QUERY:
' LANGUAGE SQL;
RESULT:
	postgres: unterminated quoted string at or near "' LANGUAGE SQL;"
LINE 1: ' LANGUAGE SQL;
        ^


-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf12 USING btree ADD FUNCTION 1 fn_opf12(int4, int2);
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

DROP OPERATOR FAMILY alt_opf12 USING btree;
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. hash comparison functions should return INTEGER in ALTER OPERATOR FAMILY ... ADD FUNCTION
BEGIN TRANSACTION;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR FAMILY alt_opf13 USING hash;
RESULT:
	postgres: None

-----------
QUERY:

CREATE FUNCTION fn_opf13  (int4) RETURNS BIGINT AS 'SELECT NULL::BIGINT;
RESULT:
	postgres: unterminated quoted string at or near "'SELECT NULL::BIGINT;"
LINE 2: ...REATE FUNCTION fn_opf13  (int4) RETURNS BIGINT AS 'SELECT NU...
                                                             ^


-----------
QUERY:
' LANGUAGE SQL;
RESULT:
	postgres: unterminated quoted string at or near "' LANGUAGE SQL;"
LINE 1: ' LANGUAGE SQL;
        ^


-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf13 USING hash ADD FUNCTION 1 fn_opf13(int4);
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

DROP OPERATOR FAMILY alt_opf13 USING hash;
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. btree comparison functions should have two arguments in ALTER OPERATOR FAMILY ... ADD FUNCTION
BEGIN TRANSACTION;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR FAMILY alt_opf14 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

CREATE FUNCTION fn_opf14 (int4) RETURNS BIGINT AS 'SELECT NULL::BIGINT;
RESULT:
	postgres: unterminated quoted string at or near "'SELECT NULL::BIGINT;"
LINE 2: CREATE FUNCTION fn_opf14 (int4) RETURNS BIGINT AS 'SELECT NU...
                                                          ^


-----------
QUERY:
' LANGUAGE SQL;
RESULT:
	postgres: unterminated quoted string at or near "' LANGUAGE SQL;"
LINE 1: ' LANGUAGE SQL;
        ^


-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf14 USING btree ADD FUNCTION 1 fn_opf14(int4);
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

DROP OPERATOR FAMILY alt_opf14 USING btree;
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. hash comparison functions should have one argument in ALTER OPERATOR FAMILY ... ADD FUNCTION
BEGIN TRANSACTION;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OPERATOR FAMILY alt_opf15 USING hash;
RESULT:
	postgres: None

-----------
QUERY:

CREATE FUNCTION fn_opf15 (int4, int2) RETURNS BIGINT AS 'SELECT NULL::BIGINT;
RESULT:
	postgres: unterminated quoted string at or near "'SELECT NULL::BIGINT;"
LINE 2: ... FUNCTION fn_opf15 (int4, int2) RETURNS BIGINT AS 'SELECT NU...
                                                             ^


-----------
QUERY:
' LANGUAGE SQL;
RESULT:
	postgres: unterminated quoted string at or near "' LANGUAGE SQL;"
LINE 1: ' LANGUAGE SQL;
        ^


-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf15 USING hash ADD FUNCTION 1 fn_opf15(int4, int2);
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

DROP OPERATOR FAMILY alt_opf15 USING hash;
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ROLLBACK;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. In gist throw an error when giving different data types for function argument
-- without defining left / right type in ALTER OPERATOR FAMILY ... ADD FUNCTION
CREATE OPERATOR FAMILY alt_opf16 USING gist;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf16 USING gist ADD FUNCTION 1 btint42cmp(int4, int2);
RESULT:
	postgres: associated data types must be specified for index support function


-----------
QUERY:

DROP OPERATOR FAMILY alt_opf16 USING gist;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. duplicate operator number / function number in ALTER OPERATOR FAMILY ... ADD FUNCTION
CREATE OPERATOR FAMILY alt_opf17 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4), OPERATOR 1 < (int4, int4);
RESULT:
	postgres: operator number 1 for (integer,integer) appears more than once


-----------
QUERY:
 -- operator # appears twice in same statement
ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4);
RESULT:
	postgres: None

-----------
QUERY:
 -- operator 1 requested first-time
ALTER OPERATOR FAMILY alt_opf17 USING btree ADD OPERATOR 1 < (int4, int4);
RESULT:
	postgres: operator 1(integer,integer) already exists in operator family "alt_opf17"


-----------
QUERY:
 -- operator 1 requested again in separate statement
ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2);
RESULT:
	postgres: function number 1 for (integer,smallint) appears more than once


-----------
QUERY:
    -- procedure 1 appears twice in same statement
ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2);
RESULT:
	postgres: None

-----------
QUERY:
    -- procedure 1 appears first time
ALTER OPERATOR FAMILY alt_opf17 USING btree ADD
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2);
RESULT:
	postgres: operator 1(integer,smallint) already exists in operator family "alt_opf17"


-----------
QUERY:
    -- procedure 1 requested again in separate statement
DROP OPERATOR FAMILY alt_opf17 USING btree;
RESULT:
	postgres: None

-----------
QUERY:



-- Should fail. Ensure that DROP requests for missing OPERATOR / FUNCTIONS
-- return appropriate message in ALTER OPERATOR FAMILY ... DROP OPERATOR / FUNCTION
CREATE OPERATOR FAMILY alt_opf18 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf18 USING btree DROP OPERATOR 1 (int4, int4);
RESULT:
	postgres: operator 1(integer,integer) does not exist in operator family "alt_opf18"


-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf18 USING btree ADD
  OPERATOR 1 < (int4, int2) ,
  OPERATOR 2 <= (int4, int2) ,
  OPERATOR 3 = (int4, int2) ,
  OPERATOR 4 >= (int4, int2) ,
  OPERATOR 5 > (int4, int2) ,
  FUNCTION 1 btint42cmp(int4, int2);
RESULT:
	postgres: None

-----------
QUERY:

-- Should fail. Not allowed to have cross-type equalimage function.
ALTER OPERATOR FAMILY alt_opf18 USING btree
  ADD FUNCTION 4 (int4, int2) btequalimage(oid);
RESULT:
	postgres: btree equal image functions must not be cross-type


-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf18 USING btree DROP FUNCTION 2 (int4, int4);
RESULT:
	postgres: function 2(integer,integer) does not exist in operator family "alt_opf18"


-----------
QUERY:

DROP OPERATOR FAMILY alt_opf18 USING btree;
RESULT:
	postgres: None

-----------
QUERY:


-- Should fail. Invalid opclass options function (#5) specifications.
CREATE OPERATOR FAMILY alt_opf19 USING btree;
RESULT:
	postgres: None

-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 test_opclass_options_func(internal, text[], bool);
RESULT:
	postgres: function test_opclass_options_func(internal, text[], boolean) does not exist


-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4) btint42cmp(int4, int2);
RESULT:
	postgres: invalid operator class options parsing function
HINT:  Valid signature of operator class options parsing function is (internal) RETURNS void.


-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4, int2) btint42cmp(int4, int2);
RESULT:
	postgres: left and right associated data types for operator class options parsing functions must match


-----------
QUERY:

ALTER OPERATOR FAMILY alt_opf19 USING btree ADD FUNCTION 5 (int4) test_opclass_options_func(internal);
RESULT:
	postgres: None

-----------
QUERY:
 -- Ok
ALTER OPERATOR FAMILY alt_opf19 USING btree DROP FUNCTION 5 (int4, int4);
RESULT:
	postgres: None

-----------
QUERY:

DROP OPERATOR FAMILY alt_opf19 USING btree;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Statistics
--
SET SESSION AUTHORIZATION regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE alt_regress_1 (a INTEGER, b INTEGER);
RESULT:
	postgres: None

-----------
QUERY:

CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_1;
RESULT:
	postgres: None

-----------
QUERY:


ALTER STATISTICS alt_stat1 RENAME TO alt_stat2;
RESULT:
	postgres: statistics object "alt_stat2" already exists in schema "alt_nsp1"


-----------
QUERY:
   -- failed (name conflict)
ALTER STATISTICS alt_stat1 RENAME TO alt_stat3;
RESULT:
	postgres: None

-----------
QUERY:
   -- OK
ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user2"


-----------
QUERY:
  -- failed (no role membership)
ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER STATISTICS alt_stat2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
    -- OK

SET SESSION AUTHORIZATION regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE alt_regress_2 (a INTEGER, b INTEGER);
RESULT:
	postgres: None

-----------
QUERY:

CREATE STATISTICS alt_stat1 ON a, b FROM alt_regress_2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE STATISTICS alt_stat2 ON a, b FROM alt_regress_2;
RESULT:
	postgres: None

-----------
QUERY:


ALTER STATISTICS alt_stat3 RENAME TO alt_stat4;
RESULT:
	postgres: must be owner of statistics object alt_stat3


-----------
QUERY:
    -- failed (not owner)
ALTER STATISTICS alt_stat1 RENAME TO alt_stat4;
RESULT:
	postgres: None

-----------
QUERY:
    -- OK
ALTER STATISTICS alt_stat3 OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be owner of statistics object alt_stat3


-----------
QUERY:
 -- failed (not owner)
ALTER STATISTICS alt_stat2 OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user3"


-----------
QUERY:
 -- failed (no role membership)
ALTER STATISTICS alt_stat3 SET SCHEMA alt_nsp2;
RESULT:
	postgres: must be owner of statistics object alt_stat3


-----------
QUERY:
		-- failed (not owner)
ALTER STATISTICS alt_stat2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: statistics object "alt_stat2" already exists in schema "alt_nsp2"


-----------
QUERY:
		-- failed (name conflict)

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:

SELECT nspname, stxname, rolname
  FROM pg_statistic_ext s, pg_namespace n, pg_authid a
 WHERE s.stxnamespace = n.oid AND s.stxowner = a.oid
   AND n.nspname in ('alt_nsp1', 'alt_nsp2')
 ORDER BY nspname, stxname;
RESULT:
	postgres: [('alt_nsp1', 'alt_stat2', 'regress_alter_generic_user2'), ('alt_nsp1', 'alt_stat3', 'regress_alter_generic_user1'), ('alt_nsp1', 'alt_stat4', 'regress_alter_generic_user2'), ('alt_nsp2', 'alt_stat2', 'regress_alter_generic_user3')]

-----------
QUERY:


--
-- Text Search Dictionary
--
SET SESSION AUTHORIZATION regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
RESULT:
	postgres: None

-----------
QUERY:


ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict2;
RESULT:
	postgres: text search dictionary "alt_ts_dict2" already exists in schema "alt_nsp1"


-----------
QUERY:
  -- failed (name conflict)
ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user2"


-----------
QUERY:
  -- failed (no role membership)
ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

SET SESSION AUTHORIZATION regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEXT SEARCH DICTIONARY alt_ts_dict1 (template=simple);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEXT SEARCH DICTIONARY alt_ts_dict2 (template=simple);
RESULT:
	postgres: None

-----------
QUERY:


ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 RENAME TO alt_ts_dict4;
RESULT:
	postgres: must be owner of text search dictionary alt_ts_dict3


-----------
QUERY:
  -- failed (not owner)
ALTER TEXT SEARCH DICTIONARY alt_ts_dict1 RENAME TO alt_ts_dict4;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be owner of text search dictionary alt_ts_dict3


-----------
QUERY:
  -- failed (not owner)
ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user3"


-----------
QUERY:
  -- failed (no role membership)
ALTER TEXT SEARCH DICTIONARY alt_ts_dict3 SET SCHEMA alt_nsp2;
RESULT:
	postgres: must be owner of text search dictionary alt_ts_dict3


-----------
QUERY:
  -- failed (not owner)
ALTER TEXT SEARCH DICTIONARY alt_ts_dict2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: text search dictionary "alt_ts_dict2" already exists in schema "alt_nsp2"


-----------
QUERY:
  -- failed (name conflict)

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SELECT nspname, dictname, rolname
  FROM pg_ts_dict t, pg_namespace n, pg_authid a
  WHERE t.dictnamespace = n.oid AND t.dictowner = a.oid
    AND n.nspname in ('alt_nsp1', 'alt_nsp2')
  ORDER BY nspname, dictname;
RESULT:
	postgres: [('alt_nsp1', 'alt_ts_dict2', 'regress_alter_generic_user2'), ('alt_nsp1', 'alt_ts_dict3', 'regress_alter_generic_user1'), ('alt_nsp1', 'alt_ts_dict4', 'regress_alter_generic_user2'), ('alt_nsp2', 'alt_ts_dict2', 'regress_alter_generic_user3')]

-----------
QUERY:


--
-- Text Search Configuration
--
SET SESSION AUTHORIZATION regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
RESULT:
	postgres: None

-----------
QUERY:


ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf2;
RESULT:
	postgres: text search configuration "alt_ts_conf2" already exists in schema "alt_nsp1"


-----------
QUERY:
  -- failed (name conflict)
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user2"


-----------
QUERY:
  -- failed (no role membership)
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

SET SESSION AUTHORIZATION regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEXT SEARCH CONFIGURATION alt_ts_conf1 (copy=english);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEXT SEARCH CONFIGURATION alt_ts_conf2 (copy=english);
RESULT:
	postgres: None

-----------
QUERY:


ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 RENAME TO alt_ts_conf4;
RESULT:
	postgres: must be owner of text search configuration alt_ts_conf3


-----------
QUERY:
  -- failed (not owner)
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf1 RENAME TO alt_ts_conf4;
RESULT:
	postgres: None

-----------
QUERY:
  -- OK
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 OWNER TO regress_alter_generic_user2;
RESULT:
	postgres: must be owner of text search configuration alt_ts_conf3


-----------
QUERY:
  -- failed (not owner)
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 OWNER TO regress_alter_generic_user3;
RESULT:
	postgres: must be able to SET ROLE "regress_alter_generic_user3"


-----------
QUERY:
  -- failed (no role membership)
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf3 SET SCHEMA alt_nsp2;
RESULT:
	postgres: must be owner of text search configuration alt_ts_conf3


-----------
QUERY:
  -- failed (not owner)
ALTER TEXT SEARCH CONFIGURATION alt_ts_conf2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: text search configuration "alt_ts_conf2" already exists in schema "alt_nsp2"


-----------
QUERY:
  -- failed (name conflict)

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SELECT nspname, cfgname, rolname
  FROM pg_ts_config t, pg_namespace n, pg_authid a
  WHERE t.cfgnamespace = n.oid AND t.cfgowner = a.oid
    AND n.nspname in ('alt_nsp1', 'alt_nsp2')
  ORDER BY nspname, cfgname;
RESULT:
	postgres: [('alt_nsp1', 'alt_ts_conf2', 'regress_alter_generic_user2'), ('alt_nsp1', 'alt_ts_conf3', 'regress_alter_generic_user1'), ('alt_nsp1', 'alt_ts_conf4', 'regress_alter_generic_user2'), ('alt_nsp2', 'alt_ts_conf2', 'regress_alter_generic_user3')]

-----------
QUERY:


--
-- Text Search Template
--
CREATE TEXT SEARCH TEMPLATE alt_ts_temp1 (lexize=dsimple_lexize);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
RESULT:
	postgres: None

-----------
QUERY:


ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp2;
RESULT:
	postgres: text search template "alt_ts_temp2" already exists in schema "alt_nsp1"


-----------
QUERY:
 -- failed (name conflict)
ALTER TEXT SEARCH TEMPLATE alt_ts_temp1 RENAME TO alt_ts_temp3;
RESULT:
	postgres: None

-----------
QUERY:
 -- OK
ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
    -- OK

CREATE TEXT SEARCH TEMPLATE alt_ts_temp2 (lexize=dsimple_lexize);
RESULT:
	postgres: None

-----------
QUERY:

ALTER TEXT SEARCH TEMPLATE alt_ts_temp2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: text search template "alt_ts_temp2" already exists in schema "alt_nsp2"


-----------
QUERY:
    -- failed (name conflict)

-- invalid: non-lowercase quoted identifiers
CREATE TEXT SEARCH TEMPLATE tstemp_case ("Init" = init_function);
RESULT:
	postgres: text search template parameter "Init" not recognized


-----------
QUERY:


SELECT nspname, tmplname
  FROM pg_ts_template t, pg_namespace n
  WHERE t.tmplnamespace = n.oid AND nspname like 'alt_nsp%'
  ORDER BY nspname, tmplname;
RESULT:
	postgres: [('alt_nsp1', 'alt_ts_temp2'), ('alt_nsp1', 'alt_ts_temp3'), ('alt_nsp2', 'alt_ts_temp2')]

-----------
QUERY:


--
-- Text Search Parser
--

CREATE TEXT SEARCH PARSER alt_ts_prs1
    (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEXT SEARCH PARSER alt_ts_prs2
    (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
RESULT:
	postgres: None

-----------
QUERY:


ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs2;
RESULT:
	postgres: text search parser "alt_ts_prs2" already exists in schema "alt_nsp1"


-----------
QUERY:
 -- failed (name conflict)
ALTER TEXT SEARCH PARSER alt_ts_prs1 RENAME TO alt_ts_prs3;
RESULT:
	postgres: None

-----------
QUERY:
 -- OK
ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: None

-----------
QUERY:
   -- OK

CREATE TEXT SEARCH PARSER alt_ts_prs2
    (start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype);
RESULT:
	postgres: None

-----------
QUERY:

ALTER TEXT SEARCH PARSER alt_ts_prs2 SET SCHEMA alt_nsp2;
RESULT:
	postgres: text search parser "alt_ts_prs2" already exists in schema "alt_nsp2"


-----------
QUERY:
   -- failed (name conflict)

-- invalid: non-lowercase quoted identifiers
CREATE TEXT SEARCH PARSER tspars_case ("Start" = start_function);
RESULT:
	postgres: text search parser parameter "Start" not recognized


-----------
QUERY:


SELECT nspname, prsname
  FROM pg_ts_parser t, pg_namespace n
  WHERE t.prsnamespace = n.oid AND nspname like 'alt_nsp%'
  ORDER BY nspname, prsname;
RESULT:
	postgres: [('alt_nsp1', 'alt_ts_prs2'), ('alt_nsp1', 'alt_ts_prs3'), ('alt_nsp2', 'alt_ts_prs2')]

-----------
QUERY:


---
--- Cleanup resources
---
DROP FOREIGN DATA WRAPPER alt_fdw2 CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP FOREIGN DATA WRAPPER alt_fdw3 CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


DROP LANGUAGE alt_lang2 CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP LANGUAGE alt_lang3 CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


DROP SCHEMA alt_nsp1 CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP SCHEMA alt_nsp2 CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


DROP USER regress_alter_generic_user1;
RESULT:
	postgres: None

-----------
QUERY:

DROP USER regress_alter_generic_user2;
RESULT:
	postgres: None

-----------
QUERY:

DROP USER regress_alter_generic_user3;
RESULT:
	postgres: None
