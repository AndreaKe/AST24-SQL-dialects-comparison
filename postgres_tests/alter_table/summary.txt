Guest DBMS identified: postgres
-----------
QUERY:
--
-- ALTER_TABLE
--

-- Clean up in case a prior regression run failed
SET client_min_messages TO 'warning'
RESULT: []

-----------
QUERY:
DROP ROLE IF EXISTS regress_alter_table_user1
RESULT: []

-----------
QUERY:
RESET client_min_messages
RESULT: []

-----------
QUERY:
CREATE USER regress_alter_table_user1
RESULT: []

-----------
QUERY:
--
-- add attribute
--

CREATE TABLE attmp (initial int4)
RESULT: []

-----------
QUERY:
COMMENT ON TABLE attmp_wrong IS 'table comment'
RESULT: []

-----------
QUERY:
COMMENT ON TABLE attmp IS 'table comment'
RESULT: []

-----------
QUERY:
COMMENT ON TABLE attmp IS NULL
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN xmin integer
RESULT: []

-----------
QUERY:
-- fails

ALTER TABLE attmp ADD COLUMN a int4 default 3
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN b name
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN c text
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN d float8
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN e float4
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN f int2
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN g polygon
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN i char
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN k int4
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN l tid
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN m xid
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN n oidvector
RESULT: []

-----------
QUERY:
--ALTER TABLE attmp ADD COLUMN o lock /* REPLACED */,
ALTER TABLE attmp ADD COLUMN p boolean
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN q point
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN r lseg
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN s path
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN t box
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN v timestamp
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN w interval
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN x float8[]
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN y float4[]
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN z int2[]
RESULT: []

-----------
QUERY:
INSERT INTO attmp (a, b, c, d, e, f, g,    i,    k, l, m, n, p, q, r, s, t,
	v, w, x, y, z)
   VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
	'c',
	314159, '(1,1)', '512',
	'1 2 3 4 5 6 7 8', true, '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)',
	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}')
RESULT: []

-----------
QUERY:
SELECT * FROM attmp
RESULT: []

-----------
QUERY:
DROP TABLE attmp
RESULT: []

-----------
QUERY:
-- the wolf bug - schema mods caused inconsistent row descriptors
CREATE TABLE attmp (
	initial 	int4
)
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN a int4
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN b name
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN c text
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN d float8
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN e float4
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN f int2
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN g polygon
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN i char
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN k int4
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN l tid
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN m xid
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN n oidvector
RESULT: []

-----------
QUERY:
--ALTER TABLE attmp ADD COLUMN o lock /* REPLACED */,
ALTER TABLE attmp ADD COLUMN p boolean
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN q point
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN r lseg
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN s path
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN t box
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN v timestamp
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN w interval
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN x float8[]
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN y float4[]
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ADD COLUMN z int2[]
RESULT: []

-----------
QUERY:
INSERT INTO attmp (a, b, c, d, e, f, g,    i,   k, l, m, n, p, q, r, s, t,
	v, w, x, y, z)
   VALUES (4, 'name', 'text', 4.1, 4.1, 2, '(4.1,4.1,3.1,3.1)',
        'c',
	314159, '(1,1)', '512',
	'1 2 3 4 5 6 7 8', true, '(1.1,1.1)', '(4.1,4.1,3.1,3.1)',
	'(0,2,4.1,4.1,3.1,3.1)', '(4.1,4.1,3.1,3.1)',
	'epoch', '01:00:10', '{1.0,2.0,3.0,4.0}', '{1.0,2.0,3.0,4.0}', '{1,2,3,4}')
RESULT: []

-----------
QUERY:
SELECT * FROM attmp
RESULT: []

-----------
QUERY:
CREATE INDEX attmp_idx ON attmp (a, (d + e), b)
RESULT: []

-----------
QUERY:
ALTER INDEX attmp_idx ALTER COLUMN 0 SET STATISTICS 1000
RESULT: []

-----------
QUERY:
ALTER INDEX attmp_idx ALTER COLUMN 1 SET STATISTICS 1000
RESULT: []

-----------
QUERY:
ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS 1000
RESULT: []

-----------
QUERY:
-- \d+ attmp_idx

ALTER INDEX attmp_idx ALTER COLUMN 3 SET STATISTICS 1000
RESULT: []

-----------
QUERY:
ALTER INDEX attmp_idx ALTER COLUMN 4 SET STATISTICS 1000
RESULT: []

-----------
QUERY:
ALTER INDEX attmp_idx ALTER COLUMN 2 SET STATISTICS -1
RESULT: []

-----------
QUERY:
DROP TABLE attmp
RESULT: []

-----------
QUERY:
--
-- rename - check on both non-temp and temp tables
--
CREATE TABLE attmp (regtable int)
RESULT: []

-----------
QUERY:
CREATE TEMP TABLE attmp (attmptable int)
RESULT: []

-----------
QUERY:
ALTER TABLE attmp RENAME TO attmp_new
RESULT: []

-----------
QUERY:
SELECT * FROM attmp
RESULT: []

-----------
QUERY:
SELECT * FROM attmp_new
RESULT: []

-----------
QUERY:
ALTER TABLE attmp RENAME TO attmp_new2
RESULT: []

-----------
QUERY:
SELECT * FROM attmp
RESULT: []

-----------
QUERY:
-- should fail
SELECT * FROM attmp_new
RESULT: []

-----------
QUERY:
SELECT * FROM attmp_new2
RESULT: []

-----------
QUERY:
DROP TABLE attmp_new
RESULT: []

-----------
QUERY:
DROP TABLE attmp_new2
RESULT: []

-----------
QUERY:
-- check rename of partitioned tables and indexes also
CREATE TABLE part_attmp (a int primary key) partition by range (a)
RESULT: []

-----------
QUERY:
CREATE TABLE part_attmp1 PARTITION OF part_attmp FOR VALUES FROM (0) TO (100)
RESULT: []

-----------
QUERY:
ALTER INDEX part_attmp_pkey RENAME TO part_attmp_index
RESULT: []

-----------
QUERY:
ALTER INDEX part_attmp1_pkey RENAME TO part_attmp1_index
RESULT: []

-----------
QUERY:
ALTER TABLE part_attmp RENAME TO part_at2tmp
RESULT: []

-----------
QUERY:
ALTER TABLE part_attmp1 RENAME TO part_at2tmp1
RESULT: []

-----------
QUERY:
SET ROLE regress_alter_table_user1
RESULT: []

-----------
QUERY:
ALTER INDEX part_attmp_index RENAME TO fail
RESULT: []

-----------
QUERY:
ALTER INDEX part_attmp1_index RENAME TO fail
RESULT: []

-----------
QUERY:
ALTER TABLE part_at2tmp RENAME TO fail
RESULT: []

-----------
QUERY:
ALTER TABLE part_at2tmp1 RENAME TO fail
RESULT: []

-----------
QUERY:
RESET ROLE
RESULT: []

-----------
QUERY:
DROP TABLE part_at2tmp
RESULT: []

-----------
QUERY:
--
-- check renaming to a table/* REPLACED */''s array type/* REPLACED */''s autogenerated name
-- (the array type/* REPLACED */''s name should get out of the way)
--
CREATE TABLE attmp_array (id int)
RESULT: []

-----------
QUERY:
CREATE TABLE attmp_array2 (id int)
RESULT: []

-----------
QUERY:
SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype
RESULT: []

-----------
QUERY:
SELECT typname FROM pg_type WHERE oid = 'attmp_array2[]'::regtype
RESULT: []

-----------
QUERY:
ALTER TABLE attmp_array2 RENAME TO _attmp_array
RESULT: []

-----------
QUERY:
SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype
RESULT: []

-----------
QUERY:
SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype
RESULT: []

-----------
QUERY:
DROP TABLE _attmp_array
RESULT: []

-----------
QUERY:
DROP TABLE attmp_array
RESULT: []

-----------
QUERY:
-- renaming to table/* REPLACED */''s own array type/* REPLACED */''s name is an interesting corner case
CREATE TABLE attmp_array (id int)
RESULT: []

-----------
QUERY:
SELECT typname FROM pg_type WHERE oid = 'attmp_array[]'::regtype
RESULT: []

-----------
QUERY:
ALTER TABLE attmp_array RENAME TO _attmp_array
RESULT: []

-----------
QUERY:
SELECT typname FROM pg_type WHERE oid = '_attmp_array[]'::regtype
RESULT: []

-----------
QUERY:
DROP TABLE _attmp_array
RESULT: []

-----------
QUERY:
-- ALTER TABLE ... RENAME on non-table relations
-- renaming indexes (FIXME: this should probably test the index/* REPLACED */''s functionality)
ALTER INDEX IF EXISTS __onek_unique1 RENAME TO attmp_onek_unique1
RESULT: []

-----------
QUERY:
ALTER INDEX IF EXISTS __attmp_onek_unique1 RENAME TO onek_unique1
RESULT: []

-----------
QUERY:
ALTER INDEX onek_unique1 RENAME TO attmp_onek_unique1
RESULT: []

-----------
QUERY:
ALTER INDEX attmp_onek_unique1 RENAME TO onek_unique1
RESULT: []

-----------
QUERY:
SET ROLE regress_alter_table_user1
RESULT: []

-----------
QUERY:
ALTER INDEX onek_unique1 RENAME TO fail
RESULT: []

-----------
QUERY:
-- permission denied
RESET ROLE
RESULT: []

-----------
QUERY:
-- rename statements with mismatching statement and object types
CREATE TABLE alter_idx_rename_test (a INT)
RESULT: []

-----------
QUERY:
CREATE INDEX alter_idx_rename_test_idx ON alter_idx_rename_test (a)
RESULT: []

-----------
QUERY:
CREATE TABLE alter_idx_rename_test_parted (a INT) PARTITION BY LIST (a)
RESULT: []

-----------
QUERY:
CREATE INDEX alter_idx_rename_test_parted_idx ON alter_idx_rename_test_parted (a)
RESULT: []

-----------
QUERY:
BEGIN
RESULT: []

-----------
QUERY:
ALTER INDEX alter_idx_rename_test RENAME TO alter_idx_rename_test_2
RESULT: []

-----------
QUERY:
ALTER INDEX alter_idx_rename_test_parted RENAME TO alter_idx_rename_test_parted_2
RESULT: []

-----------
QUERY:
SELECT relation::regclass, mode FROM pg_locks
WHERE pid = pg_backend_pid() AND locktype = 'relation'
  AND relation::regclass::text LIKE 'alter\_idx%'
ORDER BY relation::regclass::text COLLATE "C"
RESULT: []

-----------
QUERY:
COMMIT
RESULT: []

-----------
QUERY:
BEGIN
RESULT: []

-----------
QUERY:
ALTER INDEX alter_idx_rename_test_idx RENAME TO alter_idx_rename_test_idx_2
RESULT: []

-----------
QUERY:
ALTER INDEX alter_idx_rename_test_parted_idx RENAME TO alter_idx_rename_test_parted_idx_2
RESULT: []

-----------
QUERY:
SELECT relation::regclass, mode FROM pg_locks
WHERE pid = pg_backend_pid() AND locktype = 'relation'
  AND relation::regclass::text LIKE 'alter\_idx%'
ORDER BY relation::regclass::text COLLATE "C"
RESULT: []

-----------
QUERY:
COMMIT
RESULT: []

-----------
QUERY:
BEGIN
RESULT: []

-----------
QUERY:
ALTER TABLE alter_idx_rename_test_idx_2 RENAME TO alter_idx_rename_test_idx_3
RESULT: []

-----------
QUERY:
ALTER TABLE alter_idx_rename_test_parted_idx_2 RENAME TO alter_idx_rename_test_parted_idx_3
RESULT: []

-----------
QUERY:
SELECT relation::regclass, mode FROM pg_locks
WHERE pid = pg_backend_pid() AND locktype = 'relation'
  AND relation::regclass::text LIKE 'alter\_idx%'
ORDER BY relation::regclass::text COLLATE "C"
RESULT: []

-----------
QUERY:
COMMIT
RESULT: []

-----------
QUERY:
DROP TABLE alter_idx_rename_test_2
RESULT: []

-----------
QUERY:
-- renaming views
CREATE VIEW attmp_view (unique1) AS SELECT unique1 FROM tenk1
RESULT: []

-----------
QUERY:
ALTER TABLE attmp_view RENAME TO attmp_view_new
RESULT: []

-----------
QUERY:
SET ROLE regress_alter_table_user1
RESULT: []

-----------
QUERY:
ALTER VIEW attmp_view_new RENAME TO fail
RESULT: []

-----------
QUERY:
-- permission denied
RESET ROLE
RESULT: []

-----------
QUERY:
-- hack to ensure we get an indexscan here
set enable_seqscan to off
RESULT: []

-----------
QUERY:
set enable_bitmapscan to off
RESULT: []

-----------
QUERY:
-- 5 values, sorted
SELECT unique1 FROM tenk1 WHERE unique1 < 5
RESULT: []

-----------
QUERY:
reset enable_seqscan
RESULT: []

-----------
QUERY:
reset enable_bitmapscan
RESULT: []

-----------
QUERY:
DROP VIEW attmp_view_new
RESULT: []

-----------
QUERY:
-- toast-like relation name
alter table stud_emp rename to pg_toast_stud_emp
RESULT: []

-----------
QUERY:
alter table pg_toast_stud_emp rename to stud_emp
RESULT: []

-----------
QUERY:
-- renaming index should rename constraint as well
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1)
RESULT: []

-----------
QUERY:
ALTER INDEX onek_unique1_constraint RENAME TO onek_unique1_constraint_foo
RESULT: []

-----------
QUERY:
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo
RESULT: []

-----------
QUERY:
-- renaming constraint
ALTER TABLE onek ADD CONSTRAINT onek_check_constraint CHECK (unique1 >= 0)
RESULT: []

-----------
QUERY:
ALTER TABLE onek RENAME CONSTRAINT onek_check_constraint TO onek_check_constraint_foo
RESULT: []

-----------
QUERY:
ALTER TABLE onek DROP CONSTRAINT onek_check_constraint_foo
RESULT: []

-----------
QUERY:
-- renaming constraint should rename index as well
ALTER TABLE onek ADD CONSTRAINT onek_unique1_constraint UNIQUE (unique1)
RESULT: []

-----------
QUERY:
DROP INDEX onek_unique1_constraint
RESULT: []

-----------
QUERY:
-- to see whether it/* REPLACED */''s there
ALTER TABLE onek RENAME CONSTRAINT onek_unique1_constraint TO onek_unique1_constraint_foo
RESULT: []

-----------
QUERY:
DROP INDEX onek_unique1_constraint_foo
RESULT: []

-----------
QUERY:
-- to see whether it/* REPLACED */''s there
ALTER TABLE onek DROP CONSTRAINT onek_unique1_constraint_foo
RESULT: []

-----------
QUERY:
-- renaming constraints vs. inheritance
CREATE TABLE constraint_rename_test (a int CONSTRAINT con1 CHECK (a > 0), b int, c int)
RESULT: []

-----------
QUERY:
-- \d constraint_rename_test
CREATE TABLE constraint_rename_test2 (a int CONSTRAINT con1 CHECK (a > 0), d int) INHERITS (constraint_rename_test)
RESULT: []

-----------
QUERY:
-- \d constraint_rename_test2
ALTER TABLE constraint_rename_test2 RENAME CONSTRAINT con1 TO con1foo
RESULT: []

-----------
QUERY:
-- fail
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con1 TO con1foo
RESULT: []

-----------
QUERY:
-- fail
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con1 TO con1foo
RESULT: []

-----------
QUERY:
-- ok
-- \d constraint_rename_test
-- \d constraint_rename_test2
ALTER TABLE constraint_rename_test ADD CONSTRAINT con2 CHECK (b > 0) NO INHERIT
RESULT: []

-----------
QUERY:
ALTER TABLE ONLY constraint_rename_test RENAME CONSTRAINT con2 TO con2foo
RESULT: []

-----------
QUERY:
-- ok
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con2foo TO con2bar
RESULT: []

-----------
QUERY:
-- ok
-- \d constraint_rename_test
-- \d constraint_rename_test2
ALTER TABLE constraint_rename_test ADD CONSTRAINT con3 PRIMARY KEY (a)
RESULT: []

-----------
QUERY:
ALTER TABLE constraint_rename_test RENAME CONSTRAINT con3 TO con3foo
RESULT: []

-----------
QUERY:
-- ok
-- \d constraint_rename_test
-- \d constraint_rename_test2
DROP TABLE constraint_rename_test2
RESULT: []

-----------
QUERY:
DROP TABLE constraint_rename_test
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS constraint_not_exist RENAME CONSTRAINT con3 TO con3foo
RESULT: []

-----------
QUERY:
-- ok
ALTER TABLE IF EXISTS constraint_rename_test ADD CONSTRAINT con4 UNIQUE (a)
RESULT: []

-----------
QUERY:
-- renaming constraints with cache reset of target relation
CREATE TABLE constraint_rename_cache (a int,
  CONSTRAINT chk_a CHECK (a > 0),
  PRIMARY KEY (a))
RESULT: []

-----------
QUERY:
ALTER TABLE constraint_rename_cache
  RENAME CONSTRAINT chk_a TO chk_a_new
RESULT: []

-----------
QUERY:
ALTER TABLE constraint_rename_cache
  RENAME CONSTRAINT constraint_rename_cache_pkey TO constraint_rename_pkey_new
RESULT: []

-----------
QUERY:
CREATE TABLE like_constraint_rename_cache
  (LIKE constraint_rename_cache INCLUDING ALL)
RESULT: []

-----------
QUERY:
-- \d like_constraint_rename_cache
DROP TABLE constraint_rename_cache
RESULT: []

-----------
QUERY:
DROP TABLE like_constraint_rename_cache
RESULT: []

-----------
QUERY:
-- FOREIGN KEY CONSTRAINT adding TEST

CREATE TABLE attmp2 (a int primary key)
RESULT: []

-----------
QUERY:
CREATE TABLE attmp3 (a int, b int)
RESULT: []

-----------
QUERY:
CREATE TABLE attmp4 (a int, b int, unique(a,b))
RESULT: []

-----------
QUERY:
CREATE TABLE attmp5 (a int, b int)
RESULT: []

-----------
QUERY:
-- Insert rows into attmp2 (pktable)
INSERT INTO attmp2 values (1)
RESULT: []

-----------
QUERY:
INSERT INTO attmp2 values (2)
RESULT: []

-----------
QUERY:
INSERT INTO attmp2 values (3)
RESULT: []

-----------
QUERY:
INSERT INTO attmp2 values (4)
RESULT: []

-----------
QUERY:
-- Insert rows into attmp3
INSERT INTO attmp3 values (1,10)
RESULT: []

-----------
QUERY:
INSERT INTO attmp3 values (1,20)
RESULT: []

-----------
QUERY:
INSERT INTO attmp3 values (5,50)
RESULT: []

-----------
QUERY:
-- Try (and fail) to add constraint due to invalid source columns
ALTER TABLE attmp3 add constraint attmpconstr foreign key(c) references attmp2 match full
RESULT: []

-----------
QUERY:
-- Try (and fail) to add constraint due to invalid destination columns explicitly given
ALTER TABLE attmp3 add constraint attmpconstr foreign key(a) references attmp2(b) match full
RESULT: []

-----------
QUERY:
-- Try (and fail) to add constraint due to invalid data
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full
RESULT: []

-----------
QUERY:
-- Delete failing row
DELETE FROM attmp3 where a=5
RESULT: []

-----------
QUERY:
-- Try (and succeed)
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full
RESULT: []

-----------
QUERY:
ALTER TABLE attmp3 drop constraint attmpconstr
RESULT: []

-----------
QUERY:
INSERT INTO attmp3 values (5,50)
RESULT: []

-----------
QUERY:
-- Try NOT VALID and then VALIDATE CONSTRAINT, but fails. Delete failure then re-validate
ALTER TABLE attmp3 add constraint attmpconstr foreign key (a) references attmp2 match full NOT VALID
RESULT: []

-----------
QUERY:
ALTER TABLE attmp3 validate constraint attmpconstr
RESULT: []

-----------
QUERY:
-- Delete failing row
DELETE FROM attmp3 where a=5
RESULT: []

-----------
QUERY:
-- Try (and succeed) and repeat to show it works on already valid constraint
ALTER TABLE attmp3 validate constraint attmpconstr
RESULT: []

-----------
QUERY:
ALTER TABLE attmp3 validate constraint attmpconstr
RESULT: []

-----------
QUERY:
-- Try a non-verified CHECK constraint
ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10)
RESULT: []

-----------
QUERY:
-- fail
ALTER TABLE attmp3 ADD CONSTRAINT b_greater_than_ten CHECK (b > 10) NOT VALID
RESULT: []

-----------
QUERY:
-- succeeds
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten
RESULT: []

-----------
QUERY:
-- fails
DELETE FROM attmp3 WHERE NOT b > 10
RESULT: []

-----------
QUERY:
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten
RESULT: []

-----------
QUERY:
-- succeeds
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_greater_than_ten
RESULT: []

-----------
QUERY:
-- succeeds

-- Test inherited NOT VALID CHECK constraints
select * from attmp3
RESULT: []

-----------
QUERY:
CREATE TABLE attmp6 () INHERITS (attmp3)
RESULT: []

-----------
QUERY:
CREATE TABLE attmp7 () INHERITS (attmp3)
RESULT: []

-----------
QUERY:
INSERT INTO attmp6 VALUES (6, 30), (7, 16)
RESULT: []

-----------
QUERY:
ALTER TABLE attmp3 ADD CONSTRAINT b_le_20 CHECK (b <= 20) NOT VALID
RESULT: []

-----------
QUERY:
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20
RESULT: []

-----------
QUERY:
-- fails
DELETE FROM attmp6 WHERE b > 20
RESULT: []

-----------
QUERY:
ALTER TABLE attmp3 VALIDATE CONSTRAINT b_le_20
RESULT: []

-----------
QUERY:
-- succeeds

-- An already validated constraint must not be revalidated
CREATE FUNCTION boo(int) RETURNS int IMMUTABLE STRICT LANGUAGE plpgsql AS $$ BEGIN RAISE NOTICE 'boo: %', $1; RETURN $1; END; $$
RESULT: []

-----------
QUERY:
INSERT INTO attmp7 VALUES (8, 18)
RESULT: []

-----------
QUERY:
ALTER TABLE attmp7 ADD CONSTRAINT identity CHECK (b = boo(b))
RESULT: []

-----------
QUERY:
ALTER TABLE attmp3 ADD CONSTRAINT IDENTITY check (b = boo(b)) NOT VALID
RESULT: []

-----------
QUERY:
ALTER TABLE attmp3 VALIDATE CONSTRAINT identity
RESULT: []

-----------
QUERY:
-- A NO INHERIT constraint should not be looked for in children during VALIDATE CONSTRAINT
create table parent_noinh_convalid (a int)
RESULT: []

-----------
QUERY:
create table child_noinh_convalid () inherits (parent_noinh_convalid)
RESULT: []

-----------
QUERY:
insert into parent_noinh_convalid values (1)
RESULT: []

-----------
QUERY:
insert into child_noinh_convalid values (1)
RESULT: []

-----------
QUERY:
alter table parent_noinh_convalid add constraint check_a_is_2 check (a = 2) no inherit not valid
RESULT: []

-----------
QUERY:
-- fail, because of the row in parent
alter table parent_noinh_convalid validate constraint check_a_is_2
RESULT: []

-----------
QUERY:
delete from only parent_noinh_convalid
RESULT: []

-----------
QUERY:
-- ok (parent itself contains no violating rows)
alter table parent_noinh_convalid validate constraint check_a_is_2
RESULT: []

-----------
QUERY:
select convalidated from pg_constraint where conrelid = 'parent_noinh_convalid'::regclass and conname = 'check_a_is_2'
RESULT: []

-----------
QUERY:
-- cleanup
drop table parent_noinh_convalid, child_noinh_convalid
RESULT: []

-----------
QUERY:
-- Try (and fail) to create constraint from attmp5(a) to attmp4(a) - unique constraint on
-- attmp4 is a,b

ALTER TABLE attmp5 add constraint attmpconstr foreign key(a) references attmp4(a) match full
RESULT: []

-----------
QUERY:
DROP TABLE attmp7
RESULT: []

-----------
QUERY:
DROP TABLE attmp6
RESULT: []

-----------
QUERY:
DROP TABLE attmp5
RESULT: []

-----------
QUERY:
DROP TABLE attmp4
RESULT: []

-----------
QUERY:
DROP TABLE attmp3
RESULT: []

-----------
QUERY:
DROP TABLE attmp2
RESULT: []

-----------
QUERY:
-- NOT VALID with plan invalidation -- ensure we don/* REPLACED */''t use a constraint for
-- exclusion until validated
set constraint_exclusion TO 'partition'
RESULT: []

-----------
QUERY:
create table nv_parent (d date, check (false) no inherit not valid)
RESULT: []

-----------
QUERY:
-- not valid constraint added at creation time should automatically become valid
-- \d nv_parent

create table nv_child_2010 () inherits (nv_parent)
RESULT: []

-----------
QUERY:
create table nv_child_2011 () inherits (nv_parent)
RESULT: []

-----------
QUERY:
alter table nv_child_2010 add check (d between '2010-01-01'::date and '2010-12-31'::date) not valid
RESULT: []

-----------
QUERY:
alter table nv_child_2011 add check (d between '2011-01-01'::date and '2011-12-31'::date) not valid
RESULT: []

-----------
QUERY:
explain (costs off) select * from nv_parent where d between '2011-08-01' and '2011-08-31'
RESULT: []

-----------
QUERY:
create table nv_child_2009 (check (d between '2009-01-01'::date and '2009-12-31'::date)) inherits (nv_parent)
RESULT: []

-----------
QUERY:
explain (costs off) select * from nv_parent where d between '2011-08-01'::date and '2011-08-31'::date
RESULT: []

-----------
QUERY:
explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date
RESULT: []

-----------
QUERY:
-- after validation, the constraint should be used
alter table nv_child_2011 VALIDATE CONSTRAINT nv_child_2011_d_check
RESULT: []

-----------
QUERY:
explain (costs off) select * from nv_parent where d between '2009-08-01'::date and '2009-08-31'::date
RESULT: []

-----------
QUERY:
-- add an inherited NOT VALID constraint
alter table nv_parent add check (d between '2001-01-01'::date and '2099-12-31'::date) not valid
RESULT: []

-----------
QUERY:
-- \d nv_child_2009
-- we leave nv_parent and children around to help test pg_dump logic

-- Foreign key adding test with mixed types

-- Note: these tables are TEMP to avoid name conflicts when this test
-- is run in parallel with foreign_key.sql.

CREATE TEMP TABLE PKTABLE (ptest1 int PRIMARY KEY)
RESULT: []

-----------
QUERY:
INSERT INTO PKTABLE VALUES(42)
RESULT: []

-----------
QUERY:
CREATE TEMP TABLE FKTABLE (ftest1 inet)
RESULT: []

-----------
QUERY:
-- This next should fail, because int=inet does not exist
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable
RESULT: []

-----------
QUERY:
-- This should also fail for the same reason, but here we
-- give the column name
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable(ptest1)
RESULT: []

-----------
QUERY:
DROP TABLE FKTABLE
RESULT: []

-----------
QUERY:
-- This should succeed, even though they are different types,
-- because int=int8 exists and is a member of the integer opfamily
CREATE TEMP TABLE FKTABLE (ftest1 int8)
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable
RESULT: []

-----------
QUERY:
-- Check it actually works
INSERT INTO FKTABLE VALUES(42)
RESULT: []

-----------
QUERY:
-- should succeed
INSERT INTO FKTABLE VALUES(43)
RESULT: []

-----------
QUERY:
-- should fail
DROP TABLE FKTABLE
RESULT: []

-----------
QUERY:
-- This should fail, because we/* REPLACED */''d have to cast numeric to int which is
-- not an implicit coercion (or use numeric=numeric, but that/* REPLACED */''s not part
-- of the integer opfamily)
CREATE TEMP TABLE FKTABLE (ftest1 numeric)
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable
RESULT: []

-----------
QUERY:
DROP TABLE FKTABLE
RESULT: []

-----------
QUERY:
DROP TABLE PKTABLE
RESULT: []

-----------
QUERY:
-- On the other hand, this should work because int implicitly promotes to
-- numeric, and we allow promotion on the FK side
CREATE TEMP TABLE PKTABLE (ptest1 numeric PRIMARY KEY)
RESULT: []

-----------
QUERY:
INSERT INTO PKTABLE VALUES(42)
RESULT: []

-----------
QUERY:
CREATE TEMP TABLE FKTABLE (ftest1 int)
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1) references pktable
RESULT: []

-----------
QUERY:
-- Check it actually works
INSERT INTO FKTABLE VALUES(42)
RESULT: []

-----------
QUERY:
-- should succeed
INSERT INTO FKTABLE VALUES(43)
RESULT: []

-----------
QUERY:
-- should fail
DROP TABLE FKTABLE
RESULT: []

-----------
QUERY:
DROP TABLE PKTABLE
RESULT: []

-----------
QUERY:
CREATE TEMP TABLE PKTABLE (ptest1 int, ptest2 inet,
                           PRIMARY KEY(ptest1, ptest2))
RESULT: []

-----------
QUERY:
-- This should fail, because we just chose really odd types
CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp)
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2) references pktable
RESULT: []

-----------
QUERY:
DROP TABLE FKTABLE
RESULT: []

-----------
QUERY:
-- Again, so should this...
CREATE TEMP TABLE FKTABLE (ftest1 cidr, ftest2 timestamp)
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
     references pktable(ptest1, ptest2)
RESULT: []

-----------
QUERY:
DROP TABLE FKTABLE
RESULT: []

-----------
QUERY:
-- This fails because we mixed up the column ordering
CREATE TEMP TABLE FKTABLE (ftest1 int, ftest2 inet)
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest1, ftest2)
     references pktable(ptest2, ptest1)
RESULT: []

-----------
QUERY:
-- As does this...
ALTER TABLE FKTABLE ADD FOREIGN KEY(ftest2, ftest1)
     references pktable(ptest1, ptest2)
RESULT: []

-----------
QUERY:
DROP TABLE FKTABLE
RESULT: []

-----------
QUERY:
DROP TABLE PKTABLE
RESULT: []

-----------
QUERY:
-- Test that ALTER CONSTRAINT updates trigger deferrability properly

CREATE TEMP TABLE PKTABLE (ptest1 int primary key)
RESULT: []

-----------
QUERY:
CREATE TEMP TABLE FKTABLE (ftest1 int)
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD CONSTRAINT fknd FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD CONSTRAINT fkdd FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD CONSTRAINT fkdi FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY IMMEDIATE
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD CONSTRAINT fknd2 FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION DEFERRABLE INITIALLY DEFERRED
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ALTER CONSTRAINT fknd2 NOT DEFERRABLE
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD CONSTRAINT fkdd2 FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ALTER CONSTRAINT fkdd2 DEFERRABLE INITIALLY DEFERRED
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ADD CONSTRAINT fkdi2 FOREIGN KEY(ftest1) REFERENCES pktable
  ON DELETE CASCADE ON UPDATE NO ACTION NOT DEFERRABLE
RESULT: []

-----------
QUERY:
ALTER TABLE FKTABLE ALTER CONSTRAINT fkdi2 DEFERRABLE INITIALLY IMMEDIATE
RESULT: []

-----------
QUERY:
SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
WHERE tgrelid = 'pktable'::regclass
ORDER BY 1,2,3
RESULT: []

-----------
QUERY:
SELECT conname, tgfoid::regproc, tgtype, tgdeferrable, tginitdeferred
FROM pg_trigger JOIN pg_constraint con ON con.oid = tgconstraint
WHERE tgrelid = 'fktable'::regclass
ORDER BY 1,2,3
RESULT: []

-----------
QUERY:
-- temp tables should go away by themselves, need not drop them.

-- test check constraint adding

create table atacc1 ( test int )
RESULT: []

-----------
QUERY:
-- add a check constraint
alter table atacc1 add constraint atacc_test1 check (test>3)
RESULT: []

-----------
QUERY:
-- should fail
insert into atacc1 (test) values (2)
RESULT: []

-----------
QUERY:
-- should succeed
insert into atacc1 (test) values (4)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- let/* REPLACED */''s do one where the check fails when added
create table atacc1 ( test int )
RESULT: []

-----------
QUERY:
-- insert a soon to be failing row
insert into atacc1 (test) values (2)
RESULT: []

-----------
QUERY:
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test>3)
RESULT: []

-----------
QUERY:
insert into atacc1 (test) values (4)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- let/* REPLACED */''s do one where the check fails because the column doesn/* REPLACED */''t exist
create table atacc1 ( test int )
RESULT: []

-----------
QUERY:
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test1>3)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- something a little more complicated
create table atacc1 ( test int, test2 int, test3 int)
RESULT: []

-----------
QUERY:
-- add a check constraint (fails)
alter table atacc1 add constraint atacc_test1 check (test+test2<test3*4)
RESULT: []

-----------
QUERY:
-- should fail
insert into atacc1 (test,test2,test3) values (4,4,2)
RESULT: []

-----------
QUERY:
-- should succeed
insert into atacc1 (test,test2,test3) values (4,4,5)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- lets do some naming tests
create table atacc1 (test int check (test>3), test2 int)
RESULT: []

-----------
QUERY:
alter table atacc1 add check (test2>test)
RESULT: []

-----------
QUERY:
-- should fail for $2
insert into atacc1 (test2, test) values (3, 4)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- inheritance related tests
create table atacc1 (test int)
RESULT: []

-----------
QUERY:
create table atacc2 (test2 int)
RESULT: []

-----------
QUERY:
create table atacc3 (test3 int) inherits (atacc1, atacc2)
RESULT: []

-----------
QUERY:
alter table atacc2 add constraint foo check (test2>0)
RESULT: []

-----------
QUERY:
-- fail and then succeed on atacc2
insert into atacc2 (test2) values (-3)
RESULT: []

-----------
QUERY:
insert into atacc2 (test2) values (3)
RESULT: []

-----------
QUERY:
-- fail and then succeed on atacc3
insert into atacc3 (test2) values (-3)
RESULT: []

-----------
QUERY:
insert into atacc3 (test2) values (3)
RESULT: []

-----------
QUERY:
drop table atacc3
RESULT: []

-----------
QUERY:
drop table atacc2
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- same things with one created with INHERIT
create table atacc1 (test int)
RESULT: []

-----------
QUERY:
create table atacc2 (test2 int)
RESULT: []

-----------
QUERY:
create table atacc3 (test3 int) inherits (atacc1, atacc2)
RESULT: []

-----------
QUERY:
alter table atacc3 no inherit atacc2
RESULT: []

-----------
QUERY:
-- fail
alter table atacc3 no inherit atacc2
RESULT: []

-----------
QUERY:
-- make sure it really isn/* REPLACED */''t a child
insert into atacc3 (test2) values (3)
RESULT: []

-----------
QUERY:
select test2 from atacc2
RESULT: []

-----------
QUERY:
-- fail due to missing constraint
alter table atacc2 add constraint foo check (test2>0)
RESULT: []

-----------
QUERY:
alter table atacc3 inherit atacc2
RESULT: []

-----------
QUERY:
-- fail due to missing column
alter table atacc3 rename test2 to testx
RESULT: []

-----------
QUERY:
alter table atacc3 inherit atacc2
RESULT: []

-----------
QUERY:
-- fail due to mismatched data type
alter table atacc3 add test2 bool
RESULT: []

-----------
QUERY:
alter table atacc3 inherit atacc2
RESULT: []

-----------
QUERY:
alter table atacc3 drop test2
RESULT: []

-----------
QUERY:
-- succeed
alter table atacc3 add test2 int
RESULT: []

-----------
QUERY:
update atacc3 set test2 = 4 where test2 is null
RESULT: []

-----------
QUERY:
alter table atacc3 add constraint foo check (test2>0)
RESULT: []

-----------
QUERY:
alter table atacc3 inherit atacc2
RESULT: []

-----------
QUERY:
-- fail due to duplicates and circular inheritance
alter table atacc3 inherit atacc2
RESULT: []

-----------
QUERY:
alter table atacc2 inherit atacc3
RESULT: []

-----------
QUERY:
alter table atacc2 inherit atacc2
RESULT: []

-----------
QUERY:
-- test that we really are a child now (should see 4 not 3 and cascade should go through)
select test2 from atacc2
RESULT: []

-----------
QUERY:
drop table atacc2 cascade
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- adding only to a parent is allowed as of 9.2

create table atacc1 (test int)
RESULT: []

-----------
QUERY:
create table atacc2 (test2 int) inherits (atacc1)
RESULT: []

-----------
QUERY:
-- ok:
alter table atacc1 add constraint foo check (test>0) no inherit
RESULT: []

-----------
QUERY:
-- check constraint is not there on child
insert into atacc2 (test) values (-3)
RESULT: []

-----------
QUERY:
-- check constraint is there on parent
insert into atacc1 (test) values (-3)
RESULT: []

-----------
QUERY:
insert into atacc1 (test) values (3)
RESULT: []

-----------
QUERY:
-- fail, violating row:
alter table atacc2 add constraint foo check (test>0) no inherit
RESULT: []

-----------
QUERY:
drop table atacc2
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- test unique constraint adding

create table atacc1 ( test int )
RESULT: []

-----------
QUERY:
-- add a unique constraint
alter table atacc1 add constraint atacc_test1 unique (test)
RESULT: []

-----------
QUERY:
-- insert first value
insert into atacc1 (test) values (2)
RESULT: []

-----------
QUERY:
-- should fail
insert into atacc1 (test) values (2)
RESULT: []

-----------
QUERY:
-- should succeed
insert into atacc1 (test) values (4)
RESULT: []

-----------
QUERY:
-- try to create duplicates via alter table using - should fail
alter table atacc1 alter column test type integer using 0
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- let/* REPLACED */''s do one where the unique constraint fails when added
create table atacc1 ( test int )
RESULT: []

-----------
QUERY:
-- insert soon to be failing rows
insert into atacc1 (test) values (2)
RESULT: []

-----------
QUERY:
insert into atacc1 (test) values (2)
RESULT: []

-----------
QUERY:
-- add a unique constraint (fails)
alter table atacc1 add constraint atacc_test1 unique (test)
RESULT: []

-----------
QUERY:
insert into atacc1 (test) values (3)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- let/* REPLACED */''s do one where the unique constraint fails
-- because the column doesn/* REPLACED */''t exist
create table atacc1 ( test int )
RESULT: []

-----------
QUERY:
-- add a unique constraint (fails)
alter table atacc1 add constraint atacc_test1 unique (test1)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- something a little more complicated
create table atacc1 ( test int, test2 int)
RESULT: []

-----------
QUERY:
-- add a unique constraint
alter table atacc1 add constraint atacc_test1 unique (test, test2)
RESULT: []

-----------
QUERY:
-- insert initial value
insert into atacc1 (test,test2) values (4,4)
RESULT: []

-----------
QUERY:
-- should fail
insert into atacc1 (test,test2) values (4,4)
RESULT: []

-----------
QUERY:
-- should all succeed
insert into atacc1 (test,test2) values (4,5)
RESULT: []

-----------
QUERY:
insert into atacc1 (test,test2) values (5,4)
RESULT: []

-----------
QUERY:
insert into atacc1 (test,test2) values (5,5)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- lets do some naming tests
create table atacc1 (test int, test2 int, unique(test))
RESULT: []

-----------
QUERY:
alter table atacc1 add unique (test2)
RESULT: []

-----------
QUERY:
-- should fail for @@ second one @@
insert into atacc1 (test2, test) values (3, 3)
RESULT: []

-----------
QUERY:
insert into atacc1 (test2, test) values (2, 3)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- test primary key constraint adding

create table atacc1 ( id serial, test int)
RESULT: []

-----------
QUERY:
-- add a primary key constraint
alter table atacc1 add constraint atacc_test1 primary key (test)
RESULT: []

-----------
QUERY:
-- insert first value
insert into atacc1 (test) values (2)
RESULT: []

-----------
QUERY:
-- should fail
insert into atacc1 (test) values (2)
RESULT: []

-----------
QUERY:
-- should succeed
insert into atacc1 (test) values (4)
RESULT: []

-----------
QUERY:
-- inserting NULL should fail
insert into atacc1 (test) values(NULL)
RESULT: []

-----------
QUERY:
-- try adding a second primary key (should fail)
alter table atacc1 add constraint atacc_oid1 primary key(id)
RESULT: []

-----------
QUERY:
-- drop first primary key constraint
alter table atacc1 drop constraint atacc_test1 restrict
RESULT: []

-----------
QUERY:
-- try adding a primary key on oid (should succeed)
alter table atacc1 add constraint atacc_oid1 primary key(id)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- let/* REPLACED */''s do one where the primary key constraint fails when added
create table atacc1 ( test int )
RESULT: []

-----------
QUERY:
-- insert soon to be failing rows
insert into atacc1 (test) values (2)
RESULT: []

-----------
QUERY:
insert into atacc1 (test) values (2)
RESULT: []

-----------
QUERY:
-- add a primary key (fails)
alter table atacc1 add constraint atacc_test1 primary key (test)
RESULT: []

-----------
QUERY:
insert into atacc1 (test) values (3)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- let/* REPLACED */''s do another one where the primary key constraint fails when added
create table atacc1 ( test int )
RESULT: []

-----------
QUERY:
-- insert soon to be failing row
insert into atacc1 (test) values (NULL)
RESULT: []

-----------
QUERY:
-- add a primary key (fails)
alter table atacc1 add constraint atacc_test1 primary key (test)
RESULT: []

-----------
QUERY:
insert into atacc1 (test) values (3)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- let/* REPLACED */''s do one where the primary key constraint fails
-- because the column doesn/* REPLACED */''t exist
create table atacc1 ( test int )
RESULT: []

-----------
QUERY:
-- add a primary key constraint (fails)
alter table atacc1 add constraint atacc_test1 primary key (test1)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- adding a new column as primary key to a non-empty table.
-- should fail unless the column has a non-null default value.
create table atacc1 ( test int )
RESULT: []

-----------
QUERY:
insert into atacc1 (test) values (0)
RESULT: []

-----------
QUERY:
-- add a primary key column without a default (fails).
alter table atacc1 add column test2 int primary key
RESULT: []

-----------
QUERY:
-- now add a primary key column with a default (succeeds).
alter table atacc1 add column test2 int default 0 primary key
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- this combination used to have order-of-execution problems (bug #15580)
create table atacc1 (a int)
RESULT: []

-----------
QUERY:
insert into atacc1 values(1)
RESULT: []

-----------
QUERY:
alter table atacc1
  add column b float8 not null default random(),
  add primary key(a)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- additionally, we/* REPLACED */''ve seen issues with foreign key validation not being
-- properly delayed until after a table rewrite.  Check that works ok.
create table atacc1 (a int primary key)
RESULT: []

-----------
QUERY:
alter table atacc1 add constraint atacc1_fkey foreign key (a) references atacc1 (a) not valid
RESULT: []

-----------
QUERY:
alter table atacc1 validate constraint atacc1_fkey, alter a type bigint
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- we/* REPLACED */''ve also seen issues with check constraints being validated at the wrong
-- time when there/* REPLACED */''s a pending table rewrite.
create table atacc1 (a bigint, b int)
RESULT: []

-----------
QUERY:
insert into atacc1 values(1,1)
RESULT: []

-----------
QUERY:
alter table atacc1 add constraint atacc1_chk check(b = 1) not valid
RESULT: []

-----------
QUERY:
alter table atacc1 validate constraint atacc1_chk, alter a type int
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- same as above, but ensure the constraint violation is detected
create table atacc1 (a bigint, b int)
RESULT: []

-----------
QUERY:
insert into atacc1 values(1,2)
RESULT: []

-----------
QUERY:
alter table atacc1 add constraint atacc1_chk check(b = 1) not valid
RESULT: []

-----------
QUERY:
alter table atacc1 validate constraint atacc1_chk, alter a type int
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- something a little more complicated
create table atacc1 ( test int, test2 int)
RESULT: []

-----------
QUERY:
-- add a primary key constraint
alter table atacc1 add constraint atacc_test1 primary key (test, test2)
RESULT: []

-----------
QUERY:
-- try adding a second primary key - should fail
alter table atacc1 add constraint atacc_test2 primary key (test)
RESULT: []

-----------
QUERY:
-- insert initial value
insert into atacc1 (test,test2) values (4,4)
RESULT: []

-----------
QUERY:
-- should fail
insert into atacc1 (test,test2) values (4,4)
RESULT: []

-----------
QUERY:
insert into atacc1 (test,test2) values (NULL,3)
RESULT: []

-----------
QUERY:
insert into atacc1 (test,test2) values (3, NULL)
RESULT: []

-----------
QUERY:
insert into atacc1 (test,test2) values (NULL,NULL)
RESULT: []

-----------
QUERY:
-- should all succeed
insert into atacc1 (test,test2) values (4,5)
RESULT: []

-----------
QUERY:
insert into atacc1 (test,test2) values (5,4)
RESULT: []

-----------
QUERY:
insert into atacc1 (test,test2) values (5,5)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- lets do some naming tests
create table atacc1 (test int, test2 int, primary key(test))
RESULT: []

-----------
QUERY:
-- only first should succeed
insert into atacc1 (test2, test) values (3, 3)
RESULT: []

-----------
QUERY:
insert into atacc1 (test2, test) values (2, 3)
RESULT: []

-----------
QUERY:
insert into atacc1 (test2, test) values (1, NULL)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- alter table / alter column [set/drop] not null tests
-- try altering system catalogs, should fail
alter table pg_class alter column relname drop not null
RESULT: []

-----------
QUERY:
alter table pg_class alter relname set not null
RESULT: []

-----------
QUERY:
-- try altering non-existent table, should fail
alter table non_existent alter column bar set not null
RESULT: []

-----------
QUERY:
alter table non_existent alter column bar drop not null
RESULT: []

-----------
QUERY:
-- test setting columns to null and not null and vice versa
-- test checking for null values and primary key
create table atacc1 (test int not null)
RESULT: []

-----------
QUERY:
alter table atacc1 add constraint "atacc1_pkey" primary key (test)
RESULT: []

-----------
QUERY:
-- \d atacc1
alter table atacc1 alter column test drop not null
RESULT: []

-----------
QUERY:
-- \d atacc1
alter table atacc1 drop constraint "atacc1_pkey"
RESULT: []

-----------
QUERY:
-- \d atacc1
insert into atacc1 values (null)
RESULT: []

-----------
QUERY:
alter table atacc1 alter test set not null
RESULT: []

-----------
QUERY:
delete from atacc1
RESULT: []

-----------
QUERY:
alter table atacc1 alter test set not null
RESULT: []

-----------
QUERY:
-- try altering a non-existent column, should fail
alter table atacc1 alter bar set not null
RESULT: []

-----------
QUERY:
alter table atacc1 alter bar drop not null
RESULT: []

-----------
QUERY:
-- try creating a view and altering that, should fail
create view myview as select * from atacc1
RESULT: []

-----------
QUERY:
alter table myview alter column test drop not null
RESULT: []

-----------
QUERY:
alter table myview alter column test set not null
RESULT: []

-----------
QUERY:
drop view myview
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- set not null verified by constraints
create table atacc1 (test_a int, test_b int)
RESULT: []

-----------
QUERY:
insert into atacc1 values (null, 1)
RESULT: []

-----------
QUERY:
-- constraint not cover all values, should fail
alter table atacc1 add constraint atacc1_constr_or check(test_a is not null or test_b < 10)
RESULT: []

-----------
QUERY:
alter table atacc1 alter test_a set not null
RESULT: []

-----------
QUERY:
alter table atacc1 drop constraint atacc1_constr_or
RESULT: []

-----------
QUERY:
-- not valid constraint, should fail
alter table atacc1 add constraint atacc1_constr_invalid check(test_a is not null) not valid
RESULT: []

-----------
QUERY:
alter table atacc1 alter test_a set not null
RESULT: []

-----------
QUERY:
alter table atacc1 drop constraint atacc1_constr_invalid
RESULT: []

-----------
QUERY:
-- with valid constraint
update atacc1 set test_a = 1
RESULT: []

-----------
QUERY:
alter table atacc1 add constraint atacc1_constr_a_valid check(test_a is not null)
RESULT: []

-----------
QUERY:
alter table atacc1 alter test_a set not null
RESULT: []

-----------
QUERY:
delete from atacc1
RESULT: []

-----------
QUERY:
insert into atacc1 values (2, null)
RESULT: []

-----------
QUERY:
alter table atacc1 alter test_a drop not null
RESULT: []

-----------
QUERY:
-- test multiple set not null at same time
-- test_a checked by atacc1_constr_a_valid, test_b should fail by table scan
alter table atacc1 alter test_a set not null, alter test_b set not null
RESULT: []

-----------
QUERY:
-- commands order has no importance
alter table atacc1 alter test_b set not null, alter test_a set not null
RESULT: []

-----------
QUERY:
-- valid one by table scan, one by check constraints
update atacc1 set test_b = 1
RESULT: []

-----------
QUERY:
alter table atacc1 alter test_b set not null, alter test_a set not null
RESULT: []

-----------
QUERY:
alter table atacc1 alter test_a drop not null, alter test_b drop not null
RESULT: []

-----------
QUERY:
-- both column has check constraints
alter table atacc1 add constraint atacc1_constr_b_valid check(test_b is not null)
RESULT: []

-----------
QUERY:
alter table atacc1 alter test_b set not null, alter test_a set not null
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- test inheritance
create table parent (a int)
RESULT: []

-----------
QUERY:
create table child (b varchar(255)) inherits (parent)
RESULT: []

-----------
QUERY:
alter table parent alter a set not null
RESULT: []

-----------
QUERY:
insert into parent values (NULL)
RESULT: []

-----------
QUERY:
insert into child (a, b) values (NULL, 'foo')
RESULT: []

-----------
QUERY:
alter table parent alter a drop not null
RESULT: []

-----------
QUERY:
insert into parent values (NULL)
RESULT: []

-----------
QUERY:
insert into child (a, b) values (NULL, 'foo')
RESULT: []

-----------
QUERY:
alter table only parent alter a set not null
RESULT: []

-----------
QUERY:
alter table child alter a set not null
RESULT: []

-----------
QUERY:
drop table child
RESULT: []

-----------
QUERY:
drop table parent
RESULT: []

-----------
QUERY:
-- test setting and removing default values
create table def_test (
	c1	int4 default 5,
	c2	text default 'initial_default'
)
RESULT: []

-----------
QUERY:
insert into def_test default values
RESULT: []

-----------
QUERY:
alter table def_test alter column c1 drop default
RESULT: []

-----------
QUERY:
insert into def_test default values
RESULT: []

-----------
QUERY:
alter table def_test alter column c2 drop default
RESULT: []

-----------
QUERY:
insert into def_test default values
RESULT: []

-----------
QUERY:
alter table def_test alter column c1 set default 10
RESULT: []

-----------
QUERY:
alter table def_test alter column c2 set default 'new_default'
RESULT: []

-----------
QUERY:
insert into def_test default values
RESULT: []

-----------
QUERY:
select * from def_test
RESULT: []

-----------
QUERY:
-- set defaults to an incorrect type: this should fail
alter table def_test alter column c1 set default 'wrong_datatype'
RESULT: []

-----------
QUERY:
alter table def_test alter column c2 set default 20
RESULT: []

-----------
QUERY:
-- set defaults on a non-existent column: this should fail
alter table def_test alter column c3 set default 30
RESULT: []

-----------
QUERY:
-- set defaults on views: we need to create a view, add a rule
-- to allow insertions into it, and then alter the view to add
-- a default
create view def_view_test as select * from def_test
RESULT: []

-----------
QUERY:
create rule def_view_test_ins as
	on insert to def_view_test
	do instead insert into def_test select new.*
RESULT: []

-----------
QUERY:
insert into def_view_test default values
RESULT: []

-----------
QUERY:
alter table def_view_test alter column c1 set default 45
RESULT: []

-----------
QUERY:
insert into def_view_test default values
RESULT: []

-----------
QUERY:
alter table def_view_test alter column c2 set default 'view_default'
RESULT: []

-----------
QUERY:
insert into def_view_test default values
RESULT: []

-----------
QUERY:
select * from def_view_test
RESULT: []

-----------
QUERY:
drop rule def_view_test_ins on def_view_test
RESULT: []

-----------
QUERY:
drop view def_view_test
RESULT: []

-----------
QUERY:
drop table def_test
RESULT: []

-----------
QUERY:
-- alter table / drop column tests
-- try altering system catalogs, should fail
alter table pg_class drop column relname
RESULT: []

-----------
QUERY:
-- try altering non-existent table, should fail
alter table nosuchtable drop column bar
RESULT: []

-----------
QUERY:
-- test dropping columns
create table atacc1 (a int4 not null, b int4, c int4 not null, d int4)
RESULT: []

-----------
QUERY:
insert into atacc1 values (1, 2, 3, 4)
RESULT: []

-----------
QUERY:
alter table atacc1 drop a
RESULT: []

-----------
QUERY:
alter table atacc1 drop a
RESULT: []

-----------
QUERY:
-- SELECTs
select * from atacc1
RESULT: []

-----------
QUERY:
select * from atacc1 order by a
RESULT: []

-----------
QUERY:
select * from atacc1 order by "........pg.dropped.1........"
RESULT: []

-----------
QUERY:
select * from atacc1 group by a
RESULT: []

-----------
QUERY:
select * from atacc1 group by "........pg.dropped.1........"
RESULT: []

-----------
QUERY:
select atacc1.* from atacc1
RESULT: []

-----------
QUERY:
select a from atacc1
RESULT: []

-----------
QUERY:
select atacc1.a from atacc1
RESULT: []

-----------
QUERY:
select b,c,d from atacc1
RESULT: []

-----------
QUERY:
select a,b,c,d from atacc1
RESULT: []

-----------
QUERY:
select * from atacc1 where a = 1
RESULT: []

-----------
QUERY:
select "........pg.dropped.1........" from atacc1
RESULT: []

-----------
QUERY:
select atacc1."........pg.dropped.1........" from atacc1
RESULT: []

-----------
QUERY:
select "........pg.dropped.1........",b,c,d from atacc1
RESULT: []

-----------
QUERY:
select * from atacc1 where "........pg.dropped.1........" = 1
RESULT: []

-----------
QUERY:
-- UPDATEs
update atacc1 set a = 3
RESULT: []

-----------
QUERY:
update atacc1 set b = 2 where a = 3
RESULT: []

-----------
QUERY:
update atacc1 set "........pg.dropped.1........" = 3
RESULT: []

-----------
QUERY:
update atacc1 set b = 2 where "........pg.dropped.1........" = 3
RESULT: []

-----------
QUERY:
-- INSERTs
insert into atacc1 values (10, 11, 12, 13)
RESULT: []

-----------
QUERY:
insert into atacc1 values (default, 11, 12, 13)
RESULT: []

-----------
QUERY:
insert into atacc1 values (11, 12, 13)
RESULT: []

-----------
QUERY:
insert into atacc1 (a) values (10)
RESULT: []

-----------
QUERY:
insert into atacc1 (a) values (default)
RESULT: []

-----------
QUERY:
insert into atacc1 (a,b,c,d) values (10,11,12,13)
RESULT: []

-----------
QUERY:
insert into atacc1 (a,b,c,d) values (default,11,12,13)
RESULT: []

-----------
QUERY:
insert into atacc1 (b,c,d) values (11,12,13)
RESULT: []

-----------
QUERY:
insert into atacc1 ("........pg.dropped.1........") values (10)
RESULT: []

-----------
QUERY:
insert into atacc1 ("........pg.dropped.1........") values (default)
RESULT: []

-----------
QUERY:
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (10,11,12,13)
RESULT: []

-----------
QUERY:
insert into atacc1 ("........pg.dropped.1........",b,c,d) values (default,11,12,13)
RESULT: []

-----------
QUERY:
-- DELETEs
delete from atacc1 where a = 3
RESULT: []

-----------
QUERY:
delete from atacc1 where "........pg.dropped.1........" = 3
RESULT: []

-----------
QUERY:
delete from atacc1
RESULT: []

-----------
QUERY:
-- try dropping a non-existent column, should fail
alter table atacc1 drop bar
RESULT: []

-----------
QUERY:
-- try removing an oid column, should succeed (as it/* REPLACED */''s nonexistent)
alter table atacc1 SET WITHOUT OIDS
RESULT: []

-----------
QUERY:
-- try adding an oid column, should fail (not supported)
alter table atacc1 SET WITH OIDS
RESULT: []

-----------
QUERY:
-- try dropping the xmin column, should fail
alter table atacc1 drop xmin
RESULT: []

-----------
QUERY:
-- try creating a view and altering that, should fail
create view myview as select * from atacc1
RESULT: []

-----------
QUERY:
select * from myview
RESULT: []

-----------
QUERY:
alter table myview drop d
RESULT: []

-----------
QUERY:
drop view myview
RESULT: []

-----------
QUERY:
-- test some commands to make sure they fail on the dropped column
analyze atacc1(a)
RESULT: []

-----------
QUERY:
analyze atacc1("........pg.dropped.1........")
RESULT: []

-----------
QUERY:
vacuum analyze atacc1(a)
RESULT: []

-----------
QUERY:
vacuum analyze atacc1("........pg.dropped.1........")
RESULT: []

-----------
QUERY:
comment on column atacc1.a is 'testing'
RESULT: []

-----------
QUERY:
comment on column atacc1."........pg.dropped.1........" is 'testing'
RESULT: []

-----------
QUERY:
alter table atacc1 alter a set storage plain
RESULT: []

-----------
QUERY:
alter table atacc1 alter "........pg.dropped.1........" set storage plain
RESULT: []

-----------
QUERY:
alter table atacc1 alter a set statistics 0
RESULT: []

-----------
QUERY:
alter table atacc1 alter "........pg.dropped.1........" set statistics 0
RESULT: []

-----------
QUERY:
alter table atacc1 alter a set default 3
RESULT: []

-----------
QUERY:
alter table atacc1 alter "........pg.dropped.1........" set default 3
RESULT: []

-----------
QUERY:
alter table atacc1 alter a drop default
RESULT: []

-----------
QUERY:
alter table atacc1 alter "........pg.dropped.1........" drop default
RESULT: []

-----------
QUERY:
alter table atacc1 alter a set not null
RESULT: []

-----------
QUERY:
alter table atacc1 alter "........pg.dropped.1........" set not null
RESULT: []

-----------
QUERY:
alter table atacc1 alter a drop not null
RESULT: []

-----------
QUERY:
alter table atacc1 alter "........pg.dropped.1........" drop not null
RESULT: []

-----------
QUERY:
alter table atacc1 rename a to x
RESULT: []

-----------
QUERY:
alter table atacc1 rename "........pg.dropped.1........" to x
RESULT: []

-----------
QUERY:
alter table atacc1 add primary key(a)
RESULT: []

-----------
QUERY:
alter table atacc1 add primary key("........pg.dropped.1........")
RESULT: []

-----------
QUERY:
alter table atacc1 add unique(a)
RESULT: []

-----------
QUERY:
alter table atacc1 add unique("........pg.dropped.1........")
RESULT: []

-----------
QUERY:
alter table atacc1 add check (a > 3)
RESULT: []

-----------
QUERY:
alter table atacc1 add check ("........pg.dropped.1........" > 3)
RESULT: []

-----------
QUERY:
create table atacc2 (id int4 unique)
RESULT: []

-----------
QUERY:
alter table atacc1 add foreign key (a) references atacc2(id)
RESULT: []

-----------
QUERY:
alter table atacc1 add foreign key ("........pg.dropped.1........") references atacc2(id)
RESULT: []

-----------
QUERY:
alter table atacc2 add foreign key (id) references atacc1(a)
RESULT: []

-----------
QUERY:
alter table atacc2 add foreign key (id) references atacc1("........pg.dropped.1........")
RESULT: []

-----------
QUERY:
drop table atacc2
RESULT: []

-----------
QUERY:
create index "testing_idx" on atacc1(a)
RESULT: []

-----------
QUERY:
create index "testing_idx" on atacc1("........pg.dropped.1........")
RESULT: []

-----------
QUERY:
-- test create as and select into
insert into atacc1 values (21, 22, 23)
RESULT: []

-----------
QUERY:
create table attest1 as select * from atacc1
RESULT: []

-----------
QUERY:
select * from attest1
RESULT: []

-----------
QUERY:
drop table attest1
RESULT: []

-----------
QUERY:
select * into attest2 from atacc1
RESULT: []

-----------
QUERY:
select * from attest2
RESULT: []

-----------
QUERY:
drop table attest2
RESULT: []

-----------
QUERY:
-- try dropping all columns
alter table atacc1 drop c
RESULT: []

-----------
QUERY:
alter table atacc1 drop d
RESULT: []

-----------
QUERY:
alter table atacc1 drop b
RESULT: []

-----------
QUERY:
select * from atacc1
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- test constraint error reporting in presence of dropped columns
create table atacc1 (id serial primary key, value int check (value < 10))
RESULT: []

-----------
QUERY:
insert into atacc1(value) values (100)
RESULT: []

-----------
QUERY:
alter table atacc1 drop column value
RESULT: []

-----------
QUERY:
alter table atacc1 add column value int check (value < 10)
RESULT: []

-----------
QUERY:
insert into atacc1(value) values (100)
RESULT: []

-----------
QUERY:
insert into atacc1(id, value) values (null, 0)
RESULT: []

-----------
QUERY:
drop table atacc1
RESULT: []

-----------
QUERY:
-- test inheritance
create table parent (a int, b int, c int)
RESULT: []

-----------
QUERY:
insert into parent values (1, 2, 3)
RESULT: []

-----------
QUERY:
alter table parent drop a
RESULT: []

-----------
QUERY:
create table child (d varchar(255)) inherits (parent)
RESULT: []

-----------
QUERY:
insert into child values (12, 13, 'testing')
RESULT: []

-----------
QUERY:
select * from parent
RESULT: []

-----------
QUERY:
select * from child
RESULT: []

-----------
QUERY:
alter table parent drop c
RESULT: []

-----------
QUERY:
select * from parent
RESULT: []

-----------
QUERY:
select * from child
RESULT: []

-----------
QUERY:
drop table child
RESULT: []

-----------
QUERY:
drop table parent
RESULT: []

-----------
QUERY:
-- check error cases for inheritance column merging
create table parent (a float8, b numeric(10,4), c text collate "C")
RESULT: []

-----------
QUERY:
create table child (a float4) inherits (parent)
RESULT: []

-----------
QUERY:
-- fail
create table child (b decimal(10,7)) inherits (parent)
RESULT: []

-----------
QUERY:
-- fail
create table child (c text collate "POSIX") inherits (parent)
RESULT: []

-----------
QUERY:
-- fail
create table child (a double precision, b decimal(10,4)) inherits (parent)
RESULT: []

-----------
QUERY:
drop table child
RESULT: []

-----------
QUERY:
drop table parent
RESULT: []

-----------
QUERY:
-- test copy in/out
create table attest (a int4, b int4, c int4)
RESULT: []

-----------
QUERY:
insert into attest values (1,2,3)
RESULT: []

-----------
QUERY:
alter table attest drop a
RESULT: []

-----------
QUERY:
copy attest to stdout
RESULT: []

-----------
QUERY:
copy attest(a) to stdout
RESULT: []

-----------
QUERY:
copy attest("........pg.dropped.1........") to stdout
RESULT: []

-----------
QUERY:
copy attest from stdin
RESULT: []

-----------
QUERY:
10	11	12
\.
select * from attest
RESULT: []

-----------
QUERY:
copy attest from stdin
RESULT: []

-----------
QUERY:
21	22
\.
select * from attest
RESULT: []

-----------
QUERY:
copy attest(a) from stdin
RESULT: []

-----------
QUERY:
copy attest("........pg.dropped.1........") from stdin
RESULT: []

-----------
QUERY:
copy attest(b,c) from stdin
RESULT: []

-----------
QUERY:
31	32
\.
select * from attest
RESULT: []

-----------
QUERY:
drop table attest
RESULT: []

-----------
QUERY:
-- test inheritance

create table dropColumn (a int, b int, e int)
RESULT: []

-----------
QUERY:
create table dropColumnChild (c int) inherits (dropColumn)
RESULT: []

-----------
QUERY:
create table dropColumnAnother (d int) inherits (dropColumnChild)
RESULT: []

-----------
QUERY:
-- these two should fail
alter table dropColumnchild drop column a
RESULT: []

-----------
QUERY:
alter table only dropColumnChild drop column b
RESULT: []

-----------
QUERY:
-- these three should work
alter table only dropColumn drop column e
RESULT: []

-----------
QUERY:
alter table dropColumnChild drop column c
RESULT: []

-----------
QUERY:
alter table dropColumn drop column a
RESULT: []

-----------
QUERY:
create table renameColumn (a int)
RESULT: []

-----------
QUERY:
create table renameColumnChild (b int) inherits (renameColumn)
RESULT: []

-----------
QUERY:
create table renameColumnAnother (c int) inherits (renameColumnChild)
RESULT: []

-----------
QUERY:
-- these three should fail
alter table renameColumnChild rename column a to d
RESULT: []

-----------
QUERY:
alter table only renameColumnChild rename column a to d
RESULT: []

-----------
QUERY:
alter table only renameColumn rename column a to d
RESULT: []

-----------
QUERY:
-- these should work
alter table renameColumn rename column a to d
RESULT: []

-----------
QUERY:
alter table renameColumnChild rename column b to a
RESULT: []

-----------
QUERY:
-- these should work
alter table if exists doesnt_exist_tab rename column a to d
RESULT: []

-----------
QUERY:
alter table if exists doesnt_exist_tab rename column b to a
RESULT: []

-----------
QUERY:
-- this should work
alter table renameColumn add column w int
RESULT: []

-----------
QUERY:
-- this should fail
alter table only renameColumn add column x int
RESULT: []

-----------
QUERY:
-- Test corner cases in dropping of inherited columns

create table p1 (f1 int, f2 int)
RESULT: []

-----------
QUERY:
create table c1 (f1 int not null) inherits(p1)
RESULT: []

-----------
QUERY:
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1
RESULT: []

-----------
QUERY:
-- should work
alter table p1 drop column f1
RESULT: []

-----------
QUERY:
-- c1.f1 is still there, but no longer inherited
select f1 from c1
RESULT: []

-----------
QUERY:
alter table c1 drop column f1
RESULT: []

-----------
QUERY:
select f1 from c1
RESULT: []

-----------
QUERY:
drop table p1 cascade
RESULT: []

-----------
QUERY:
create table p1 (f1 int, f2 int)
RESULT: []

-----------
QUERY:
create table c1 () inherits(p1)
RESULT: []

-----------
QUERY:
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1
RESULT: []

-----------
QUERY:
alter table p1 drop column f1
RESULT: []

-----------
QUERY:
-- c1.f1 is dropped now, since there is no local definition for it
select f1 from c1
RESULT: []

-----------
QUERY:
drop table p1 cascade
RESULT: []

-----------
QUERY:
create table p1 (f1 int, f2 int)
RESULT: []

-----------
QUERY:
create table c1 () inherits(p1)
RESULT: []

-----------
QUERY:
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1
RESULT: []

-----------
QUERY:
alter table only p1 drop column f1
RESULT: []

-----------
QUERY:
-- c1.f1 is NOT dropped, but must now be considered non-inherited
alter table c1 drop column f1
RESULT: []

-----------
QUERY:
drop table p1 cascade
RESULT: []

-----------
QUERY:
create table p1 (f1 int, f2 int)
RESULT: []

-----------
QUERY:
create table c1 (f1 int not null) inherits(p1)
RESULT: []

-----------
QUERY:
-- should be rejected since c1.f1 is inherited
alter table c1 drop column f1
RESULT: []

-----------
QUERY:
alter table only p1 drop column f1
RESULT: []

-----------
QUERY:
-- c1.f1 is still there, but no longer inherited
alter table c1 drop column f1
RESULT: []

-----------
QUERY:
drop table p1 cascade
RESULT: []

-----------
QUERY:
create table p1(id int, name text)
RESULT: []

-----------
QUERY:
create table p2(id2 int, name text, height int)
RESULT: []

-----------
QUERY:
create table c1(age int) inherits(p1,p2)
RESULT: []

-----------
QUERY:
create table gc1() inherits (c1)
RESULT: []

-----------
QUERY:
select relname, attname, attinhcount, attislocal
from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
order by relname, attnum
RESULT: []

-----------
QUERY:
-- should work
alter table only p1 drop column name
RESULT: []

-----------
QUERY:
-- should work. Now c1.name is local and inhcount is 0.
alter table p2 drop column name
RESULT: []

-----------
QUERY:
-- should be rejected since its inherited
alter table gc1 drop column name
RESULT: []

-----------
QUERY:
-- should work, and drop gc1.name along
alter table c1 drop column name
RESULT: []

-----------
QUERY:
-- should fail: column does not exist
alter table gc1 drop column name
RESULT: []

-----------
QUERY:
-- should work and drop the attribute in all tables
alter table p2 drop column height
RESULT: []

-----------
QUERY:
-- IF EXISTS test
create table dropColumnExists ()
RESULT: []

-----------
QUERY:
alter table dropColumnExists drop column non_existing
RESULT: []

-----------
QUERY:
--fail
alter table dropColumnExists drop column if exists non_existing
RESULT: []

-----------
QUERY:
--succeed

select relname, attname, attinhcount, attislocal
from pg_class join pg_attribute on (pg_class.oid = pg_attribute.attrelid)
where relname in ('p1','p2','c1','gc1') and attnum > 0 and not attisdropped
order by relname, attnum
RESULT: []

-----------
QUERY:
drop table p1, p2 cascade
RESULT: []

-----------
QUERY:
-- test attinhcount tracking with merged columns

create table depth0()
RESULT: []

-----------
QUERY:
create table depth1(c text) inherits (depth0)
RESULT: []

-----------
QUERY:
create table depth2() inherits (depth1)
RESULT: []

-----------
QUERY:
alter table depth0 add c text
RESULT: []

-----------
QUERY:
select attrelid::regclass, attname, attinhcount, attislocal
from pg_attribute
where attnum > 0 and attrelid::regclass in ('depth0', 'depth1', 'depth2')
order by attrelid::regclass::text, attnum
RESULT: []

-----------
QUERY:
-- test renumbering of child-table columns in inherited operations

create table p1 (f1 int)
RESULT: []

-----------
QUERY:
create table c1 (f2 text, f3 int) inherits (p1)
RESULT: []

-----------
QUERY:
alter table p1 add column a1 int check (a1 > 0)
RESULT: []

-----------
QUERY:
alter table p1 add column f2 text
RESULT: []

-----------
QUERY:
insert into p1 values (1,2,'abc')
RESULT: []

-----------
QUERY:
insert into c1 values(11,'xyz',33,0)
RESULT: []

-----------
QUERY:
-- should fail
insert into c1 values(11,'xyz',33,22)
RESULT: []

-----------
QUERY:
select * from p1
RESULT: []

-----------
QUERY:
update p1 set a1 = a1 + 1, f2 = upper(f2)
RESULT: []

-----------
QUERY:
select * from p1
RESULT: []

-----------
QUERY:
drop table p1 cascade
RESULT: []

-----------
QUERY:
-- test that operations with a dropped column do not try to reference
-- its datatype

create domain mytype as text
RESULT: []

-----------
QUERY:
create temp table foo (f1 text, f2 mytype, f3 text)
RESULT: []

-----------
QUERY:
insert into foo values('bb','cc','dd')
RESULT: []

-----------
QUERY:
select * from foo
RESULT: []

-----------
QUERY:
drop domain mytype cascade
RESULT: []

-----------
QUERY:
select * from foo
RESULT: []

-----------
QUERY:
insert into foo values('qq','rr')
RESULT: []

-----------
QUERY:
select * from foo
RESULT: []

-----------
QUERY:
update foo set f3 = 'zz'
RESULT: []

-----------
QUERY:
select * from foo
RESULT: []

-----------
QUERY:
select f3,max(f1) from foo group by f3
RESULT: []

-----------
QUERY:
-- Simple tests for alter table column type
alter table foo alter f1 TYPE integer
RESULT: []

-----------
QUERY:
-- fails
alter table foo alter f1 TYPE varchar(10)
RESULT: []

-----------
QUERY:
create table anothertab (atcol1 serial8, atcol2 boolean,
	constraint anothertab_chk check (atcol1 <= 3))
RESULT: []

-----------
QUERY:
insert into anothertab (atcol1, atcol2) values (default, true)
RESULT: []

-----------
QUERY:
insert into anothertab (atcol1, atcol2) values (default, false)
RESULT: []

-----------
QUERY:
select * from anothertab
RESULT: []

-----------
QUERY:
alter table anothertab alter column atcol1 type boolean
RESULT: []

-----------
QUERY:
-- fails
alter table anothertab alter column atcol1 type boolean using atcol1::int
RESULT: []

-----------
QUERY:
-- fails
alter table anothertab alter column atcol1 type integer
RESULT: []

-----------
QUERY:
select * from anothertab
RESULT: []

-----------
QUERY:
insert into anothertab (atcol1, atcol2) values (45, null)
RESULT: []

-----------
QUERY:
-- fails
insert into anothertab (atcol1, atcol2) values (default, null)
RESULT: []

-----------
QUERY:
select * from anothertab
RESULT: []

-----------
QUERY:
alter table anothertab alter column atcol2 type text
      using case when atcol2 is true then 'IT WAS TRUE'
                 when atcol2 is false then 'IT WAS FALSE'
                 else 'IT WAS NULL!' end
RESULT: []

-----------
QUERY:
select * from anothertab
RESULT: []

-----------
QUERY:
alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end
RESULT: []

-----------
QUERY:
-- fails
alter table anothertab alter column atcol1 drop default
RESULT: []

-----------
QUERY:
alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end
RESULT: []

-----------
QUERY:
-- fails
alter table anothertab drop constraint anothertab_chk
RESULT: []

-----------
QUERY:
alter table anothertab drop constraint anothertab_chk
RESULT: []

-----------
QUERY:
-- fails
alter table anothertab drop constraint IF EXISTS anothertab_chk
RESULT: []

-----------
QUERY:
-- succeeds

alter table anothertab alter column atcol1 type boolean
        using case when atcol1 % 2 = 0 then true else false end
RESULT: []

-----------
QUERY:
select * from anothertab
RESULT: []

-----------
QUERY:
drop table anothertab
RESULT: []

-----------
QUERY:
-- Test index handling in alter table column type (cf. bugs #15835, #15865)
create table anothertab(f1 int primary key, f2 int unique,
                        f3 int, f4 int, f5 int)
RESULT: []

-----------
QUERY:
alter table anothertab
  add exclude using btree (f3 with =)
RESULT: []

-----------
QUERY:
alter table anothertab
  add exclude using btree (f4 with =) where (f4 is not null)
RESULT: []

-----------
QUERY:
alter table anothertab
  add exclude using btree (f4 with =) where (f5 > 0)
RESULT: []

-----------
QUERY:
alter table anothertab
  add unique(f1,f4)
RESULT: []

-----------
QUERY:
create index on anothertab(f2,f3)
RESULT: []

-----------
QUERY:
create unique index on anothertab(f4)
RESULT: []

-----------
QUERY:
-- \d anothertab
alter table anothertab alter column f1 type bigint
RESULT: []

-----------
QUERY:
alter table anothertab
  alter column f2 type bigint,
  alter column f3 type bigint,
  alter column f4 type bigint
RESULT: []

-----------
QUERY:
alter table anothertab alter column f5 type bigint
RESULT: []

-----------
QUERY:
-- \d anothertab

drop table anothertab
RESULT: []

-----------
QUERY:
-- test that USING expressions are parsed before column alter type / drop steps
create table another (f1 int, f2 text, f3 text)
RESULT: []

-----------
QUERY:
insert into another values(1, 'one', 'uno')
RESULT: []

-----------
QUERY:
insert into another values(2, 'two', 'due')
RESULT: []

-----------
QUERY:
insert into another values(3, 'three', 'tre')
RESULT: []

-----------
QUERY:
select * from another
RESULT: []

-----------
QUERY:
alter table another
  alter f1 type text using f2 || ' and ' || f3 || ' more',
  alter f2 type bigint using f1 * 10,
  drop column f3
RESULT: []

-----------
QUERY:
select * from another
RESULT: []

-----------
QUERY:
drop table another
RESULT: []

-----------
QUERY:
-- Create an index that skips WAL, then perform a SET DATA TYPE that skips
-- rewriting the index.
begin
RESULT: []

-----------
QUERY:
create table skip_wal_skip_rewrite_index (c varchar(10) primary key)
RESULT: []

-----------
QUERY:
alter table skip_wal_skip_rewrite_index alter c type varchar(20)
RESULT: []

-----------
QUERY:
commit
RESULT: []

-----------
QUERY:
-- We disallow changing table/* REPLACED */''s row type if it/* REPLACED */''s used for storage
create table at_tab1 (a int, b text)
RESULT: []

-----------
QUERY:
create table at_tab2 (x int, y at_tab1)
RESULT: []

-----------
QUERY:
alter table at_tab1 alter column b type varchar
RESULT: []

-----------
QUERY:
-- fails
drop table at_tab2
RESULT: []

-----------
QUERY:
-- Use of row type in an expression is defended differently
create table at_tab2 (x int, y text, check((x,y)::at_tab1 = (1,'42')::at_tab1))
RESULT: []

-----------
QUERY:
alter table at_tab1 alter column b type varchar
RESULT: []

-----------
QUERY:
-- allowed, but ...
insert into at_tab2 values(1,'42')
RESULT: []

-----------
QUERY:
-- ... this will fail
drop table at_tab1, at_tab2
RESULT: []

-----------
QUERY:
-- Check it for a partitioned table, too
create table at_tab1 (a int, b text) partition by list(a)
RESULT: []

-----------
QUERY:
create table at_tab2 (x int, y at_tab1)
RESULT: []

-----------
QUERY:
alter table at_tab1 alter column b type varchar
RESULT: []

-----------
QUERY:
-- fails
drop table at_tab1, at_tab2
RESULT: []

-----------
QUERY:
-- Alter column type that/* REPLACED */''s part of a partitioned index
create table at_partitioned (a int, b text) partition by range (a)
RESULT: []

-----------
QUERY:
create table at_part_1 partition of at_partitioned for values from (0) to (1000)
RESULT: []

-----------
QUERY:
insert into at_partitioned values (512, '0.123')
RESULT: []

-----------
QUERY:
create table at_part_2 (b text, a int)
RESULT: []

-----------
QUERY:
insert into at_part_2 values ('1.234', 1024)
RESULT: []

-----------
QUERY:
create index on at_partitioned (b)
RESULT: []

-----------
QUERY:
create index on at_partitioned (a)
RESULT: []

-----------
QUERY:
-- \d at_part_1
-- \d at_part_2
alter table at_partitioned attach partition at_part_2 for values from (1000) to (2000)
RESULT: []

-----------
QUERY:
-- \d at_part_2
alter table at_partitioned alter column b type numeric using b::numeric
RESULT: []

-----------
QUERY:
-- \d at_part_1
-- \d at_part_2
drop table at_partitioned
RESULT: []

-----------
QUERY:
-- Alter column type when no table rewrite is required
-- Also check that comments are preserved
create table at_partitioned(id int, name varchar(64), unique (id, name))
  partition by hash(id)
RESULT: []

-----------
QUERY:
comment on constraint at_partitioned_id_name_key on at_partitioned is 'parent constraint'
RESULT: []

-----------
QUERY:
comment on index at_partitioned_id_name_key is 'parent index'
RESULT: []

-----------
QUERY:
create table at_partitioned_0 partition of at_partitioned
  for values with (modulus 2, remainder 0)
RESULT: []

-----------
QUERY:
comment on constraint at_partitioned_0_id_name_key on at_partitioned_0 is 'child 0 constraint'
RESULT: []

-----------
QUERY:
comment on index at_partitioned_0_id_name_key is 'child 0 index'
RESULT: []

-----------
QUERY:
create table at_partitioned_1 partition of at_partitioned
  for values with (modulus 2, remainder 1)
RESULT: []

-----------
QUERY:
comment on constraint at_partitioned_1_id_name_key on at_partitioned_1 is 'child 1 constraint'
RESULT: []

-----------
QUERY:
comment on index at_partitioned_1_id_name_key is 'child 1 index'
RESULT: []

-----------
QUERY:
insert into at_partitioned values(1, 'foo')
RESULT: []

-----------
QUERY:
insert into at_partitioned values(3, 'bar')
RESULT: []

-----------
QUERY:
create temp table old_oids as
  select relname, oid as oldoid, relfilenode as oldfilenode
  from pg_class where relname like 'at_partitioned%'
RESULT: []

-----------
QUERY:
select relname,
  c.oid = oldoid as orig_oid,
  case relfilenode
    when 0 then 'none'
    when c.oid then 'own'
    when oldfilenode then 'orig'
    else 'OTHER'
    end as storage,
  obj_description(c.oid, 'pg_class') as desc
  from pg_class c left join old_oids using (relname)
  where relname like 'at_partitioned%'
  order by relname
RESULT: []

-----------
QUERY:
select conname, obj_description(oid, 'pg_constraint') as desc
  from pg_constraint where conname like 'at_partitioned%'
  order by conname
RESULT: []

-----------
QUERY:
alter table at_partitioned alter column name type varchar(127)
RESULT: []

-----------
QUERY:
-- Note: these tests currently show the wrong behavior for comments :-(

select relname,
  c.oid = oldoid as orig_oid,
  case relfilenode
    when 0 then 'none'
    when c.oid then 'own'
    when oldfilenode then 'orig'
    else 'OTHER'
    end as storage,
  obj_description(c.oid, 'pg_class') as desc
  from pg_class c left join old_oids using (relname)
  where relname like 'at_partitioned%'
  order by relname
RESULT: []

-----------
QUERY:
select conname, obj_description(oid, 'pg_constraint') as desc
  from pg_constraint where conname like 'at_partitioned%'
  order by conname
RESULT: []

-----------
QUERY:
-- Don/* REPLACED */''t remove this DROP, it exposes bug #15672
drop table at_partitioned
RESULT: []

-----------
QUERY:
-- disallow recursive containment of row types
create temp table recur1 (f1 int)
RESULT: []

-----------
QUERY:
alter table recur1 add column f2 recur1
RESULT: []

-----------
QUERY:
-- fails
alter table recur1 add column f2 recur1[]
RESULT: []

-----------
QUERY:
-- fails
create domain array_of_recur1 as recur1[]
RESULT: []

-----------
QUERY:
alter table recur1 add column f2 array_of_recur1
RESULT: []

-----------
QUERY:
-- fails
create temp table recur2 (f1 int, f2 recur1)
RESULT: []

-----------
QUERY:
alter table recur1 add column f2 recur2
RESULT: []

-----------
QUERY:
-- fails
alter table recur1 add column f2 int
RESULT: []

-----------
QUERY:
alter table recur1 alter column f2 type recur2
RESULT: []

-----------
QUERY:
-- fails

-- SET STORAGE may need to add a TOAST table
create table test_storage (a text, c text storage plain)
RESULT: []

-----------
QUERY:
select reltoastrelid <> 0 as has_toast_table
  from pg_class where oid = 'test_storage'::regclass
RESULT: []

-----------
QUERY:
alter table test_storage alter a set storage plain
RESULT: []

-----------
QUERY:
-- rewrite table to remove its TOAST table /* REPLACED */, need a non-constant column default
alter table test_storage add b int default random()::int
RESULT: []

-----------
QUERY:
select reltoastrelid <> 0 as has_toast_table
  from pg_class where oid = 'test_storage'::regclass
RESULT: []

-----------
QUERY:
alter table test_storage alter a set storage default
RESULT: []

-----------
QUERY:
-- re-add TOAST table
select reltoastrelid <> 0 as has_toast_table
  from pg_class where oid = 'test_storage'::regclass
RESULT: []

-----------
QUERY:
-- check STORAGE correctness
create table test_storage_failed (a text, b int storage extended)
RESULT: []

-----------
QUERY:
-- test that SET STORAGE propagates to index correctly
create index test_storage_idx on test_storage (b, a)
RESULT: []

-----------
QUERY:
alter table test_storage alter column a set storage external
RESULT: []

-----------
QUERY:
-- \d+ test_storage
-- \d+ test_storage_idx

-- ALTER COLUMN TYPE with a check constraint and a child table (bug #13779)
CREATE TABLE test_inh_check (a float check (a > 10.2), b float)
RESULT: []

-----------
QUERY:
CREATE TABLE test_inh_check_child() INHERITS(test_inh_check)
RESULT: []

-----------
QUERY:
-- \d test_inh_check
-- \d test_inh_check_child
select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2
RESULT: []

-----------
QUERY:
ALTER TABLE test_inh_check ALTER COLUMN a TYPE numeric
RESULT: []

-----------
QUERY:
-- \d test_inh_check
-- \d test_inh_check_child
select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2
RESULT: []

-----------
QUERY:
-- also try noinherit, local, and local+inherited cases
ALTER TABLE test_inh_check ADD CONSTRAINT bnoinherit CHECK (b > 100) NO INHERIT
RESULT: []

-----------
QUERY:
ALTER TABLE test_inh_check_child ADD CONSTRAINT blocal CHECK (b < 1000)
RESULT: []

-----------
QUERY:
ALTER TABLE test_inh_check_child ADD CONSTRAINT bmerged CHECK (b > 1)
RESULT: []

-----------
QUERY:
ALTER TABLE test_inh_check ADD CONSTRAINT bmerged CHECK (b > 1)
RESULT: []

-----------
QUERY:
-- \d test_inh_check
-- \d test_inh_check_child
select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2
RESULT: []

-----------
QUERY:
ALTER TABLE test_inh_check ALTER COLUMN b TYPE numeric
RESULT: []

-----------
QUERY:
-- \d test_inh_check
-- \d test_inh_check_child
select relname, conname, coninhcount, conislocal, connoinherit
  from pg_constraint c, pg_class r
  where relname like 'test_inh_check%' and c.conrelid = r.oid
  order by 1, 2
RESULT: []

-----------
QUERY:
-- ALTER COLUMN TYPE with different schema in children
-- Bug at https://postgr.es/m/20170102225618.GA10071@telsasoft.com
CREATE TABLE test_type_diff (f1 int)
RESULT: []

-----------
QUERY:
CREATE TABLE test_type_diff_c (extra smallint) INHERITS (test_type_diff)
RESULT: []

-----------
QUERY:
ALTER TABLE test_type_diff ADD COLUMN f2 int
RESULT: []

-----------
QUERY:
INSERT INTO test_type_diff_c VALUES (1, 2, 3)
RESULT: []

-----------
QUERY:
ALTER TABLE test_type_diff ALTER COLUMN f2 TYPE bigint USING f2::bigint
RESULT: []

-----------
QUERY:
CREATE TABLE test_type_diff2 (int_two int2, int_four int4, int_eight int8)
RESULT: []

-----------
QUERY:
CREATE TABLE test_type_diff2_c1 (int_four int4, int_eight int8, int_two int2)
RESULT: []

-----------
QUERY:
CREATE TABLE test_type_diff2_c2 (int_eight int8, int_two int2, int_four int4)
RESULT: []

-----------
QUERY:
CREATE TABLE test_type_diff2_c3 (int_two int2, int_four int4, int_eight int8)
RESULT: []

-----------
QUERY:
ALTER TABLE test_type_diff2_c1 INHERIT test_type_diff2
RESULT: []

-----------
QUERY:
ALTER TABLE test_type_diff2_c2 INHERIT test_type_diff2
RESULT: []

-----------
QUERY:
ALTER TABLE test_type_diff2_c3 INHERIT test_type_diff2
RESULT: []

-----------
QUERY:
INSERT INTO test_type_diff2_c1 VALUES (1, 2, 3)
RESULT: []

-----------
QUERY:
INSERT INTO test_type_diff2_c2 VALUES (4, 5, 6)
RESULT: []

-----------
QUERY:
INSERT INTO test_type_diff2_c3 VALUES (7, 8, 9)
RESULT: []

-----------
QUERY:
ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int8 USING int_four::int8
RESULT: []

-----------
QUERY:
-- whole-row references are disallowed
ALTER TABLE test_type_diff2 ALTER COLUMN int_four TYPE int4 USING (pg_column_size(test_type_diff2))
RESULT: []

-----------
QUERY:
-- check for rollback of ANALYZE corrupting table property flags (bug #11638)
CREATE TABLE check_fk_presence_1 (id int PRIMARY KEY, t text)
RESULT: []

-----------
QUERY:
CREATE TABLE check_fk_presence_2 (id int REFERENCES check_fk_presence_1, t text)
RESULT: []

-----------
QUERY:
BEGIN
RESULT: []

-----------
QUERY:
ALTER TABLE check_fk_presence_2 DROP CONSTRAINT check_fk_presence_2_id_fkey
RESULT: []

-----------
QUERY:
ANALYZE check_fk_presence_2
RESULT: []

-----------
QUERY:
ROLLBACK
RESULT: []

-----------
QUERY:
-- \d check_fk_presence_2
DROP TABLE check_fk_presence_1, check_fk_presence_2
RESULT: []

-----------
QUERY:
-- check column addition within a view (bug #14876)
create table at_base_table(id int, stuff text)
RESULT: []

-----------
QUERY:
insert into at_base_table values (23, 'skidoo')
RESULT: []

-----------
QUERY:
create view at_view_1 as select * from at_base_table bt
RESULT: []

-----------
QUERY:
create view at_view_2 as select *, to_json(v1) as j from at_view_1 v1
RESULT: []

-----------
QUERY:
-- \d+ at_view_1
-- \d+ at_view_2
explain (verbose, costs off) select * from at_view_2
RESULT: []

-----------
QUERY:
select * from at_view_2
RESULT: []

-----------
QUERY:
create or replace view at_view_1 as select *, 2+2 as more from at_base_table bt
RESULT: []

-----------
QUERY:
-- \d+ at_view_1
-- \d+ at_view_2
explain (verbose, costs off) select * from at_view_2
RESULT: []

-----------
QUERY:
select * from at_view_2
RESULT: []

-----------
QUERY:
drop view at_view_2
RESULT: []

-----------
QUERY:
drop view at_view_1
RESULT: []

-----------
QUERY:
drop table at_base_table
RESULT: []

-----------
QUERY:
-- related case (bug #17811)
begin
RESULT: []

-----------
QUERY:
create temp table t1 as select * from int8_tbl
RESULT: []

-----------
QUERY:
create temp view v1 as select 1::int8 as q1
RESULT: []

-----------
QUERY:
create temp view v2 as select * from v1
RESULT: []

-----------
QUERY:
create or replace temp view v1 with (security_barrier = true)
  as select * from t1
RESULT: []

-----------
QUERY:
create temp table log (q1 int8, q2 int8)
RESULT: []

-----------
QUERY:
create rule v1_upd_rule as on update to v1
  do also insert into log values (new.*)
RESULT: []

-----------
QUERY:
update v2 set q1 = q1 + 1 where q1 = 123
RESULT: []

-----------
QUERY:
select * from t1
RESULT: []

-----------
QUERY:
select * from log
RESULT: []

-----------
QUERY:
rollback
RESULT: []

-----------
QUERY:
-- check adding a column not itself requiring a rewrite, together with
-- a column requiring a default (bug #16038)

-- ensure that rewrites aren/* REPLACED */''t silently optimized away, removing the
-- value of the test
CREATE FUNCTION check_ddl_rewrite(p_tablename regclass, p_ddl text)
RETURNS boolean
LANGUAGE plpgsql AS $$
DECLARE
    v_relfilenode oid;
BEGIN
    v_relfilenode := relfilenode FROM pg_class WHERE oid = p_tablename;

    EXECUTE p_ddl;

    RETURN v_relfilenode <> (SELECT relfilenode FROM pg_class WHERE oid = p_tablename);
END;
$$
RESULT: []

-----------
QUERY:
CREATE TABLE rewrite_test(col text)
RESULT: []

-----------
QUERY:
INSERT INTO rewrite_test VALUES ('something')
RESULT: []

-----------
QUERY:
INSERT INTO rewrite_test VALUES (NULL)
RESULT: []

-----------
QUERY:
-- empty[12] don/* REPLACED */''t need rewrite, but notempty[12]_rewrite will force one
SELECT check_ddl_rewrite('rewrite_test', $$
  ALTER TABLE rewrite_test
      ADD COLUMN empty1 text,
      ADD COLUMN notempty1_rewrite serial;
$$)
RESULT: []

-----------
QUERY:
SELECT check_ddl_rewrite('rewrite_test', $$
    ALTER TABLE rewrite_test
        ADD COLUMN notempty2_rewrite serial,
        ADD COLUMN empty2 text;
$$)
RESULT: []

-----------
QUERY:
-- also check that fast defaults cause no problem, first without rewrite
SELECT check_ddl_rewrite('rewrite_test', $$
    ALTER TABLE rewrite_test
        ADD COLUMN empty3 text,
        ADD COLUMN notempty3_norewrite int default 42;
$$)
RESULT: []

-----------
QUERY:
SELECT check_ddl_rewrite('rewrite_test', $$
    ALTER TABLE rewrite_test
        ADD COLUMN notempty4_norewrite int default 42,
        ADD COLUMN empty4 text;
$$)
RESULT: []

-----------
QUERY:
-- then with rewrite
SELECT check_ddl_rewrite('rewrite_test', $$
    ALTER TABLE rewrite_test
        ADD COLUMN empty5 text,
        ADD COLUMN notempty5_norewrite int default 42,
        ADD COLUMN notempty5_rewrite serial;
$$)
RESULT: []

-----------
QUERY:
SELECT check_ddl_rewrite('rewrite_test', $$
    ALTER TABLE rewrite_test
        ADD COLUMN notempty6_rewrite serial,
        ADD COLUMN empty6 text,
        ADD COLUMN notempty6_norewrite int default 42;
$$)
RESULT: []

-----------
QUERY:
-- cleanup
DROP FUNCTION check_ddl_rewrite(regclass, text)
RESULT: []

-----------
QUERY:
DROP TABLE rewrite_test
RESULT: []

-----------
QUERY:
--
-- lock levels
--
drop type lockmodes
RESULT: []

-----------
QUERY:
create type lockmodes as enum (
 'SIReadLock'
,'AccessShareLock'
,'RowShareLock'
,'RowExclusiveLock'
,'ShareUpdateExclusiveLock'
,'ShareLock'
,'ShareRowExclusiveLock'
,'ExclusiveLock'
,'AccessExclusiveLock'
)
RESULT: []

-----------
QUERY:
drop view my_locks
RESULT: []

-----------
QUERY:
create or replace view my_locks as
select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
from pg_locks l join pg_class c on l.relation = c.oid
where virtualtransaction = (
        select virtualtransaction
        from pg_locks
        where transactionid = pg_current_xact_id()::xid)
and locktype = 'relation'
and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
and c.relname != 'my_locks'
group by c.relname
RESULT: []

-----------
QUERY:
create table alterlock (f1 int primary key, f2 text)
RESULT: []

-----------
QUERY:
insert into alterlock values (1, 'foo')
RESULT: []

-----------
QUERY:
create table alterlock2 (f3 int primary key, f1 int)
RESULT: []

-----------
QUERY:
insert into alterlock2 values (1, 1)
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock alter column f2 set statistics 150
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
rollback
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock cluster on alterlock_pkey
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
commit
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock set without cluster
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
commit
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock set (fillfactor = 100)
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
commit
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock reset (fillfactor)
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
commit
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock set (toast.autovacuum_enabled = off)
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
commit
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock set (autovacuum_enabled = off)
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
commit
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock alter column f2 set (n_distinct = 1)
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
rollback
RESULT: []

-----------
QUERY:
-- test that mixing options with different lock levels works as expected
begin
RESULT: []

-----------
QUERY:
alter table alterlock set (autovacuum_enabled = off, fillfactor = 80)
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
commit
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock alter column f2 set storage extended
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
rollback
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock alter column f2 set default 'x'
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
rollback
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
create trigger ttdummy
	before delete or update on alterlock
	for each row
	execute procedure
	ttdummy (1, 1)
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
rollback
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
alter table alterlock2 add foreign key (f1) references alterlock (f1)
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
rollback
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock2
add constraint alterlock2nv foreign key (f1) references alterlock (f1) NOT VALID
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
commit
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter table alterlock2 validate constraint alterlock2nv
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
rollback
RESULT: []

-----------
QUERY:
create or replace view my_locks as
select case when c.relname like 'pg_toast%' then 'pg_toast' else c.relname end, max(mode::lockmodes) as max_lockmode
from pg_locks l join pg_class c on l.relation = c.oid
where virtualtransaction = (
        select virtualtransaction
        from pg_locks
        where transactionid = pg_current_xact_id()::xid)
and locktype = 'relation'
and relnamespace != (select oid from pg_namespace where nspname = 'pg_catalog')
and c.relname = 'my_locks'
group by c.relname
RESULT: []

-----------
QUERY:
-- raise exception
alter table my_locks set (autovacuum_enabled = false)
RESULT: []

-----------
QUERY:
alter view my_locks set (autovacuum_enabled = false)
RESULT: []

-----------
QUERY:
alter table my_locks reset (autovacuum_enabled)
RESULT: []

-----------
QUERY:
alter view my_locks reset (autovacuum_enabled)
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
alter view my_locks set (security_barrier=off)
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
alter view my_locks reset (security_barrier)
RESULT: []

-----------
QUERY:
rollback
RESULT: []

-----------
QUERY:
-- this test intentionally applies the ALTER TABLE command against a view, but
-- uses a view option so we expect this to succeed. This form of SQL is
-- accepted for historical reasons, as shown in the docs for ALTER VIEW
begin
RESULT: []

-----------
QUERY:
alter table my_locks set (security_barrier=off)
RESULT: []

-----------
QUERY:
select * from my_locks order by 1
RESULT: []

-----------
QUERY:
alter table my_locks reset (security_barrier)
RESULT: []

-----------
QUERY:
rollback
RESULT: []

-----------
QUERY:
-- cleanup
drop table alterlock2
RESULT: []

-----------
QUERY:
drop table alterlock
RESULT: []

-----------
QUERY:
drop view my_locks
RESULT: []

-----------
QUERY:
drop type lockmodes
RESULT: []

-----------
QUERY:
--
-- alter function
--
create function test_strict(text) returns text as
    'select coalesce($1, ''got passed a null'')
RESULT: []

-----------
QUERY:
'
    language sql returns null on null input
RESULT: []

-----------
QUERY:
select test_strict(NULL)
RESULT: []

-----------
QUERY:
alter function test_strict(text) called on null input
RESULT: []

-----------
QUERY:
select test_strict(NULL)
RESULT: []

-----------
QUERY:
create function non_strict(text) returns text as
    'select coalesce($1, ''got passed a null'')
RESULT: []

-----------
QUERY:
'
    language sql called on null input
RESULT: []

-----------
QUERY:
select non_strict(NULL)
RESULT: []

-----------
QUERY:
alter function non_strict(text) returns null on null input
RESULT: []

-----------
QUERY:
select non_strict(NULL)
RESULT: []

-----------
QUERY:
--
-- alter object set schema
--

create schema alter1
RESULT: []

-----------
QUERY:
create schema alter2
RESULT: []

-----------
QUERY:
create table alter1.t1(f1 serial primary key, f2 int check (f2 > 0))
RESULT: []

-----------
QUERY:
create view alter1.v1 as select * from alter1.t1
RESULT: []

-----------
QUERY:
create function alter1.plus1(int) returns int as 'select $1+1' language sql
RESULT: []

-----------
QUERY:
create domain alter1.posint integer check (value > 0)
RESULT: []

-----------
QUERY:
create type alter1.ctype as (f1 int, f2 text)
RESULT: []

-----------
QUERY:
create function alter1.same(alter1.ctype, alter1.ctype) returns boolean language sql
as 'select $1.f1 is not distinct from $2.f1 and $1.f2 is not distinct from $2.f2'
RESULT: []

-----------
QUERY:
create operator alter1.=(procedure = alter1.same, leftarg  = alter1.ctype, rightarg = alter1.ctype)
RESULT: []

-----------
QUERY:
create operator class alter1.ctype_hash_ops default for type alter1.ctype using hash as
  operator 1 alter1.=(alter1.ctype, alter1.ctype)
RESULT: []

-----------
QUERY:
create conversion alter1.latin1_to_utf8 for 'latin1' to 'utf8' from iso8859_1_to_utf8
RESULT: []

-----------
QUERY:
create text search parser alter1.prs(start = prsd_start, gettoken = prsd_nexttoken, end = prsd_end, lextypes = prsd_lextype)
RESULT: []

-----------
QUERY:
create text search configuration alter1.cfg(parser = alter1.prs)
RESULT: []

-----------
QUERY:
create text search template alter1.tmpl(init = dsimple_init, lexize = dsimple_lexize)
RESULT: []

-----------
QUERY:
create text search dictionary alter1.dict(template = alter1.tmpl)
RESULT: []

-----------
QUERY:
insert into alter1.t1(f2) values(11)
RESULT: []

-----------
QUERY:
insert into alter1.t1(f2) values(12)
RESULT: []

-----------
QUERY:
alter table alter1.t1 set schema alter1
RESULT: []

-----------
QUERY:
-- no-op, same schema
alter table alter1.t1 set schema alter2
RESULT: []

-----------
QUERY:
alter table alter1.v1 set schema alter2
RESULT: []

-----------
QUERY:
alter function alter1.plus1(int) set schema alter2
RESULT: []

-----------
QUERY:
alter domain alter1.posint set schema alter2
RESULT: []

-----------
QUERY:
alter operator class alter1.ctype_hash_ops using hash set schema alter2
RESULT: []

-----------
QUERY:
alter operator family alter1.ctype_hash_ops using hash set schema alter2
RESULT: []

-----------
QUERY:
alter operator alter1.=(alter1.ctype, alter1.ctype) set schema alter2
RESULT: []

-----------
QUERY:
alter function alter1.same(alter1.ctype, alter1.ctype) set schema alter2
RESULT: []

-----------
QUERY:
alter type alter1.ctype set schema alter1
RESULT: []

-----------
QUERY:
-- no-op, same schema
alter type alter1.ctype set schema alter2
RESULT: []

-----------
QUERY:
alter conversion alter1.latin1_to_utf8 set schema alter2
RESULT: []

-----------
QUERY:
alter text search parser alter1.prs set schema alter2
RESULT: []

-----------
QUERY:
alter text search configuration alter1.cfg set schema alter2
RESULT: []

-----------
QUERY:
alter text search template alter1.tmpl set schema alter2
RESULT: []

-----------
QUERY:
alter text search dictionary alter1.dict set schema alter2
RESULT: []

-----------
QUERY:
-- this should succeed because nothing is left in alter1
drop schema alter1
RESULT: []

-----------
QUERY:
insert into alter2.t1(f2) values(13)
RESULT: []

-----------
QUERY:
insert into alter2.t1(f2) values(14)
RESULT: []

-----------
QUERY:
select * from alter2.t1
RESULT: []

-----------
QUERY:
select * from alter2.v1
RESULT: []

-----------
QUERY:
select alter2.plus1(41)
RESULT: []

-----------
QUERY:
-- clean up
drop schema alter2 cascade
RESULT: []

-----------
QUERY:
--
-- composite types
--

CREATE TYPE test_type AS (a int)
RESULT: []

-----------
QUERY:
-- \d test_type

ALTER TYPE nosuchtype ADD ATTRIBUTE b text
RESULT: []

-----------
QUERY:
-- fails

ALTER TYPE test_type ADD ATTRIBUTE b text
RESULT: []

-----------
QUERY:
-- \d test_type

ALTER TYPE test_type ADD ATTRIBUTE b text
RESULT: []

-----------
QUERY:
-- fails

ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE varchar
RESULT: []

-----------
QUERY:
-- \d test_type

ALTER TYPE test_type ALTER ATTRIBUTE b SET DATA TYPE integer
RESULT: []

-----------
QUERY:
-- \d test_type

ALTER TYPE test_type DROP ATTRIBUTE b
RESULT: []

-----------
QUERY:
-- \d test_type

ALTER TYPE test_type DROP ATTRIBUTE c
RESULT: []

-----------
QUERY:
-- fails

ALTER TYPE test_type DROP ATTRIBUTE IF EXISTS c
RESULT: []

-----------
QUERY:
ALTER TYPE test_type DROP ATTRIBUTE a, ADD ATTRIBUTE d boolean
RESULT: []

-----------
QUERY:
-- \d test_type

ALTER TYPE test_type RENAME ATTRIBUTE a TO aa
RESULT: []

-----------
QUERY:
ALTER TYPE test_type RENAME ATTRIBUTE d TO dd
RESULT: []

-----------
QUERY:
-- \d test_type

DROP TYPE test_type
RESULT: []

-----------
QUERY:
CREATE TYPE test_type1 AS (a int, b text)
RESULT: []

-----------
QUERY:
CREATE TABLE test_tbl1 (x int, y test_type1)
RESULT: []

-----------
QUERY:
ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar
RESULT: []

-----------
QUERY:
-- fails

DROP TABLE test_tbl1
RESULT: []

-----------
QUERY:
CREATE TABLE test_tbl1 (x int, y text)
RESULT: []

-----------
QUERY:
CREATE INDEX test_tbl1_idx ON test_tbl1((row(x,y)::test_type1))
RESULT: []

-----------
QUERY:
ALTER TYPE test_type1 ALTER ATTRIBUTE b TYPE varchar
RESULT: []

-----------
QUERY:
-- fails

DROP TABLE test_tbl1
RESULT: []

-----------
QUERY:
DROP TYPE test_type1
RESULT: []

-----------
QUERY:
CREATE TYPE test_type2 AS (a int, b text)
RESULT: []

-----------
QUERY:
CREATE TABLE test_tbl2 OF test_type2
RESULT: []

-----------
QUERY:
CREATE TABLE test_tbl2_subclass () INHERITS (test_tbl2)
RESULT: []

-----------
QUERY:
-- \d test_type2
-- \d test_tbl2

ALTER TYPE test_type2 ADD ATTRIBUTE c text
RESULT: []

-----------
QUERY:
-- fails
ALTER TYPE test_type2 ADD ATTRIBUTE c text CASCADE
RESULT: []

-----------
QUERY:
-- \d test_type2
-- \d test_tbl2

ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar
RESULT: []

-----------
QUERY:
-- fails
ALTER TYPE test_type2 ALTER ATTRIBUTE b TYPE varchar CASCADE
RESULT: []

-----------
QUERY:
-- \d test_type2
-- \d test_tbl2

ALTER TYPE test_type2 DROP ATTRIBUTE b
RESULT: []

-----------
QUERY:
-- fails
ALTER TYPE test_type2 DROP ATTRIBUTE b CASCADE
RESULT: []

-----------
QUERY:
-- \d test_type2
-- \d test_tbl2

ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa
RESULT: []

-----------
QUERY:
-- fails
ALTER TYPE test_type2 RENAME ATTRIBUTE a TO aa CASCADE
RESULT: []

-----------
QUERY:
-- \d test_type2
-- \d test_tbl2
-- \d test_tbl2_subclass

DROP TABLE test_tbl2_subclass, test_tbl2
RESULT: []

-----------
QUERY:
DROP TYPE test_type2
RESULT: []

-----------
QUERY:
CREATE TYPE test_typex AS (a int, b text)
RESULT: []

-----------
QUERY:
CREATE TABLE test_tblx (x int, y test_typex check ((y).a > 0))
RESULT: []

-----------
QUERY:
ALTER TYPE test_typex DROP ATTRIBUTE a
RESULT: []

-----------
QUERY:
-- fails
ALTER TYPE test_typex DROP ATTRIBUTE a CASCADE
RESULT: []

-----------
QUERY:
-- \d test_tblx
DROP TABLE test_tblx
RESULT: []

-----------
QUERY:
DROP TYPE test_typex
RESULT: []

-----------
QUERY:
-- This test isn/* REPLACED */''t that interesting on its own, but the purpose is to leave
-- behind a table to test pg_upgrade with. The table has a composite type
-- column in it, and the composite type has a dropped attribute.
CREATE TYPE test_type3 AS (a int)
RESULT: []

-----------
QUERY:
CREATE TABLE test_tbl3 (c) AS SELECT '(1)'::test_type3
RESULT: []

-----------
QUERY:
ALTER TYPE test_type3 DROP ATTRIBUTE a, ADD ATTRIBUTE b int
RESULT: []

-----------
QUERY:
CREATE TYPE test_type_empty AS ()
RESULT: []

-----------
QUERY:
DROP TYPE test_type_empty
RESULT: []

-----------
QUERY:
--
-- typed tables: OF / NOT OF
--

CREATE TYPE tt_t0 AS (z inet, x int, y numeric(8,2))
RESULT: []

-----------
QUERY:
ALTER TYPE tt_t0 DROP ATTRIBUTE z
RESULT: []

-----------
QUERY:
CREATE TABLE tt0 (x int NOT NULL, y numeric(8,2))
RESULT: []

-----------
QUERY:
-- OK
CREATE TABLE tt1 (x int, y bigint)
RESULT: []

-----------
QUERY:
-- wrong base type
CREATE TABLE tt2 (x int, y numeric(9,2))
RESULT: []

-----------
QUERY:
-- wrong typmod
CREATE TABLE tt3 (y numeric(8,2), x int)
RESULT: []

-----------
QUERY:
-- wrong column order
CREATE TABLE tt4 (x int)
RESULT: []

-----------
QUERY:
-- too few columns
CREATE TABLE tt5 (x int, y numeric(8,2), z int)
RESULT: []

-----------
QUERY:
-- too few columns
CREATE TABLE tt6 () INHERITS (tt0)
RESULT: []

-----------
QUERY:
-- can/* REPLACED */''t have a parent
CREATE TABLE tt7 (x int, q text, y numeric(8,2))
RESULT: []

-----------
QUERY:
ALTER TABLE tt7 DROP q
RESULT: []

-----------
QUERY:
-- OK

ALTER TABLE tt0 OF tt_t0
RESULT: []

-----------
QUERY:
ALTER TABLE tt1 OF tt_t0
RESULT: []

-----------
QUERY:
ALTER TABLE tt2 OF tt_t0
RESULT: []

-----------
QUERY:
ALTER TABLE tt3 OF tt_t0
RESULT: []

-----------
QUERY:
ALTER TABLE tt4 OF tt_t0
RESULT: []

-----------
QUERY:
ALTER TABLE tt5 OF tt_t0
RESULT: []

-----------
QUERY:
ALTER TABLE tt6 OF tt_t0
RESULT: []

-----------
QUERY:
ALTER TABLE tt7 OF tt_t0
RESULT: []

-----------
QUERY:
CREATE TYPE tt_t1 AS (x int, y numeric(8,2))
RESULT: []

-----------
QUERY:
ALTER TABLE tt7 OF tt_t1
RESULT: []

-----------
QUERY:
-- reassign an already-typed table
ALTER TABLE tt7 NOT OF
RESULT: []

-----------
QUERY:
-- \d tt7

-- make sure we can drop a constraint on the parent but it remains on the child
CREATE TABLE test_drop_constr_parent (c text CHECK (c IS NOT NULL))
RESULT: []

-----------
QUERY:
CREATE TABLE test_drop_constr_child () INHERITS (test_drop_constr_parent)
RESULT: []

-----------
QUERY:
ALTER TABLE ONLY test_drop_constr_parent DROP CONSTRAINT "test_drop_constr_parent_c_check"
RESULT: []

-----------
QUERY:
-- should fail
INSERT INTO test_drop_constr_child (c) VALUES (NULL)
RESULT: []

-----------
QUERY:
DROP TABLE test_drop_constr_parent CASCADE
RESULT: []

-----------
QUERY:
--
-- IF EXISTS test
--
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f)
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10)
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2
RESULT: []

-----------
QUERY:
CREATE TABLE tt8(a int)
RESULT: []

-----------
QUERY:
CREATE SCHEMA alter2
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 ADD COLUMN f int
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 ADD CONSTRAINT xxx PRIMARY KEY(f)
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 ADD CHECK (f BETWEEN 0 AND 10)
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 ALTER COLUMN f SET DEFAULT 0
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 RENAME COLUMN f TO f1
RESULT: []

-----------
QUERY:
ALTER TABLE IF EXISTS tt8 SET SCHEMA alter2
RESULT: []

-----------
QUERY:
-- \d alter2.tt8

DROP TABLE alter2.tt8
RESULT: []

-----------
QUERY:
DROP SCHEMA alter2
RESULT: []

-----------
QUERY:
--
-- Check conflicts between index and CHECK constraint names
--
CREATE TABLE tt9(c integer)
RESULT: []

-----------
QUERY:
ALTER TABLE tt9 ADD CHECK(c > 1)
RESULT: []

-----------
QUERY:
ALTER TABLE tt9 ADD CHECK(c > 2)
RESULT: []

-----------
QUERY:
-- picks nonconflicting name
ALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 3)
RESULT: []

-----------
QUERY:
ALTER TABLE tt9 ADD CONSTRAINT foo CHECK(c > 4)
RESULT: []

-----------
QUERY:
-- fail, dup name
ALTER TABLE tt9 ADD UNIQUE(c)
RESULT: []

-----------
QUERY:
ALTER TABLE tt9 ADD UNIQUE(c)
RESULT: []

-----------
QUERY:
-- picks nonconflicting name
ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key UNIQUE(c)
RESULT: []

-----------
QUERY:
-- fail, dup name
ALTER TABLE tt9 ADD CONSTRAINT foo UNIQUE(c)
RESULT: []

-----------
QUERY:
-- fail, dup name
ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key CHECK(c > 5)
RESULT: []

-----------
QUERY:
-- fail, dup name
ALTER TABLE tt9 ADD CONSTRAINT tt9_c_key2 CHECK(c > 6)
RESULT: []

-----------
QUERY:
ALTER TABLE tt9 ADD UNIQUE(c)
RESULT: []

-----------
QUERY:
-- picks nonconflicting name
-- \d tt9
DROP TABLE tt9
RESULT: []

-----------
QUERY:
-- Check that comments on constraints and indexes are not lost at ALTER TABLE.
CREATE TABLE comment_test (
  id int,
  positive_col int CHECK (positive_col > 0),
  indexed_col int,
  CONSTRAINT comment_test_pk PRIMARY KEY (id))
RESULT: []

-----------
QUERY:
CREATE INDEX comment_test_index ON comment_test(indexed_col)
RESULT: []

-----------
QUERY:
COMMENT ON COLUMN comment_test.id IS 'Column ''id'' on comment_test'
RESULT: []

-----------
QUERY:
COMMENT ON INDEX comment_test_index IS 'Simple index on comment_test'
RESULT: []

-----------
QUERY:
COMMENT ON CONSTRAINT comment_test_positive_col_check ON comment_test IS 'CHECK constraint on comment_test.positive_col'
RESULT: []

-----------
QUERY:
COMMENT ON CONSTRAINT comment_test_pk ON comment_test IS 'PRIMARY KEY constraint of comment_test'
RESULT: []

-----------
QUERY:
COMMENT ON INDEX comment_test_pk IS 'Index backing the PRIMARY KEY of comment_test'
RESULT: []

-----------
QUERY:
SELECT col_description('comment_test'::regclass, 1) as comment
RESULT: []

-----------
QUERY:
SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2
RESULT: []

-----------
QUERY:
SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2
RESULT: []

-----------
QUERY:
-- Change the datatype of all the columns. ALTER TABLE is optimized to not
-- rebuild an index if the new data type is binary compatible with the old
-- one. Check do a dummy ALTER TABLE that doesn/* REPLACED */''t change the datatype
-- first, to test that no-op codepath, and another one that does.
ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE int
RESULT: []

-----------
QUERY:
ALTER TABLE comment_test ALTER COLUMN indexed_col SET DATA TYPE text
RESULT: []

-----------
QUERY:
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int
RESULT: []

-----------
QUERY:
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text
RESULT: []

-----------
QUERY:
ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE int
RESULT: []

-----------
QUERY:
ALTER TABLE comment_test ALTER COLUMN positive_col SET DATA TYPE bigint
RESULT: []

-----------
QUERY:
-- Check that the comments are intact.
SELECT col_description('comment_test'::regclass, 1) as comment
RESULT: []

-----------
QUERY:
SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test'::regclass ORDER BY 1, 2
RESULT: []

-----------
QUERY:
SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test'::regclass ORDER BY 1, 2
RESULT: []

-----------
QUERY:
-- Check compatibility for foreign keys and comments. This is done
-- separately as rebuilding the column type of the parent leads
-- to an error and would reduce the test scope.
CREATE TABLE comment_test_child (
  id text CONSTRAINT comment_test_child_fk REFERENCES comment_test)
RESULT: []

-----------
QUERY:
CREATE INDEX comment_test_child_fk ON comment_test_child(id)
RESULT: []

-----------
QUERY:
COMMENT ON COLUMN comment_test_child.id IS 'Column ''id'' on comment_test_child'
RESULT: []

-----------
QUERY:
COMMENT ON INDEX comment_test_child_fk IS 'Index backing the FOREIGN KEY of comment_test_child'
RESULT: []

-----------
QUERY:
COMMENT ON CONSTRAINT comment_test_child_fk ON comment_test_child IS 'FOREIGN KEY constraint of comment_test_child'
RESULT: []

-----------
QUERY:
-- Change column type of parent
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE text
RESULT: []

-----------
QUERY:
ALTER TABLE comment_test ALTER COLUMN id SET DATA TYPE int USING id::integer
RESULT: []

-----------
QUERY:
-- Comments should be intact
SELECT col_description('comment_test_child'::regclass, 1) as comment
RESULT: []

-----------
QUERY:
SELECT indexrelid::regclass::text as index, obj_description(indexrelid, 'pg_class') as comment FROM pg_index where indrelid = 'comment_test_child'::regclass ORDER BY 1, 2
RESULT: []

-----------
QUERY:
SELECT conname as constraint, obj_description(oid, 'pg_constraint') as comment FROM pg_constraint where conrelid = 'comment_test_child'::regclass ORDER BY 1, 2
RESULT: []

-----------
QUERY:
-- Check that we map relation oids to filenodes and back correctly.  Only
-- display bad mappings so the test output doesn/* REPLACED */''t change all the time.  A
-- filenode function call can return NULL for a relation dropped concurrently
-- with the call/* REPLACED */''s surrounding query, so ignore a NULL mapped_oid for
-- relations that no longer exist after all calls finish.
CREATE TEMP TABLE filenode_mapping AS
SELECT
    oid, mapped_oid, reltablespace, relfilenode, relname
FROM pg_class,
    pg_filenode_relation(reltablespace, pg_relation_filenode(oid)) AS mapped_oid
WHERE relkind IN ('r', 'i', 'S', 't', 'm') AND mapped_oid IS DISTINCT FROM oid
RESULT: []

-----------
QUERY:
SELECT m.* FROM filenode_mapping m LEFT JOIN pg_class c ON c.oid = m.oid
WHERE c.oid IS NOT NULL OR m.mapped_oid IS NOT NULL
RESULT: []

-----------
QUERY:
-- Checks on creating and manipulation of user defined relations in
-- pg_catalog.

SHOW allow_system_table_mods
RESULT: []

-----------
QUERY:
-- disallowed because of search_path issues with pg_dump
CREATE TABLE pg_catalog.new_system_table()
RESULT: []

-----------
QUERY:
-- instead create in public first, move to catalog
CREATE TABLE new_system_table(id serial primary key, othercol text)
RESULT: []

-----------
QUERY:
ALTER TABLE new_system_table SET SCHEMA pg_catalog
RESULT: []

-----------
QUERY:
ALTER TABLE new_system_table SET SCHEMA public
RESULT: []

-----------
QUERY:
ALTER TABLE new_system_table SET SCHEMA pg_catalog
RESULT: []

-----------
QUERY:
-- will be ignored -- already there:
ALTER TABLE new_system_table SET SCHEMA pg_catalog
RESULT: []

-----------
QUERY:
ALTER TABLE new_system_table RENAME TO old_system_table
RESULT: []

-----------
QUERY:
CREATE INDEX old_system_table__othercol ON old_system_table (othercol)
RESULT: []

-----------
QUERY:
INSERT INTO old_system_table(othercol) VALUES ('somedata'), ('otherdata')
RESULT: []

-----------
QUERY:
UPDATE old_system_table SET id = -id
RESULT: []

-----------
QUERY:
DELETE FROM old_system_table WHERE othercol = 'somedata'
RESULT: []

-----------
QUERY:
TRUNCATE old_system_table
RESULT: []

-----------
QUERY:
ALTER TABLE old_system_table DROP CONSTRAINT new_system_table_pkey
RESULT: []

-----------
QUERY:
ALTER TABLE old_system_table DROP COLUMN othercol
RESULT: []

-----------
QUERY:
DROP TABLE old_system_table
RESULT: []

-----------
QUERY:
-- set logged
CREATE UNLOGGED TABLE unlogged1(f1 SERIAL PRIMARY KEY, f2 TEXT)
RESULT: []

-----------
QUERY:
-- has sequence, toast
-- check relpersistence of an unlogged table
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
UNION ALL
SELECT r.relname || ' toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'
UNION ALL
SELECT r.relname || ' toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
ORDER BY relname
RESULT: []

-----------
QUERY:
CREATE UNLOGGED TABLE unlogged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged1)
RESULT: []

-----------
QUERY:
-- foreign key
CREATE UNLOGGED TABLE unlogged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES unlogged3)
RESULT: []

-----------
QUERY:
-- self-referencing foreign key
ALTER TABLE unlogged3 SET LOGGED
RESULT: []

-----------
QUERY:
-- skip self-referencing foreign key
ALTER TABLE unlogged2 SET LOGGED
RESULT: []

-----------
QUERY:
-- fails because a foreign key to an unlogged table exists
ALTER TABLE unlogged1 SET LOGGED
RESULT: []

-----------
QUERY:
-- check relpersistence of an unlogged table after changing to permanent
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged1'
UNION ALL
SELECT r.relname || ' toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^unlogged1'
UNION ALL
SELECT r.relname || ' toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^unlogged1'
ORDER BY relname
RESULT: []

-----------
QUERY:
ALTER TABLE unlogged1 SET LOGGED
RESULT: []

-----------
QUERY:
-- silently do nothing
DROP TABLE unlogged3
RESULT: []

-----------
QUERY:
DROP TABLE unlogged2
RESULT: []

-----------
QUERY:
DROP TABLE unlogged1
RESULT: []

-----------
QUERY:
-- set unlogged
CREATE TABLE logged1(f1 SERIAL PRIMARY KEY, f2 TEXT)
RESULT: []

-----------
QUERY:
-- has sequence, toast
-- check relpersistence of a permanent table
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
UNION ALL
SELECT r.relname || ' toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'
UNION ALL
SELECT r.relname ||' toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
ORDER BY relname
RESULT: []

-----------
QUERY:
CREATE TABLE logged2(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged1)
RESULT: []

-----------
QUERY:
-- foreign key
CREATE TABLE logged3(f1 SERIAL PRIMARY KEY, f2 INTEGER REFERENCES logged3)
RESULT: []

-----------
QUERY:
-- self-referencing foreign key
ALTER TABLE logged1 SET UNLOGGED
RESULT: []

-----------
QUERY:
-- fails because a foreign key from a permanent table exists
ALTER TABLE logged3 SET UNLOGGED
RESULT: []

-----------
QUERY:
-- skip self-referencing foreign key
ALTER TABLE logged2 SET UNLOGGED
RESULT: []

-----------
QUERY:
ALTER TABLE logged1 SET UNLOGGED
RESULT: []

-----------
QUERY:
-- check relpersistence of a permanent table after changing to unlogged
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^logged1'
UNION ALL
SELECT r.relname || ' toast table', t.relkind, t.relpersistence FROM pg_class r JOIN pg_class t ON t.oid = r.reltoastrelid WHERE r.relname ~ '^logged1'
UNION ALL
SELECT r.relname || ' toast index', ri.relkind, ri.relpersistence FROM pg_class r join pg_class t ON t.oid = r.reltoastrelid JOIN pg_index i ON i.indrelid = t.oid JOIN pg_class ri ON ri.oid = i.indexrelid WHERE r.relname ~ '^logged1'
ORDER BY relname
RESULT: []

-----------
QUERY:
ALTER TABLE logged1 SET UNLOGGED
RESULT: []

-----------
QUERY:
-- silently do nothing
DROP TABLE logged3
RESULT: []

-----------
QUERY:
DROP TABLE logged2
RESULT: []

-----------
QUERY:
DROP TABLE logged1
RESULT: []

-----------
QUERY:
-- test ADD COLUMN IF NOT EXISTS
CREATE TABLE test_add_column(c1 integer)
RESULT: []

-----------
QUERY:
-- \d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN c2 integer
RESULT: []

-----------
QUERY:
-- \d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN c2 integer
RESULT: []

-----------
QUERY:
-- fail because c2 already exists
ALTER TABLE ONLY test_add_column
	ADD COLUMN c2 integer
RESULT: []

-----------
QUERY:
-- fail because c2 already exists
-- \d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer
RESULT: []

-----------
QUERY:
-- skipping because c2 already exists
ALTER TABLE ONLY test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer
RESULT: []

-----------
QUERY:
-- skipping because c2 already exists
-- \d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN c2 integer, -- fail because c2 already exists
	ADD COLUMN c3 integer primary key
RESULT: []

-----------
QUERY:
-- \d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
	ADD COLUMN c3 integer primary key
RESULT: []

-----------
QUERY:
-- \d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
	ADD COLUMN IF NOT EXISTS c3 integer primary key
RESULT: []

-----------
QUERY:
-- skipping because c3 already exists
-- \d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c2 integer, -- skipping because c2 already exists
	ADD COLUMN IF NOT EXISTS c3 integer, -- skipping because c3 already exists
	ADD COLUMN c4 integer REFERENCES test_add_column
RESULT: []

-----------
QUERY:
-- \d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c4 integer REFERENCES test_add_column
RESULT: []

-----------
QUERY:
-- \d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c5 SERIAL CHECK (c5 > 8)
RESULT: []

-----------
QUERY:
-- \d test_add_column
ALTER TABLE test_add_column
	ADD COLUMN IF NOT EXISTS c5 SERIAL CHECK (c5 > 10)
RESULT: []

-----------
QUERY:
-- \d test_add_column*
DROP TABLE test_add_column
RESULT: []

-----------
QUERY:
-- \d test_add_column*

-- assorted cases with multiple ALTER TABLE steps
CREATE TABLE ataddindex(f1 INT)
RESULT: []

-----------
QUERY:
INSERT INTO ataddindex VALUES (42), (43)
RESULT: []

-----------
QUERY:
CREATE UNIQUE INDEX ataddindexi0 ON ataddindex(f1)
RESULT: []

-----------
QUERY:
ALTER TABLE ataddindex
  ADD PRIMARY KEY USING INDEX ataddindexi0,
  ALTER f1 TYPE BIGINT
RESULT: []

-----------
QUERY:
-- \d ataddindex
DROP TABLE ataddindex
RESULT: []

-----------
QUERY:
CREATE TABLE ataddindex(f1 VARCHAR(10))
RESULT: []

-----------
QUERY:
INSERT INTO ataddindex(f1) VALUES ('foo'), ('a')
RESULT: []

-----------
QUERY:
ALTER TABLE ataddindex
  ALTER f1 SET DATA TYPE TEXT,
  ADD EXCLUDE ((f1 LIKE 'a') WITH =)
RESULT: []

-----------
QUERY:
-- \d ataddindex
DROP TABLE ataddindex
RESULT: []

-----------
QUERY:
CREATE TABLE ataddindex(id int, ref_id int)
RESULT: []

-----------
QUERY:
ALTER TABLE ataddindex
  ADD PRIMARY KEY (id),
  ADD FOREIGN KEY (ref_id) REFERENCES ataddindex
RESULT: []

-----------
QUERY:
-- \d ataddindex
DROP TABLE ataddindex
RESULT: []

-----------
QUERY:
CREATE TABLE ataddindex(id int, ref_id int)
RESULT: []

-----------
QUERY:
ALTER TABLE ataddindex
  ADD UNIQUE (id),
  ADD FOREIGN KEY (ref_id) REFERENCES ataddindex (id)
RESULT: []

-----------
QUERY:
-- \d ataddindex
DROP TABLE ataddindex
RESULT: []

-----------
QUERY:
CREATE TABLE atnotnull1 ()
RESULT: []

-----------
QUERY:
ALTER TABLE atnotnull1
  ADD COLUMN a INT,
  ALTER a SET NOT NULL
RESULT: []

-----------
QUERY:
ALTER TABLE atnotnull1
  ADD COLUMN b INT,
  ADD NOT NULL b
RESULT: []

-----------
QUERY:
ALTER TABLE atnotnull1
  ADD COLUMN c INT,
  ADD PRIMARY KEY (c)
RESULT: []

-----------
QUERY:
-- \d+ atnotnull1

-- cannot drop column that is part of the partition key
CREATE TABLE partitioned (
	a int,
	b int
) PARTITION BY RANGE (a, (a+b+1))
RESULT: []

-----------
QUERY:
ALTER TABLE partitioned DROP COLUMN a
RESULT: []

-----------
QUERY:
ALTER TABLE partitioned ALTER COLUMN a TYPE char(5)
RESULT: []

-----------
QUERY:
ALTER TABLE partitioned DROP COLUMN b
RESULT: []

-----------
QUERY:
ALTER TABLE partitioned ALTER COLUMN b TYPE char(5)
RESULT: []

-----------
QUERY:
-- specifying storage parameters for partitioned tables is not supported
ALTER TABLE partitioned SET (fillfactor=100)
RESULT: []

-----------
QUERY:
-- partitioned table cannot participate in regular inheritance
CREATE TABLE nonpartitioned (
	a int,
	b int
)
RESULT: []

-----------
QUERY:
ALTER TABLE partitioned INHERIT nonpartitioned
RESULT: []

-----------
QUERY:
ALTER TABLE nonpartitioned INHERIT partitioned
RESULT: []

-----------
QUERY:
-- cannot add NO INHERIT constraint to partitioned tables
ALTER TABLE partitioned ADD CONSTRAINT chk_a CHECK (a > 0) NO INHERIT
RESULT: []

-----------
QUERY:
DROP TABLE partitioned, nonpartitioned
RESULT: []

-----------
QUERY:
--
-- ATTACH PARTITION
--

-- check that target table is partitioned
CREATE TABLE unparted (
	a int
)
RESULT: []

-----------
QUERY:
CREATE TABLE fail_part (like unparted)
RESULT: []

-----------
QUERY:
ALTER TABLE unparted ATTACH PARTITION fail_part FOR VALUES IN ('a')
RESULT: []

-----------
QUERY:
DROP TABLE unparted, fail_part
RESULT: []

-----------
QUERY:
-- check that partition bound is compatible
CREATE TABLE list_parted (
	a int NOT NULL,
	b char(2) COLLATE "C",
	CONSTRAINT check_a CHECK (a > 0)
) PARTITION BY LIST (a)
RESULT: []

-----------
QUERY:
CREATE TABLE fail_part (LIKE list_parted)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES FROM (1) TO (10)
RESULT: []

-----------
QUERY:
DROP TABLE fail_part
RESULT: []

-----------
QUERY:
-- check that the table being attached exists
ALTER TABLE list_parted ATTACH PARTITION nonexistent FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
-- check ownership of the source table
CREATE ROLE regress_test_me
RESULT: []

-----------
QUERY:
CREATE ROLE regress_test_not_me
RESULT: []

-----------
QUERY:
CREATE TABLE not_owned_by_me (LIKE list_parted)
RESULT: []

-----------
QUERY:
ALTER TABLE not_owned_by_me OWNER TO regress_test_not_me
RESULT: []

-----------
QUERY:
SET SESSION AUTHORIZATION regress_test_me
RESULT: []

-----------
QUERY:
CREATE TABLE owned_by_me (
	a int
) PARTITION BY LIST (a)
RESULT: []

-----------
QUERY:
ALTER TABLE owned_by_me ATTACH PARTITION not_owned_by_me FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
RESET SESSION AUTHORIZATION
RESULT: []

-----------
QUERY:
DROP TABLE owned_by_me, not_owned_by_me
RESULT: []

-----------
QUERY:
DROP ROLE regress_test_not_me
RESULT: []

-----------
QUERY:
DROP ROLE regress_test_me
RESULT: []

-----------
QUERY:
-- check that the table being attached is not part of regular inheritance
CREATE TABLE parent (LIKE list_parted)
RESULT: []

-----------
QUERY:
CREATE TABLE child () INHERITS (parent)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION child FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION parent FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
DROP TABLE parent CASCADE
RESULT: []

-----------
QUERY:
-- check any TEMP-ness
CREATE TEMP TABLE temp_parted (a int) PARTITION BY LIST (a)
RESULT: []

-----------
QUERY:
CREATE TABLE perm_part (a int)
RESULT: []

-----------
QUERY:
ALTER TABLE temp_parted ATTACH PARTITION perm_part FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
DROP TABLE temp_parted, perm_part
RESULT: []

-----------
QUERY:
-- check that the table being attached is not a typed table
CREATE TYPE mytype AS (a int)
RESULT: []

-----------
QUERY:
CREATE TABLE fail_part OF mytype
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
DROP TYPE mytype CASCADE
RESULT: []

-----------
QUERY:
-- check that the table being attached has only columns present in the parent
CREATE TABLE fail_part (like list_parted, c int)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
DROP TABLE fail_part
RESULT: []

-----------
QUERY:
-- check that the table being attached has every column of the parent
CREATE TABLE fail_part (a int NOT NULL)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
DROP TABLE fail_part
RESULT: []

-----------
QUERY:
-- check that columns match in type, collation and NOT NULL status
CREATE TABLE fail_part (
	b char(3),
	a int NOT NULL
)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
ALTER TABLE fail_part ALTER b TYPE char (2) COLLATE "POSIX"
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
DROP TABLE fail_part
RESULT: []

-----------
QUERY:
-- check that the table being attached has all constraints of the parent
CREATE TABLE fail_part (
	b char(2) COLLATE "C",
	a int NOT NULL
)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
-- check that the constraint matches in definition with parent/* REPLACED */''s constraint
ALTER TABLE fail_part ADD CONSTRAINT check_a CHECK (a >= 0)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
DROP TABLE fail_part
RESULT: []

-----------
QUERY:
-- check the attributes and constraints after partition is attached
CREATE TABLE part_1 (
	a int NOT NULL,
	b char(2) COLLATE "C",
	CONSTRAINT check_a CHECK (a > 0)
)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION part_1 FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
-- attislocal and conislocal are always false for merged attributes and constraints respectively.
SELECT attislocal, attinhcount FROM pg_attribute WHERE attrelid = 'part_1'::regclass AND attnum > 0
RESULT: []

-----------
QUERY:
SELECT conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_1'::regclass AND conname = 'check_a'
RESULT: []

-----------
QUERY:
-- check that the new partition won/* REPLACED */''t overlap with an existing partition
CREATE TABLE fail_part (LIKE part_1 INCLUDING CONSTRAINTS)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION fail_part FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
DROP TABLE fail_part
RESULT: []

-----------
QUERY:
-- check that an existing table can be attached as a default partition
CREATE TABLE def_part (LIKE list_parted INCLUDING CONSTRAINTS)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION def_part DEFAULT
RESULT: []

-----------
QUERY:
-- check attaching default partition fails if a default partition already
-- exists
CREATE TABLE fail_def_part (LIKE part_1 INCLUDING CONSTRAINTS)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted ATTACH PARTITION fail_def_part DEFAULT
RESULT: []

-----------
QUERY:
-- check validation when attaching list partitions
CREATE TABLE list_parted2 (
	a int,
	b char
) PARTITION BY LIST (a)
RESULT: []

-----------
QUERY:
-- check that violating rows are correctly reported
CREATE TABLE part_2 (LIKE list_parted2)
RESULT: []

-----------
QUERY:
INSERT INTO part_2 VALUES (3, 'a')
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2)
RESULT: []

-----------
QUERY:
-- should be ok after deleting the bad row
DELETE FROM part_2
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2)
RESULT: []

-----------
QUERY:
-- check partition cannot be attached if default has some row for its values
CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT
RESULT: []

-----------
QUERY:
INSERT INTO list_parted2_def VALUES (11, 'z')
RESULT: []

-----------
QUERY:
CREATE TABLE part_3 (LIKE list_parted2)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11)
RESULT: []

-----------
QUERY:
-- should be ok after deleting the bad row
DELETE FROM list_parted2_def WHERE a = 11
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_3 FOR VALUES IN (11)
RESULT: []

-----------
QUERY:
-- adding constraints that describe the desired partition constraint
-- (or more restrictive) will help skip the validation scan
CREATE TABLE part_3_4 (
	LIKE list_parted2,
	CONSTRAINT check_a CHECK (a IN (3))
)
RESULT: []

-----------
QUERY:
-- however, if a list partition does not accept nulls, there should be
-- an explicit NOT NULL constraint on the partition key column for the
-- validation scan to be skipped /* REPLACED */,
ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4)
RESULT: []

-----------
QUERY:
-- adding a NOT NULL constraint will cause the scan to be skipped
ALTER TABLE list_parted2 DETACH PARTITION part_3_4
RESULT: []

-----------
QUERY:
ALTER TABLE part_3_4 ALTER a SET NOT NULL
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_3_4 FOR VALUES IN (3, 4)
RESULT: []

-----------
QUERY:
-- check if default partition scan skipped
ALTER TABLE list_parted2_def ADD CONSTRAINT check_a CHECK (a IN (5, 6))
RESULT: []

-----------
QUERY:
CREATE TABLE part_55_66 PARTITION OF list_parted2 FOR VALUES IN (55, 66)
RESULT: []

-----------
QUERY:
-- check validation when attaching range partitions
CREATE TABLE range_parted (
	a int,
	b int
) PARTITION BY RANGE (a, b)
RESULT: []

-----------
QUERY:
-- check that violating rows are correctly reported
CREATE TABLE part1 (
	a int NOT NULL CHECK (a = 1),
	b int NOT NULL CHECK (b >= 1 AND b <= 10)
)
RESULT: []

-----------
QUERY:
INSERT INTO part1 VALUES (1, 10)
RESULT: []

-----------
QUERY:
-- Remember the TO bound is exclusive
ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10)
RESULT: []

-----------
QUERY:
-- should be ok after deleting the bad row
DELETE FROM part1
RESULT: []

-----------
QUERY:
ALTER TABLE range_parted ATTACH PARTITION part1 FOR VALUES FROM (1, 1) TO (1, 10)
RESULT: []

-----------
QUERY:
-- adding constraints that describe the desired partition constraint
-- (or more restrictive) will help skip the validation scan
CREATE TABLE part2 (
	a int NOT NULL CHECK (a = 1),
	b int NOT NULL CHECK (b >= 10 AND b < 18)
)
RESULT: []

-----------
QUERY:
ALTER TABLE range_parted ATTACH PARTITION part2 FOR VALUES FROM (1, 10) TO (1, 20)
RESULT: []

-----------
QUERY:
-- Create default partition
CREATE TABLE partr_def1 PARTITION OF range_parted DEFAULT
RESULT: []

-----------
QUERY:
-- Only one default partition is allowed, hence, following should give error
CREATE TABLE partr_def2 (LIKE part1 INCLUDING CONSTRAINTS)
RESULT: []

-----------
QUERY:
ALTER TABLE range_parted ATTACH PARTITION partr_def2 DEFAULT
RESULT: []

-----------
QUERY:
-- Overlapping partitions cannot be attached, hence, following should give error
INSERT INTO partr_def1 VALUES (2, 10)
RESULT: []

-----------
QUERY:
CREATE TABLE part3 (LIKE range_parted)
RESULT: []

-----------
QUERY:
ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (2, 10) TO (2, 20)
RESULT: []

-----------
QUERY:
-- Attaching partitions should be successful when there are no overlapping rows
ALTER TABLE range_parted ATTACH partition part3 FOR VALUES FROM (3, 10) TO (3, 20)
RESULT: []

-----------
QUERY:
-- check that leaf partitions are scanned when attaching a partitioned
-- table
CREATE TABLE part_5 (
	LIKE list_parted2
) PARTITION BY LIST (b)
RESULT: []

-----------
QUERY:
-- check that violating rows are correctly reported
CREATE TABLE part_5_a PARTITION OF part_5 FOR VALUES IN ('a')
RESULT: []

-----------
QUERY:
INSERT INTO part_5_a (a, b) VALUES (6, 'a')
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5)
RESULT: []

-----------
QUERY:
-- delete the faulting row and also add a constraint to skip the scan
DELETE FROM part_5_a WHERE a NOT IN (3)
RESULT: []

-----------
QUERY:
ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 5)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 DETACH PARTITION part_5
RESULT: []

-----------
QUERY:
ALTER TABLE part_5 DROP CONSTRAINT check_a
RESULT: []

-----------
QUERY:
-- scan should again be skipped, even though NOT NULL is now a column property
ALTER TABLE part_5 ADD CONSTRAINT check_a CHECK (a IN (5)), ALTER a SET NOT NULL
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_5 FOR VALUES IN (5)
RESULT: []

-----------
QUERY:
-- Check the case where attnos of the partitioning columns in the table being
-- attached differs from the parent.  It should not affect the constraint-
-- checking logic that allows to skip the scan.
CREATE TABLE part_6 (
	c int,
	LIKE list_parted2,
	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 6)
)
RESULT: []

-----------
QUERY:
ALTER TABLE part_6 DROP c
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_6 FOR VALUES IN (6)
RESULT: []

-----------
QUERY:
-- Similar to above, but the table being attached is a partitioned table
-- whose partition has still different attnos for the root partitioning
-- columns.
CREATE TABLE part_7 (
	LIKE list_parted2,
	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
) PARTITION BY LIST (b)
RESULT: []

-----------
QUERY:
CREATE TABLE part_7_a_null (
	c int,
	d int,
	e int,
	LIKE list_parted2,  -- /* REPLACED */''a/* REPLACED */'' will have attnum = 4
	CONSTRAINT check_b CHECK (b IS NULL OR b = 'a'),
	CONSTRAINT check_a CHECK (a IS NOT NULL AND a = 7)
)
RESULT: []

-----------
QUERY:
ALTER TABLE part_7_a_null DROP c, DROP d, DROP e
RESULT: []

-----------
QUERY:
ALTER TABLE part_7 ATTACH PARTITION part_7_a_null FOR VALUES IN ('a', null)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7)
RESULT: []

-----------
QUERY:
-- Same example, but check this time that the constraint correctly detects
-- violating rows
ALTER TABLE list_parted2 DETACH PARTITION part_7
RESULT: []

-----------
QUERY:
ALTER TABLE part_7 DROP CONSTRAINT check_a
RESULT: []

-----------
QUERY:
-- thusly, scan won/* REPLACED */''t be skipped
INSERT INTO part_7 (a, b) VALUES (8, null), (9, 'a')
RESULT: []

-----------
QUERY:
SELECT tableoid::regclass, a, b FROM part_7 order by a
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION part_7 FOR VALUES IN (7)
RESULT: []

-----------
QUERY:
-- check that leaf partitions of default partition are scanned when
-- attaching a partitioned table.
ALTER TABLE part_5 DROP CONSTRAINT check_a
RESULT: []

-----------
QUERY:
CREATE TABLE part5_def PARTITION OF part_5 DEFAULT PARTITION BY LIST(a)
RESULT: []

-----------
QUERY:
CREATE TABLE part5_def_p1 PARTITION OF part5_def FOR VALUES IN (5)
RESULT: []

-----------
QUERY:
INSERT INTO part5_def_p1 VALUES (5, 'y')
RESULT: []

-----------
QUERY:
CREATE TABLE part5_p1 (LIKE part_5)
RESULT: []

-----------
QUERY:
ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y')
RESULT: []

-----------
QUERY:
-- should be ok after deleting the bad row
DELETE FROM part5_def_p1 WHERE b = 'y'
RESULT: []

-----------
QUERY:
ALTER TABLE part_5 ATTACH PARTITION part5_p1 FOR VALUES IN ('y')
RESULT: []

-----------
QUERY:
-- check that the table being attached is not already a partition
ALTER TABLE list_parted2 ATTACH PARTITION part_2 FOR VALUES IN (2)
RESULT: []

-----------
QUERY:
-- check that circular inheritance is not allowed
ALTER TABLE part_5 ATTACH PARTITION list_parted2 FOR VALUES IN ('b')
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ATTACH PARTITION list_parted2 FOR VALUES IN (0)
RESULT: []

-----------
QUERY:
-- If a partitioned table being created or an existing table being attached
-- as a partition does not have a constraint that would allow validation scan
-- to be skipped, but an individual partition does, then the partition/* REPLACED */''s
-- validation scan is skipped.
CREATE TABLE quuux (a int, b text) PARTITION BY LIST (a)
RESULT: []

-----------
QUERY:
CREATE TABLE quuux_default PARTITION OF quuux DEFAULT PARTITION BY LIST (b)
RESULT: []

-----------
QUERY:
CREATE TABLE quuux_default1 PARTITION OF quuux_default (
	CONSTRAINT check_1 CHECK (a IS NOT NULL AND a = 1)
) FOR VALUES IN ('b')
RESULT: []

-----------
QUERY:
CREATE TABLE quuux1 (a int, b text)
RESULT: []

-----------
QUERY:
ALTER TABLE quuux ATTACH PARTITION quuux1 FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
-- validate!
CREATE TABLE quuux2 (a int, b text)
RESULT: []

-----------
QUERY:
ALTER TABLE quuux ATTACH PARTITION quuux2 FOR VALUES IN (2)
RESULT: []

-----------
QUERY:
-- skip validation
DROP TABLE quuux1, quuux2
RESULT: []

-----------
QUERY:
-- should validate for quuux1, but not for quuux2
CREATE TABLE quuux1 PARTITION OF quuux FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
CREATE TABLE quuux2 PARTITION OF quuux FOR VALUES IN (2)
RESULT: []

-----------
QUERY:
DROP TABLE quuux
RESULT: []

-----------
QUERY:
-- check validation when attaching hash partitions

-- Use hand-rolled hash functions and operator class to get predictable result
-- on different machines. part_test_int4_ops is defined in test_setup.sql.

-- check that the new partition won/* REPLACED */''t overlap with an existing partition
CREATE TABLE hash_parted (
	a int,
	b int
) PARTITION BY HASH (a part_test_int4_ops)
RESULT: []

-----------
QUERY:
CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 4, REMAINDER 0)
RESULT: []

-----------
QUERY:
CREATE TABLE fail_part (LIKE hpart_1)
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 4)
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 0)
RESULT: []

-----------
QUERY:
DROP TABLE fail_part
RESULT: []

-----------
QUERY:
-- check validation when attaching hash partitions

-- check that violating rows are correctly reported
CREATE TABLE hpart_2 (LIKE hash_parted)
RESULT: []

-----------
QUERY:
INSERT INTO hpart_2 VALUES (3, 0)
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1)
RESULT: []

-----------
QUERY:
-- should be ok after deleting the bad row
DELETE FROM hpart_2
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted ATTACH PARTITION hpart_2 FOR VALUES WITH (MODULUS 4, REMAINDER 1)
RESULT: []

-----------
QUERY:
-- check that leaf partitions are scanned when attaching a partitioned
-- table
CREATE TABLE hpart_5 (
	LIKE hash_parted
) PARTITION BY LIST (b)
RESULT: []

-----------
QUERY:
-- check that violating rows are correctly reported
CREATE TABLE hpart_5_a PARTITION OF hpart_5 FOR VALUES IN ('1', '2', '3')
RESULT: []

-----------
QUERY:
INSERT INTO hpart_5_a (a, b) VALUES (7, 1)
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2)
RESULT: []

-----------
QUERY:
-- should be ok after deleting the bad row
DELETE FROM hpart_5_a
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted ATTACH PARTITION hpart_5 FOR VALUES WITH (MODULUS 4, REMAINDER 2)
RESULT: []

-----------
QUERY:
-- check that the table being attach is with valid modulus and remainder value
CREATE TABLE fail_part(LIKE hash_parted)
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 0, REMAINDER 1)
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 8, REMAINDER 8)
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted ATTACH PARTITION fail_part FOR VALUES WITH (MODULUS 3, REMAINDER 2)
RESULT: []

-----------
QUERY:
DROP TABLE fail_part
RESULT: []

-----------
QUERY:
--
-- DETACH PARTITION
--

-- check that the table is partitioned at all
CREATE TABLE regular_table (a int)
RESULT: []

-----------
QUERY:
ALTER TABLE regular_table DETACH PARTITION any_name
RESULT: []

-----------
QUERY:
DROP TABLE regular_table
RESULT: []

-----------
QUERY:
-- check that the partition being detached exists at all
ALTER TABLE list_parted2 DETACH PARTITION part_4
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted DETACH PARTITION hpart_4
RESULT: []

-----------
QUERY:
-- check that the partition being detached is actually a partition of the parent
CREATE TABLE not_a_part (a int)
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 DETACH PARTITION not_a_part
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 DETACH PARTITION part_1
RESULT: []

-----------
QUERY:
ALTER TABLE hash_parted DETACH PARTITION not_a_part
RESULT: []

-----------
QUERY:
DROP TABLE not_a_part
RESULT: []

-----------
QUERY:
-- check that, after being detached, attinhcount/coninhcount is dropped to 0 and
-- attislocal/conislocal is set to true
ALTER TABLE list_parted2 DETACH PARTITION part_3_4
RESULT: []

-----------
QUERY:
SELECT attinhcount, attislocal FROM pg_attribute WHERE attrelid = 'part_3_4'::regclass AND attnum > 0
RESULT: []

-----------
QUERY:
SELECT coninhcount, conislocal FROM pg_constraint WHERE conrelid = 'part_3_4'::regclass AND conname = 'check_a'
RESULT: []

-----------
QUERY:
DROP TABLE part_3_4
RESULT: []

-----------
QUERY:
-- check that a detached partition is not dropped on dropping a partitioned table
CREATE TABLE range_parted2 (
    a int
) PARTITION BY RANGE(a)
RESULT: []

-----------
QUERY:
CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100)
RESULT: []

-----------
QUERY:
ALTER TABLE range_parted2 DETACH PARTITION part_rp
RESULT: []

-----------
QUERY:
DROP TABLE range_parted2
RESULT: []

-----------
QUERY:
SELECT * from part_rp
RESULT: []

-----------
QUERY:
DROP TABLE part_rp
RESULT: []

-----------
QUERY:
-- concurrent detach
CREATE TABLE range_parted2 (
	a int
) PARTITION BY RANGE(a)
RESULT: []

-----------
QUERY:
CREATE TABLE part_rp PARTITION OF range_parted2 FOR VALUES FROM (0) to (100)
RESULT: []

-----------
QUERY:
BEGIN
RESULT: []

-----------
QUERY:
-- doesn/* REPLACED */''t work in a partition block
ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY
RESULT: []

-----------
QUERY:
COMMIT
RESULT: []

-----------
QUERY:
CREATE TABLE part_rpd PARTITION OF range_parted2 DEFAULT
RESULT: []

-----------
QUERY:
-- doesn/* REPLACED */''t work if there/* REPLACED */''s a default partition
ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY
RESULT: []

-----------
QUERY:
-- doesn/* REPLACED */''t work for the default partition
ALTER TABLE range_parted2 DETACH PARTITION part_rpd CONCURRENTLY
RESULT: []

-----------
QUERY:
DROP TABLE part_rpd
RESULT: []

-----------
QUERY:
-- works fine
ALTER TABLE range_parted2 DETACH PARTITION part_rp CONCURRENTLY
RESULT: []

-----------
QUERY:
-- \d+ range_parted2
-- constraint should be created
-- \d part_rp
CREATE TABLE part_rp100 PARTITION OF range_parted2 (CHECK (a>=123 AND a<133 AND a IS NOT NULL)) FOR VALUES FROM (100) to (200)
RESULT: []

-----------
QUERY:
ALTER TABLE range_parted2 DETACH PARTITION part_rp100 CONCURRENTLY
RESULT: []

-----------
QUERY:
-- redundant constraint should not be created
-- \d part_rp100
DROP TABLE range_parted2
RESULT: []

-----------
QUERY:
-- Check ALTER TABLE commands for partitioned tables and partitions

-- cannot add/drop column to/from *only* the parent
ALTER TABLE ONLY list_parted2 ADD COLUMN c int
RESULT: []

-----------
QUERY:
ALTER TABLE ONLY list_parted2 DROP COLUMN b
RESULT: []

-----------
QUERY:
-- cannot add a column to partition or drop an inherited one
ALTER TABLE part_2 ADD COLUMN c text
RESULT: []

-----------
QUERY:
ALTER TABLE part_2 DROP COLUMN b
RESULT: []

-----------
QUERY:
-- Nor rename, alter type
ALTER TABLE part_2 RENAME COLUMN b to c
RESULT: []

-----------
QUERY:
ALTER TABLE part_2 ALTER COLUMN b TYPE text
RESULT: []

-----------
QUERY:
-- cannot add/drop NOT NULL or check constraints to *only* the parent, when
-- partitions exist
ALTER TABLE ONLY list_parted2 ALTER b SET NOT NULL
RESULT: []

-----------
QUERY:
ALTER TABLE ONLY list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz')
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ALTER b SET NOT NULL
RESULT: []

-----------
QUERY:
ALTER TABLE ONLY list_parted2 ALTER b DROP NOT NULL
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ADD CONSTRAINT check_b CHECK (b <> 'zz')
RESULT: []

-----------
QUERY:
ALTER TABLE ONLY list_parted2 DROP CONSTRAINT check_b
RESULT: []

-----------
QUERY:
-- It/* REPLACED */''s alright though, if no partitions are yet created
CREATE TABLE parted_no_parts (a int) PARTITION BY LIST (a)
RESULT: []

-----------
QUERY:
ALTER TABLE ONLY parted_no_parts ALTER a SET NOT NULL
RESULT: []

-----------
QUERY:
ALTER TABLE ONLY parted_no_parts ADD CONSTRAINT check_a CHECK (a > 0)
RESULT: []

-----------
QUERY:
ALTER TABLE ONLY parted_no_parts ALTER a DROP NOT NULL
RESULT: []

-----------
QUERY:
ALTER TABLE ONLY parted_no_parts DROP CONSTRAINT check_a
RESULT: []

-----------
QUERY:
DROP TABLE parted_no_parts
RESULT: []

-----------
QUERY:
-- cannot drop inherited NOT NULL or check constraints from partition
ALTER TABLE list_parted2 ALTER b SET NOT NULL, ADD CONSTRAINT check_a2 CHECK (a > 0)
RESULT: []

-----------
QUERY:
ALTER TABLE part_2 ALTER b DROP NOT NULL
RESULT: []

-----------
QUERY:
ALTER TABLE part_2 DROP CONSTRAINT check_a2
RESULT: []

-----------
QUERY:
-- Doesn/* REPLACED */''t make sense to add NO INHERIT constraints on partitioned tables
ALTER TABLE list_parted2 add constraint check_b2 check (b <> 'zz') NO INHERIT
RESULT: []

-----------
QUERY:
-- check that a partition cannot participate in regular inheritance
CREATE TABLE inh_test () INHERITS (part_2)
RESULT: []

-----------
QUERY:
CREATE TABLE inh_test (LIKE part_2)
RESULT: []

-----------
QUERY:
ALTER TABLE inh_test INHERIT part_2
RESULT: []

-----------
QUERY:
ALTER TABLE part_2 INHERIT inh_test
RESULT: []

-----------
QUERY:
-- cannot drop or alter type of partition key columns of lower level
-- partitioned tables /* REPLACED */, for example, part_5, which is list_parted2/* REPLACED */''s
-- partition, is partitioned on b /* REPLACED */,
ALTER TABLE list_parted2 DROP COLUMN b
RESULT: []

-----------
QUERY:
ALTER TABLE list_parted2 ALTER COLUMN b TYPE text
RESULT: []

-----------
QUERY:
-- dropping non-partition key columns should be allowed on the parent table.
ALTER TABLE list_parted DROP COLUMN b
RESULT: []

-----------
QUERY:
SELECT * FROM list_parted
RESULT: []

-----------
QUERY:
-- cleanup
DROP TABLE list_parted, list_parted2, range_parted
RESULT: []

-----------
QUERY:
DROP TABLE fail_def_part
RESULT: []

-----------
QUERY:
DROP TABLE hash_parted
RESULT: []

-----------
QUERY:
-- more tests for certain multi-level partitioning scenarios
create table p (a int, b int) partition by range (a, b)
RESULT: []

-----------
QUERY:
create table p1 (b int, a int not null) partition by range (b)
RESULT: []

-----------
QUERY:
create table p11 (like p1)
RESULT: []

-----------
QUERY:
alter table p11 drop a
RESULT: []

-----------
QUERY:
alter table p11 add a int
RESULT: []

-----------
QUERY:
alter table p11 drop a
RESULT: []

-----------
QUERY:
alter table p11 add a int not null
RESULT: []

-----------
QUERY:
-- attnum for key attribute /* REPLACED */''a/* REPLACED */'' is different in p, p1, and p11
select attrelid::regclass, attname, attnum
from pg_attribute
where attname = 'a'
 and (attrelid = 'p'::regclass
   or attrelid = 'p1'::regclass
   or attrelid = 'p11'::regclass)
order by attrelid::regclass::text
RESULT: []

-----------
QUERY:
alter table p1 attach partition p11 for values from (2) to (5)
RESULT: []

-----------
QUERY:
insert into p1 (a, b) values (2, 3)
RESULT: []

-----------
QUERY:
-- check that partition validation scan correctly detects violating rows
alter table p attach partition p1 for values from (1, 2) to (1, 10)
RESULT: []

-----------
QUERY:
-- cleanup
drop table p
RESULT: []

-----------
QUERY:
drop table p1
RESULT: []

-----------
QUERY:
-- validate constraint on partitioned tables should only scan leaf partitions
create table parted_validate_test (a int) partition by list (a)
RESULT: []

-----------
QUERY:
create table parted_validate_test_1 partition of parted_validate_test for values in (0, 1)
RESULT: []

-----------
QUERY:
alter table parted_validate_test add constraint parted_validate_test_chka check (a > 0) not valid
RESULT: []

-----------
QUERY:
alter table parted_validate_test validate constraint parted_validate_test_chka
RESULT: []

-----------
QUERY:
drop table parted_validate_test
RESULT: []

-----------
QUERY:
-- test alter column options
CREATE TABLE attmp(i integer)
RESULT: []

-----------
QUERY:
INSERT INTO attmp VALUES (1)
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ALTER COLUMN i SET (n_distinct = 1, n_distinct_inherited = 2)
RESULT: []

-----------
QUERY:
ALTER TABLE attmp ALTER COLUMN i RESET (n_distinct_inherited)
RESULT: []

-----------
QUERY:
ANALYZE attmp
RESULT: []

-----------
QUERY:
DROP TABLE attmp
RESULT: []

-----------
QUERY:
DROP USER regress_alter_table_user1
RESULT: []

-----------
QUERY:
-- check that violating rows are correctly reported when attaching as the
-- default partition
create table defpart_attach_test (a int) partition by list (a)
RESULT: []

-----------
QUERY:
create table defpart_attach_test1 partition of defpart_attach_test for values in (1)
RESULT: []

-----------
QUERY:
create table defpart_attach_test_d (b int, a int)
RESULT: []

-----------
QUERY:
alter table defpart_attach_test_d drop b
RESULT: []

-----------
QUERY:
insert into defpart_attach_test_d values (1), (2)
RESULT: []

-----------
QUERY:
-- error because its constraint as the default partition would be violated
-- by the row containing 1
alter table defpart_attach_test attach partition defpart_attach_test_d default
RESULT: []

-----------
QUERY:
delete from defpart_attach_test_d where a = 1
RESULT: []

-----------
QUERY:
alter table defpart_attach_test_d add check (a > 1)
RESULT: []

-----------
QUERY:
-- should be attached successfully and without needing to be scanned
alter table defpart_attach_test attach partition defpart_attach_test_d default
RESULT: []

-----------
QUERY:
-- check that attaching a partition correctly reports any rows in the default
-- partition that should not be there for the new partition to be attached
-- successfully
create table defpart_attach_test_2 (like defpart_attach_test_d)
RESULT: []

-----------
QUERY:
alter table defpart_attach_test attach partition defpart_attach_test_2 for values in (2)
RESULT: []

-----------
QUERY:
drop table defpart_attach_test
RESULT: []

-----------
QUERY:
-- check combinations of temporary and permanent relations when attaching
-- partitions.
create table perm_part_parent (a int) partition by list (a)
RESULT: []

-----------
QUERY:
create temp table temp_part_parent (a int) partition by list (a)
RESULT: []

-----------
QUERY:
create table perm_part_child (a int)
RESULT: []

-----------
QUERY:
create temp table temp_part_child (a int)
RESULT: []

-----------
QUERY:
alter table temp_part_parent attach partition perm_part_child default
RESULT: []

-----------
QUERY:
-- error
alter table perm_part_parent attach partition temp_part_child default
RESULT: []

-----------
QUERY:
-- error
alter table temp_part_parent attach partition temp_part_child default
RESULT: []

-----------
QUERY:
-- ok
drop table perm_part_parent cascade
RESULT: []

-----------
QUERY:
drop table temp_part_parent cascade
RESULT: []

-----------
QUERY:
-- check that attaching partitions to a table while it is being used is
-- prevented
create table tab_part_attach (a int) partition by list (a)
RESULT: []

-----------
QUERY:
create or replace function func_part_attach() returns trigger
  language plpgsql as $$
  begin
    execute 'create table tab_part_attach_1 (a int)';
    execute 'alter table tab_part_attach attach partition tab_part_attach_1 for values in (1)';
    return null;
  end $$
RESULT: []

-----------
QUERY:
create trigger trig_part_attach before insert on tab_part_attach
  for each statement execute procedure func_part_attach()
RESULT: []

-----------
QUERY:
insert into tab_part_attach values (1)
RESULT: []

-----------
QUERY:
drop table tab_part_attach
RESULT: []

-----------
QUERY:
drop function func_part_attach()
RESULT: []

-----------
QUERY:
-- test case where the partitioning operator is a SQL function whose
-- evaluation results in the table/* REPLACED */''s relcache being rebuilt partway through
-- the execution of an ATTACH PARTITION command
create function at_test_sql_partop (int4, int4) returns int language sql
as $$ select case when $1 = $2 then 0 when $1 > $2 then 1 else -1 end; $$
RESULT: []

-----------
QUERY:
create operator class at_test_sql_partop for type int4 using btree as
    operator 1 < (int4, int4), operator 2 <= (int4, int4),
    operator 3 = (int4, int4), operator 4 >= (int4, int4),
    operator 5 > (int4, int4), function 1 at_test_sql_partop(int4, int4)
RESULT: []

-----------
QUERY:
create table at_test_sql_partop (a int) partition by range (a at_test_sql_partop)
RESULT: []

-----------
QUERY:
create table at_test_sql_partop_1 (a int)
RESULT: []

-----------
QUERY:
alter table at_test_sql_partop attach partition at_test_sql_partop_1 for values from (0) to (10)
RESULT: []

-----------
QUERY:
drop table at_test_sql_partop
RESULT: []

-----------
QUERY:
drop operator class at_test_sql_partop using btree
RESULT: []

-----------
QUERY:
drop function at_test_sql_partop
RESULT: []

-----------
QUERY:
/* Test case for bug #16242 */

-- We create a parent and child where the child has missing
-- non-null attribute values, and arrange to pass them through
-- tuple conversion from the child to the parent tupdesc
create table bar1 (a integer, b integer not null default 1)
  partition by range (a)
RESULT: []

-----------
QUERY:
create table bar2 (a integer)
RESULT: []

-----------
QUERY:
insert into bar2 values (1)
RESULT: []

-----------
QUERY:
alter table bar2 add column b integer not null default 1
RESULT: []

-----------
QUERY:
-- (at this point bar2 contains tuple with natts=1)
alter table bar1 attach partition bar2 default
RESULT: []

-----------
QUERY:
-- this works:
select * from bar1
RESULT: []

-----------
QUERY:
-- this exercises tuple conversion:
create function xtrig()
  returns trigger language plpgsql
as $$
  declare
    r record;
  begin
    for r in select * from old loop
      raise info 'a=%, b=%', r.a, r.b;
    end loop;
    return NULL;
  end;
$$
RESULT: []

-----------
QUERY:
create trigger xtrig
  after update on bar1
  referencing old table as old
  for each statement execute procedure xtrig()
RESULT: []

-----------
QUERY:
update bar1 set a = a + 1
RESULT: []

-----------
QUERY:
/* End test case for bug #16242 */

/* Test case for bug #17409 */

create table attbl (p1 int constraint pk_attbl primary key)
RESULT: []

-----------
QUERY:
create table atref (c1 int references attbl(p1))
RESULT: []

-----------
QUERY:
cluster attbl using pk_attbl
RESULT: []

-----------
QUERY:
alter table attbl alter column p1 set data type bigint
RESULT: []

-----------
QUERY:
alter table atref alter column c1 set data type bigint
RESULT: []

-----------
QUERY:
drop table attbl, atref
RESULT: []

-----------
QUERY:
create table attbl (p1 int constraint pk_attbl primary key)
RESULT: []

-----------
QUERY:
alter table attbl replica identity using index pk_attbl
RESULT: []

-----------
QUERY:
create table atref (c1 int references attbl(p1))
RESULT: []

-----------
QUERY:
alter table attbl alter column p1 set data type bigint
RESULT: []

-----------
QUERY:
alter table atref alter column c1 set data type bigint
RESULT: []

-----------
QUERY:
drop table attbl, atref
RESULT: []

-----------
QUERY:
/* End test case for bug #17409 */

-- Test that ALTER TABLE rewrite preserves a clustered index
-- for normal indexes and indexes on constraints.
create table alttype_cluster (a int)
RESULT: []

-----------
QUERY:
alter table alttype_cluster add primary key (a)
RESULT: []

-----------
QUERY:
create index alttype_cluster_ind on alttype_cluster (a)
RESULT: []

-----------
QUERY:
alter table alttype_cluster cluster on alttype_cluster_ind
RESULT: []

-----------
QUERY:
-- Normal index remains clustered.
select indexrelid::regclass, indisclustered from pg_index
  where indrelid = 'alttype_cluster'::regclass
  order by indexrelid::regclass::text
RESULT: []

-----------
QUERY:
alter table alttype_cluster alter a type bigint
RESULT: []

-----------
QUERY:
select indexrelid::regclass, indisclustered from pg_index
  where indrelid = 'alttype_cluster'::regclass
  order by indexrelid::regclass::text
RESULT: []

-----------
QUERY:
-- Constraint index remains clustered.
alter table alttype_cluster cluster on alttype_cluster_pkey
RESULT: []

-----------
QUERY:
select indexrelid::regclass, indisclustered from pg_index
  where indrelid = 'alttype_cluster'::regclass
  order by indexrelid::regclass::text
RESULT: []

-----------
QUERY:
alter table alttype_cluster alter a type int
RESULT: []

-----------
QUERY:
select indexrelid::regclass, indisclustered from pg_index
  where indrelid = 'alttype_cluster'::regclass
  order by indexrelid::regclass::text
RESULT: []

-----------
QUERY:
drop table alttype_cluster
RESULT: []

-----------
QUERY:
--
-- Check that attaching or detaching a partitioned partition correctly leads
-- to its partitions/* REPLACED */'' constraint being updated to reflect the parent/* REPLACED */''s
-- newly added/removed constraint
create table target_parted (a int, b int) partition by list (a)
RESULT: []

-----------
QUERY:
create table attach_parted (a int, b int) partition by list (b)
RESULT: []

-----------
QUERY:
create table attach_parted_part1 partition of attach_parted for values in (1)
RESULT: []

-----------
QUERY:
-- insert a row directly into the leaf partition so that its partition
-- constraint is built and stored in the relcache
insert into attach_parted_part1 values (1, 1)
RESULT: []

-----------
QUERY:
-- the following better invalidate the partition constraint of the leaf
-- partition too...
alter table target_parted attach partition attach_parted for values in (1)
RESULT: []

-----------
QUERY:
-- ...such that the following insert fails
insert into attach_parted_part1 values (2, 1)
RESULT: []

-----------
QUERY:
-- ...and doesn/* REPLACED */''t when the partition is detached along with its own partition
alter table target_parted detach partition attach_parted
RESULT: []

-----------
QUERY:
insert into attach_parted_part1 values (2, 1)
RESULT: []

-----------
QUERY:
-- Test altering table having publication
create schema alter1
RESULT: []

-----------
QUERY:
create schema alter2
RESULT: []

-----------
QUERY:
create table alter1.t1 (a int)
RESULT: []

-----------
QUERY:
set client_min_messages = 'ERROR'
RESULT: []

-----------
QUERY:
create publication pub1 for table alter1.t1, tables in schema alter2
RESULT: []

-----------
QUERY:
reset client_min_messages
RESULT: []

-----------
QUERY:
alter table alter1.t1 set schema alter2
RESULT: []

-----------
QUERY:
-- \d+ alter2.t1
drop publication pub1
RESULT: []

-----------
QUERY:
drop schema alter1 cascade
RESULT: []

-----------
QUERY:
drop schema alter2 cascade
RESULT: []
=========================================
Summary for test case alter_table/test.sql of postgres
=========================================
