
-----------
QUERY:
--
-- CREATE_TABLE
--

-- Error cases
CREATE TABLE unknowntab (
	u unknown    -- fail
);
RESULT:
	ERROR - column "u" has pseudo-type unknown


-----------
QUERY:


CREATE TYPE unknown_comptype AS (
	u unknown    -- fail
);
RESULT:
	ERROR - column "u" has pseudo-type unknown


-----------
QUERY:


-- invalid: non-lowercase quoted reloptions identifiers
CREATE TABLE tas_case WITH ("Fillfactor" = 10) AS SELECT 1 a;
RESULT:
	ERROR - unrecognized parameter "Fillfactor"


-----------
QUERY:


CREATE UNLOGGED TABLE unlogged1 (a int primary key);
RESULT:
	[]

-----------
QUERY:
			-- OK
CREATE TEMPORARY TABLE unlogged2 (a int primary key);
RESULT:
	[]

-----------
QUERY:
			-- OK
SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged\d' ORDER BY relname;
RESULT:
	[('unlogged1', 'r', 'u'), ('unlogged1_pkey', 'i', 'u'), ('unlogged2', 'r', 't'), ('unlogged2_pkey', 'i', 't')]

-----------
QUERY:

REINDEX INDEX unlogged1_pkey;
RESULT:
	[]

-----------
QUERY:

REINDEX INDEX unlogged2_pkey;
RESULT:
	[]

-----------
QUERY:

SELECT relname, relkind, relpersistence FROM pg_class WHERE relname ~ '^unlogged\d' ORDER BY relname;
RESULT:
	[('unlogged1', 'r', 'u'), ('unlogged1_pkey', 'i', 'u'), ('unlogged2', 'r', 't'), ('unlogged2_pkey', 'i', 't')]

-----------
QUERY:

DROP TABLE unlogged2;
RESULT:
	[]

-----------
QUERY:

INSERT INTO unlogged1 VALUES (42);
RESULT:
	[]

-----------
QUERY:

CREATE UNLOGGED TABLE public.unlogged2 (a int primary key);
RESULT:
	[]

-----------
QUERY:
		-- also OK
CREATE UNLOGGED TABLE pg_temp.unlogged3 (a int primary key);
RESULT:
	ERROR - only temporary relations may be created in temporary schemas
LINE 2: CREATE UNLOGGED TABLE pg_temp.unlogged3 (a int primary key);
                              ^


-----------
QUERY:
	-- not OK
CREATE TABLE pg_temp.implicitly_temp (a int primary key);
RESULT:
	[]

-----------
QUERY:
		-- OK
CREATE TEMP TABLE explicitly_temp (a int primary key);
RESULT:
	[]

-----------
QUERY:
			-- also OK
CREATE TEMP TABLE pg_temp.doubly_temp (a int primary key);
RESULT:
	[]

-----------
QUERY:
		-- also OK
CREATE TEMP TABLE public.temp_to_perm (a int primary key);
RESULT:
	ERROR - cannot create temporary relation in non-temporary schema
LINE 2: CREATE TEMP TABLE public.temp_to_perm (a int primary key);
                          ^


-----------
QUERY:
		-- not OK
DROP TABLE unlogged1, public.unlogged2;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
RESULT:
	[]

-----------
QUERY:

CREATE TABLE as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
RESULT:
	ERROR - relation "as_select1" already exists


-----------
QUERY:

CREATE TABLE IF NOT EXISTS as_select1 AS SELECT * FROM pg_class WHERE relkind = 'r';
RESULT:
	[]

-----------
QUERY:

DROP TABLE as_select1;
RESULT:
	[]

-----------
QUERY:


PREPARE select1 AS SELECT 1 as a;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE as_select1 AS EXECUTE select1;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE as_select1 AS EXECUTE select1;
RESULT:
	ERROR - relation "as_select1" already exists


-----------
QUERY:

SELECT * FROM as_select1;
RESULT:
	[(1,)]

-----------
QUERY:

CREATE TABLE IF NOT EXISTS as_select1 AS EXECUTE select1;
RESULT:
	[]

-----------
QUERY:

DROP TABLE as_select1;
RESULT:
	[]

-----------
QUERY:

DEALLOCATE select1;
RESULT:
	[]

-----------
QUERY:


-- create an extra wide table to test for issues related to that
-- (temporarily hide query, to avoid the long CREATE TABLE stmt)
-- \set ECHO none
SELECT 'CREATE TABLE extra_wide_table(firstc text, '|| array_to_string(array_agg('c'||i||' bool'),',')||', lastc text);
RESULT:
	ERROR - unterminated quoted string at or near "', lastc text);"
LINE 6: ... array_to_string(array_agg('c'||i||' bool'),',')||', lastc t...
                                                             ^


-----------
QUERY:
'
FROM generate_series(1, 1100) g(i)
-- \gexec
-- \set ECHO all
INSERT INTO extra_wide_table(firstc, lastc) VALUES('first col', 'last col');
RESULT:
	ERROR - syntax error at or near "'
FROM generate_series(1, 1100) g(i)
-- \gexec
-- \set ECHO all
INSERT INTO extra_wide_table(firstc, lastc) VALUES('"
LINE 1: '
        ^


-----------
QUERY:

SELECT firstc, lastc FROM extra_wide_table;
RESULT:
	ERROR - relation "extra_wide_table" does not exist
LINE 2: SELECT firstc, lastc FROM extra_wide_table;
                                  ^


-----------
QUERY:


-- check that tables with oids cannot be created anymore
CREATE TABLE withoid() WITH OIDS;
RESULT:
	ERROR - syntax error at or near "OIDS"
LINE 4: CREATE TABLE withoid() WITH OIDS;
                                    ^


-----------
QUERY:

CREATE TABLE withoid() WITH (oids);
RESULT:
	ERROR - tables declared WITH OIDS are not supported


-----------
QUERY:

CREATE TABLE withoid() WITH (oids = true);
RESULT:
	ERROR - tables declared WITH OIDS are not supported


-----------
QUERY:


-- but explicitly not adding oids is still supported
CREATE TEMP TABLE withoutoid() WITHOUT OIDS;
RESULT:
	[]

-----------
QUERY:
 DROP TABLE withoutoid;
RESULT:
	[]

-----------
QUERY:

CREATE TEMP TABLE withoutoid() WITH (oids = false);
RESULT:
	[]

-----------
QUERY:
 DROP TABLE withoutoid;
RESULT:
	[]

-----------
QUERY:


-- check restriction with default expressions
-- invalid use of column reference in default expressions
CREATE TABLE default_expr_column (id int DEFAULT (id));
RESULT:
	ERROR - cannot use column reference in DEFAULT expression
LINE 5: CREATE TABLE default_expr_column (id int DEFAULT (id));
                                                          ^


-----------
QUERY:

CREATE TABLE default_expr_column (id int DEFAULT (bar.id));
RESULT:
	ERROR - cannot use column reference in DEFAULT expression
LINE 2: CREATE TABLE default_expr_column (id int DEFAULT (bar.id));
                                                          ^


-----------
QUERY:

CREATE TABLE default_expr_agg_column (id int DEFAULT (avg(id)));
RESULT:
	ERROR - cannot use column reference in DEFAULT expression
LINE 2: ...TE TABLE default_expr_agg_column (id int DEFAULT (avg(id)));
                                                                 ^


-----------
QUERY:

-- invalid column definition
CREATE TABLE default_expr_non_column (a int DEFAULT (avg(non_existent)));
RESULT:
	ERROR - cannot use column reference in DEFAULT expression
LINE 3: ...TABLE default_expr_non_column (a int DEFAULT (avg(non_existe...
                                                             ^


-----------
QUERY:

-- invalid use of aggregate
CREATE TABLE default_expr_agg (a int DEFAULT (avg(1)));
RESULT:
	ERROR - aggregate functions are not allowed in DEFAULT expressions
LINE 3: CREATE TABLE default_expr_agg (a int DEFAULT (avg(1)));
                                                      ^


-----------
QUERY:

-- invalid use of subquery
CREATE TABLE default_expr_agg (a int DEFAULT (select 1));
RESULT:
	ERROR - cannot use subquery in DEFAULT expression
LINE 3: CREATE TABLE default_expr_agg (a int DEFAULT (select 1));
                                                     ^


-----------
QUERY:

-- invalid use of set-returning function
CREATE TABLE default_expr_agg (a int DEFAULT (generate_series(1,3)));
RESULT:
	ERROR - set-returning functions are not allowed in DEFAULT expressions
LINE 3: CREATE TABLE default_expr_agg (a int DEFAULT (generate_serie...
                                                      ^


-----------
QUERY:


-- Verify that subtransaction rollback restores rd_createSubid.
BEGIN;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE remember_create_subid (c int);
RESULT:
	[]

-----------
QUERY:

SAVEPOINT q;
RESULT:
	[]

-----------
QUERY:
 DROP TABLE remember_create_subid;
RESULT:
	[]

-----------
QUERY:
 ROLLBACK TO q;
RESULT:
	[]

-----------
QUERY:

COMMIT;
RESULT:
	[]

-----------
QUERY:

DROP TABLE remember_create_subid;
RESULT:
	[]

-----------
QUERY:


-- Verify that subtransaction rollback restores rd_firstRelfilenodeSubid.
CREATE TABLE remember_node_subid (c int);
RESULT:
	[]

-----------
QUERY:

BEGIN;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE remember_node_subid ALTER c TYPE bigint;
RESULT:
	[]

-----------
QUERY:

SAVEPOINT q;
RESULT:
	[]

-----------
QUERY:
 DROP TABLE remember_node_subid;
RESULT:
	[]

-----------
QUERY:
 ROLLBACK TO q;
RESULT:
	[]

-----------
QUERY:

COMMIT;
RESULT:
	[]

-----------
QUERY:

DROP TABLE remember_node_subid;
RESULT:
	[]

-----------
QUERY:


--
-- Partitioned tables
--

-- cannot combine INHERITS and PARTITION BY (although grammar allows)
CREATE TABLE partitioned (
	a int
) INHERITS (some_table) PARTITION BY LIST (a);
RESULT:
	ERROR - cannot create partitioned table as inheritance child


-----------
QUERY:


-- cannot use more than 1 column as partition key for list partitioned table
CREATE TABLE partitioned (
	a1 int,
	a2 int
) PARTITION BY LIST (a1, a2);
RESULT:
	ERROR - cannot use "list" partition strategy with more than one column


-----------
QUERY:
	-- fail

-- prevent using prohibited expressions in the key
CREATE FUNCTION retset (a int) RETURNS SETOF int AS $$ SELECT 1; $$ LANGUAGE SQL IMMUTABLE;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE (retset(a));
RESULT:
	ERROR - set-returning functions are not allowed in partition key expressions


-----------
QUERY:

DROP FUNCTION retset(int);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE ((avg(a)));
RESULT:
	ERROR - aggregate functions are not allowed in partition key expressions


-----------
QUERY:


CREATE TABLE partitioned (
	a int,
	b int
) PARTITION BY RANGE ((avg(a) OVER (PARTITION BY b)));
RESULT:
	ERROR - window functions are not allowed in partition key expressions


-----------
QUERY:


CREATE TABLE partitioned (
	a int
) PARTITION BY LIST ((a LIKE (SELECT 1)));
RESULT:
	ERROR - cannot use subquery in partition key expression


-----------
QUERY:


CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE ((42));
RESULT:
	ERROR - cannot use constant expression as partition key


-----------
QUERY:


CREATE FUNCTION const_func () RETURNS int AS $$ SELECT 1; $$ LANGUAGE SQL IMMUTABLE;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE (const_func());
RESULT:
	ERROR - cannot use constant expression as partition key


-----------
QUERY:

DROP FUNCTION const_func();
RESULT:
	[]

-----------
QUERY:


-- only accept valid partitioning strategy
CREATE TABLE partitioned (
    a int
) PARTITION BY MAGIC (a);
RESULT:
	ERROR - unrecognized partitioning strategy "magic"


-----------
QUERY:


-- specified column must be present in the table
CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE (b);
RESULT:
	ERROR - column "b" named in partition key does not exist
LINE 6: ) PARTITION BY RANGE (b);
                              ^


-----------
QUERY:


-- cannot use system columns in partition key
CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE (xmin);
RESULT:
	ERROR - cannot use system column "xmin" in partition key
LINE 6: ) PARTITION BY RANGE (xmin);
                              ^


-----------
QUERY:


-- cannot use pseudotypes
CREATE TABLE partitioned (
	a int,
	b int
) PARTITION BY RANGE (((a, b)));
RESULT:
	ERROR - partition key column 1 has pseudo-type record


-----------
QUERY:

CREATE TABLE partitioned (
	a int,
	b int
) PARTITION BY RANGE (a, ('unknown'));
RESULT:
	ERROR - partition key column 2 has pseudo-type unknown


-----------
QUERY:


-- functions in key must be immutable
CREATE FUNCTION immut_func (a int) RETURNS int AS $$ SELECT a + random()::int; $$ LANGUAGE SQL;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE partitioned (
	a int
) PARTITION BY RANGE (immut_func(a));
RESULT:
	ERROR - functions in partition key expression must be marked IMMUTABLE


-----------
QUERY:

DROP FUNCTION immut_func(int);
RESULT:
	[]

-----------
QUERY:


-- prevent using columns of unsupported types in key (type must have a btree operator class)
CREATE TABLE partitioned (
	a point
) PARTITION BY LIST (a);
RESULT:
	ERROR - data type point has no default operator class for access method "btree"
HINT:  You must specify a btree operator class or define a default btree operator class for the data type.


-----------
QUERY:

CREATE TABLE partitioned (
	a point
) PARTITION BY LIST (a point_ops);
RESULT:
	ERROR - operator class "point_ops" does not exist for access method "btree"


-----------
QUERY:

CREATE TABLE partitioned (
	a point
) PARTITION BY RANGE (a);
RESULT:
	ERROR - data type point has no default operator class for access method "btree"
HINT:  You must specify a btree operator class or define a default btree operator class for the data type.


-----------
QUERY:

CREATE TABLE partitioned (
	a point
) PARTITION BY RANGE (a point_ops);
RESULT:
	ERROR - operator class "point_ops" does not exist for access method "btree"


-----------
QUERY:


-- cannot add NO INHERIT constraints to partitioned tables
CREATE TABLE partitioned (
	a int,
	CONSTRAINT check_a CHECK (a > 0) NO INHERIT
) PARTITION BY RANGE (a);
RESULT:
	ERROR - cannot add NO INHERIT constraint to partitioned table "partitioned"


-----------
QUERY:


-- some checks after successful creation of a partitioned table
CREATE FUNCTION plusone(a int) RETURNS INT AS $$ SELECT a+1; $$ LANGUAGE SQL;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE partitioned (
	a int,
	b int,
	c text,
	d text
) PARTITION BY RANGE (a oid_ops, plusone(b), c collate "default", d collate "C");
RESULT:
	[]

-----------
QUERY:


-- check relkind
SELECT relkind FROM pg_class WHERE relname = 'partitioned';
RESULT:
	[('p',)]

-----------
QUERY:


-- prevent a function referenced in partition key from being dropped
DROP FUNCTION plusone(int);
RESULT:
	ERROR - cannot drop function plusone(integer) because other objects depend on it
DETAIL:  table partitioned depends on function plusone(integer)
HINT:  Use DROP ... CASCADE to drop the dependent objects too.


-----------
QUERY:


-- partitioned table cannot participate in regular inheritance
CREATE TABLE partitioned2 (
	a int,
	b text
) PARTITION BY RANGE ((a+1), substr(b, 1, 5));
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail () INHERITS (partitioned2);
RESULT:
	ERROR - cannot inherit from partitioned table "partitioned2"


-----------
QUERY:


-- Partition key in describe output
-- \d partitioned
-- \d+ partitioned2

INSERT INTO partitioned2 VALUES (1, 'hello');
RESULT:
	ERROR - no partition of relation "partitioned2" found for row
DETAIL:  Partition key of the failing row contains ((a + 1), substr(b, 1, 5)) = (2, hello).


-----------
QUERY:

CREATE TABLE part2_1 PARTITION OF partitioned2 FOR VALUES FROM (-1, 'aaaaa') TO (100, 'ccccc');
RESULT:
	[]

-----------
QUERY:

-- \d+ part2_1

DROP TABLE partitioned, partitioned2;
RESULT:
	[]

-----------
QUERY:


-- check reference to partitioned table/* REPLACED */ ''s rowtype in partition descriptor
create table partitioned (a int, b int)
  partition by list ((row(a, b)::partitioned));
RESULT:
	[]

-----------
QUERY:

create table partitioned1
  partition of partitioned for values in ('(1,2)'::partitioned);
RESULT:
	[]

-----------
QUERY:

create table partitioned2
  partition of partitioned for values in ('(2,4)'::partitioned);
RESULT:
	[]

-----------
QUERY:

explain (costs off)
select * from partitioned where row(a,b)::partitioned = '(1,2)'::partitioned;
RESULT:
	[('Seq Scan on partitioned1 partitioned',), ("  Filter: (ROW(a, b)::partitioned = '(1,2)'::partitioned)",)]

-----------
QUERY:

drop table partitioned;
RESULT:
	[]

-----------
QUERY:


-- whole-row Var in partition key works too
create table partitioned (a int, b int)
  partition by list ((partitioned));
RESULT:
	[]

-----------
QUERY:

create table partitioned1
  partition of partitioned for values in ('(1,2)');
RESULT:
	[]

-----------
QUERY:

create table partitioned2
  partition of partitioned for values in ('(2,4)');
RESULT:
	[]

-----------
QUERY:

explain (costs off)
select * from partitioned where partitioned = '(1,2)'::partitioned;
RESULT:
	[('Seq Scan on partitioned1 partitioned',), ("  Filter: ((partitioned.*)::partitioned = '(1,2)'::partitioned)",)]

-----------
QUERY:

-- \d+ partitioned1
drop table partitioned;
RESULT:
	[]

-----------
QUERY:


-- check that dependencies of partition columns are handled correctly
create domain intdom1 as int;
RESULT:
	[]

-----------
QUERY:


create table partitioned (
	a intdom1,
	b text
) partition by range (a);
RESULT:
	[]

-----------
QUERY:


alter table partitioned drop column a;
RESULT:
	ERROR - cannot drop column "a" because it is part of the partition key of relation "partitioned"


-----------
QUERY:
  -- fail

drop domain intdom1;
RESULT:
	ERROR - cannot drop type intdom1 because other objects depend on it
DETAIL:  table partitioned depends on type intdom1
HINT:  Use DROP ... CASCADE to drop the dependent objects too.


-----------
QUERY:
  -- fail, requires cascade

drop domain intdom1 cascade;
RESULT:
	[]

-----------
QUERY:


table partitioned;
RESULT:
	ERROR - relation "partitioned" does not exist
LINE 3: table partitioned;
              ^


-----------
QUERY:
  -- gone

-- likewise for columns used in partition expressions
create domain intdom1 as int;
RESULT:
	[]

-----------
QUERY:


create table partitioned (
	a intdom1,
	b text
) partition by range (plusone(a));
RESULT:
	[]

-----------
QUERY:


alter table partitioned drop column a;
RESULT:
	ERROR - cannot drop column "a" because it is part of the partition key of relation "partitioned"


-----------
QUERY:
  -- fail

drop domain intdom1;
RESULT:
	ERROR - cannot drop type intdom1 because other objects depend on it
DETAIL:  table partitioned depends on type intdom1
HINT:  Use DROP ... CASCADE to drop the dependent objects too.


-----------
QUERY:
  -- fail, requires cascade

drop domain intdom1 cascade;
RESULT:
	[]

-----------
QUERY:


table partitioned;
RESULT:
	ERROR - relation "partitioned" does not exist
LINE 3: table partitioned;
              ^


-----------
QUERY:
  -- gone


--
-- Partitions
--

-- check partition bound syntax

CREATE TABLE list_parted (
	a int
) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_p1 PARTITION OF list_parted FOR VALUES IN ('1');
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_p2 PARTITION OF list_parted FOR VALUES IN (2);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_p3 PARTITION OF list_parted FOR VALUES IN ((2+1));
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_null PARTITION OF list_parted FOR VALUES IN (null);
RESULT:
	[]

-----------
QUERY:

-- \d+ list_parted

-- forbidden expressions for partition bound with list partitioned table
CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename);
RESULT:
	ERROR - cannot use column reference in partition bound expression
LINE 5: ...expr_fail PARTITION OF list_parted FOR VALUES IN (somename);
                                                             ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (somename.somename);
RESULT:
	ERROR - cannot use column reference in partition bound expression
LINE 2: ...expr_fail PARTITION OF list_parted FOR VALUES IN (somename.s...
                                                             ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (a);
RESULT:
	ERROR - cannot use column reference in partition bound expression
LINE 2: ..._bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (a);
                                                                    ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(a));
RESULT:
	ERROR - cannot use column reference in partition bound expression
LINE 2: ...s_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(a));
                                                                   ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(somename));
RESULT:
	ERROR - cannot use column reference in partition bound expression
LINE 2: ..._fail PARTITION OF list_parted FOR VALUES IN (sum(somename))...
                                                             ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(1));
RESULT:
	ERROR - aggregate functions are not allowed in partition bound
LINE 2: ...s_expr_fail PARTITION OF list_parted FOR VALUES IN (sum(1));
                                                               ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((select 1));
RESULT:
	ERROR - cannot use subquery in partition bound
LINE 2: ...expr_fail PARTITION OF list_parted FOR VALUES IN ((select 1)...
                                                             ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN (generate_series(4, 6));
RESULT:
	ERROR - set-returning functions are not allowed in partition bound
LINE 2: ...expr_fail PARTITION OF list_parted FOR VALUES IN (generate_s...
                                                             ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF list_parted FOR VALUES IN ((1+1) collate "POSIX");
RESULT:
	ERROR - collations are not supported by type integer
LINE 2: ...ail PARTITION OF list_parted FOR VALUES IN ((1+1) collate "P...
                                                             ^


-----------
QUERY:


-- syntax does not allow empty list of values for list partitions
CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES IN ();
RESULT:
	ERROR - syntax error at or near ")"
LINE 4: ...E TABLE fail_part PARTITION OF list_parted FOR VALUES IN ();
                                                                     ^


-----------
QUERY:

-- trying to specify range for list partitioned table
CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES FROM (1) TO (2);
RESULT:
	ERROR - invalid bound specification for a list partition
LINE 3: ...BLE fail_part PARTITION OF list_parted FOR VALUES FROM (1) T...
                                                             ^


-----------
QUERY:

-- trying to specify modulus and remainder for list partitioned table
CREATE TABLE fail_part PARTITION OF list_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
RESULT:
	ERROR - invalid bound specification for a list partition
LINE 3: ...BLE fail_part PARTITION OF list_parted FOR VALUES WITH (MODU...
                                                             ^


-----------
QUERY:


-- check default partition cannot be created more than once
CREATE TABLE part_default PARTITION OF list_parted DEFAULT;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail_default_part PARTITION OF list_parted DEFAULT;
RESULT:
	ERROR - partition "fail_default_part" conflicts with existing default partition "part_default"
LINE 2: ...TE TABLE fail_default_part PARTITION OF list_parted DEFAULT;
                                                               ^


-----------
QUERY:


-- specified literal can/* REPLACED */ ''t be cast to the partition column data type
CREATE TABLE bools (
	a bool
) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE bools_true PARTITION OF bools FOR VALUES IN (1);
RESULT:
	ERROR - specified value cannot be cast to type boolean for column "a"
LINE 2: ...REATE TABLE bools_true PARTITION OF bools FOR VALUES IN (1);
                                                                    ^


-----------
QUERY:

DROP TABLE bools;
RESULT:
	[]

-----------
QUERY:


-- specified literal can be cast, and the cast might not be immutable
CREATE TABLE moneyp (
	a money
) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE moneyp_10 PARTITION OF moneyp FOR VALUES IN (10);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE moneyp_11 PARTITION OF moneyp FOR VALUES IN ('11');
RESULT:
	[]

-----------
QUERY:

CREATE TABLE moneyp_12 PARTITION OF moneyp FOR VALUES IN (to_char(12, '99')::int);
RESULT:
	[]

-----------
QUERY:

DROP TABLE moneyp;
RESULT:
	[]

-----------
QUERY:


-- cast is immutable
CREATE TABLE bigintp (
	a bigint
) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE bigintp_10 PARTITION OF bigintp FOR VALUES IN (10);
RESULT:
	[]

-----------
QUERY:

-- fails due to overlap:
CREATE TABLE bigintp_10_2 PARTITION OF bigintp FOR VALUES IN ('10');
RESULT:
	ERROR - partition "bigintp_10_2" would overlap partition "bigintp_10"
LINE 3: ...ABLE bigintp_10_2 PARTITION OF bigintp FOR VALUES IN ('10');
                                                                 ^


-----------
QUERY:

DROP TABLE bigintp;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE range_parted (
	a date
) PARTITION BY RANGE (a);
RESULT:
	[]

-----------
QUERY:


-- forbidden expressions for partition bounds with range partitioned table
CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (somename) TO ('2019-01-01');
RESULT:
	ERROR - cannot use column reference in partition bound expression
LINE 5:   FOR VALUES FROM (somename) TO ('2019-01-01');
                           ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (somename.somename) TO ('2019-01-01');
RESULT:
	ERROR - cannot use column reference in partition bound expression
LINE 3:   FOR VALUES FROM (somename.somename) TO ('2019-01-01');
                           ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (a) TO ('2019-01-01');
RESULT:
	ERROR - cannot use column reference in partition bound expression
LINE 3:   FOR VALUES FROM (a) TO ('2019-01-01');
                           ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (max(a)) TO ('2019-01-01');
RESULT:
	ERROR - cannot use column reference in partition bound expression
LINE 3:   FOR VALUES FROM (max(a)) TO ('2019-01-01');
                               ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (max(somename)) TO ('2019-01-01');
RESULT:
	ERROR - cannot use column reference in partition bound expression
LINE 3:   FOR VALUES FROM (max(somename)) TO ('2019-01-01');
                               ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (max('2019-02-01'::date)) TO ('2019-01-01');
RESULT:
	ERROR - aggregate functions are not allowed in partition bound
LINE 3:   FOR VALUES FROM (max('2019-02-01'::date)) TO ('2019-01-01'...
                           ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM ((select 1)) TO ('2019-01-01');
RESULT:
	ERROR - cannot use subquery in partition bound
LINE 3:   FOR VALUES FROM ((select 1)) TO ('2019-01-01');
                           ^


-----------
QUERY:

CREATE TABLE part_bogus_expr_fail PARTITION OF range_parted
  FOR VALUES FROM (generate_series(1, 3)) TO ('2019-01-01');
RESULT:
	ERROR - set-returning functions are not allowed in partition bound
LINE 3:   FOR VALUES FROM (generate_series(1, 3)) TO ('2019-01-01');
                           ^


-----------
QUERY:


-- trying to specify list for range partitioned table
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES IN ('a');
RESULT:
	ERROR - invalid bound specification for a range partition
LINE 4: ...BLE fail_part PARTITION OF range_parted FOR VALUES IN ('a');
                                                              ^


-----------
QUERY:

-- trying to specify modulus and remainder for range partitioned table
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
RESULT:
	ERROR - invalid bound specification for a range partition
LINE 3: ...LE fail_part PARTITION OF range_parted FOR VALUES WITH (MODU...
                                                             ^


-----------
QUERY:

-- each of start and end bounds must have same number of values as the
-- length of the partition key
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a', 1) TO ('z');
RESULT:
	ERROR - FROM must specify exactly one value per partitioning column


-----------
QUERY:

CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM ('a') TO ('z', 1);
RESULT:
	ERROR - TO must specify exactly one value per partitioning column


-----------
QUERY:


-- cannot specify null values in range bounds
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES FROM (null) TO (maxvalue);
RESULT:
	ERROR - cannot specify NULL in range bound


-----------
QUERY:


-- trying to specify modulus and remainder for range partitioned table
CREATE TABLE fail_part PARTITION OF range_parted FOR VALUES WITH (MODULUS 10, REMAINDER 1);
RESULT:
	ERROR - invalid bound specification for a range partition
LINE 4: ...LE fail_part PARTITION OF range_parted FOR VALUES WITH (MODU...
                                                             ^


-----------
QUERY:


-- check partition bound syntax for the hash partition
CREATE TABLE hash_parted (
	a int
) PARTITION BY HASH (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE hpart_1 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 0);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE hpart_2 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 50, REMAINDER 1);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE hpart_3 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 200, REMAINDER 2);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE hpart_4 PARTITION OF hash_parted FOR VALUES WITH (MODULUS 10, REMAINDER 3);
RESULT:
	[]

-----------
QUERY:

-- modulus 25 is factor of modulus of 50 but 10 is not a factor of 25.
CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 25, REMAINDER 3);
RESULT:
	ERROR - every hash partition modulus must be a factor of the next larger modulus
DETAIL:  The new modulus 25 is not divisible by 10, the modulus of existing partition "hpart_4".


-----------
QUERY:

-- previous modulus 50 is factor of 150 but this modulus is not a factor of next modulus 200.
CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 150, REMAINDER 3);
RESULT:
	ERROR - every hash partition modulus must be a factor of the next larger modulus
DETAIL:  The new modulus 150 is not a factor of 200, the modulus of existing partition "hpart_3".


-----------
QUERY:

-- overlapping remainders
CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODULUS 100, REMAINDER 3);
RESULT:
	ERROR - partition "fail_part" would overlap partition "hpart_4"
LINE 3: ...BLE fail_part PARTITION OF hash_parted FOR VALUES WITH (MODU...
                                                             ^


-----------
QUERY:

-- trying to specify range for the hash partitioned table
CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES FROM ('a', 1) TO ('z');
RESULT:
	ERROR - invalid bound specification for a hash partition
LINE 3: ...BLE fail_part PARTITION OF hash_parted FOR VALUES FROM ('a',...
                                                             ^


-----------
QUERY:

-- trying to specify list value for the hash partitioned table
CREATE TABLE fail_part PARTITION OF hash_parted FOR VALUES IN (1000);
RESULT:
	ERROR - invalid bound specification for a hash partition
LINE 3: ...BLE fail_part PARTITION OF hash_parted FOR VALUES IN (1000);
                                                             ^


-----------
QUERY:


-- trying to create default partition for the hash partitioned table
CREATE TABLE fail_default_part PARTITION OF hash_parted DEFAULT;
RESULT:
	ERROR - a hash-partitioned table may not have a default partition


-----------
QUERY:


-- check if compatible with the specified parent

-- cannot create as partition of a non-partitioned table
CREATE TABLE unparted (
	a int
);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail_part PARTITION OF unparted FOR VALUES IN ('a');
RESULT:
	ERROR - "unparted" is not partitioned


-----------
QUERY:

CREATE TABLE fail_part PARTITION OF unparted FOR VALUES WITH (MODULUS 2, REMAINDER 1);
RESULT:
	ERROR - "unparted" is not partitioned


-----------
QUERY:

DROP TABLE unparted;
RESULT:
	[]

-----------
QUERY:


-- cannot create a permanent rel as partition of a temp rel
CREATE TEMP TABLE temp_parted (
	a int
) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail_part PARTITION OF temp_parted FOR VALUES IN ('a');
RESULT:
	ERROR - cannot create a permanent relation as partition of temporary relation "temp_parted"


-----------
QUERY:

DROP TABLE temp_parted;
RESULT:
	[]

-----------
QUERY:


-- check for partition bound overlap and other invalid specifications

CREATE TABLE list_parted2 (
	a varchar
) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_null_z PARTITION OF list_parted2 FOR VALUES IN (null, 'z');
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part_ab PARTITION OF list_parted2 FOR VALUES IN ('a', 'b');
RESULT:
	[]

-----------
QUERY:

CREATE TABLE list_parted2_def PARTITION OF list_parted2 DEFAULT;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN (null);
RESULT:
	ERROR - partition "fail_part" would overlap partition "part_null_z"
LINE 3: ...LE fail_part PARTITION OF list_parted2 FOR VALUES IN (null);
                                                                 ^


-----------
QUERY:

CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('b', 'c');
RESULT:
	ERROR - partition "fail_part" would overlap partition "part_ab"
LINE 2: ...ail_part PARTITION OF list_parted2 FOR VALUES IN ('b', 'c');
                                                             ^


-----------
QUERY:

-- check default partition overlap
INSERT INTO list_parted2 VALUES('X');
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail_part PARTITION OF list_parted2 FOR VALUES IN ('W', 'X', 'Y');
RESULT:
	ERROR - updated partition constraint for default partition "list_parted2_def" would be violated by some row


-----------
QUERY:


CREATE TABLE range_parted2 (
	a int
) PARTITION BY RANGE (a);
RESULT:
	[]

-----------
QUERY:


-- trying to create range partition with empty range
CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (0);
RESULT:
	ERROR - empty range bound specified for partition "fail_part"
LINE 4: ..._part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (0);
                                                             ^
DETAIL:  Specified lower bound (1) is greater than or equal to upper bound (0).


-----------
QUERY:

-- note that the range /* REPLACED */ ''[1, 1)/* REPLACED */ '' has no elements
CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (1);
RESULT:
	ERROR - empty range bound specified for partition "fail_part"
LINE 3: ..._part PARTITION OF range_parted2 FOR VALUES FROM (1) TO (1);
                                                             ^
DETAIL:  Specified lower bound (1) is greater than or equal to upper bound (1).


-----------
QUERY:


CREATE TABLE part0 PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (1);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (minvalue) TO (2);
RESULT:
	ERROR - partition "fail_part" would overlap partition "part0"
LINE 2: ..._part PARTITION OF range_parted2 FOR VALUES FROM (minvalue) ...
                                                             ^


-----------
QUERY:

CREATE TABLE part1 PARTITION OF range_parted2 FOR VALUES FROM (1) TO (10);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (-1) TO (1);
RESULT:
	ERROR - partition "fail_part" would overlap partition "part0"
LINE 2: ..._part PARTITION OF range_parted2 FOR VALUES FROM (-1) TO (1)...
                                                             ^


-----------
QUERY:

CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (9) TO (maxvalue);
RESULT:
	ERROR - partition "fail_part" would overlap partition "part1"
LINE 2: ..._part PARTITION OF range_parted2 FOR VALUES FROM (9) TO (max...
                                                             ^


-----------
QUERY:

CREATE TABLE part2 PARTITION OF range_parted2 FOR VALUES FROM (20) TO (30);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part3 PARTITION OF range_parted2 FOR VALUES FROM (30) TO (40);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (30);
RESULT:
	ERROR - partition "fail_part" would overlap partition "part2"
LINE 2: ...art PARTITION OF range_parted2 FOR VALUES FROM (10) TO (30);
                                                                   ^


-----------
QUERY:

CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (10) TO (50);
RESULT:
	ERROR - partition "fail_part" would overlap partition "part2"
LINE 2: ...art PARTITION OF range_parted2 FOR VALUES FROM (10) TO (50);
                                                                   ^


-----------
QUERY:


-- Create a default partition for range partitioned table
CREATE TABLE range2_default PARTITION OF range_parted2 DEFAULT;
RESULT:
	[]

-----------
QUERY:


-- More than one default partition is not allowed, so this should give error
CREATE TABLE fail_default_part PARTITION OF range_parted2 DEFAULT;
RESULT:
	ERROR - partition "fail_default_part" conflicts with existing default partition "range2_default"
LINE 4: ... TABLE fail_default_part PARTITION OF range_parted2 DEFAULT;
                                                               ^


-----------
QUERY:


-- Check if the range for default partitions overlap
INSERT INTO range_parted2 VALUES (85);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail_part PARTITION OF range_parted2 FOR VALUES FROM (80) TO (90);
RESULT:
	ERROR - updated partition constraint for default partition "range2_default" would be violated by some row


-----------
QUERY:

CREATE TABLE part4 PARTITION OF range_parted2 FOR VALUES FROM (90) TO (100);
RESULT:
	[]

-----------
QUERY:


-- now check for multi-column range partition key
CREATE TABLE range_parted3 (
	a int,
	b int
) PARTITION BY RANGE (a, (b+1));
RESULT:
	[]

-----------
QUERY:


CREATE TABLE part00 PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, maxvalue);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (0, minvalue) TO (0, 1);
RESULT:
	ERROR - partition "fail_part" would overlap partition "part00"
LINE 2: ..._part PARTITION OF range_parted3 FOR VALUES FROM (0, minvalu...
                                                             ^


-----------
QUERY:


CREATE TABLE part10 PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, 1);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part11 PARTITION OF range_parted3 FOR VALUES FROM (1, 1) TO (1, 10);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE part12 PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, maxvalue);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1, 20);
RESULT:
	ERROR - partition "fail_part" would overlap partition "part12"
LINE 2: ...rt PARTITION OF range_parted3 FOR VALUES FROM (1, 10) TO (1,...
                                                             ^


-----------
QUERY:

CREATE TABLE range3_default PARTITION OF range_parted3 DEFAULT;
RESULT:
	[]

-----------
QUERY:


-- cannot create a partition that says column b is allowed to range
-- from -infinity to +infinity, while there exist partitions that have
-- more specific ranges
CREATE TABLE fail_part PARTITION OF range_parted3 FOR VALUES FROM (1, minvalue) TO (1, maxvalue);
RESULT:
	ERROR - partition "fail_part" would overlap partition "part10"
LINE 6: ..._part PARTITION OF range_parted3 FOR VALUES FROM (1, minvalu...
                                                             ^


-----------
QUERY:


-- check for partition bound overlap and other invalid specifications for the hash partition
CREATE TABLE hash_parted2 (
	a varchar
) PARTITION BY HASH (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE h2part_1 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 4, REMAINDER 2);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE h2part_2 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 0);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE h2part_3 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 4);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE h2part_4 PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 5);
RESULT:
	[]

-----------
QUERY:

-- overlap with part_4
CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 2, REMAINDER 1);
RESULT:
	ERROR - partition "fail_part" would overlap partition "h2part_4"
LINE 3: ...LE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODU...
                                                             ^


-----------
QUERY:

-- modulus must be greater than zero
CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 0, REMAINDER 1);
RESULT:
	ERROR - modulus for hash partition must be an integer value greater than zero


-----------
QUERY:

-- remainder must be greater than or equal to zero and less than modulus
CREATE TABLE fail_part PARTITION OF hash_parted2 FOR VALUES WITH (MODULUS 8, REMAINDER 8);
RESULT:
	ERROR - remainder for hash partition must be less than modulus


-----------
QUERY:


-- check schema propagation from parent

CREATE TABLE parted (
	a text,
	b int NOT NULL DEFAULT 0,
	CONSTRAINT check_a CHECK (length(a) > 0)
) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:


CREATE TABLE part_a PARTITION OF parted FOR VALUES IN ('a');
RESULT:
	[]

-----------
QUERY:


-- only inherited attributes (never local ones)
SELECT attname, attislocal, attinhcount FROM pg_attribute
  WHERE attrelid = 'part_a'::regclass and attnum > 0
  ORDER BY attnum;
RESULT:
	[('a', False, 1), ('b', False, 1)]

-----------
QUERY:


-- able to specify column default, column constraint, and table constraint

-- first check the /* REPLACED */ ''column specified more than once/* REPLACED */ '' error
CREATE TABLE part_b PARTITION OF parted (
	b NOT NULL,
	b DEFAULT 1,
	b CHECK (b >= 0),
	CONSTRAINT check_a CHECK (length(a) > 0)
) FOR VALUES IN ('b');
RESULT:
	ERROR - column "b" specified more than once


-----------
QUERY:


CREATE TABLE part_b PARTITION OF parted (
	b NOT NULL DEFAULT 1,
	CONSTRAINT check_a CHECK (length(a) > 0),
	CONSTRAINT check_b CHECK (b >= 0)
) FOR VALUES IN ('b');
RESULT:
	[]

-----------
QUERY:

-- conislocal should be false for any merged constraints, true otherwise
SELECT conname, conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass ORDER BY coninhcount DESC, conname;
RESULT:
	[('check_a', False, 1), ('part_b_b_not_null', True, 1), ('check_b', True, 0)]

-----------
QUERY:


-- Once check_b is added to the parent, it should be made non-local for part_b
ALTER TABLE parted ADD CONSTRAINT check_b CHECK (b >= 0);
RESULT:
	[]

-----------
QUERY:

SELECT conname, conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass ORDER BY coninhcount DESC, conname;
RESULT:
	[('check_a', False, 1), ('check_b', False, 1), ('part_b_b_not_null', True, 1)]

-----------
QUERY:


-- Neither check_a nor check_b are droppable from part_b
ALTER TABLE part_b DROP CONSTRAINT check_a;
RESULT:
	ERROR - cannot drop inherited constraint "check_a" of relation "part_b"


-----------
QUERY:

ALTER TABLE part_b DROP CONSTRAINT check_b;
RESULT:
	ERROR - cannot drop inherited constraint "check_b" of relation "part_b"


-----------
QUERY:


-- And dropping it from parted should leave no trace of them on part_b, unlike
-- traditional inheritance where they will be left behind, because they would
-- be local constraints.
ALTER TABLE parted DROP CONSTRAINT check_a, DROP CONSTRAINT check_b;
RESULT:
	[]

-----------
QUERY:

SELECT conname, conislocal, coninhcount FROM pg_constraint WHERE conrelid = 'part_b'::regclass ORDER BY coninhcount DESC, conname;
RESULT:
	[('part_b_b_not_null', True, 1)]

-----------
QUERY:


-- specify PARTITION BY for a partition
CREATE TABLE fail_part_col_not_found PARTITION OF parted FOR VALUES IN ('c') PARTITION BY RANGE (c);
RESULT:
	ERROR - column "c" named in partition key does not exist
LINE 4: ...TITION OF parted FOR VALUES IN ('c') PARTITION BY RANGE (c);
                                                                    ^


-----------
QUERY:

CREATE TABLE part_c PARTITION OF parted (b WITH OPTIONS NOT NULL DEFAULT 0) FOR VALUES IN ('c') PARTITION BY RANGE ((b));
RESULT:
	[]

-----------
QUERY:


-- create a level-2 partition
CREATE TABLE part_c_1_10 PARTITION OF part_c FOR VALUES FROM (1) TO (10);
RESULT:
	[]

-----------
QUERY:


-- check that NOT NULL and default value are inherited correctly
create table parted_notnull_inh_test (a int default 1, b int not null default 0) partition by list (a);
RESULT:
	[]

-----------
QUERY:

create table parted_notnull_inh_test1 partition of parted_notnull_inh_test (a not null, b default 1) for values in (1);
RESULT:
	[]

-----------
QUERY:

insert into parted_notnull_inh_test (b) values (null);
RESULT:
	ERROR - null value in column "b" of relation "parted_notnull_inh_test1" violates not-null constraint
DETAIL:  Failing row contains (1, null).


-----------
QUERY:

-- note that while b/* REPLACED */ ''s default is overridden, a/* REPLACED */ ''s default is preserved
-- \d parted_notnull_inh_test1
drop table parted_notnull_inh_test;
RESULT:
	[]

-----------
QUERY:


-- check that collations are assigned in partition bound expressions
create table parted_boolean_col (a bool, b text) partition by list(a);
RESULT:
	[]

-----------
QUERY:

create table parted_boolean_less partition of parted_boolean_col
  for values in ('foo' < 'bar');
RESULT:
	[]

-----------
QUERY:

create table parted_boolean_greater partition of parted_boolean_col
  for values in ('foo' > 'bar');
RESULT:
	[]

-----------
QUERY:

drop table parted_boolean_col;
RESULT:
	[]

-----------
QUERY:


-- check for a conflicting COLLATE clause
create table parted_collate_must_match (a text collate "C", b text collate "C")
  partition by range (a);
RESULT:
	[]

-----------
QUERY:

-- on the partition key
create table parted_collate_must_match1 partition of parted_collate_must_match
  (a collate "POSIX") for values from ('a') to ('m');
RESULT:
	[]

-----------
QUERY:

-- on another column
create table parted_collate_must_match2 partition of parted_collate_must_match
  (b collate "POSIX") for values from ('m') to ('z');
RESULT:
	[]

-----------
QUERY:

drop table parted_collate_must_match;
RESULT:
	[]

-----------
QUERY:


-- check that non-matching collations for partition bound
-- expressions are coerced to the right collation

create table test_part_coll_posix (a text) partition by range (a collate "POSIX");
RESULT:
	[]

-----------
QUERY:

-- ok, collation is implicitly coerced
create table test_part_coll partition of test_part_coll_posix for values from ('a' collate "C") to ('g');
RESULT:
	[]

-----------
QUERY:

-- ok
create table test_part_coll2 partition of test_part_coll_posix for values from ('g') to ('m');
RESULT:
	[]

-----------
QUERY:

-- ok, collation is implicitly coerced
create table test_part_coll_cast partition of test_part_coll_posix for values from (name 'm' collate "C") to ('s');
RESULT:
	[]

-----------
QUERY:

-- ok /* REPLACED */ , partition collation silently overrides the default collation of type /* REPLACED */ ''name/* REPLACED */ ''
create table test_part_coll_cast2 partition of test_part_coll_posix for values from (name 's') to ('z');
RESULT:
	[]

-----------
QUERY:


drop table test_part_coll_posix;
RESULT:
	[]

-----------
QUERY:


-- Partition bound in describe output
-- \d+ part_b

-- Both partition bound and partition key in describe output
-- \d+ part_c

-- a level-2 partition/* REPLACED */ ''s constraint will include the parent/* REPLACED */ ''s expressions
-- \d+ part_c_1_10

-- Show partition count in the parent/* REPLACED */ ''s describe output
-- Tempted to include \d+ output listing partitions with bound info but
-- output could vary depending on the order in which partition oids are
-- returned.
-- \d parted
-- \d hash_parted

-- check that we get the expected partition constraints
CREATE TABLE range_parted4 (a int, b int, c int) PARTITION BY RANGE (abs(a), abs(b), c);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE unbounded_range_part PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (MAXVALUE, MAXVALUE, MAXVALUE);
RESULT:
	[]

-----------
QUERY:

-- \d+ unbounded_range_part
DROP TABLE unbounded_range_part;
RESULT:
	[]

-----------
QUERY:

CREATE TABLE range_parted4_1 PARTITION OF range_parted4 FOR VALUES FROM (MINVALUE, MINVALUE, MINVALUE) TO (1, MAXVALUE, MAXVALUE);
RESULT:
	[]

-----------
QUERY:

-- \d+ range_parted4_1
CREATE TABLE range_parted4_2 PARTITION OF range_parted4 FOR VALUES FROM (3, 4, 5) TO (6, 7, MAXVALUE);
RESULT:
	[]

-----------
QUERY:

-- \d+ range_parted4_2
CREATE TABLE range_parted4_3 PARTITION OF range_parted4 FOR VALUES FROM (6, 8, MINVALUE) TO (9, MAXVALUE, MAXVALUE);
RESULT:
	[]

-----------
QUERY:

-- \d+ range_parted4_3
DROP TABLE range_parted4;
RESULT:
	[]

-----------
QUERY:


-- user-defined operator class in partition key
CREATE FUNCTION my_int4_sort(int4,int4) RETURNS int LANGUAGE sql
  AS $$ SELECT CASE WHEN $1 = $2 THEN 0 WHEN $1 > $2 THEN 1 ELSE -1 END; $$;
RESULT:
	[]

-----------
QUERY:

CREATE OPERATOR CLASS test_int4_ops FOR TYPE int4 USING btree AS
  OPERATOR 1 < (int4,int4), OPERATOR 2 <= (int4,int4),
  OPERATOR 3 = (int4,int4), OPERATOR 4 >= (int4,int4),
  OPERATOR 5 > (int4,int4), FUNCTION 1 my_int4_sort(int4,int4);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE partkey_t (a int4) PARTITION BY RANGE (a test_int4_ops);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE partkey_t_1 PARTITION OF partkey_t FOR VALUES FROM (0) TO (1000);
RESULT:
	[]

-----------
QUERY:

INSERT INTO partkey_t VALUES (100);
RESULT:
	[]

-----------
QUERY:

INSERT INTO partkey_t VALUES (200);
RESULT:
	[]

-----------
QUERY:


-- cleanup
DROP TABLE parted, list_parted, range_parted, list_parted2, range_parted2, range_parted3;
RESULT:
	[]

-----------
QUERY:

DROP TABLE partkey_t, hash_parted, hash_parted2;
RESULT:
	[]

-----------
QUERY:

DROP OPERATOR CLASS test_int4_ops USING btree;
RESULT:
	[]

-----------
QUERY:

DROP FUNCTION my_int4_sort(int4,int4);
RESULT:
	[]

-----------
QUERY:


-- comments on partitioned tables columns
CREATE TABLE parted_col_comment (a int, b text) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

COMMENT ON TABLE parted_col_comment IS 'Am partitioned table';
RESULT:
	[]

-----------
QUERY:

COMMENT ON COLUMN parted_col_comment.a IS 'Partition key';
RESULT:
	[]

-----------
QUERY:

SELECT obj_description('parted_col_comment'::regclass);
RESULT:
	[('Am partitioned table',)]

-----------
QUERY:

-- \d+ parted_col_comment
DROP TABLE parted_col_comment;
RESULT:
	[]

-----------
QUERY:


-- specifying storage parameters for partitioned tables is not supported
CREATE TABLE parted_col_comment (a int, b text) PARTITION BY LIST (a) WITH (fillfactor=100);
RESULT:
	ERROR - cannot specify storage parameters for a partitioned table
HINT:  Specify storage parameters for its leaf partitions instead.


-----------
QUERY:


-- list partitioning on array type column
CREATE TABLE arrlp (a int[]) PARTITION BY LIST (a);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE arrlp12 PARTITION OF arrlp FOR VALUES IN ('{1}', '{2}');
RESULT:
	[]

-----------
QUERY:

-- \d+ arrlp12
DROP TABLE arrlp;
RESULT:
	[]

-----------
QUERY:


-- partition on boolean column
create table boolspart (a bool) partition by list (a);
RESULT:
	[]

-----------
QUERY:

create table boolspart_t partition of boolspart for values in (true);
RESULT:
	[]

-----------
QUERY:

create table boolspart_f partition of boolspart for values in (false);
RESULT:
	[]

-----------
QUERY:

-- \d+ boolspart
drop table boolspart;
RESULT:
	[]

-----------
QUERY:


-- partitions mixing temporary and permanent relations
create table perm_parted (a int) partition by list (a);
RESULT:
	[]

-----------
QUERY:

create temporary table temp_parted (a int) partition by list (a);
RESULT:
	[]

-----------
QUERY:

create table perm_part partition of temp_parted default;
RESULT:
	ERROR - cannot create a permanent relation as partition of temporary relation "temp_parted"


-----------
QUERY:
 -- error
create temp table temp_part partition of perm_parted default;
RESULT:
	ERROR - cannot create a temporary relation as partition of permanent relation "perm_parted"


-----------
QUERY:
 -- error
create temp table temp_part partition of temp_parted default;
RESULT:
	[]

-----------
QUERY:
 -- ok
drop table perm_parted cascade;
RESULT:
	[]

-----------
QUERY:

drop table temp_parted cascade;
RESULT:
	[]

-----------
QUERY:


-- check that adding partitions to a table while it is being used is prevented
create table tab_part_create (a int) partition by list (a);
RESULT:
	[]

-----------
QUERY:

create or replace function func_part_create() returns trigger
  language plpgsql as $$
  begin
    execute 'create table tab_part_create_1 partition of tab_part_create for values in (1)';
    return null;
  end $$;
RESULT:
	[]

-----------
QUERY:

create trigger trig_part_create before insert on tab_part_create
  for each statement execute procedure func_part_create();
RESULT:
	[]

-----------
QUERY:

insert into tab_part_create values (1);
RESULT:
	ERROR - cannot CREATE TABLE .. PARTITION OF "tab_part_create" because it is being used by active queries in this session
CONTEXT:  SQL statement "create table tab_part_create_1 partition of tab_part_create for values in (1)"
PL/pgSQL function func_part_create() line 3 at EXECUTE


-----------
QUERY:

drop table tab_part_create;
RESULT:
	[]

-----------
QUERY:

drop function func_part_create();
RESULT:
	[]

-----------
QUERY:


-- test using a volatile expression as partition bound
create table volatile_partbound_test (partkey timestamp) partition by range (partkey);
RESULT:
	[]

-----------
QUERY:

create table volatile_partbound_test1 partition of volatile_partbound_test for values from (minvalue) to (current_timestamp);
RESULT:
	[]

-----------
QUERY:

create table volatile_partbound_test2 partition of volatile_partbound_test for values from (current_timestamp) to (maxvalue);
RESULT:
	[]

-----------
QUERY:

-- this should go into the partition volatile_partbound_test2
insert into volatile_partbound_test values (current_timestamp);
RESULT:
	[]

-----------
QUERY:

select tableoid::regclass from volatile_partbound_test;
RESULT:
	[('volatile_partbound_test2',)]

-----------
QUERY:

drop table volatile_partbound_test;
RESULT:
	[]

-----------
QUERY:


-- test the case where a check constraint on default partition allows
-- to avoid scanning it when adding a new partition
create table defcheck (a int, b int) partition by list (b);
RESULT:
	[]

-----------
QUERY:

create table defcheck_def (a int, c int, b int);
RESULT:
	[]

-----------
QUERY:

alter table defcheck_def drop c;
RESULT:
	[]

-----------
QUERY:

alter table defcheck attach partition defcheck_def default;
RESULT:
	[]

-----------
QUERY:

alter table defcheck_def add check (b <= 0 and b is not null);
RESULT:
	[]

-----------
QUERY:

create table defcheck_1 partition of defcheck for values in (1, null);
RESULT:
	[]

-----------
QUERY:


-- test that complex default partition constraints are enforced correctly
insert into defcheck_def values (0, 0);
RESULT:
	[]

-----------
QUERY:

create table defcheck_0 partition of defcheck for values in (0);
RESULT:
	ERROR - updated partition constraint for default partition "defcheck_def" would be violated by some row


-----------
QUERY:

drop table defcheck;
RESULT:
	[]

-----------
QUERY:


-- tests of column drop with partition tables and indexes using
-- predicates and expressions.
create table part_column_drop (
  useless_1 int,
  id int,
  useless_2 int,
  d int,
  b int,
  useless_3 int
) partition by range (id);
RESULT:
	[]

-----------
QUERY:

alter table part_column_drop drop column useless_1;
RESULT:
	[]

-----------
QUERY:

alter table part_column_drop drop column useless_2;
RESULT:
	[]

-----------
QUERY:

alter table part_column_drop drop column useless_3;
RESULT:
	[]

-----------
QUERY:

create index part_column_drop_b_pred on part_column_drop(b) where b = 1;
RESULT:
	[]

-----------
QUERY:

create index part_column_drop_b_expr on part_column_drop((b = 1));
RESULT:
	[]

-----------
QUERY:

create index part_column_drop_d_pred on part_column_drop(d) where d = 2;
RESULT:
	[]

-----------
QUERY:

create index part_column_drop_d_expr on part_column_drop((d = 2));
RESULT:
	[]

-----------
QUERY:

create table part_column_drop_1_10 partition of
  part_column_drop for values from (1) to (10);
RESULT:
	[]

-----------
QUERY:

-- \d part_column_drop
-- \d part_column_drop_1_10
drop table part_column_drop;
RESULT:
	[]
