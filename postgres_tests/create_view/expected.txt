
-----------
QUERY:
--
-- CREATE_VIEW
-- Virtual class definitions
--	(this also tests the query rewrite system)
--

-- directory paths and dlsuffix are passed to us in environment variables
-- \getenv abs_srcdir PG_ABS_SRCDIR
-- \getenv libdir PG_LIBDIR
-- \getenv dlsuffix PG_DLSUFFIX

-- \set regresslib /* REPLACED */ PG_LIBDIR '/regress' /* REPLACED */ PG_DLSUFFIX

CREATE FUNCTION interpt_pp(path, path)
    RETURNS point
    AS /* REPLACED */ PG_LIBDIR '/regress' PG_DLSUFFIX
    LANGUAGE C STRICT;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE real_city (
	pop			int4,
	cname		text,
	outline 	path
);
RESULT:
	[]

-----------
QUERY:


-- \set filename /* REPLACED */ PG_ABS_SRCDIR '/data/real_city.data'
COPY real_city FROM /* REPLACED */ PG_ABS_SRCDIR '/data/real_city.data';
RESULT:
	[]

-----------
QUERY:

ANALYZE real_city;
RESULT:
	[]

-----------
QUERY:


SELECT *
   INTO TABLE ramp
   FROM ONLY road
   WHERE name ~ '.*Ramp';
RESULT:
	[]

-----------
QUERY:


CREATE VIEW street AS
   SELECT r.name, r.thepath, c.cname AS cname
   FROM ONLY road r, real_city c
   WHERE c.outline ?# r.thepath;
RESULT:
	[]

-----------
QUERY:


CREATE VIEW iexit AS
   SELECT ih.name, ih.thepath,
	interpt_pp(ih.thepath, r.thepath) AS exit
   FROM ihighway ih, ramp r
   WHERE ih.thepath ?# r.thepath;
RESULT:
	[]

-----------
QUERY:


CREATE VIEW toyemp AS
   SELECT name, age, location, 12*salary AS annualsal
   FROM emp;
RESULT:
	[]

-----------
QUERY:


-- Test comments
COMMENT ON VIEW noview IS 'no view';
RESULT:
	ERROR - relation "noview" does not exist


-----------
QUERY:

COMMENT ON VIEW toyemp IS 'is a view';
RESULT:
	[]

-----------
QUERY:

COMMENT ON VIEW toyemp IS NULL;
RESULT:
	[]

-----------
QUERY:


-- These views are left around mainly to exercise special cases in pg_dump.

CREATE TABLE view_base_table (key int PRIMARY KEY, data varchar(20));
RESULT:
	[]

-----------
QUERY:


CREATE VIEW key_dependent_view AS
   SELECT * FROM view_base_table GROUP BY key;
RESULT:
	[]

-----------
QUERY:


ALTER TABLE view_base_table DROP CONSTRAINT view_base_table_pkey;
RESULT:
	ERROR - cannot drop constraint view_base_table_pkey on table view_base_table because other objects depend on it
DETAIL:  view key_dependent_view depends on constraint view_base_table_pkey on table view_base_table
HINT:  Use DROP ... CASCADE to drop the dependent objects too.


-----------
QUERY:
  -- fails

CREATE VIEW key_dependent_view_no_cols AS
   SELECT FROM view_base_table GROUP BY key HAVING length(data) > 0;
RESULT:
	[]

-----------
QUERY:


--
-- CREATE OR REPLACE VIEW
--

CREATE TABLE viewtest_tbl (a int, b int, c numeric(10,1), d text COLLATE "C");
RESULT:
	[]

-----------
QUERY:


COPY viewtest_tbl FROM stdin;
RESULT:
	ERROR - can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

5	10	1.1	xy
10	15	2.2	xyz
15	20	3.3	xyzz
20	25	4.4	xyzzy
-- \.

CREATE OR REPLACE VIEW viewtest AS
	SELECT * FROM viewtest_tbl;
RESULT:
	ERROR - syntax error at or near "5"
LINE 2: 5 10 1.1 xy
        ^


-----------
QUERY:


CREATE OR REPLACE VIEW viewtest AS
	SELECT * FROM viewtest_tbl WHERE a > 10;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM viewtest;
RESULT:
	[]

-----------
QUERY:


CREATE OR REPLACE VIEW viewtest AS
	SELECT a, b, c, d FROM viewtest_tbl WHERE a > 5 ORDER BY b DESC;
RESULT:
	[]

-----------
QUERY:


SELECT * FROM viewtest;
RESULT:
	[]

-----------
QUERY:


-- should fail
CREATE OR REPLACE VIEW viewtest AS
	SELECT a FROM viewtest_tbl WHERE a <> 20;
RESULT:
	ERROR - cannot drop columns from view


-----------
QUERY:


-- should fail
CREATE OR REPLACE VIEW viewtest AS
	SELECT 1, * FROM viewtest_tbl;
RESULT:
	ERROR - cannot change name of view column "a" to "?column?"
HINT:  Use ALTER VIEW ... RENAME COLUMN ... to change name of view column instead.


-----------
QUERY:


-- should fail
CREATE OR REPLACE VIEW viewtest AS
	SELECT a, b::numeric, c, d FROM viewtest_tbl;
RESULT:
	ERROR - cannot change data type of view column "b" from integer to numeric


-----------
QUERY:


-- should fail
CREATE OR REPLACE VIEW viewtest AS
	SELECT a, b, c::numeric(10,2), d FROM viewtest_tbl;
RESULT:
	ERROR - cannot change data type of view column "c" from numeric(10,1) to numeric(10,2)


-----------
QUERY:


-- should fail
CREATE OR REPLACE VIEW viewtest AS
	SELECT a, b, c, d COLLATE "POSIX" FROM viewtest_tbl;
RESULT:
	ERROR - cannot change collation of view column "d" from "C" to "POSIX"


-----------
QUERY:


-- should work
CREATE OR REPLACE VIEW viewtest AS
	SELECT a, b, c, d, 0 AS e FROM viewtest_tbl;
RESULT:
	[]

-----------
QUERY:


DROP VIEW viewtest;
RESULT:
	[]

-----------
QUERY:

DROP TABLE viewtest_tbl;
RESULT:
	[]

-----------
QUERY:


-- tests for temporary views

CREATE SCHEMA temp_view_test
    CREATE TABLE base_table (a int, id int)
    CREATE TABLE base_table2 (a int, id int);
RESULT:
	[]

-----------
QUERY:


SET search_path TO temp_view_test, public;
RESULT:
	[]

-----------
QUERY:


CREATE TEMPORARY TABLE temp_table (a int, id int);
RESULT:
	[]

-----------
QUERY:


-- should be created in temp_view_test schema
CREATE VIEW v1 AS SELECT * FROM base_table;
RESULT:
	[]

-----------
QUERY:

-- should be created in temp object schema
CREATE VIEW v1_temp AS SELECT * FROM temp_table;
RESULT:
	[]

-----------
QUERY:

-- should be created in temp object schema
CREATE TEMP VIEW v2_temp AS SELECT * FROM base_table;
RESULT:
	[]

-----------
QUERY:

-- should be created in temp_views schema
CREATE VIEW temp_view_test.v2 AS SELECT * FROM base_table;
RESULT:
	[]

-----------
QUERY:

-- should fail
CREATE VIEW temp_view_test.v3_temp AS SELECT * FROM temp_table;
RESULT:
	ERROR - cannot create temporary relation in non-temporary schema


-----------
QUERY:

-- should fail
CREATE SCHEMA test_view_schema
    CREATE TEMP VIEW testview AS SELECT 1;
RESULT:
	ERROR - cannot create temporary relation in non-temporary schema


-----------
QUERY:


-- joins: if any of the join relations are temporary, the view
-- should also be temporary

-- should be non-temp
CREATE VIEW v3 AS
    SELECT t1.a AS t1_a, t2.a AS t2_a
    FROM base_table t1, base_table2 t2
    WHERE t1.id = t2.id;
RESULT:
	[]

-----------
QUERY:

-- should be temp (one join rel is temp)
CREATE VIEW v4_temp AS
    SELECT t1.a AS t1_a, t2.a AS t2_a
    FROM base_table t1, temp_table t2
    WHERE t1.id = t2.id;
RESULT:
	[]

-----------
QUERY:

-- should be temp
CREATE VIEW v5_temp AS
    SELECT t1.a AS t1_a, t2.a AS t2_a, t3.a AS t3_a
    FROM base_table t1, base_table2 t2, temp_table t3
    WHERE t1.id = t2.id and t2.id = t3.id;
RESULT:
	[]

-----------
QUERY:


-- subqueries
CREATE VIEW v4 AS SELECT * FROM base_table WHERE id IN (SELECT id FROM base_table2);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v5 AS SELECT t1.id, t2.a FROM base_table t1, (SELECT * FROM base_table2) t2;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v6 AS SELECT * FROM base_table WHERE EXISTS (SELECT 1 FROM base_table2);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v7 AS SELECT * FROM base_table WHERE NOT EXISTS (SELECT 1 FROM base_table2);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v8 AS SELECT * FROM base_table WHERE EXISTS (SELECT 1);
RESULT:
	[]

-----------
QUERY:


CREATE VIEW v6_temp AS SELECT * FROM base_table WHERE id IN (SELECT id FROM temp_table);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v7_temp AS SELECT t1.id, t2.a FROM base_table t1, (SELECT * FROM temp_table) t2;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v8_temp AS SELECT * FROM base_table WHERE EXISTS (SELECT 1 FROM temp_table);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v9_temp AS SELECT * FROM base_table WHERE NOT EXISTS (SELECT 1 FROM temp_table);
RESULT:
	[]

-----------
QUERY:


-- a view should also be temporary if it references a temporary view
CREATE VIEW v10_temp AS SELECT * FROM v7_temp;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v11_temp AS SELECT t1.id, t2.a FROM base_table t1, v10_temp t2;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v12_temp AS SELECT true FROM v11_temp;
RESULT:
	[]

-----------
QUERY:


-- a view should also be temporary if it references a temporary sequence
CREATE SEQUENCE seq1;
RESULT:
	[]

-----------
QUERY:

CREATE TEMPORARY SEQUENCE seq1_temp;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v9 AS SELECT seq1.is_called FROM seq1;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW v13_temp AS SELECT seq1_temp.is_called FROM seq1_temp;
RESULT:
	[]

-----------
QUERY:


SELECT relname FROM pg_class
    WHERE relname LIKE 'v_'
    AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'temp_view_test')
    ORDER BY relname;
RESULT:
	[('v1',), ('v2',), ('v3',), ('v4',), ('v5',), ('v6',), ('v7',), ('v8',), ('v9',)]

-----------
QUERY:

SELECT relname FROM pg_class
    WHERE relname LIKE 'v%'
    AND relnamespace IN (SELECT oid FROM pg_namespace WHERE nspname LIKE 'pg_temp%')
    ORDER BY relname;
RESULT:
	[('v10_temp',), ('v11_temp',), ('v12_temp',), ('v13_temp',), ('v1_temp',), ('v2_temp',), ('v4_temp',), ('v5_temp',), ('v6_temp',), ('v7_temp',), ('v8_temp',), ('v9_temp',)]

-----------
QUERY:


CREATE SCHEMA testviewschm2;
RESULT:
	[]

-----------
QUERY:

SET search_path TO testviewschm2, public;
RESULT:
	[]

-----------
QUERY:


CREATE TABLE t1 (num int, name text);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE t2 (num2 int, value text);
RESULT:
	[]

-----------
QUERY:

CREATE TEMP TABLE tt (num2 int, value text);
RESULT:
	[]

-----------
QUERY:


CREATE VIEW nontemp1 AS SELECT * FROM t1 CROSS JOIN t2;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW temporal1 AS SELECT * FROM t1 CROSS JOIN tt;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW nontemp2 AS SELECT * FROM t1 INNER JOIN t2 ON t1.num = t2.num2;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW temporal2 AS SELECT * FROM t1 INNER JOIN tt ON t1.num = tt.num2;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW nontemp3 AS SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num2;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW temporal3 AS SELECT * FROM t1 LEFT JOIN tt ON t1.num = tt.num2;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW nontemp4 AS SELECT * FROM t1 LEFT JOIN t2 ON t1.num = t2.num2 AND t2.value = 'xxx';
RESULT:
	[]

-----------
QUERY:

CREATE VIEW temporal4 AS SELECT * FROM t1 LEFT JOIN tt ON t1.num = tt.num2 AND tt.value = 'xxx';
RESULT:
	[]

-----------
QUERY:


SELECT relname FROM pg_class
    WHERE relname LIKE 'nontemp%'
    AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'testviewschm2')
    ORDER BY relname;
RESULT:
	[('nontemp1',), ('nontemp2',), ('nontemp3',), ('nontemp4',)]

-----------
QUERY:

SELECT relname FROM pg_class
    WHERE relname LIKE 'temporal%'
    AND relnamespace IN (SELECT oid FROM pg_namespace WHERE nspname LIKE 'pg_temp%')
    ORDER BY relname;
RESULT:
	[('temporal1',), ('temporal2',), ('temporal3',), ('temporal4',)]

-----------
QUERY:


CREATE TABLE tbl1 ( a int, b int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE tbl2 (c int, d int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE tbl3 (e int, f int);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE tbl4 (g int, h int);
RESULT:
	[]

-----------
QUERY:

CREATE TEMP TABLE tmptbl (i int, j int);
RESULT:
	[]

-----------
QUERY:


--Should be in testviewschm2
CREATE   VIEW  pubview AS SELECT * FROM tbl1 WHERE tbl1.a
BETWEEN (SELECT d FROM tbl2 WHERE c = 1) AND (SELECT e FROM tbl3 WHERE f = 2)
AND EXISTS (SELECT g FROM tbl4 LEFT JOIN tbl3 ON tbl4.h = tbl3.f);
RESULT:
	[]

-----------
QUERY:


SELECT count(*) FROM pg_class where relname = 'pubview'
AND relnamespace IN (SELECT OID FROM pg_namespace WHERE nspname = 'testviewschm2');
RESULT:
	[(1,)]

-----------
QUERY:


--Should be in temp object schema
CREATE   VIEW  mytempview AS SELECT * FROM tbl1 WHERE tbl1.a
BETWEEN (SELECT d FROM tbl2 WHERE c = 1) AND (SELECT e FROM tbl3 WHERE f = 2)
AND EXISTS (SELECT g FROM tbl4 LEFT JOIN tbl3 ON tbl4.h = tbl3.f)
AND NOT EXISTS (SELECT g FROM tbl4 LEFT JOIN tmptbl ON tbl4.h = tmptbl.j);
RESULT:
	[]

-----------
QUERY:


SELECT count(*) FROM pg_class where relname LIKE 'mytempview'
And relnamespace IN (SELECT OID FROM pg_namespace WHERE nspname LIKE 'pg_temp%');
RESULT:
	[(1,)]

-----------
QUERY:


--
-- CREATE VIEW and WITH(...) clause
--
CREATE VIEW mysecview1
       AS SELECT * FROM tbl1 WHERE a = 0;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW mysecview2 WITH (security_barrier=true)
       AS SELECT * FROM tbl1 WHERE a > 0;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW mysecview3 WITH (security_barrier=false)
       AS SELECT * FROM tbl1 WHERE a < 0;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW mysecview4 WITH (security_barrier)
       AS SELECT * FROM tbl1 WHERE a <> 0;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW mysecview5 WITH (security_barrier=100)	-- Error
       AS SELECT * FROM tbl1 WHERE a > 100;
RESULT:
	ERROR - invalid value for boolean option "security_barrier": 100


-----------
QUERY:

CREATE VIEW mysecview6 WITH (invalid_option)		-- Error
       AS SELECT * FROM tbl1 WHERE a < 100;
RESULT:
	ERROR - unrecognized parameter "invalid_option"


-----------
QUERY:

CREATE VIEW mysecview7 WITH (security_invoker=true)
       AS SELECT * FROM tbl1 WHERE a = 100;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW mysecview8 WITH (security_invoker=false, security_barrier=true)
       AS SELECT * FROM tbl1 WHERE a > 100;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW mysecview9 WITH (security_invoker)
       AS SELECT * FROM tbl1 WHERE a < 100;
RESULT:
	[]

-----------
QUERY:

CREATE VIEW mysecview10 WITH (security_invoker=100)	-- Error
       AS SELECT * FROM tbl1 WHERE a <> 100;
RESULT:
	ERROR - invalid value for boolean option "security_invoker": 100


-----------
QUERY:

SELECT relname, relkind, reloptions FROM pg_class
       WHERE oid in ('mysecview1'::regclass, 'mysecview2'::regclass,
                     'mysecview3'::regclass, 'mysecview4'::regclass,
                     'mysecview7'::regclass, 'mysecview8'::regclass,
                     'mysecview9'::regclass)
       ORDER BY relname;
RESULT:
	[('mysecview1', 'v', None), ('mysecview2', 'v', ['security_barrier=true']), ('mysecview3', 'v', ['security_barrier=false']), ('mysecview4', 'v', ['security_barrier=true']), ('mysecview7', 'v', ['security_invoker=true']), ('mysecview8', 'v', ['security_invoker=false', 'security_barrier=true']), ('mysecview9', 'v', ['security_invoker=true'])]

-----------
QUERY:


CREATE OR REPLACE VIEW mysecview1
       AS SELECT * FROM tbl1 WHERE a = 256;
RESULT:
	[]

-----------
QUERY:

CREATE OR REPLACE VIEW mysecview2
       AS SELECT * FROM tbl1 WHERE a > 256;
RESULT:
	[]

-----------
QUERY:

CREATE OR REPLACE VIEW mysecview3 WITH (security_barrier=true)
       AS SELECT * FROM tbl1 WHERE a < 256;
RESULT:
	[]

-----------
QUERY:

CREATE OR REPLACE VIEW mysecview4 WITH (security_barrier=false)
       AS SELECT * FROM tbl1 WHERE a <> 256;
RESULT:
	[]

-----------
QUERY:

CREATE OR REPLACE VIEW mysecview7
       AS SELECT * FROM tbl1 WHERE a > 256;
RESULT:
	[]

-----------
QUERY:

CREATE OR REPLACE VIEW mysecview8 WITH (security_invoker=true)
       AS SELECT * FROM tbl1 WHERE a < 256;
RESULT:
	[]

-----------
QUERY:

CREATE OR REPLACE VIEW mysecview9 WITH (security_invoker=false, security_barrier=true)
       AS SELECT * FROM tbl1 WHERE a <> 256;
RESULT:
	[]

-----------
QUERY:

SELECT relname, relkind, reloptions FROM pg_class
       WHERE oid in ('mysecview1'::regclass, 'mysecview2'::regclass,
                     'mysecview3'::regclass, 'mysecview4'::regclass,
                     'mysecview7'::regclass, 'mysecview8'::regclass,
                     'mysecview9'::regclass)
       ORDER BY relname;
RESULT:
	[('mysecview1', 'v', None), ('mysecview2', 'v', None), ('mysecview3', 'v', ['security_barrier=true']), ('mysecview4', 'v', ['security_barrier=false']), ('mysecview7', 'v', None), ('mysecview8', 'v', ['security_invoker=true']), ('mysecview9', 'v', ['security_invoker=false', 'security_barrier=true'])]

-----------
QUERY:


-- Check that unknown literals are converted to /* REPLACED */ ''text/* REPLACED */ '' in CREATE VIEW,
-- so that we don/* REPLACED */ ''t end up with unknown-type columns.

CREATE VIEW unspecified_types AS
  SELECT 42 as i, 42.5 as num, 'foo' as u, 'foo'::unknown as u2, null as n;
RESULT:
	[]

-----------
QUERY:

-- \d+ unspecified_types
SELECT * FROM unspecified_types;
RESULT:
	[(42, Decimal('42.5'), 'foo', 'foo', None)]

-----------
QUERY:


-- This test checks that proper typmods are assigned in a multi-row VALUES

CREATE VIEW tt1 AS
  SELECT * FROM (
    VALUES
       ('abc'::varchar(3), '0123456789', 42, 'abcd'::varchar(4)),
       ('0123456789', 'abc'::varchar(3), 42.12, 'abc'::varchar(4))
  ) vv(a,b,c,d);
RESULT:
	[]

-----------
QUERY:

-- \d+ tt1
SELECT * FROM tt1;
RESULT:
	[('abc', '0123456789', Decimal('42'), 'abcd'), ('0123456789', 'abc', Decimal('42.12'), 'abc')]

-----------
QUERY:

SELECT a::varchar(3) FROM tt1;
RESULT:
	[('abc',), ('012',)]

-----------
QUERY:

DROP VIEW tt1;
RESULT:
	[]

-----------
QUERY:


-- Test view decompilation in the face of relation renaming conflicts

CREATE TABLE tt1 (f1 int, f2 int, f3 text);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE tx1 (x1 int, x2 int, x3 text);
RESULT:
	[]

-----------
QUERY:

CREATE TABLE temp_view_test.tt1 (y1 int, f2 int, f3 text);
RESULT:
	[]

-----------
QUERY:


CREATE VIEW aliased_view_1 AS
  select * from tt1
    where exists (select 1 from tx1 where tt1.f1 = tx1.x1);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW aliased_view_2 AS
  select * from tt1 a1
    where exists (select 1 from tx1 where a1.f1 = tx1.x1);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW aliased_view_3 AS
  select * from tt1
    where exists (select 1 from tx1 a2 where tt1.f1 = a2.x1);
RESULT:
	[]

-----------
QUERY:

CREATE VIEW aliased_view_4 AS
  select * from temp_view_test.tt1
    where exists (select 1 from tt1 where temp_view_test.tt1.y1 = tt1.f1);
RESULT:
	[]

-----------
QUERY:


-- \d+ aliased_view_1
-- \d+ aliased_view_2
-- \d+ aliased_view_3
-- \d+ aliased_view_4

ALTER TABLE tx1 RENAME TO a1;
RESULT:
	[]

-----------
QUERY:


-- \d+ aliased_view_1
-- \d+ aliased_view_2
-- \d+ aliased_view_3
-- \d+ aliased_view_4

ALTER TABLE tt1 RENAME TO a2;
RESULT:
	[]

-----------
QUERY:


-- \d+ aliased_view_1
-- \d+ aliased_view_2
-- \d+ aliased_view_3
-- \d+ aliased_view_4

ALTER TABLE a1 RENAME TO tt1;
RESULT:
	[]

-----------
QUERY:


-- \d+ aliased_view_1
-- \d+ aliased_view_2
-- \d+ aliased_view_3
-- \d+ aliased_view_4

ALTER TABLE a2 RENAME TO tx1;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE tx1 SET SCHEMA temp_view_test;
RESULT:
	[]

-----------
QUERY:


-- \d+ aliased_view_1
-- \d+ aliased_view_2
-- \d+ aliased_view_3
-- \d+ aliased_view_4

ALTER TABLE temp_view_test.tt1 RENAME TO tmp1;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE temp_view_test.tmp1 SET SCHEMA testviewschm2;
RESULT:
	[]

-----------
QUERY:

ALTER TABLE tmp1 RENAME TO tx1;
RESULT:
	[]

-----------
QUERY:


-- \d+ aliased_view_1
-- \d+ aliased_view_2
-- \d+ aliased_view_3
-- \d+ aliased_view_4

-- Test aliasing of joins

create view view_of_joins as
select * from
  (select * from (tbl1 cross join tbl2) same) ss,
  (tbl3 cross join tbl4) same;
RESULT:
	[]

-----------
QUERY:


-- \d+ view_of_joins

create table tbl1a (a int, c int);
RESULT:
	[]

-----------
QUERY:

create view view_of_joins_2a as select * from tbl1 join tbl1a using (a);
RESULT:
	[]

-----------
QUERY:

create view view_of_joins_2b as select * from tbl1 join tbl1a using (a) as x;
RESULT:
	[]

-----------
QUERY:

create view view_of_joins_2c as select * from (tbl1 join tbl1a using (a)) as y;
RESULT:
	[]

-----------
QUERY:

create view view_of_joins_2d as select * from (tbl1 join tbl1a using (a) as x) as y;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('view_of_joins_2a', true);
RESULT:
	[(' SELECT tbl1.a,\n    tbl1.b,\n    tbl1a.c\n   FROM tbl1\n     JOIN tbl1a USING (a);',)]

-----------
QUERY:

select pg_get_viewdef('view_of_joins_2b', true);
RESULT:
	[(' SELECT tbl1.a,\n    tbl1.b,\n    tbl1a.c\n   FROM tbl1\n     JOIN tbl1a USING (a) AS x;',)]

-----------
QUERY:

select pg_get_viewdef('view_of_joins_2c', true);
RESULT:
	[(' SELECT y.a,\n    y.b,\n    y.c\n   FROM (tbl1\n     JOIN tbl1a USING (a)) y;',)]

-----------
QUERY:

select pg_get_viewdef('view_of_joins_2d', true);
RESULT:
	[(' SELECT y.a,\n    y.b,\n    y.c\n   FROM (tbl1\n     JOIN tbl1a USING (a) AS x) y;',)]

-----------
QUERY:


-- Test view decompilation in the face of column addition/deletion/renaming

create table tt2 (a int, b int, c int);
RESULT:
	[]

-----------
QUERY:

create table tt3 (ax int8, b int2, c numeric);
RESULT:
	[]

-----------
QUERY:

create table tt4 (ay int, b int, q int);
RESULT:
	[]

-----------
QUERY:


create view v1 as select * from tt2 natural join tt3;
RESULT:
	[]

-----------
QUERY:

create view v1a as select * from (tt2 natural join tt3) j;
RESULT:
	[]

-----------
QUERY:

create view v2 as select * from tt2 join tt3 using (b,c) join tt4 using (b);
RESULT:
	[]

-----------
QUERY:

create view v2a as select * from (tt2 join tt3 using (b,c) join tt4 using (b)) j;
RESULT:
	[]

-----------
QUERY:

create view v3 as select * from tt2 join tt3 using (b,c) full join tt4 using (b);
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('v1', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a,\n    tt3.ax\n   FROM tt2\n     JOIN tt3 USING (b, c);',)]

-----------
QUERY:

select pg_get_viewdef('v1a', true);
RESULT:
	[(' SELECT j.b,\n    j.c,\n    j.a,\n    j.ax\n   FROM (tt2\n     JOIN tt3 USING (b, c)) j;',)]

-----------
QUERY:

select pg_get_viewdef('v2', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a,\n    tt3.ax,\n    tt4.ay,\n    tt4.q\n   FROM tt2\n     JOIN tt3 USING (b, c)\n     JOIN tt4 USING (b);',)]

-----------
QUERY:

select pg_get_viewdef('v2a', true);
RESULT:
	[(' SELECT j.b,\n    j.c,\n    j.a,\n    j.ax,\n    j.ay,\n    j.q\n   FROM (tt2\n     JOIN tt3 USING (b, c)\n     JOIN tt4 USING (b)) j;',)]

-----------
QUERY:

select pg_get_viewdef('v3', true);
RESULT:
	[(' SELECT b,\n    tt3.c,\n    tt2.a,\n    tt3.ax,\n    tt4.ay,\n    tt4.q\n   FROM tt2\n     JOIN tt3 USING (b, c)\n     FULL JOIN tt4 USING (b);',)]

-----------
QUERY:


alter table tt2 add column d int;
RESULT:
	[]

-----------
QUERY:

alter table tt2 add column e int;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('v1', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a,\n    tt3.ax\n   FROM tt2\n     JOIN tt3 USING (b, c);',)]

-----------
QUERY:

select pg_get_viewdef('v1a', true);
RESULT:
	[(' SELECT j.b,\n    j.c,\n    j.a,\n    j.ax\n   FROM (tt2\n     JOIN tt3 USING (b, c)) j;',)]

-----------
QUERY:

select pg_get_viewdef('v2', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a,\n    tt3.ax,\n    tt4.ay,\n    tt4.q\n   FROM tt2\n     JOIN tt3 USING (b, c)\n     JOIN tt4 USING (b);',)]

-----------
QUERY:

select pg_get_viewdef('v2a', true);
RESULT:
	[(' SELECT j.b,\n    j.c,\n    j.a,\n    j.ax,\n    j.ay,\n    j.q\n   FROM (tt2\n     JOIN tt3 USING (b, c)\n     JOIN tt4 USING (b)) j;',)]

-----------
QUERY:

select pg_get_viewdef('v3', true);
RESULT:
	[(' SELECT b,\n    tt3.c,\n    tt2.a,\n    tt3.ax,\n    tt4.ay,\n    tt4.q\n   FROM tt2\n     JOIN tt3 USING (b, c)\n     FULL JOIN tt4 USING (b);',)]

-----------
QUERY:


alter table tt3 rename c to d;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('v1', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a,\n    tt3.ax\n   FROM tt2\n     JOIN tt3 tt3(ax, b, c) USING (b, c);',)]

-----------
QUERY:

select pg_get_viewdef('v1a', true);
RESULT:
	[(' SELECT j.b,\n    j.c,\n    j.a,\n    j.ax\n   FROM (tt2\n     JOIN tt3 tt3(ax, b, c) USING (b, c)) j;',)]

-----------
QUERY:

select pg_get_viewdef('v2', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a,\n    tt3.ax,\n    tt4.ay,\n    tt4.q\n   FROM tt2\n     JOIN tt3 tt3(ax, b, c) USING (b, c)\n     JOIN tt4 USING (b);',)]

-----------
QUERY:

select pg_get_viewdef('v2a', true);
RESULT:
	[(' SELECT j.b,\n    j.c,\n    j.a,\n    j.ax,\n    j.ay,\n    j.q\n   FROM (tt2\n     JOIN tt3 tt3(ax, b, c) USING (b, c)\n     JOIN tt4 USING (b)) j;',)]

-----------
QUERY:

select pg_get_viewdef('v3', true);
RESULT:
	[(' SELECT b,\n    tt3.c,\n    tt2.a,\n    tt3.ax,\n    tt4.ay,\n    tt4.q\n   FROM tt2\n     JOIN tt3 tt3(ax, b, c) USING (b, c)\n     FULL JOIN tt4 USING (b);',)]

-----------
QUERY:


alter table tt3 add column c int;
RESULT:
	[]

-----------
QUERY:

alter table tt3 add column e int;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('v1', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a,\n    tt3.ax\n   FROM tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c);',)]

-----------
QUERY:

select pg_get_viewdef('v1a', true);
RESULT:
	[(' SELECT j.b,\n    j.c,\n    j.a,\n    j.ax\n   FROM (tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)) j(b, c, a, d, e, ax, c_1, e_1);',)]

-----------
QUERY:

select pg_get_viewdef('v2', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a,\n    tt3.ax,\n    tt4.ay,\n    tt4.q\n   FROM tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)\n     JOIN tt4 USING (b);',)]

-----------
QUERY:

select pg_get_viewdef('v2a', true);
RESULT:
	[(' SELECT j.b,\n    j.c,\n    j.a,\n    j.ax,\n    j.ay,\n    j.q\n   FROM (tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)\n     JOIN tt4 USING (b)) j(b, c, a, d, e, ax, c_1, e_1, ay, q);',)]

-----------
QUERY:

select pg_get_viewdef('v3', true);
RESULT:
	[(' SELECT b,\n    tt3.c,\n    tt2.a,\n    tt3.ax,\n    tt4.ay,\n    tt4.q\n   FROM tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)\n     FULL JOIN tt4 USING (b);',)]

-----------
QUERY:


alter table tt2 drop column d;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('v1', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a,\n    tt3.ax\n   FROM tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c);',)]

-----------
QUERY:

select pg_get_viewdef('v1a', true);
RESULT:
	[(' SELECT j.b,\n    j.c,\n    j.a,\n    j.ax\n   FROM (tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)) j(b, c, a, e, ax, c_1, e_1);',)]

-----------
QUERY:

select pg_get_viewdef('v2', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a,\n    tt3.ax,\n    tt4.ay,\n    tt4.q\n   FROM tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)\n     JOIN tt4 USING (b);',)]

-----------
QUERY:

select pg_get_viewdef('v2a', true);
RESULT:
	[(' SELECT j.b,\n    j.c,\n    j.a,\n    j.ax,\n    j.ay,\n    j.q\n   FROM (tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)\n     JOIN tt4 USING (b)) j(b, c, a, e, ax, c_1, e_1, ay, q);',)]

-----------
QUERY:

select pg_get_viewdef('v3', true);
RESULT:
	[(' SELECT b,\n    tt3.c,\n    tt2.a,\n    tt3.ax,\n    tt4.ay,\n    tt4.q\n   FROM tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c)\n     FULL JOIN tt4 USING (b);',)]

-----------
QUERY:


create table tt5 (a int, b int);
RESULT:
	[]

-----------
QUERY:

create table tt6 (c int, d int);
RESULT:
	[]

-----------
QUERY:

create view vv1 as select * from (tt5 cross join tt6) j(aa,bb,cc,dd);
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('vv1', true);
RESULT:
	[(' SELECT j.aa,\n    j.bb,\n    j.cc,\n    j.dd\n   FROM (tt5\n     CROSS JOIN tt6) j(aa, bb, cc, dd);',)]

-----------
QUERY:

alter table tt5 add column c int;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('vv1', true);
RESULT:
	[(' SELECT j.aa,\n    j.bb,\n    j.cc,\n    j.dd\n   FROM (tt5\n     CROSS JOIN tt6) j(aa, bb, c, cc, dd);',)]

-----------
QUERY:

alter table tt5 add column cc int;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('vv1', true);
RESULT:
	[(' SELECT j.aa,\n    j.bb,\n    j.cc,\n    j.dd\n   FROM (tt5\n     CROSS JOIN tt6) j(aa, bb, c, cc_1, cc, dd);',)]

-----------
QUERY:

alter table tt5 drop column c;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('vv1', true);
RESULT:
	[(' SELECT j.aa,\n    j.bb,\n    j.cc,\n    j.dd\n   FROM (tt5\n     CROSS JOIN tt6) j(aa, bb, cc_1, cc, dd);',)]

-----------
QUERY:


create view v4 as select * from v1;
RESULT:
	[]

-----------
QUERY:

alter view v1 rename column a to x;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('v1', true);
RESULT:
	[(' SELECT tt2.b,\n    tt3.c,\n    tt2.a AS x,\n    tt3.ax\n   FROM tt2\n     JOIN tt3 tt3(ax, b, c, c_1, e) USING (b, c);',)]

-----------
QUERY:

select pg_get_viewdef('v4', true);
RESULT:
	[(' SELECT b,\n    c,\n    x AS a,\n    ax\n   FROM v1;',)]

-----------
QUERY:



-- Unnamed FULL JOIN USING is lots of fun too

create table tt7 (x int, xx int, y int);
RESULT:
	[]

-----------
QUERY:

alter table tt7 drop column xx;
RESULT:
	[]

-----------
QUERY:

create table tt8 (x int, z int);
RESULT:
	[]

-----------
QUERY:


create view vv2 as
select * from (values(1,2,3,4,5)) v(a,b,c,d,e)
union all
select * from tt7 full join tt8 using (x), tt8 tt8x;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('vv2', true);
RESULT:
	[(' SELECT v.a,\n    v.b,\n    v.c,\n    v.d,\n    v.e\n   FROM ( VALUES (1,2,3,4,5)) v(a, b, c, d, e)\nUNION ALL\n SELECT x AS a,\n    tt7.y AS b,\n    tt8.z AS c,\n    tt8x.x_1 AS d,\n    tt8x.z AS e\n   FROM tt7\n     FULL JOIN tt8 USING (x),\n    tt8 tt8x(x_1, z);',)]

-----------
QUERY:


create view vv3 as
select * from (values(1,2,3,4,5,6)) v(a,b,c,x,e,f)
union all
select * from
  tt7 full join tt8 using (x),
  tt7 tt7x full join tt8 tt8x using (x);
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('vv3', true);
RESULT:
	[(' SELECT v.a,\n    v.b,\n    v.c,\n    v.x,\n    v.e,\n    v.f\n   FROM ( VALUES (1,2,3,4,5,6)) v(a, b, c, x, e, f)\nUNION ALL\n SELECT x AS a,\n    tt7.y AS b,\n    tt8.z AS c,\n    x_1 AS x,\n    tt7x.y AS e,\n    tt8x.z AS f\n   FROM tt7\n     FULL JOIN tt8 USING (x),\n    tt7 tt7x(x_1, y)\n     FULL JOIN tt8 tt8x(x_1, z) USING (x_1);',)]

-----------
QUERY:


create view vv4 as
select * from (values(1,2,3,4,5,6,7)) v(a,b,c,x,e,f,g)
union all
select * from
  tt7 full join tt8 using (x),
  tt7 tt7x full join tt8 tt8x using (x) full join tt8 tt8y using (x);
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('vv4', true);
RESULT:
	[(' SELECT v.a,\n    v.b,\n    v.c,\n    v.x,\n    v.e,\n    v.f,\n    v.g\n   FROM ( VALUES (1,2,3,4,5,6,7)) v(a, b, c, x, e, f, g)\nUNION ALL\n SELECT x AS a,\n    tt7.y AS b,\n    tt8.z AS c,\n    x_1 AS x,\n    tt7x.y AS e,\n    tt8x.z AS f,\n    tt8y.z AS g\n   FROM tt7\n     FULL JOIN tt8 USING (x),\n    tt7 tt7x(x_1, y)\n     FULL JOIN tt8 tt8x(x_1, z) USING (x_1)\n     FULL JOIN tt8 tt8y(x_1, z) USING (x_1);',)]

-----------
QUERY:


alter table tt7 add column zz int;
RESULT:
	[]

-----------
QUERY:

alter table tt7 add column z int;
RESULT:
	[]

-----------
QUERY:

alter table tt7 drop column zz;
RESULT:
	[]

-----------
QUERY:

alter table tt8 add column z2 int;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('vv2', true);
RESULT:
	[(' SELECT v.a,\n    v.b,\n    v.c,\n    v.d,\n    v.e\n   FROM ( VALUES (1,2,3,4,5)) v(a, b, c, d, e)\nUNION ALL\n SELECT x AS a,\n    tt7.y AS b,\n    tt8.z AS c,\n    tt8x.x_1 AS d,\n    tt8x.z AS e\n   FROM tt7\n     FULL JOIN tt8 USING (x),\n    tt8 tt8x(x_1, z, z2);',)]

-----------
QUERY:

select pg_get_viewdef('vv3', true);
RESULT:
	[(' SELECT v.a,\n    v.b,\n    v.c,\n    v.x,\n    v.e,\n    v.f\n   FROM ( VALUES (1,2,3,4,5,6)) v(a, b, c, x, e, f)\nUNION ALL\n SELECT x AS a,\n    tt7.y AS b,\n    tt8.z AS c,\n    x_1 AS x,\n    tt7x.y AS e,\n    tt8x.z AS f\n   FROM tt7\n     FULL JOIN tt8 USING (x),\n    tt7 tt7x(x_1, y, z)\n     FULL JOIN tt8 tt8x(x_1, z, z2) USING (x_1);',)]

-----------
QUERY:

select pg_get_viewdef('vv4', true);
RESULT:
	[(' SELECT v.a,\n    v.b,\n    v.c,\n    v.x,\n    v.e,\n    v.f,\n    v.g\n   FROM ( VALUES (1,2,3,4,5,6,7)) v(a, b, c, x, e, f, g)\nUNION ALL\n SELECT x AS a,\n    tt7.y AS b,\n    tt8.z AS c,\n    x_1 AS x,\n    tt7x.y AS e,\n    tt8x.z AS f,\n    tt8y.z AS g\n   FROM tt7\n     FULL JOIN tt8 USING (x),\n    tt7 tt7x(x_1, y, z)\n     FULL JOIN tt8 tt8x(x_1, z, z2) USING (x_1)\n     FULL JOIN tt8 tt8y(x_1, z, z2) USING (x_1);',)]

-----------
QUERY:


-- Implicit coercions in a JOIN USING create issues similar to FULL JOIN

create table tt7a (x date, xx int, y int);
RESULT:
	[]

-----------
QUERY:

alter table tt7a drop column xx;
RESULT:
	[]

-----------
QUERY:

create table tt8a (x timestamptz, z int);
RESULT:
	[]

-----------
QUERY:


create view vv2a as
select * from (values(now(),2,3,now(),5)) v(a,b,c,d,e)
union all
select * from tt7a left join tt8a using (x), tt8a tt8ax;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('vv2a', true);
RESULT:
	[(' SELECT v.a,\n    v.b,\n    v.c,\n    v.d,\n    v.e\n   FROM ( VALUES (now(),2,3,now(),5)) v(a, b, c, d, e)\nUNION ALL\n SELECT x AS a,\n    tt7a.y AS b,\n    tt8a.z AS c,\n    tt8ax.x_1 AS d,\n    tt8ax.z AS e\n   FROM tt7a\n     LEFT JOIN tt8a USING (x),\n    tt8a tt8ax(x_1, z);',)]

-----------
QUERY:


--
-- Also check dropping a column that existed when the view was made
--

create table tt9 (x int, xx int, y int);
RESULT:
	[]

-----------
QUERY:

create table tt10 (x int, z int);
RESULT:
	[]

-----------
QUERY:


create view vv5 as select x,y,z from tt9 join tt10 using(x);
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('vv5', true);
RESULT:
	[(' SELECT tt9.x,\n    tt9.y,\n    tt10.z\n   FROM tt9\n     JOIN tt10 USING (x);',)]

-----------
QUERY:


alter table tt9 drop column xx;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('vv5', true);
RESULT:
	[(' SELECT tt9.x,\n    tt9.y,\n    tt10.z\n   FROM tt9\n     JOIN tt10 USING (x);',)]

-----------
QUERY:


--
-- Another corner case is that we might add a column to a table below a
-- JOIN USING, and thereby make the USING column name ambiguous
--

create table tt11 (x int, y int);
RESULT:
	[]

-----------
QUERY:

create table tt12 (x int, z int);
RESULT:
	[]

-----------
QUERY:

create table tt13 (z int, q int);
RESULT:
	[]

-----------
QUERY:


create view vv6 as select x,y,z,q from
  (tt11 join tt12 using(x)) join tt13 using(z);
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('vv6', true);
RESULT:
	[(' SELECT tt11.x,\n    tt11.y,\n    tt12.z,\n    tt13.q\n   FROM tt11\n     JOIN tt12 USING (x)\n     JOIN tt13 USING (z);',)]

-----------
QUERY:


alter table tt11 add column z int;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('vv6', true);
RESULT:
	[(' SELECT tt11.x,\n    tt11.y,\n    tt12.z,\n    tt13.q\n   FROM tt11 tt11(x, y, z_1)\n     JOIN tt12 USING (x)\n     JOIN tt13 USING (z);',)]

-----------
QUERY:


--
-- Check cases involving dropped/altered columns in a function/* REPLACED */ ''s rowtype result
--

create table tt14t (f1 text, f2 text, f3 text, f4 text);
RESULT:
	[]

-----------
QUERY:

insert into tt14t values('foo', 'bar', 'baz', '42');
RESULT:
	[]

-----------
QUERY:


alter table tt14t drop column f2;
RESULT:
	[]

-----------
QUERY:


create function tt14f() returns setof tt14t as
$$
declare
    rec1 record;
begin
    for rec1 in select * from tt14t
    loop
        return next rec1;
    end loop;
end;
$$
language plpgsql;
RESULT:
	[]

-----------
QUERY:


create view tt14v as select t.* from tt14f() t;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('tt14v', true);
RESULT:
	[(' SELECT f1,\n    f3,\n    f4\n   FROM tt14f() t(f1, f3, f4);',)]

-----------
QUERY:

select * from tt14v;
RESULT:
	[('foo', 'baz', '42')]

-----------
QUERY:


alter table tt14t drop column f3;
RESULT:
	ERROR - cannot drop column f3 of table tt14t because other objects depend on it
DETAIL:  view tt14v depends on column f3 of table tt14t
HINT:  Use DROP ... CASCADE to drop the dependent objects too.


-----------
QUERY:
  -- fail, view has explicit reference to f3

-- We used to have a bug that would allow the above to succeed, posing
-- hazards for later execution of the view.  Check that the internal
-- defenses for those hazards haven/* REPLACED */ ''t bit-rotted, in case some other
-- bug with similar symptoms emerges.
begin;
RESULT:
	[]

-----------
QUERY:


-- destroy the dependency entry that prevents the DROP:
delete from pg_depend where
  objid = (select oid from pg_rewrite
           where ev_class = 'tt14v'::regclass and rulename = '_RETURN')
  and refobjsubid = 3
returning pg_describe_object(classid, objid, objsubid) as obj,
          pg_describe_object(refclassid, refobjid, refobjsubid) as ref,
          deptype;
RESULT:
	[('rule _RETURN on view tt14v', 'column f3 of table tt14t', 'n')]

-----------
QUERY:


-- this will now succeed:
alter table tt14t drop column f3;
RESULT:
	[]

-----------
QUERY:


-- column f3 is still in the view, sort of ...
select pg_get_viewdef('tt14v', true);
RESULT:
	[(' SELECT f1,\n    "?dropped?column?" AS f3,\n    f4\n   FROM tt14f() t(f1, f4);',)]

-----------
QUERY:

-- ... and you can even EXPLAIN it ...
explain (verbose, costs off) select * from tt14v;
RESULT:
	[('Function Scan on testviewschm2.tt14f t',), ('  Output: t.f1, t.f3, t.f4',), ('  Function Call: tt14f()',)]

-----------
QUERY:

-- but it will fail at execution
select f1, f4 from tt14v;
RESULT:
	[('foo', '42')]

-----------
QUERY:

select * from tt14v;
RESULT:
	ERROR - attribute 3 of type record has been dropped


-----------
QUERY:


rollback;
RESULT:
	[]

-----------
QUERY:


-- likewise, altering a referenced column/* REPLACED */ ''s type is prohibited ...
alter table tt14t alter column f4 type integer using f4::integer;
RESULT:
	ERROR - cannot alter type of a column used by a view or rule
DETAIL:  rule _RETURN on view tt14v depends on column "f4"


-----------
QUERY:
  -- fail

-- ... but some bug might let it happen, so check defenses
begin;
RESULT:
	[]

-----------
QUERY:


-- destroy the dependency entry that prevents the ALTER:
delete from pg_depend where
  objid = (select oid from pg_rewrite
           where ev_class = 'tt14v'::regclass and rulename = '_RETURN')
  and refobjsubid = 4
returning pg_describe_object(classid, objid, objsubid) as obj,
          pg_describe_object(refclassid, refobjid, refobjsubid) as ref,
          deptype;
RESULT:
	[('rule _RETURN on view tt14v', 'column f4 of table tt14t', 'n')]

-----------
QUERY:


-- this will now succeed:
alter table tt14t alter column f4 type integer using f4::integer;
RESULT:
	[]

-----------
QUERY:


-- f4 is still in the view ...
select pg_get_viewdef('tt14v', true);
RESULT:
	[(' SELECT f1,\n    f3,\n    f4\n   FROM tt14f() t(f1, f3, f4);',)]

-----------
QUERY:

-- but will fail at execution
select f1, f3 from tt14v;
RESULT:
	[('foo', 'baz')]

-----------
QUERY:

select * from tt14v;
RESULT:
	ERROR - attribute 4 of type record has wrong type
DETAIL:  Table has type integer, but query expects text.


-----------
QUERY:


rollback;
RESULT:
	[]

-----------
QUERY:


drop view tt14v;
RESULT:
	[]

-----------
QUERY:


create view tt14v as select t.f1, t.f4 from tt14f() t;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('tt14v', true);
RESULT:
	[(' SELECT f1,\n    f4\n   FROM tt14f() t(f1, f3, f4);',)]

-----------
QUERY:

select * from tt14v;
RESULT:
	[('foo', '42')]

-----------
QUERY:


alter table tt14t drop column f3;
RESULT:
	[]

-----------
QUERY:
  -- ok

select pg_get_viewdef('tt14v', true);
RESULT:
	[(' SELECT f1,\n    f4\n   FROM tt14f() t(f1, f4);',)]

-----------
QUERY:

explain (verbose, costs off) select * from tt14v;
RESULT:
	[('Function Scan on testviewschm2.tt14f t',), ('  Output: t.f1, t.f4',), ('  Function Call: tt14f()',)]

-----------
QUERY:

select * from tt14v;
RESULT:
	[('foo', '42')]

-----------
QUERY:


-- check display of whole-row variables in some corner cases

create type nestedcomposite as (x int8_tbl);
RESULT:
	[]

-----------
QUERY:

create view tt15v as select row(i)::nestedcomposite from int8_tbl i;
RESULT:
	[]

-----------
QUERY:

select * from tt15v;
RESULT:
	[('("(123,456)")',), ('("(123,4567890123456789)")',), ('("(4567890123456789,123)")',), ('("(4567890123456789,4567890123456789)")',), ('("(4567890123456789,-4567890123456789)")',)]

-----------
QUERY:

select pg_get_viewdef('tt15v', true);
RESULT:
	[(' SELECT ROW(i.*::int8_tbl)::nestedcomposite AS "row"\n   FROM int8_tbl i;',)]

-----------
QUERY:

select row(i.*::int8_tbl)::nestedcomposite from int8_tbl i;
RESULT:
	[('("(123,456)")',), ('("(123,4567890123456789)")',), ('("(4567890123456789,123)")',), ('("(4567890123456789,4567890123456789)")',), ('("(4567890123456789,-4567890123456789)")',)]

-----------
QUERY:


create view tt16v as select * from int8_tbl i, lateral(values(i)) ss;
RESULT:
	[]

-----------
QUERY:

select * from tt16v;
RESULT:
	[(123, 456, '(123,456)'), (123, 4567890123456789, '(123,4567890123456789)'), (4567890123456789, 123, '(4567890123456789,123)'), (4567890123456789, 4567890123456789, '(4567890123456789,4567890123456789)'), (4567890123456789, -4567890123456789, '(4567890123456789,-4567890123456789)')]

-----------
QUERY:

select pg_get_viewdef('tt16v', true);
RESULT:
	[(' SELECT i.q1,\n    i.q2,\n    ss.column1\n   FROM int8_tbl i,\n    LATERAL ( VALUES (i.*::int8_tbl)) ss;',)]

-----------
QUERY:

select * from int8_tbl i, lateral(values(i.*::int8_tbl)) ss;
RESULT:
	[(123, 456, '(123,456)'), (123, 4567890123456789, '(123,4567890123456789)'), (4567890123456789, 123, '(4567890123456789,123)'), (4567890123456789, 4567890123456789, '(4567890123456789,4567890123456789)'), (4567890123456789, -4567890123456789, '(4567890123456789,-4567890123456789)')]

-----------
QUERY:


create view tt17v as select * from int8_tbl i where i in (values(i));
RESULT:
	[]

-----------
QUERY:

select * from tt17v;
RESULT:
	[(123, 456), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789)]

-----------
QUERY:

select pg_get_viewdef('tt17v', true);
RESULT:
	[(' SELECT q1,\n    q2\n   FROM int8_tbl i\n  WHERE (i.* IN ( VALUES (i.*::int8_tbl)));',)]

-----------
QUERY:

select * from int8_tbl i where i.* in (values(i.*::int8_tbl));
RESULT:
	[(123, 456), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789)]

-----------
QUERY:


create table tt15v_log(o tt15v, n tt15v, incr bool);
RESULT:
	[]

-----------
QUERY:

create rule updlog as on update to tt15v do also
  insert into tt15v_log values(old, new, row(old,old) < row(new,new));
RESULT:
	[]

-----------
QUERY:

-- \d+ tt15v

-- check unique-ification of overlength names

create view tt18v as
  select * from int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxy
  union all
  select * from int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxz;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('tt18v', true);
RESULT:
	[(' SELECT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q1,\n    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q2\n   FROM int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\nUNION ALL\n SELECT xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q1,\n    xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.q2\n   FROM int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx;',)]

-----------
QUERY:

explain (costs off) select * from tt18v;
RESULT:
	[('Append',), ('  ->  Seq Scan on int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx',), ('  ->  Seq Scan on int8_tbl xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx_1',)]

-----------
QUERY:


-- check display of ScalarArrayOp with a sub-select

select 'foo'::text = any(array['abc','def','foo']::text[]);
RESULT:
	[(True,)]

-----------
QUERY:

select 'foo'::text = any((select array['abc','def','foo']::text[]));
RESULT:
	ERROR - operator does not exist: text = text[]
LINE 2: select 'foo'::text = any((select array['abc','def','foo']::t...
                           ^
HINT:  No operator matches the given name and argument types. You might need to add explicit type casts.


-----------
QUERY:
  -- fail
select 'foo'::text = any((select array['abc','def','foo']::text[])::text[]);
RESULT:
	[(True,)]

-----------
QUERY:


create view tt19v as
select 'foo'::text = any(array['abc','def','foo']::text[]) c1,
       'foo'::text = any((select array['abc','def','foo']::text[])::text[]) c2;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('tt19v', true);
RESULT:
	[(' SELECT \'foo\'::text = ANY (ARRAY[\'abc\'::text, \'def\'::text, \'foo\'::text]) AS c1,\n    \'foo\'::text = ANY ((( SELECT ARRAY[\'abc\'::text, \'def\'::text, \'foo\'::text] AS "array"))::text[]) AS c2;',)]

-----------
QUERY:


-- check display of assorted RTE_FUNCTION expressions

create view tt20v as
select * from
  coalesce(1,2) as c,
  collation for ('x'::text) col,
  current_date as d,
  localtimestamp(3) as t,
  cast(1+2 as int4) as i4,
  cast(1+2 as int8) as i8;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('tt20v', true);
RESULT:
	[(" SELECT c.c,\n    col.col,\n    d.d,\n    t.t,\n    i4.i4,\n    i8.i8\n   FROM COALESCE(1, 2) c(c),\n    COLLATION FOR ('x'::text) col(col),\n    CURRENT_DATE d(d),\n    LOCALTIMESTAMP(3) t(t),\n    CAST(1 + 2 AS integer) i4(i4),\n    CAST((1 + 2)::bigint AS bigint) i8(i8);",)]

-----------
QUERY:


-- reverse-listing of various special function syntaxes required by SQL

create view tt201v as
select
  ('2022-12-01'::date + '1 day'::interval) at time zone 'UTC' as atz,
  extract(day from now()) as extr,
  (now(), '1 day'::interval) overlaps
    (current_timestamp(2), '1 day'::interval) as o,
  'foo' is normalized isn,
  'foo' is nfkc normalized isnn,
  normalize('foo') as n,
  normalize('foo', nfkd) as nfkd,
  overlay('foo' placing 'bar' from 2) as ovl,
  overlay('foo' placing 'bar' from 2 for 3) as ovl2,
  position('foo' in 'foobar') as p,
  substring('foo' from 2 for 3) as s,
  substring('foo' similar 'f' escape '#') as ss,
  substring('foo' from 'oo') as ssf,  -- historically-permitted abuse
  trim(' ' from ' foo ') as bt,
  trim(leading ' ' from ' foo ') as lt,
  trim(trailing ' foo ') as rt,
  trim(E'\\000'::bytea from E'\\000Tom\\000'::bytea) as btb,
  trim(leading E'\\000'::bytea from E'\\000Tom\\000'::bytea) as ltb,
  trim(trailing E'\\000'::bytea from E'\\000Tom\\000'::bytea) as rtb,
  CURRENT_DATE as cd,
  (select * from CURRENT_DATE) as cd2,
  CURRENT_TIME as ct,
  (select * from CURRENT_TIME) as ct2,
  CURRENT_TIME (1) as ct3,
  (select * from CURRENT_TIME (1)) as ct4,
  CURRENT_TIMESTAMP as ct5,
  (select * from CURRENT_TIMESTAMP) as ct6,
  CURRENT_TIMESTAMP (1) as ct7,
  (select * from CURRENT_TIMESTAMP (1)) as ct8,
  LOCALTIME as lt1,
  (select * from LOCALTIME) as lt2,
  LOCALTIME (1) as lt3,
  (select * from LOCALTIME (1)) as lt4,
  LOCALTIMESTAMP as lt5,
  (select * from LOCALTIMESTAMP) as lt6,
  LOCALTIMESTAMP (1) as lt7,
  (select * from LOCALTIMESTAMP (1)) as lt8,
  CURRENT_CATALOG as ca,
  (select * from CURRENT_CATALOG) as ca2,
  CURRENT_ROLE as cr,
  (select * from CURRENT_ROLE) as cr2,
  CURRENT_SCHEMA as cs,
  (select * from CURRENT_SCHEMA) as cs2,
  CURRENT_USER as cu,
  (select * from CURRENT_USER) as cu2,
  USER as us,
  (select * from USER) as us2,
  SESSION_USER seu,
  (select * from SESSION_USER) as seu2,
  SYSTEM_USER as su,
  (select * from SYSTEM_USER) as su2;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('tt201v', true);
RESULT:
	[(' SELECT ((\'2022-12-01\'::date + \'1 day\'::interval) AT TIME ZONE \'UTC\'::text) AS atz,\n    EXTRACT(day FROM now()) AS extr,\n    ((now(), \'1 day\'::interval) OVERLAPS (CURRENT_TIMESTAMP(2), \'1 day\'::interval)) AS o,\n    (\'foo\'::text IS NORMALIZED) AS isn,\n    (\'foo\'::text IS NFKC NORMALIZED) AS isnn,\n    NORMALIZE(\'foo\'::text) AS n,\n    NORMALIZE(\'foo\'::text, NFKD) AS nfkd,\n    OVERLAY(\'foo\'::text PLACING \'bar\'::text FROM 2) AS ovl,\n    OVERLAY(\'foo\'::text PLACING \'bar\'::text FROM 2 FOR 3) AS ovl2,\n    POSITION((\'foo\'::text) IN (\'foobar\'::text)) AS p,\n    SUBSTRING(\'foo\'::text FROM 2 FOR 3) AS s,\n    SUBSTRING(\'foo\'::text SIMILAR \'f\'::text ESCAPE \'#\'::text) AS ss,\n    "substring"(\'foo\'::text, \'oo\'::text) AS ssf,\n    TRIM(BOTH \' \'::text FROM \' foo \'::text) AS bt,\n    TRIM(LEADING \' \'::text FROM \' foo \'::text) AS lt,\n    TRIM(TRAILING FROM \' foo \'::text) AS rt,\n    TRIM(BOTH \'\\x00\'::bytea FROM \'\\x00546f6d00\'::bytea) AS btb,\n    TRIM(LEADING \'\\x00\'::bytea FROM \'\\x00546f6d00\'::bytea) AS ltb,\n    TRIM(TRAILING \'\\x00\'::bytea FROM \'\\x00546f6d00\'::bytea) AS rtb,\n    CURRENT_DATE AS cd,\n    ( SELECT "current_date"."current_date"\n           FROM CURRENT_DATE "current_date"("current_date")) AS cd2,\n    CURRENT_TIME AS ct,\n    ( SELECT "current_time"."current_time"\n           FROM CURRENT_TIME "current_time"("current_time")) AS ct2,\n    CURRENT_TIME(1) AS ct3,\n    ( SELECT "current_time"."current_time"\n           FROM CURRENT_TIME(1) "current_time"("current_time")) AS ct4,\n    CURRENT_TIMESTAMP AS ct5,\n    ( SELECT "current_timestamp"."current_timestamp"\n           FROM CURRENT_TIMESTAMP "current_timestamp"("current_timestamp")) AS ct6,\n    CURRENT_TIMESTAMP(1) AS ct7,\n    ( SELECT "current_timestamp"."current_timestamp"\n           FROM CURRENT_TIMESTAMP(1) "current_timestamp"("current_timestamp")) AS ct8,\n    LOCALTIME AS lt1,\n    ( SELECT "localtime"."localtime"\n           FROM LOCALTIME "localtime"("localtime")) AS lt2,\n    LOCALTIME(1) AS lt3,\n    ( SELECT "localtime"."localtime"\n           FROM LOCALTIME(1) "localtime"("localtime")) AS lt4,\n    LOCALTIMESTAMP AS lt5,\n    ( SELECT "localtimestamp"."localtimestamp"\n           FROM LOCALTIMESTAMP "localtimestamp"("localtimestamp")) AS lt6,\n    LOCALTIMESTAMP(1) AS lt7,\n    ( SELECT "localtimestamp"."localtimestamp"\n           FROM LOCALTIMESTAMP(1) "localtimestamp"("localtimestamp")) AS lt8,\n    CURRENT_CATALOG AS ca,\n    ( SELECT "current_catalog"."current_catalog"\n           FROM CURRENT_CATALOG "current_catalog"("current_catalog")) AS ca2,\n    CURRENT_ROLE AS cr,\n    ( SELECT "current_role"."current_role"\n           FROM CURRENT_ROLE "current_role"("current_role")) AS cr2,\n    CURRENT_SCHEMA AS cs,\n    ( SELECT "current_schema"."current_schema"\n           FROM CURRENT_SCHEMA "current_schema"("current_schema")) AS cs2,\n    CURRENT_USER AS cu,\n    ( SELECT "current_user"."current_user"\n           FROM CURRENT_USER "current_user"("current_user")) AS cu2,\n    USER AS us,\n    ( SELECT "user"."user"\n           FROM USER "user"("user")) AS us2,\n    SESSION_USER AS seu,\n    ( SELECT "session_user"."session_user"\n           FROM SESSION_USER "session_user"("session_user")) AS seu2,\n    SYSTEM_USER AS su,\n    ( SELECT "system_user"."system_user"\n           FROM SYSTEM_USER "system_user"("system_user")) AS su2;',)]

-----------
QUERY:


-- corner cases with empty join conditions

create view tt21v as
select * from tt5 natural inner join tt6;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('tt21v', true);
RESULT:
	[(' SELECT tt5.a,\n    tt5.b,\n    tt5.cc,\n    tt6.c,\n    tt6.d\n   FROM tt5\n     CROSS JOIN tt6;',)]

-----------
QUERY:


create view tt22v as
select * from tt5 natural left join tt6;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('tt22v', true);
RESULT:
	[(' SELECT tt5.a,\n    tt5.b,\n    tt5.cc,\n    tt6.c,\n    tt6.d\n   FROM tt5\n     LEFT JOIN tt6 ON TRUE;',)]

-----------
QUERY:


-- check handling of views with immediately-renamed columns

create view tt23v (col_a, col_b) as
select q1 as other_name1, q2 as other_name2 from int8_tbl
union
select 42, 43;
RESULT:
	[]

-----------
QUERY:


select pg_get_viewdef('tt23v', true);
RESULT:
	[(' SELECT int8_tbl.q1 AS col_a,\n    int8_tbl.q2 AS col_b\n   FROM int8_tbl\nUNION\n SELECT 42 AS col_a,\n    43 AS col_b;',)]

-----------
QUERY:

select pg_get_ruledef(oid, true) from pg_rewrite
  where ev_class = 'tt23v'::regclass and ev_type = '1';
RESULT:
	[('CREATE RULE "_RETURN" AS\n    ON SELECT TO tt23v DO INSTEAD  SELECT int8_tbl.q1 AS col_a,\n    int8_tbl.q2 AS col_b\n   FROM int8_tbl\nUNION\n SELECT 42 AS col_a,\n    43 AS col_b;',)]

-----------
QUERY:


-- test extraction of FieldSelect field names (get_name_for_var_field)

create view tt24v as
with cte as materialized (select r from (values(1,2),(3,4)) r)
select (r).column2 as col_a, (rr).column2 as col_b from
  cte join (select rr from (values(1,7),(3,8)) rr limit 2) ss
  on (r).column1 = (rr).column1;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('tt24v', true);
RESULT:
	[(' WITH cte AS MATERIALIZED (\n         SELECT r.*::record AS r\n           FROM ( VALUES (1,2), (3,4)) r\n        )\n SELECT (cte.r).column2 AS col_a,\n    (ss.rr).column2 AS col_b\n   FROM cte\n     JOIN ( SELECT rr.*::record AS rr\n           FROM ( VALUES (1,7), (3,8)) rr\n         LIMIT 2) ss ON (cte.r).column1 = (ss.rr).column1;',)]

-----------
QUERY:

create view tt25v as
with cte as materialized (select pg_get_keywords() k)
select (k).word from cte;
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('tt25v', true);
RESULT:
	[(' WITH cte AS MATERIALIZED (\n         SELECT pg_get_keywords() AS k\n        )\n SELECT (k).word AS word\n   FROM cte;',)]

-----------
QUERY:

-- also check cases seen only in EXPLAIN
explain (verbose, costs off)
select * from tt24v;
RESULT:
	[('Hash Join',), ('  Output: (cte.r).column2, ((ROW("*VALUES*".column1, "*VALUES*".column2))).column2',), ('  Hash Cond: ((cte.r).column1 = ((ROW("*VALUES*".column1, "*VALUES*".column2))).column1)',), ('  CTE cte',), ('    ->  Values Scan on "*VALUES*_1"',), ('          Output: ROW("*VALUES*_1".column1, "*VALUES*_1".column2)',), ('  ->  CTE Scan on cte',), ('        Output: cte.r',), ('  ->  Hash',), ('        Output: (ROW("*VALUES*".column1, "*VALUES*".column2))',), ('        ->  Limit',), ('              Output: (ROW("*VALUES*".column1, "*VALUES*".column2))',), ('              ->  Values Scan on "*VALUES*"',), ('                    Output: ROW("*VALUES*".column1, "*VALUES*".column2)',)]

-----------
QUERY:

explain (verbose, costs off)
select (r).column2 from (select r from (values(1,2),(3,4)) r limit 1) ss;
RESULT:
	[('Subquery Scan on ss',), ('  Output: (ss.r).column2',), ('  ->  Limit',), ('        Output: (ROW("*VALUES*".column1, "*VALUES*".column2))',), ('        ->  Values Scan on "*VALUES*"',), ('              Output: ROW("*VALUES*".column1, "*VALUES*".column2)',)]

-----------
QUERY:


-- test pretty-print parenthesization rules, and SubLink deparsing

create view tt26v as
select x + y + z as c1,
       (x * y) + z as c2,
       x + (y * z) as c3,
       (x + y) * z as c4,
       x * (y + z) as c5,
       x + (y + z) as c6,
       x + (y # z) as c7,
       (x > y) AND (y > z OR x > z) as c8,
       (x > y) OR (y > z AND NOT (x > z)) as c9,
       (x,y) <> ALL (values(1,2),(3,4)) as c10,
       (x,y) <= ANY (values(1,2),(3,4)) as c11
from (values(1,2,3)) v(x,y,z);
RESULT:
	[]

-----------
QUERY:

select pg_get_viewdef('tt26v', true);
RESULT:
	[(' SELECT x + y + z AS c1,\n    x * y + z AS c2,\n    x + y * z AS c3,\n    (x + y) * z AS c4,\n    x * (y + z) AS c5,\n    x + (y + z) AS c6,\n    x + (y # z) AS c7,\n    x > y AND (y > z OR x > z) AS c8,\n    x > y OR y > z AND NOT x > z AS c9,\n    ((x, y) <> ALL ( VALUES (1,2), (3,4))) AS c10,\n    ((x, y) <= ANY ( VALUES (1,2), (3,4))) AS c11\n   FROM ( VALUES (1,2,3)) v(x, y, z);',)]

-----------
QUERY:


-- clean up all the random objects we made above
DROP SCHEMA temp_view_test CASCADE;
RESULT:
	[]

-----------
QUERY:

DROP SCHEMA testviewschm2 CASCADE;
RESULT:
	[]
