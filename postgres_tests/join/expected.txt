
-----------
QUERY:
--
-- JOIN
-- Test JOIN clauses
--

CREATE TABLE J1_TBL (
  i integer,
  j integer,
  t text
);
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE J2_TBL (
  i integer,
  k integer
);
RESULT:
	postgres: None

-----------
QUERY:



INSERT INTO J1_TBL VALUES (1, 4, 'one');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J1_TBL VALUES (2, 3, 'two');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J1_TBL VALUES (3, 2, 'three');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J1_TBL VALUES (4, 1, 'four');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J1_TBL VALUES (5, 0, 'five');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J1_TBL VALUES (6, 6, 'six');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J1_TBL VALUES (7, 7, 'seven');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J1_TBL VALUES (8, 8, 'eight');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J1_TBL VALUES (0, NULL, 'zero');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J1_TBL VALUES (NULL, NULL, 'null');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J1_TBL VALUES (NULL, 0, 'zero');
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO J2_TBL VALUES (1, -1);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J2_TBL VALUES (2, 2);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J2_TBL VALUES (3, -3);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J2_TBL VALUES (2, 4);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J2_TBL VALUES (5, -5);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J2_TBL VALUES (5, -5);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J2_TBL VALUES (0, NULL);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J2_TBL VALUES (NULL, NULL);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO J2_TBL VALUES (NULL, 0);
RESULT:
	postgres: None

-----------
QUERY:


-- useful in some tests below
create temp table onerow();
RESULT:
	postgres: None

-----------
QUERY:

insert into onerow default values;
RESULT:
	postgres: None

-----------
QUERY:

analyze onerow;
RESULT:
	postgres: None

-----------
QUERY:



--
-- CORRELATION NAMES
-- Make sure that table/column aliases are supported
-- before diving into more complex join syntax.
--

SELECT *
  FROM J1_TBL AS tx;
RESULT:
	postgres: [(1, 4, 'one'), (2, 3, 'two'), (3, 2, 'three'), (4, 1, 'four'), (5, 0, 'five'), (6, 6, 'six'), (7, 7, 'seven'), (8, 8, 'eight'), (0, None, 'zero'), (None, None, 'null'), (None, 0, 'zero')]

-----------
QUERY:


SELECT *
  FROM J1_TBL tx;
RESULT:
	postgres: [(1, 4, 'one'), (2, 3, 'two'), (3, 2, 'three'), (4, 1, 'four'), (5, 0, 'five'), (6, 6, 'six'), (7, 7, 'seven'), (8, 8, 'eight'), (0, None, 'zero'), (None, None, 'null'), (None, 0, 'zero')]

-----------
QUERY:


SELECT *
  FROM J1_TBL AS t1 (a, b, c);
RESULT:
	postgres: [(1, 4, 'one'), (2, 3, 'two'), (3, 2, 'three'), (4, 1, 'four'), (5, 0, 'five'), (6, 6, 'six'), (7, 7, 'seven'), (8, 8, 'eight'), (0, None, 'zero'), (None, None, 'null'), (None, 0, 'zero')]

-----------
QUERY:


SELECT *
  FROM J1_TBL t1 (a, b, c);
RESULT:
	postgres: [(1, 4, 'one'), (2, 3, 'two'), (3, 2, 'three'), (4, 1, 'four'), (5, 0, 'five'), (6, 6, 'six'), (7, 7, 'seven'), (8, 8, 'eight'), (0, None, 'zero'), (None, None, 'null'), (None, 0, 'zero')]

-----------
QUERY:


SELECT *
  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e);
RESULT:
	postgres: [(1, 4, 'one', 1, -1), (2, 3, 'two', 1, -1), (3, 2, 'three', 1, -1), (4, 1, 'four', 1, -1), (5, 0, 'five', 1, -1), (6, 6, 'six', 1, -1), (7, 7, 'seven', 1, -1), (8, 8, 'eight', 1, -1), (0, None, 'zero', 1, -1), (None, None, 'null', 1, -1), (None, 0, 'zero', 1, -1), (1, 4, 'one', 2, 2), (2, 3, 'two', 2, 2), (3, 2, 'three', 2, 2), (4, 1, 'four', 2, 2), (5, 0, 'five', 2, 2), (6, 6, 'six', 2, 2), (7, 7, 'seven', 2, 2), (8, 8, 'eight', 2, 2), (0, None, 'zero', 2, 2), (None, None, 'null', 2, 2), (None, 0, 'zero', 2, 2), (1, 4, 'one', 3, -3), (2, 3, 'two', 3, -3), (3, 2, 'three', 3, -3), (4, 1, 'four', 3, -3), (5, 0, 'five', 3, -3), (6, 6, 'six', 3, -3), (7, 7, 'seven', 3, -3), (8, 8, 'eight', 3, -3), (0, None, 'zero', 3, -3), (None, None, 'null', 3, -3), (None, 0, 'zero', 3, -3), (1, 4, 'one', 2, 4), (2, 3, 'two', 2, 4), (3, 2, 'three', 2, 4), (4, 1, 'four', 2, 4), (5, 0, 'five', 2, 4), (6, 6, 'six', 2, 4), (7, 7, 'seven', 2, 4), (8, 8, 'eight', 2, 4), (0, None, 'zero', 2, 4), (None, None, 'null', 2, 4), (None, 0, 'zero', 2, 4), (1, 4, 'one', 5, -5), (2, 3, 'two', 5, -5), (3, 2, 'three', 5, -5), (4, 1, 'four', 5, -5), (5, 0, 'five', 5, -5), (6, 6, 'six', 5, -5), (7, 7, 'seven', 5, -5), (8, 8, 'eight', 5, -5), (0, None, 'zero', 5, -5), (None, None, 'null', 5, -5), (None, 0, 'zero', 5, -5), (1, 4, 'one', 5, -5), (2, 3, 'two', 5, -5), (3, 2, 'three', 5, -5), (4, 1, 'four', 5, -5), (5, 0, 'five', 5, -5), (6, 6, 'six', 5, -5), (7, 7, 'seven', 5, -5), (8, 8, 'eight', 5, -5), (0, None, 'zero', 5, -5), (None, None, 'null', 5, -5), (None, 0, 'zero', 5, -5), (1, 4, 'one', 0, None), (2, 3, 'two', 0, None), (3, 2, 'three', 0, None), (4, 1, 'four', 0, None), (5, 0, 'five', 0, None), (6, 6, 'six', 0, None), (7, 7, 'seven', 0, None), (8, 8, 'eight', 0, None), (0, None, 'zero', 0, None), (None, None, 'null', 0, None), (None, 0, 'zero', 0, None), (1, 4, 'one', None, None), (2, 3, 'two', None, None), (3, 2, 'three', None, None), (4, 1, 'four', None, None), (5, 0, 'five', None, None), (6, 6, 'six', None, None), (7, 7, 'seven', None, None), (8, 8, 'eight', None, None), (0, None, 'zero', None, None), (None, None, 'null', None, None), (None, 0, 'zero', None, None), (1, 4, 'one', None, 0), (2, 3, 'two', None, 0), (3, 2, 'three', None, 0), (4, 1, 'four', None, 0), (5, 0, 'five', None, 0), (6, 6, 'six', None, 0), (7, 7, 'seven', None, 0), (8, 8, 'eight', None, 0), (0, None, 'zero', None, 0), (None, None, 'null', None, 0), (None, 0, 'zero', None, 0)]

-----------
QUERY:


SELECT t1.a, t2.e
  FROM J1_TBL t1 (a, b, c), J2_TBL t2 (d, e)
  WHERE t1.a = t2.d;
RESULT:
	postgres: [(0, None), (1, -1), (2, 2), (2, 4), (3, -3), (5, -5), (5, -5)]

-----------
QUERY:



--
-- CROSS JOIN
-- Qualifications are not allowed on cross joins,
-- which degenerate into a standard unqualified inner join.
--

SELECT *
  FROM J1_TBL CROSS JOIN J2_TBL;
RESULT:
	postgres: [(1, 4, 'one', 1, -1), (2, 3, 'two', 1, -1), (3, 2, 'three', 1, -1), (4, 1, 'four', 1, -1), (5, 0, 'five', 1, -1), (6, 6, 'six', 1, -1), (7, 7, 'seven', 1, -1), (8, 8, 'eight', 1, -1), (0, None, 'zero', 1, -1), (None, None, 'null', 1, -1), (None, 0, 'zero', 1, -1), (1, 4, 'one', 2, 2), (2, 3, 'two', 2, 2), (3, 2, 'three', 2, 2), (4, 1, 'four', 2, 2), (5, 0, 'five', 2, 2), (6, 6, 'six', 2, 2), (7, 7, 'seven', 2, 2), (8, 8, 'eight', 2, 2), (0, None, 'zero', 2, 2), (None, None, 'null', 2, 2), (None, 0, 'zero', 2, 2), (1, 4, 'one', 3, -3), (2, 3, 'two', 3, -3), (3, 2, 'three', 3, -3), (4, 1, 'four', 3, -3), (5, 0, 'five', 3, -3), (6, 6, 'six', 3, -3), (7, 7, 'seven', 3, -3), (8, 8, 'eight', 3, -3), (0, None, 'zero', 3, -3), (None, None, 'null', 3, -3), (None, 0, 'zero', 3, -3), (1, 4, 'one', 2, 4), (2, 3, 'two', 2, 4), (3, 2, 'three', 2, 4), (4, 1, 'four', 2, 4), (5, 0, 'five', 2, 4), (6, 6, 'six', 2, 4), (7, 7, 'seven', 2, 4), (8, 8, 'eight', 2, 4), (0, None, 'zero', 2, 4), (None, None, 'null', 2, 4), (None, 0, 'zero', 2, 4), (1, 4, 'one', 5, -5), (2, 3, 'two', 5, -5), (3, 2, 'three', 5, -5), (4, 1, 'four', 5, -5), (5, 0, 'five', 5, -5), (6, 6, 'six', 5, -5), (7, 7, 'seven', 5, -5), (8, 8, 'eight', 5, -5), (0, None, 'zero', 5, -5), (None, None, 'null', 5, -5), (None, 0, 'zero', 5, -5), (1, 4, 'one', 5, -5), (2, 3, 'two', 5, -5), (3, 2, 'three', 5, -5), (4, 1, 'four', 5, -5), (5, 0, 'five', 5, -5), (6, 6, 'six', 5, -5), (7, 7, 'seven', 5, -5), (8, 8, 'eight', 5, -5), (0, None, 'zero', 5, -5), (None, None, 'null', 5, -5), (None, 0, 'zero', 5, -5), (1, 4, 'one', 0, None), (2, 3, 'two', 0, None), (3, 2, 'three', 0, None), (4, 1, 'four', 0, None), (5, 0, 'five', 0, None), (6, 6, 'six', 0, None), (7, 7, 'seven', 0, None), (8, 8, 'eight', 0, None), (0, None, 'zero', 0, None), (None, None, 'null', 0, None), (None, 0, 'zero', 0, None), (1, 4, 'one', None, None), (2, 3, 'two', None, None), (3, 2, 'three', None, None), (4, 1, 'four', None, None), (5, 0, 'five', None, None), (6, 6, 'six', None, None), (7, 7, 'seven', None, None), (8, 8, 'eight', None, None), (0, None, 'zero', None, None), (None, None, 'null', None, None), (None, 0, 'zero', None, None), (1, 4, 'one', None, 0), (2, 3, 'two', None, 0), (3, 2, 'three', None, 0), (4, 1, 'four', None, 0), (5, 0, 'five', None, 0), (6, 6, 'six', None, 0), (7, 7, 'seven', None, 0), (8, 8, 'eight', None, 0), (0, None, 'zero', None, 0), (None, None, 'null', None, 0), (None, 0, 'zero', None, 0)]

-----------
QUERY:


-- ambiguous column
SELECT i, k, t
  FROM J1_TBL CROSS JOIN J2_TBL;
RESULT:
	postgres: column reference "i" is ambiguous
LINE 4: SELECT i, k, t
               ^


-----------
QUERY:


-- resolve previous ambiguity by specifying the table name
SELECT t1.i, k, t
  FROM J1_TBL t1 CROSS JOIN J2_TBL t2;
RESULT:
	postgres: [(1, -1, 'one'), (2, -1, 'two'), (3, -1, 'three'), (4, -1, 'four'), (5, -1, 'five'), (6, -1, 'six'), (7, -1, 'seven'), (8, -1, 'eight'), (0, -1, 'zero'), (None, -1, 'null'), (None, -1, 'zero'), (1, 2, 'one'), (2, 2, 'two'), (3, 2, 'three'), (4, 2, 'four'), (5, 2, 'five'), (6, 2, 'six'), (7, 2, 'seven'), (8, 2, 'eight'), (0, 2, 'zero'), (None, 2, 'null'), (None, 2, 'zero'), (1, -3, 'one'), (2, -3, 'two'), (3, -3, 'three'), (4, -3, 'four'), (5, -3, 'five'), (6, -3, 'six'), (7, -3, 'seven'), (8, -3, 'eight'), (0, -3, 'zero'), (None, -3, 'null'), (None, -3, 'zero'), (1, 4, 'one'), (2, 4, 'two'), (3, 4, 'three'), (4, 4, 'four'), (5, 4, 'five'), (6, 4, 'six'), (7, 4, 'seven'), (8, 4, 'eight'), (0, 4, 'zero'), (None, 4, 'null'), (None, 4, 'zero'), (1, -5, 'one'), (2, -5, 'two'), (3, -5, 'three'), (4, -5, 'four'), (5, -5, 'five'), (6, -5, 'six'), (7, -5, 'seven'), (8, -5, 'eight'), (0, -5, 'zero'), (None, -5, 'null'), (None, -5, 'zero'), (1, -5, 'one'), (2, -5, 'two'), (3, -5, 'three'), (4, -5, 'four'), (5, -5, 'five'), (6, -5, 'six'), (7, -5, 'seven'), (8, -5, 'eight'), (0, -5, 'zero'), (None, -5, 'null'), (None, -5, 'zero'), (1, None, 'one'), (2, None, 'two'), (3, None, 'three'), (4, None, 'four'), (5, None, 'five'), (6, None, 'six'), (7, None, 'seven'), (8, None, 'eight'), (0, None, 'zero'), (None, None, 'null'), (None, None, 'zero'), (1, None, 'one'), (2, None, 'two'), (3, None, 'three'), (4, None, 'four'), (5, None, 'five'), (6, None, 'six'), (7, None, 'seven'), (8, None, 'eight'), (0, None, 'zero'), (None, None, 'null'), (None, None, 'zero'), (1, 0, 'one'), (2, 0, 'two'), (3, 0, 'three'), (4, 0, 'four'), (5, 0, 'five'), (6, 0, 'six'), (7, 0, 'seven'), (8, 0, 'eight'), (0, 0, 'zero'), (None, 0, 'null'), (None, 0, 'zero')]

-----------
QUERY:


SELECT ii, tt, kk
  FROM (J1_TBL CROSS JOIN J2_TBL)
    AS tx (ii, jj, tt, ii2, kk);
RESULT:
	postgres: [(1, 'one', -1), (2, 'two', -1), (3, 'three', -1), (4, 'four', -1), (5, 'five', -1), (6, 'six', -1), (7, 'seven', -1), (8, 'eight', -1), (0, 'zero', -1), (None, 'null', -1), (None, 'zero', -1), (1, 'one', 2), (2, 'two', 2), (3, 'three', 2), (4, 'four', 2), (5, 'five', 2), (6, 'six', 2), (7, 'seven', 2), (8, 'eight', 2), (0, 'zero', 2), (None, 'null', 2), (None, 'zero', 2), (1, 'one', -3), (2, 'two', -3), (3, 'three', -3), (4, 'four', -3), (5, 'five', -3), (6, 'six', -3), (7, 'seven', -3), (8, 'eight', -3), (0, 'zero', -3), (None, 'null', -3), (None, 'zero', -3), (1, 'one', 4), (2, 'two', 4), (3, 'three', 4), (4, 'four', 4), (5, 'five', 4), (6, 'six', 4), (7, 'seven', 4), (8, 'eight', 4), (0, 'zero', 4), (None, 'null', 4), (None, 'zero', 4), (1, 'one', -5), (2, 'two', -5), (3, 'three', -5), (4, 'four', -5), (5, 'five', -5), (6, 'six', -5), (7, 'seven', -5), (8, 'eight', -5), (0, 'zero', -5), (None, 'null', -5), (None, 'zero', -5), (1, 'one', -5), (2, 'two', -5), (3, 'three', -5), (4, 'four', -5), (5, 'five', -5), (6, 'six', -5), (7, 'seven', -5), (8, 'eight', -5), (0, 'zero', -5), (None, 'null', -5), (None, 'zero', -5), (1, 'one', None), (2, 'two', None), (3, 'three', None), (4, 'four', None), (5, 'five', None), (6, 'six', None), (7, 'seven', None), (8, 'eight', None), (0, 'zero', None), (None, 'null', None), (None, 'zero', None), (1, 'one', None), (2, 'two', None), (3, 'three', None), (4, 'four', None), (5, 'five', None), (6, 'six', None), (7, 'seven', None), (8, 'eight', None), (0, 'zero', None), (None, 'null', None), (None, 'zero', None), (1, 'one', 0), (2, 'two', 0), (3, 'three', 0), (4, 'four', 0), (5, 'five', 0), (6, 'six', 0), (7, 'seven', 0), (8, 'eight', 0), (0, 'zero', 0), (None, 'null', 0), (None, 'zero', 0)]

-----------
QUERY:


SELECT tx.ii, tx.jj, tx.kk
  FROM (J1_TBL t1 (a, b, c) CROSS JOIN J2_TBL t2 (d, e))
    AS tx (ii, jj, tt, ii2, kk);
RESULT:
	postgres: [(1, 4, -1), (2, 3, -1), (3, 2, -1), (4, 1, -1), (5, 0, -1), (6, 6, -1), (7, 7, -1), (8, 8, -1), (0, None, -1), (None, None, -1), (None, 0, -1), (1, 4, 2), (2, 3, 2), (3, 2, 2), (4, 1, 2), (5, 0, 2), (6, 6, 2), (7, 7, 2), (8, 8, 2), (0, None, 2), (None, None, 2), (None, 0, 2), (1, 4, -3), (2, 3, -3), (3, 2, -3), (4, 1, -3), (5, 0, -3), (6, 6, -3), (7, 7, -3), (8, 8, -3), (0, None, -3), (None, None, -3), (None, 0, -3), (1, 4, 4), (2, 3, 4), (3, 2, 4), (4, 1, 4), (5, 0, 4), (6, 6, 4), (7, 7, 4), (8, 8, 4), (0, None, 4), (None, None, 4), (None, 0, 4), (1, 4, -5), (2, 3, -5), (3, 2, -5), (4, 1, -5), (5, 0, -5), (6, 6, -5), (7, 7, -5), (8, 8, -5), (0, None, -5), (None, None, -5), (None, 0, -5), (1, 4, -5), (2, 3, -5), (3, 2, -5), (4, 1, -5), (5, 0, -5), (6, 6, -5), (7, 7, -5), (8, 8, -5), (0, None, -5), (None, None, -5), (None, 0, -5), (1, 4, None), (2, 3, None), (3, 2, None), (4, 1, None), (5, 0, None), (6, 6, None), (7, 7, None), (8, 8, None), (0, None, None), (None, None, None), (None, 0, None), (1, 4, None), (2, 3, None), (3, 2, None), (4, 1, None), (5, 0, None), (6, 6, None), (7, 7, None), (8, 8, None), (0, None, None), (None, None, None), (None, 0, None), (1, 4, 0), (2, 3, 0), (3, 2, 0), (4, 1, 0), (5, 0, 0), (6, 6, 0), (7, 7, 0), (8, 8, 0), (0, None, 0), (None, None, 0), (None, 0, 0)]

-----------
QUERY:


SELECT *
  FROM J1_TBL CROSS JOIN J2_TBL a CROSS JOIN J2_TBL b;
RESULT:
	postgres: [(1, 4, 'one', 1, -1, 1, -1), (1, 4, 'one', 1, -1, 2, 2), (1, 4, 'one', 1, -1, 3, -3), (1, 4, 'one', 1, -1, 2, 4), (1, 4, 'one', 1, -1, 5, -5), (1, 4, 'one', 1, -1, 5, -5), (1, 4, 'one', 1, -1, 0, None), (1, 4, 'one', 1, -1, None, None), (1, 4, 'one', 1, -1, None, 0), (2, 3, 'two', 1, -1, 1, -1), (2, 3, 'two', 1, -1, 2, 2), (2, 3, 'two', 1, -1, 3, -3), (2, 3, 'two', 1, -1, 2, 4), (2, 3, 'two', 1, -1, 5, -5), (2, 3, 'two', 1, -1, 5, -5), (2, 3, 'two', 1, -1, 0, None), (2, 3, 'two', 1, -1, None, None), (2, 3, 'two', 1, -1, None, 0), (3, 2, 'three', 1, -1, 1, -1), (3, 2, 'three', 1, -1, 2, 2), (3, 2, 'three', 1, -1, 3, -3), (3, 2, 'three', 1, -1, 2, 4), (3, 2, 'three', 1, -1, 5, -5), (3, 2, 'three', 1, -1, 5, -5), (3, 2, 'three', 1, -1, 0, None), (3, 2, 'three', 1, -1, None, None), (3, 2, 'three', 1, -1, None, 0), (4, 1, 'four', 1, -1, 1, -1), (4, 1, 'four', 1, -1, 2, 2), (4, 1, 'four', 1, -1, 3, -3), (4, 1, 'four', 1, -1, 2, 4), (4, 1, 'four', 1, -1, 5, -5), (4, 1, 'four', 1, -1, 5, -5), (4, 1, 'four', 1, -1, 0, None), (4, 1, 'four', 1, -1, None, None), (4, 1, 'four', 1, -1, None, 0), (5, 0, 'five', 1, -1, 1, -1), (5, 0, 'five', 1, -1, 2, 2), (5, 0, 'five', 1, -1, 3, -3), (5, 0, 'five', 1, -1, 2, 4), (5, 0, 'five', 1, -1, 5, -5), (5, 0, 'five', 1, -1, 5, -5), (5, 0, 'five', 1, -1, 0, None), (5, 0, 'five', 1, -1, None, None), (5, 0, 'five', 1, -1, None, 0), (6, 6, 'six', 1, -1, 1, -1), (6, 6, 'six', 1, -1, 2, 2), (6, 6, 'six', 1, -1, 3, -3), (6, 6, 'six', 1, -1, 2, 4), (6, 6, 'six', 1, -1, 5, -5), (6, 6, 'six', 1, -1, 5, -5), (6, 6, 'six', 1, -1, 0, None), (6, 6, 'six', 1, -1, None, None), (6, 6, 'six', 1, -1, None, 0), (7, 7, 'seven', 1, -1, 1, -1), (7, 7, 'seven', 1, -1, 2, 2), (7, 7, 'seven', 1, -1, 3, -3), (7, 7, 'seven', 1, -1, 2, 4), (7, 7, 'seven', 1, -1, 5, -5), (7, 7, 'seven', 1, -1, 5, -5), (7, 7, 'seven', 1, -1, 0, None), (7, 7, 'seven', 1, -1, None, None), (7, 7, 'seven', 1, -1, None, 0), (8, 8, 'eight', 1, -1, 1, -1), (8, 8, 'eight', 1, -1, 2, 2), (8, 8, 'eight', 1, -1, 3, -3), (8, 8, 'eight', 1, -1, 2, 4), (8, 8, 'eight', 1, -1, 5, -5), (8, 8, 'eight', 1, -1, 5, -5), (8, 8, 'eight', 1, -1, 0, None), (8, 8, 'eight', 1, -1, None, None), (8, 8, 'eight', 1, -1, None, 0), (0, None, 'zero', 1, -1, 1, -1), (0, None, 'zero', 1, -1, 2, 2), (0, None, 'zero', 1, -1, 3, -3), (0, None, 'zero', 1, -1, 2, 4), (0, None, 'zero', 1, -1, 5, -5), (0, None, 'zero', 1, -1, 5, -5), (0, None, 'zero', 1, -1, 0, None), (0, None, 'zero', 1, -1, None, None), (0, None, 'zero', 1, -1, None, 0), (None, None, 'null', 1, -1, 1, -1), (None, None, 'null', 1, -1, 2, 2), (None, None, 'null', 1, -1, 3, -3), (None, None, 'null', 1, -1, 2, 4), (None, None, 'null', 1, -1, 5, -5), (None, None, 'null', 1, -1, 5, -5), (None, None, 'null', 1, -1, 0, None), (None, None, 'null', 1, -1, None, None), (None, None, 'null', 1, -1, None, 0), (None, 0, 'zero', 1, -1, 1, -1), (None, 0, 'zero', 1, -1, 2, 2), (None, 0, 'zero', 1, -1, 3, -3), (None, 0, 'zero', 1, -1, 2, 4), (None, 0, 'zero', 1, -1, 5, -5), (None, 0, 'zero', 1, -1, 5, -5), (None, 0, 'zero', 1, -1, 0, None), (None, 0, 'zero', 1, -1, None, None), (None, 0, 'zero', 1, -1, None, 0), (1, 4, 'one', 2, 2, 1, -1), (1, 4, 'one', 2, 2, 2, 2), (1, 4, 'one', 2, 2, 3, -3), (1, 4, 'one', 2, 2, 2, 4), (1, 4, 'one', 2, 2, 5, -5), (1, 4, 'one', 2, 2, 5, -5), (1, 4, 'one', 2, 2, 0, None), (1, 4, 'one', 2, 2, None, None), (1, 4, 'one', 2, 2, None, 0), (2, 3, 'two', 2, 2, 1, -1), (2, 3, 'two', 2, 2, 2, 2), (2, 3, 'two', 2, 2, 3, -3), (2, 3, 'two', 2, 2, 2, 4), (2, 3, 'two', 2, 2, 5, -5), (2, 3, 'two', 2, 2, 5, -5), (2, 3, 'two', 2, 2, 0, None), (2, 3, 'two', 2, 2, None, None), (2, 3, 'two', 2, 2, None, 0), (3, 2, 'three', 2, 2, 1, -1), (3, 2, 'three', 2, 2, 2, 2), (3, 2, 'three', 2, 2, 3, -3), (3, 2, 'three', 2, 2, 2, 4), (3, 2, 'three', 2, 2, 5, -5), (3, 2, 'three', 2, 2, 5, -5), (3, 2, 'three', 2, 2, 0, None), (3, 2, 'three', 2, 2, None, None), (3, 2, 'three', 2, 2, None, 0), (4, 1, 'four', 2, 2, 1, -1), (4, 1, 'four', 2, 2, 2, 2), (4, 1, 'four', 2, 2, 3, -3), (4, 1, 'four', 2, 2, 2, 4), (4, 1, 'four', 2, 2, 5, -5), (4, 1, 'four', 2, 2, 5, -5), (4, 1, 'four', 2, 2, 0, None), (4, 1, 'four', 2, 2, None, None), (4, 1, 'four', 2, 2, None, 0), (5, 0, 'five', 2, 2, 1, -1), (5, 0, 'five', 2, 2, 2, 2), (5, 0, 'five', 2, 2, 3, -3), (5, 0, 'five', 2, 2, 2, 4), (5, 0, 'five', 2, 2, 5, -5), (5, 0, 'five', 2, 2, 5, -5), (5, 0, 'five', 2, 2, 0, None), (5, 0, 'five', 2, 2, None, None), (5, 0, 'five', 2, 2, None, 0), (6, 6, 'six', 2, 2, 1, -1), (6, 6, 'six', 2, 2, 2, 2), (6, 6, 'six', 2, 2, 3, -3), (6, 6, 'six', 2, 2, 2, 4), (6, 6, 'six', 2, 2, 5, -5), (6, 6, 'six', 2, 2, 5, -5), (6, 6, 'six', 2, 2, 0, None), (6, 6, 'six', 2, 2, None, None), (6, 6, 'six', 2, 2, None, 0), (7, 7, 'seven', 2, 2, 1, -1), (7, 7, 'seven', 2, 2, 2, 2), (7, 7, 'seven', 2, 2, 3, -3), (7, 7, 'seven', 2, 2, 2, 4), (7, 7, 'seven', 2, 2, 5, -5), (7, 7, 'seven', 2, 2, 5, -5), (7, 7, 'seven', 2, 2, 0, None), (7, 7, 'seven', 2, 2, None, None), (7, 7, 'seven', 2, 2, None, 0), (8, 8, 'eight', 2, 2, 1, -1), (8, 8, 'eight', 2, 2, 2, 2), (8, 8, 'eight', 2, 2, 3, -3), (8, 8, 'eight', 2, 2, 2, 4), (8, 8, 'eight', 2, 2, 5, -5), (8, 8, 'eight', 2, 2, 5, -5), (8, 8, 'eight', 2, 2, 0, None), (8, 8, 'eight', 2, 2, None, None), (8, 8, 'eight', 2, 2, None, 0), (0, None, 'zero', 2, 2, 1, -1), (0, None, 'zero', 2, 2, 2, 2), (0, None, 'zero', 2, 2, 3, -3), (0, None, 'zero', 2, 2, 2, 4), (0, None, 'zero', 2, 2, 5, -5), (0, None, 'zero', 2, 2, 5, -5), (0, None, 'zero', 2, 2, 0, None), (0, None, 'zero', 2, 2, None, None), (0, None, 'zero', 2, 2, None, 0), (None, None, 'null', 2, 2, 1, -1), (None, None, 'null', 2, 2, 2, 2), (None, None, 'null', 2, 2, 3, -3), (None, None, 'null', 2, 2, 2, 4), (None, None, 'null', 2, 2, 5, -5), (None, None, 'null', 2, 2, 5, -5), (None, None, 'null', 2, 2, 0, None), (None, None, 'null', 2, 2, None, None), (None, None, 'null', 2, 2, None, 0), (None, 0, 'zero', 2, 2, 1, -1), (None, 0, 'zero', 2, 2, 2, 2), (None, 0, 'zero', 2, 2, 3, -3), (None, 0, 'zero', 2, 2, 2, 4), (None, 0, 'zero', 2, 2, 5, -5), (None, 0, 'zero', 2, 2, 5, -5), (None, 0, 'zero', 2, 2, 0, None), (None, 0, 'zero', 2, 2, None, None), (None, 0, 'zero', 2, 2, None, 0), (1, 4, 'one', 3, -3, 1, -1), (1, 4, 'one', 3, -3, 2, 2), (1, 4, 'one', 3, -3, 3, -3), (1, 4, 'one', 3, -3, 2, 4), (1, 4, 'one', 3, -3, 5, -5), (1, 4, 'one', 3, -3, 5, -5), (1, 4, 'one', 3, -3, 0, None), (1, 4, 'one', 3, -3, None, None), (1, 4, 'one', 3, -3, None, 0), (2, 3, 'two', 3, -3, 1, -1), (2, 3, 'two', 3, -3, 2, 2), (2, 3, 'two', 3, -3, 3, -3), (2, 3, 'two', 3, -3, 2, 4), (2, 3, 'two', 3, -3, 5, -5), (2, 3, 'two', 3, -3, 5, -5), (2, 3, 'two', 3, -3, 0, None), (2, 3, 'two', 3, -3, None, None), (2, 3, 'two', 3, -3, None, 0), (3, 2, 'three', 3, -3, 1, -1), (3, 2, 'three', 3, -3, 2, 2), (3, 2, 'three', 3, -3, 3, -3), (3, 2, 'three', 3, -3, 2, 4), (3, 2, 'three', 3, -3, 5, -5), (3, 2, 'three', 3, -3, 5, -5), (3, 2, 'three', 3, -3, 0, None), (3, 2, 'three', 3, -3, None, None), (3, 2, 'three', 3, -3, None, 0), (4, 1, 'four', 3, -3, 1, -1), (4, 1, 'four', 3, -3, 2, 2), (4, 1, 'four', 3, -3, 3, -3), (4, 1, 'four', 3, -3, 2, 4), (4, 1, 'four', 3, -3, 5, -5), (4, 1, 'four', 3, -3, 5, -5), (4, 1, 'four', 3, -3, 0, None), (4, 1, 'four', 3, -3, None, None), (4, 1, 'four', 3, -3, None, 0), (5, 0, 'five', 3, -3, 1, -1), (5, 0, 'five', 3, -3, 2, 2), (5, 0, 'five', 3, -3, 3, -3), (5, 0, 'five', 3, -3, 2, 4), (5, 0, 'five', 3, -3, 5, -5), (5, 0, 'five', 3, -3, 5, -5), (5, 0, 'five', 3, -3, 0, None), (5, 0, 'five', 3, -3, None, None), (5, 0, 'five', 3, -3, None, 0), (6, 6, 'six', 3, -3, 1, -1), (6, 6, 'six', 3, -3, 2, 2), (6, 6, 'six', 3, -3, 3, -3), (6, 6, 'six', 3, -3, 2, 4), (6, 6, 'six', 3, -3, 5, -5), (6, 6, 'six', 3, -3, 5, -5), (6, 6, 'six', 3, -3, 0, None), (6, 6, 'six', 3, -3, None, None), (6, 6, 'six', 3, -3, None, 0), (7, 7, 'seven', 3, -3, 1, -1), (7, 7, 'seven', 3, -3, 2, 2), (7, 7, 'seven', 3, -3, 3, -3), (7, 7, 'seven', 3, -3, 2, 4), (7, 7, 'seven', 3, -3, 5, -5), (7, 7, 'seven', 3, -3, 5, -5), (7, 7, 'seven', 3, -3, 0, None), (7, 7, 'seven', 3, -3, None, None), (7, 7, 'seven', 3, -3, None, 0), (8, 8, 'eight', 3, -3, 1, -1), (8, 8, 'eight', 3, -3, 2, 2), (8, 8, 'eight', 3, -3, 3, -3), (8, 8, 'eight', 3, -3, 2, 4), (8, 8, 'eight', 3, -3, 5, -5), (8, 8, 'eight', 3, -3, 5, -5), (8, 8, 'eight', 3, -3, 0, None), (8, 8, 'eight', 3, -3, None, None), (8, 8, 'eight', 3, -3, None, 0), (0, None, 'zero', 3, -3, 1, -1), (0, None, 'zero', 3, -3, 2, 2), (0, None, 'zero', 3, -3, 3, -3), (0, None, 'zero', 3, -3, 2, 4), (0, None, 'zero', 3, -3, 5, -5), (0, None, 'zero', 3, -3, 5, -5), (0, None, 'zero', 3, -3, 0, None), (0, None, 'zero', 3, -3, None, None), (0, None, 'zero', 3, -3, None, 0), (None, None, 'null', 3, -3, 1, -1), (None, None, 'null', 3, -3, 2, 2), (None, None, 'null', 3, -3, 3, -3), (None, None, 'null', 3, -3, 2, 4), (None, None, 'null', 3, -3, 5, -5), (None, None, 'null', 3, -3, 5, -5), (None, None, 'null', 3, -3, 0, None), (None, None, 'null', 3, -3, None, None), (None, None, 'null', 3, -3, None, 0), (None, 0, 'zero', 3, -3, 1, -1), (None, 0, 'zero', 3, -3, 2, 2), (None, 0, 'zero', 3, -3, 3, -3), (None, 0, 'zero', 3, -3, 2, 4), (None, 0, 'zero', 3, -3, 5, -5), (None, 0, 'zero', 3, -3, 5, -5), (None, 0, 'zero', 3, -3, 0, None), (None, 0, 'zero', 3, -3, None, None), (None, 0, 'zero', 3, -3, None, 0), (1, 4, 'one', 2, 4, 1, -1), (1, 4, 'one', 2, 4, 2, 2), (1, 4, 'one', 2, 4, 3, -3), (1, 4, 'one', 2, 4, 2, 4), (1, 4, 'one', 2, 4, 5, -5), (1, 4, 'one', 2, 4, 5, -5), (1, 4, 'one', 2, 4, 0, None), (1, 4, 'one', 2, 4, None, None), (1, 4, 'one', 2, 4, None, 0), (2, 3, 'two', 2, 4, 1, -1), (2, 3, 'two', 2, 4, 2, 2), (2, 3, 'two', 2, 4, 3, -3), (2, 3, 'two', 2, 4, 2, 4), (2, 3, 'two', 2, 4, 5, -5), (2, 3, 'two', 2, 4, 5, -5), (2, 3, 'two', 2, 4, 0, None), (2, 3, 'two', 2, 4, None, None), (2, 3, 'two', 2, 4, None, 0), (3, 2, 'three', 2, 4, 1, -1), (3, 2, 'three', 2, 4, 2, 2), (3, 2, 'three', 2, 4, 3, -3), (3, 2, 'three', 2, 4, 2, 4), (3, 2, 'three', 2, 4, 5, -5), (3, 2, 'three', 2, 4, 5, -5), (3, 2, 'three', 2, 4, 0, None), (3, 2, 'three', 2, 4, None, None), (3, 2, 'three', 2, 4, None, 0), (4, 1, 'four', 2, 4, 1, -1), (4, 1, 'four', 2, 4, 2, 2), (4, 1, 'four', 2, 4, 3, -3), (4, 1, 'four', 2, 4, 2, 4), (4, 1, 'four', 2, 4, 5, -5), (4, 1, 'four', 2, 4, 5, -5), (4, 1, 'four', 2, 4, 0, None), (4, 1, 'four', 2, 4, None, None), (4, 1, 'four', 2, 4, None, 0), (5, 0, 'five', 2, 4, 1, -1), (5, 0, 'five', 2, 4, 2, 2), (5, 0, 'five', 2, 4, 3, -3), (5, 0, 'five', 2, 4, 2, 4), (5, 0, 'five', 2, 4, 5, -5), (5, 0, 'five', 2, 4, 5, -5), (5, 0, 'five', 2, 4, 0, None), (5, 0, 'five', 2, 4, None, None), (5, 0, 'five', 2, 4, None, 0), (6, 6, 'six', 2, 4, 1, -1), (6, 6, 'six', 2, 4, 2, 2), (6, 6, 'six', 2, 4, 3, -3), (6, 6, 'six', 2, 4, 2, 4), (6, 6, 'six', 2, 4, 5, -5), (6, 6, 'six', 2, 4, 5, -5), (6, 6, 'six', 2, 4, 0, None), (6, 6, 'six', 2, 4, None, None), (6, 6, 'six', 2, 4, None, 0), (7, 7, 'seven', 2, 4, 1, -1), (7, 7, 'seven', 2, 4, 2, 2), (7, 7, 'seven', 2, 4, 3, -3), (7, 7, 'seven', 2, 4, 2, 4), (7, 7, 'seven', 2, 4, 5, -5), (7, 7, 'seven', 2, 4, 5, -5), (7, 7, 'seven', 2, 4, 0, None), (7, 7, 'seven', 2, 4, None, None), (7, 7, 'seven', 2, 4, None, 0), (8, 8, 'eight', 2, 4, 1, -1), (8, 8, 'eight', 2, 4, 2, 2), (8, 8, 'eight', 2, 4, 3, -3), (8, 8, 'eight', 2, 4, 2, 4), (8, 8, 'eight', 2, 4, 5, -5), (8, 8, 'eight', 2, 4, 5, -5), (8, 8, 'eight', 2, 4, 0, None), (8, 8, 'eight', 2, 4, None, None), (8, 8, 'eight', 2, 4, None, 0), (0, None, 'zero', 2, 4, 1, -1), (0, None, 'zero', 2, 4, 2, 2), (0, None, 'zero', 2, 4, 3, -3), (0, None, 'zero', 2, 4, 2, 4), (0, None, 'zero', 2, 4, 5, -5), (0, None, 'zero', 2, 4, 5, -5), (0, None, 'zero', 2, 4, 0, None), (0, None, 'zero', 2, 4, None, None), (0, None, 'zero', 2, 4, None, 0), (None, None, 'null', 2, 4, 1, -1), (None, None, 'null', 2, 4, 2, 2), (None, None, 'null', 2, 4, 3, -3), (None, None, 'null', 2, 4, 2, 4), (None, None, 'null', 2, 4, 5, -5), (None, None, 'null', 2, 4, 5, -5), (None, None, 'null', 2, 4, 0, None), (None, None, 'null', 2, 4, None, None), (None, None, 'null', 2, 4, None, 0), (None, 0, 'zero', 2, 4, 1, -1), (None, 0, 'zero', 2, 4, 2, 2), (None, 0, 'zero', 2, 4, 3, -3), (None, 0, 'zero', 2, 4, 2, 4), (None, 0, 'zero', 2, 4, 5, -5), (None, 0, 'zero', 2, 4, 5, -5), (None, 0, 'zero', 2, 4, 0, None), (None, 0, 'zero', 2, 4, None, None), (None, 0, 'zero', 2, 4, None, 0), (1, 4, 'one', 5, -5, 1, -1), (1, 4, 'one', 5, -5, 2, 2), (1, 4, 'one', 5, -5, 3, -3), (1, 4, 'one', 5, -5, 2, 4), (1, 4, 'one', 5, -5, 5, -5), (1, 4, 'one', 5, -5, 5, -5), (1, 4, 'one', 5, -5, 0, None), (1, 4, 'one', 5, -5, None, None), (1, 4, 'one', 5, -5, None, 0), (2, 3, 'two', 5, -5, 1, -1), (2, 3, 'two', 5, -5, 2, 2), (2, 3, 'two', 5, -5, 3, -3), (2, 3, 'two', 5, -5, 2, 4), (2, 3, 'two', 5, -5, 5, -5), (2, 3, 'two', 5, -5, 5, -5), (2, 3, 'two', 5, -5, 0, None), (2, 3, 'two', 5, -5, None, None), (2, 3, 'two', 5, -5, None, 0), (3, 2, 'three', 5, -5, 1, -1), (3, 2, 'three', 5, -5, 2, 2), (3, 2, 'three', 5, -5, 3, -3), (3, 2, 'three', 5, -5, 2, 4), (3, 2, 'three', 5, -5, 5, -5), (3, 2, 'three', 5, -5, 5, -5), (3, 2, 'three', 5, -5, 0, None), (3, 2, 'three', 5, -5, None, None), (3, 2, 'three', 5, -5, None, 0), (4, 1, 'four', 5, -5, 1, -1), (4, 1, 'four', 5, -5, 2, 2), (4, 1, 'four', 5, -5, 3, -3), (4, 1, 'four', 5, -5, 2, 4), (4, 1, 'four', 5, -5, 5, -5), (4, 1, 'four', 5, -5, 5, -5), (4, 1, 'four', 5, -5, 0, None), (4, 1, 'four', 5, -5, None, None), (4, 1, 'four', 5, -5, None, 0), (5, 0, 'five', 5, -5, 1, -1), (5, 0, 'five', 5, -5, 2, 2), (5, 0, 'five', 5, -5, 3, -3), (5, 0, 'five', 5, -5, 2, 4), (5, 0, 'five', 5, -5, 5, -5), (5, 0, 'five', 5, -5, 5, -5), (5, 0, 'five', 5, -5, 0, None), (5, 0, 'five', 5, -5, None, None), (5, 0, 'five', 5, -5, None, 0), (6, 6, 'six', 5, -5, 1, -1), (6, 6, 'six', 5, -5, 2, 2), (6, 6, 'six', 5, -5, 3, -3), (6, 6, 'six', 5, -5, 2, 4), (6, 6, 'six', 5, -5, 5, -5), (6, 6, 'six', 5, -5, 5, -5), (6, 6, 'six', 5, -5, 0, None), (6, 6, 'six', 5, -5, None, None), (6, 6, 'six', 5, -5, None, 0), (7, 7, 'seven', 5, -5, 1, -1), (7, 7, 'seven', 5, -5, 2, 2), (7, 7, 'seven', 5, -5, 3, -3), (7, 7, 'seven', 5, -5, 2, 4), (7, 7, 'seven', 5, -5, 5, -5), (7, 7, 'seven', 5, -5, 5, -5), (7, 7, 'seven', 5, -5, 0, None), (7, 7, 'seven', 5, -5, None, None), (7, 7, 'seven', 5, -5, None, 0), (8, 8, 'eight', 5, -5, 1, -1), (8, 8, 'eight', 5, -5, 2, 2), (8, 8, 'eight', 5, -5, 3, -3), (8, 8, 'eight', 5, -5, 2, 4), (8, 8, 'eight', 5, -5, 5, -5), (8, 8, 'eight', 5, -5, 5, -5), (8, 8, 'eight', 5, -5, 0, None), (8, 8, 'eight', 5, -5, None, None), (8, 8, 'eight', 5, -5, None, 0), (0, None, 'zero', 5, -5, 1, -1), (0, None, 'zero', 5, -5, 2, 2), (0, None, 'zero', 5, -5, 3, -3), (0, None, 'zero', 5, -5, 2, 4), (0, None, 'zero', 5, -5, 5, -5), (0, None, 'zero', 5, -5, 5, -5), (0, None, 'zero', 5, -5, 0, None), (0, None, 'zero', 5, -5, None, None), (0, None, 'zero', 5, -5, None, 0), (None, None, 'null', 5, -5, 1, -1), (None, None, 'null', 5, -5, 2, 2), (None, None, 'null', 5, -5, 3, -3), (None, None, 'null', 5, -5, 2, 4), (None, None, 'null', 5, -5, 5, -5), (None, None, 'null', 5, -5, 5, -5), (None, None, 'null', 5, -5, 0, None), (None, None, 'null', 5, -5, None, None), (None, None, 'null', 5, -5, None, 0), (None, 0, 'zero', 5, -5, 1, -1), (None, 0, 'zero', 5, -5, 2, 2), (None, 0, 'zero', 5, -5, 3, -3), (None, 0, 'zero', 5, -5, 2, 4), (None, 0, 'zero', 5, -5, 5, -5), (None, 0, 'zero', 5, -5, 5, -5), (None, 0, 'zero', 5, -5, 0, None), (None, 0, 'zero', 5, -5, None, None), (None, 0, 'zero', 5, -5, None, 0), (1, 4, 'one', 5, -5, 1, -1), (1, 4, 'one', 5, -5, 2, 2), (1, 4, 'one', 5, -5, 3, -3), (1, 4, 'one', 5, -5, 2, 4), (1, 4, 'one', 5, -5, 5, -5), (1, 4, 'one', 5, -5, 5, -5), (1, 4, 'one', 5, -5, 0, None), (1, 4, 'one', 5, -5, None, None), (1, 4, 'one', 5, -5, None, 0), (2, 3, 'two', 5, -5, 1, -1), (2, 3, 'two', 5, -5, 2, 2), (2, 3, 'two', 5, -5, 3, -3), (2, 3, 'two', 5, -5, 2, 4), (2, 3, 'two', 5, -5, 5, -5), (2, 3, 'two', 5, -5, 5, -5), (2, 3, 'two', 5, -5, 0, None), (2, 3, 'two', 5, -5, None, None), (2, 3, 'two', 5, -5, None, 0), (3, 2, 'three', 5, -5, 1, -1), (3, 2, 'three', 5, -5, 2, 2), (3, 2, 'three', 5, -5, 3, -3), (3, 2, 'three', 5, -5, 2, 4), (3, 2, 'three', 5, -5, 5, -5), (3, 2, 'three', 5, -5, 5, -5), (3, 2, 'three', 5, -5, 0, None), (3, 2, 'three', 5, -5, None, None), (3, 2, 'three', 5, -5, None, 0), (4, 1, 'four', 5, -5, 1, -1), (4, 1, 'four', 5, -5, 2, 2), (4, 1, 'four', 5, -5, 3, -3), (4, 1, 'four', 5, -5, 2, 4), (4, 1, 'four', 5, -5, 5, -5), (4, 1, 'four', 5, -5, 5, -5), (4, 1, 'four', 5, -5, 0, None), (4, 1, 'four', 5, -5, None, None), (4, 1, 'four', 5, -5, None, 0), (5, 0, 'five', 5, -5, 1, -1), (5, 0, 'five', 5, -5, 2, 2), (5, 0, 'five', 5, -5, 3, -3), (5, 0, 'five', 5, -5, 2, 4), (5, 0, 'five', 5, -5, 5, -5), (5, 0, 'five', 5, -5, 5, -5), (5, 0, 'five', 5, -5, 0, None), (5, 0, 'five', 5, -5, None, None), (5, 0, 'five', 5, -5, None, 0), (6, 6, 'six', 5, -5, 1, -1), (6, 6, 'six', 5, -5, 2, 2), (6, 6, 'six', 5, -5, 3, -3), (6, 6, 'six', 5, -5, 2, 4), (6, 6, 'six', 5, -5, 5, -5), (6, 6, 'six', 5, -5, 5, -5), (6, 6, 'six', 5, -5, 0, None), (6, 6, 'six', 5, -5, None, None), (6, 6, 'six', 5, -5, None, 0), (7, 7, 'seven', 5, -5, 1, -1), (7, 7, 'seven', 5, -5, 2, 2), (7, 7, 'seven', 5, -5, 3, -3), (7, 7, 'seven', 5, -5, 2, 4), (7, 7, 'seven', 5, -5, 5, -5), (7, 7, 'seven', 5, -5, 5, -5), (7, 7, 'seven', 5, -5, 0, None), (7, 7, 'seven', 5, -5, None, None), (7, 7, 'seven', 5, -5, None, 0), (8, 8, 'eight', 5, -5, 1, -1), (8, 8, 'eight', 5, -5, 2, 2), (8, 8, 'eight', 5, -5, 3, -3), (8, 8, 'eight', 5, -5, 2, 4), (8, 8, 'eight', 5, -5, 5, -5), (8, 8, 'eight', 5, -5, 5, -5), (8, 8, 'eight', 5, -5, 0, None), (8, 8, 'eight', 5, -5, None, None), (8, 8, 'eight', 5, -5, None, 0), (0, None, 'zero', 5, -5, 1, -1), (0, None, 'zero', 5, -5, 2, 2), (0, None, 'zero', 5, -5, 3, -3), (0, None, 'zero', 5, -5, 2, 4), (0, None, 'zero', 5, -5, 5, -5), (0, None, 'zero', 5, -5, 5, -5), (0, None, 'zero', 5, -5, 0, None), (0, None, 'zero', 5, -5, None, None), (0, None, 'zero', 5, -5, None, 0), (None, None, 'null', 5, -5, 1, -1), (None, None, 'null', 5, -5, 2, 2), (None, None, 'null', 5, -5, 3, -3), (None, None, 'null', 5, -5, 2, 4), (None, None, 'null', 5, -5, 5, -5), (None, None, 'null', 5, -5, 5, -5), (None, None, 'null', 5, -5, 0, None), (None, None, 'null', 5, -5, None, None), (None, None, 'null', 5, -5, None, 0), (None, 0, 'zero', 5, -5, 1, -1), (None, 0, 'zero', 5, -5, 2, 2), (None, 0, 'zero', 5, -5, 3, -3), (None, 0, 'zero', 5, -5, 2, 4), (None, 0, 'zero', 5, -5, 5, -5), (None, 0, 'zero', 5, -5, 5, -5), (None, 0, 'zero', 5, -5, 0, None), (None, 0, 'zero', 5, -5, None, None), (None, 0, 'zero', 5, -5, None, 0), (1, 4, 'one', 0, None, 1, -1), (1, 4, 'one', 0, None, 2, 2), (1, 4, 'one', 0, None, 3, -3), (1, 4, 'one', 0, None, 2, 4), (1, 4, 'one', 0, None, 5, -5), (1, 4, 'one', 0, None, 5, -5), (1, 4, 'one', 0, None, 0, None), (1, 4, 'one', 0, None, None, None), (1, 4, 'one', 0, None, None, 0), (2, 3, 'two', 0, None, 1, -1), (2, 3, 'two', 0, None, 2, 2), (2, 3, 'two', 0, None, 3, -3), (2, 3, 'two', 0, None, 2, 4), (2, 3, 'two', 0, None, 5, -5), (2, 3, 'two', 0, None, 5, -5), (2, 3, 'two', 0, None, 0, None), (2, 3, 'two', 0, None, None, None), (2, 3, 'two', 0, None, None, 0), (3, 2, 'three', 0, None, 1, -1), (3, 2, 'three', 0, None, 2, 2), (3, 2, 'three', 0, None, 3, -3), (3, 2, 'three', 0, None, 2, 4), (3, 2, 'three', 0, None, 5, -5), (3, 2, 'three', 0, None, 5, -5), (3, 2, 'three', 0, None, 0, None), (3, 2, 'three', 0, None, None, None), (3, 2, 'three', 0, None, None, 0), (4, 1, 'four', 0, None, 1, -1), (4, 1, 'four', 0, None, 2, 2), (4, 1, 'four', 0, None, 3, -3), (4, 1, 'four', 0, None, 2, 4), (4, 1, 'four', 0, None, 5, -5), (4, 1, 'four', 0, None, 5, -5), (4, 1, 'four', 0, None, 0, None), (4, 1, 'four', 0, None, None, None), (4, 1, 'four', 0, None, None, 0), (5, 0, 'five', 0, None, 1, -1), (5, 0, 'five', 0, None, 2, 2), (5, 0, 'five', 0, None, 3, -3), (5, 0, 'five', 0, None, 2, 4), (5, 0, 'five', 0, None, 5, -5), (5, 0, 'five', 0, None, 5, -5), (5, 0, 'five', 0, None, 0, None), (5, 0, 'five', 0, None, None, None), (5, 0, 'five', 0, None, None, 0), (6, 6, 'six', 0, None, 1, -1), (6, 6, 'six', 0, None, 2, 2), (6, 6, 'six', 0, None, 3, -3), (6, 6, 'six', 0, None, 2, 4), (6, 6, 'six', 0, None, 5, -5), (6, 6, 'six', 0, None, 5, -5), (6, 6, 'six', 0, None, 0, None), (6, 6, 'six', 0, None, None, None), (6, 6, 'six', 0, None, None, 0), (7, 7, 'seven', 0, None, 1, -1), (7, 7, 'seven', 0, None, 2, 2), (7, 7, 'seven', 0, None, 3, -3), (7, 7, 'seven', 0, None, 2, 4), (7, 7, 'seven', 0, None, 5, -5), (7, 7, 'seven', 0, None, 5, -5), (7, 7, 'seven', 0, None, 0, None), (7, 7, 'seven', 0, None, None, None), (7, 7, 'seven', 0, None, None, 0), (8, 8, 'eight', 0, None, 1, -1), (8, 8, 'eight', 0, None, 2, 2), (8, 8, 'eight', 0, None, 3, -3), (8, 8, 'eight', 0, None, 2, 4), (8, 8, 'eight', 0, None, 5, -5), (8, 8, 'eight', 0, None, 5, -5), (8, 8, 'eight', 0, None, 0, None), (8, 8, 'eight', 0, None, None, None), (8, 8, 'eight', 0, None, None, 0), (0, None, 'zero', 0, None, 1, -1), (0, None, 'zero', 0, None, 2, 2), (0, None, 'zero', 0, None, 3, -3), (0, None, 'zero', 0, None, 2, 4), (0, None, 'zero', 0, None, 5, -5), (0, None, 'zero', 0, None, 5, -5), (0, None, 'zero', 0, None, 0, None), (0, None, 'zero', 0, None, None, None), (0, None, 'zero', 0, None, None, 0), (None, None, 'null', 0, None, 1, -1), (None, None, 'null', 0, None, 2, 2), (None, None, 'null', 0, None, 3, -3), (None, None, 'null', 0, None, 2, 4), (None, None, 'null', 0, None, 5, -5), (None, None, 'null', 0, None, 5, -5), (None, None, 'null', 0, None, 0, None), (None, None, 'null', 0, None, None, None), (None, None, 'null', 0, None, None, 0), (None, 0, 'zero', 0, None, 1, -1), (None, 0, 'zero', 0, None, 2, 2), (None, 0, 'zero', 0, None, 3, -3), (None, 0, 'zero', 0, None, 2, 4), (None, 0, 'zero', 0, None, 5, -5), (None, 0, 'zero', 0, None, 5, -5), (None, 0, 'zero', 0, None, 0, None), (None, 0, 'zero', 0, None, None, None), (None, 0, 'zero', 0, None, None, 0), (1, 4, 'one', None, None, 1, -1), (1, 4, 'one', None, None, 2, 2), (1, 4, 'one', None, None, 3, -3), (1, 4, 'one', None, None, 2, 4), (1, 4, 'one', None, None, 5, -5), (1, 4, 'one', None, None, 5, -5), (1, 4, 'one', None, None, 0, None), (1, 4, 'one', None, None, None, None), (1, 4, 'one', None, None, None, 0), (2, 3, 'two', None, None, 1, -1), (2, 3, 'two', None, None, 2, 2), (2, 3, 'two', None, None, 3, -3), (2, 3, 'two', None, None, 2, 4), (2, 3, 'two', None, None, 5, -5), (2, 3, 'two', None, None, 5, -5), (2, 3, 'two', None, None, 0, None), (2, 3, 'two', None, None, None, None), (2, 3, 'two', None, None, None, 0), (3, 2, 'three', None, None, 1, -1), (3, 2, 'three', None, None, 2, 2), (3, 2, 'three', None, None, 3, -3), (3, 2, 'three', None, None, 2, 4), (3, 2, 'three', None, None, 5, -5), (3, 2, 'three', None, None, 5, -5), (3, 2, 'three', None, None, 0, None), (3, 2, 'three', None, None, None, None), (3, 2, 'three', None, None, None, 0), (4, 1, 'four', None, None, 1, -1), (4, 1, 'four', None, None, 2, 2), (4, 1, 'four', None, None, 3, -3), (4, 1, 'four', None, None, 2, 4), (4, 1, 'four', None, None, 5, -5), (4, 1, 'four', None, None, 5, -5), (4, 1, 'four', None, None, 0, None), (4, 1, 'four', None, None, None, None), (4, 1, 'four', None, None, None, 0), (5, 0, 'five', None, None, 1, -1), (5, 0, 'five', None, None, 2, 2), (5, 0, 'five', None, None, 3, -3), (5, 0, 'five', None, None, 2, 4), (5, 0, 'five', None, None, 5, -5), (5, 0, 'five', None, None, 5, -5), (5, 0, 'five', None, None, 0, None), (5, 0, 'five', None, None, None, None), (5, 0, 'five', None, None, None, 0), (6, 6, 'six', None, None, 1, -1), (6, 6, 'six', None, None, 2, 2), (6, 6, 'six', None, None, 3, -3), (6, 6, 'six', None, None, 2, 4), (6, 6, 'six', None, None, 5, -5), (6, 6, 'six', None, None, 5, -5), (6, 6, 'six', None, None, 0, None), (6, 6, 'six', None, None, None, None), (6, 6, 'six', None, None, None, 0), (7, 7, 'seven', None, None, 1, -1), (7, 7, 'seven', None, None, 2, 2), (7, 7, 'seven', None, None, 3, -3), (7, 7, 'seven', None, None, 2, 4), (7, 7, 'seven', None, None, 5, -5), (7, 7, 'seven', None, None, 5, -5), (7, 7, 'seven', None, None, 0, None), (7, 7, 'seven', None, None, None, None), (7, 7, 'seven', None, None, None, 0), (8, 8, 'eight', None, None, 1, -1), (8, 8, 'eight', None, None, 2, 2), (8, 8, 'eight', None, None, 3, -3), (8, 8, 'eight', None, None, 2, 4), (8, 8, 'eight', None, None, 5, -5), (8, 8, 'eight', None, None, 5, -5), (8, 8, 'eight', None, None, 0, None), (8, 8, 'eight', None, None, None, None), (8, 8, 'eight', None, None, None, 0), (0, None, 'zero', None, None, 1, -1), (0, None, 'zero', None, None, 2, 2), (0, None, 'zero', None, None, 3, -3), (0, None, 'zero', None, None, 2, 4), (0, None, 'zero', None, None, 5, -5), (0, None, 'zero', None, None, 5, -5), (0, None, 'zero', None, None, 0, None), (0, None, 'zero', None, None, None, None), (0, None, 'zero', None, None, None, 0), (None, None, 'null', None, None, 1, -1), (None, None, 'null', None, None, 2, 2), (None, None, 'null', None, None, 3, -3), (None, None, 'null', None, None, 2, 4), (None, None, 'null', None, None, 5, -5), (None, None, 'null', None, None, 5, -5), (None, None, 'null', None, None, 0, None), (None, None, 'null', None, None, None, None), (None, None, 'null', None, None, None, 0), (None, 0, 'zero', None, None, 1, -1), (None, 0, 'zero', None, None, 2, 2), (None, 0, 'zero', None, None, 3, -3), (None, 0, 'zero', None, None, 2, 4), (None, 0, 'zero', None, None, 5, -5), (None, 0, 'zero', None, None, 5, -5), (None, 0, 'zero', None, None, 0, None), (None, 0, 'zero', None, None, None, None), (None, 0, 'zero', None, None, None, 0), (1, 4, 'one', None, 0, 1, -1), (1, 4, 'one', None, 0, 2, 2), (1, 4, 'one', None, 0, 3, -3), (1, 4, 'one', None, 0, 2, 4), (1, 4, 'one', None, 0, 5, -5), (1, 4, 'one', None, 0, 5, -5), (1, 4, 'one', None, 0, 0, None), (1, 4, 'one', None, 0, None, None), (1, 4, 'one', None, 0, None, 0), (2, 3, 'two', None, 0, 1, -1), (2, 3, 'two', None, 0, 2, 2), (2, 3, 'two', None, 0, 3, -3), (2, 3, 'two', None, 0, 2, 4), (2, 3, 'two', None, 0, 5, -5), (2, 3, 'two', None, 0, 5, -5), (2, 3, 'two', None, 0, 0, None), (2, 3, 'two', None, 0, None, None), (2, 3, 'two', None, 0, None, 0), (3, 2, 'three', None, 0, 1, -1), (3, 2, 'three', None, 0, 2, 2), (3, 2, 'three', None, 0, 3, -3), (3, 2, 'three', None, 0, 2, 4), (3, 2, 'three', None, 0, 5, -5), (3, 2, 'three', None, 0, 5, -5), (3, 2, 'three', None, 0, 0, None), (3, 2, 'three', None, 0, None, None), (3, 2, 'three', None, 0, None, 0), (4, 1, 'four', None, 0, 1, -1), (4, 1, 'four', None, 0, 2, 2), (4, 1, 'four', None, 0, 3, -3), (4, 1, 'four', None, 0, 2, 4), (4, 1, 'four', None, 0, 5, -5), (4, 1, 'four', None, 0, 5, -5), (4, 1, 'four', None, 0, 0, None), (4, 1, 'four', None, 0, None, None), (4, 1, 'four', None, 0, None, 0), (5, 0, 'five', None, 0, 1, -1), (5, 0, 'five', None, 0, 2, 2), (5, 0, 'five', None, 0, 3, -3), (5, 0, 'five', None, 0, 2, 4), (5, 0, 'five', None, 0, 5, -5), (5, 0, 'five', None, 0, 5, -5), (5, 0, 'five', None, 0, 0, None), (5, 0, 'five', None, 0, None, None), (5, 0, 'five', None, 0, None, 0), (6, 6, 'six', None, 0, 1, -1), (6, 6, 'six', None, 0, 2, 2), (6, 6, 'six', None, 0, 3, -3), (6, 6, 'six', None, 0, 2, 4), (6, 6, 'six', None, 0, 5, -5), (6, 6, 'six', None, 0, 5, -5), (6, 6, 'six', None, 0, 0, None), (6, 6, 'six', None, 0, None, None), (6, 6, 'six', None, 0, None, 0), (7, 7, 'seven', None, 0, 1, -1), (7, 7, 'seven', None, 0, 2, 2), (7, 7, 'seven', None, 0, 3, -3), (7, 7, 'seven', None, 0, 2, 4), (7, 7, 'seven', None, 0, 5, -5), (7, 7, 'seven', None, 0, 5, -5), (7, 7, 'seven', None, 0, 0, None), (7, 7, 'seven', None, 0, None, None), (7, 7, 'seven', None, 0, None, 0), (8, 8, 'eight', None, 0, 1, -1), (8, 8, 'eight', None, 0, 2, 2), (8, 8, 'eight', None, 0, 3, -3), (8, 8, 'eight', None, 0, 2, 4), (8, 8, 'eight', None, 0, 5, -5), (8, 8, 'eight', None, 0, 5, -5), (8, 8, 'eight', None, 0, 0, None), (8, 8, 'eight', None, 0, None, None), (8, 8, 'eight', None, 0, None, 0), (0, None, 'zero', None, 0, 1, -1), (0, None, 'zero', None, 0, 2, 2), (0, None, 'zero', None, 0, 3, -3), (0, None, 'zero', None, 0, 2, 4), (0, None, 'zero', None, 0, 5, -5), (0, None, 'zero', None, 0, 5, -5), (0, None, 'zero', None, 0, 0, None), (0, None, 'zero', None, 0, None, None), (0, None, 'zero', None, 0, None, 0), (None, None, 'null', None, 0, 1, -1), (None, None, 'null', None, 0, 2, 2), (None, None, 'null', None, 0, 3, -3), (None, None, 'null', None, 0, 2, 4), (None, None, 'null', None, 0, 5, -5), (None, None, 'null', None, 0, 5, -5), (None, None, 'null', None, 0, 0, None), (None, None, 'null', None, 0, None, None), (None, None, 'null', None, 0, None, 0), (None, 0, 'zero', None, 0, 1, -1), (None, 0, 'zero', None, 0, 2, 2), (None, 0, 'zero', None, 0, 3, -3), (None, 0, 'zero', None, 0, 2, 4), (None, 0, 'zero', None, 0, 5, -5), (None, 0, 'zero', None, 0, 5, -5), (None, 0, 'zero', None, 0, 0, None), (None, 0, 'zero', None, 0, None, None), (None, 0, 'zero', None, 0, None, 0)]

-----------
QUERY:



--
--
-- Inner joins (equi-joins)
--
--

--
-- Inner joins (equi-joins) with USING clause
-- The USING syntax changes the shape of the resulting table
-- by including a column in the USING clause only once in the result.
--

-- Inner equi-join on specified column
SELECT *
  FROM J1_TBL INNER JOIN J2_TBL USING (i);
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (5, 0, 'five', -5), (5, 0, 'five', -5)]

-----------
QUERY:


-- Same as above, slightly different syntax
SELECT *
  FROM J1_TBL JOIN J2_TBL USING (i);
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (5, 0, 'five', -5), (5, 0, 'five', -5)]

-----------
QUERY:


SELECT *
  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, d) USING (a)
  ORDER BY a, d;
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (5, 0, 'five', -5), (5, 0, 'five', -5)]

-----------
QUERY:


SELECT *
  FROM J1_TBL t1 (a, b, c) JOIN J2_TBL t2 (a, b) USING (b)
  ORDER BY b, t1.a;
RESULT:
	postgres: [(0, 5, 'five', None), (0, None, 'zero', None), (2, 3, 'three', 2), (4, 1, 'one', 2)]

-----------
QUERY:


-- test join using aliases
SELECT * FROM J1_TBL JOIN J2_TBL USING (i) WHERE J1_TBL.t = 'one';
RESULT:
	postgres: [(1, 4, 'one', -1)]

-----------
QUERY:
  -- ok
SELECT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
RESULT:
	postgres: [(1, 4, 'one', -1)]

-----------
QUERY:
  -- ok
SELECT * FROM (J1_TBL JOIN J2_TBL USING (i)) AS x WHERE J1_TBL.t = 'one';
RESULT:
	postgres: invalid reference to FROM-clause entry for table "j1_tbl"
LINE 2: ... * FROM (J1_TBL JOIN J2_TBL USING (i)) AS x WHERE J1_TBL.t =...
                                                             ^
DETAIL:  There is an entry for table "j1_tbl", but it cannot be referenced from this part of the query.


-----------
QUERY:
  -- error
SELECT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE x.i = 1;
RESULT:
	postgres: [(1, 4, 'one', -1)]

-----------
QUERY:
  -- ok
SELECT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE x.t = 'one';
RESULT:
	postgres: column x.t does not exist
LINE 2: ...CT * FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE x.t = 'one...
                                                             ^


-----------
QUERY:
  -- error
SELECT * FROM (J1_TBL JOIN J2_TBL USING (i) AS x) AS xx WHERE x.i = 1;
RESULT:
	postgres: missing FROM-clause entry for table "x"
LINE 2: ...ROM (J1_TBL JOIN J2_TBL USING (i) AS x) AS xx WHERE x.i = 1;
                                                               ^


-----------
QUERY:
  -- error (XXX could use better hint)
SELECT * FROM J1_TBL a1 JOIN J2_TBL a2 USING (i) AS a1;
RESULT:
	postgres: table name "a1" specified more than once


-----------
QUERY:
  -- error
SELECT x.* FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
RESULT:
	postgres: [(1,)]

-----------
QUERY:

SELECT ROW(x.*) FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
RESULT:
	postgres: [('(1)',)]

-----------
QUERY:

SELECT row_to_json(x.*) FROM J1_TBL JOIN J2_TBL USING (i) AS x WHERE J1_TBL.t = 'one';
RESULT:
	postgres: [({'i': 1},)]

-----------
QUERY:


--
-- NATURAL JOIN
-- Inner equi-join on all columns with the same name
--

SELECT *
  FROM J1_TBL NATURAL JOIN J2_TBL;
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (5, 0, 'five', -5), (5, 0, 'five', -5)]

-----------
QUERY:


SELECT *
  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (a, d);
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (5, 0, 'five', -5), (5, 0, 'five', -5)]

-----------
QUERY:


SELECT *
  FROM J1_TBL t1 (a, b, c) NATURAL JOIN J2_TBL t2 (d, a);
RESULT:
	postgres: [(0, None, 'zero', None), (2, 3, 'two', 2), (4, 1, 'four', 2)]

-----------
QUERY:


-- mismatch number of columns
-- currently, Postgres will fill in with underlying names
SELECT *
  FROM J1_TBL t1 (a, b) NATURAL JOIN J2_TBL t2 (a);
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (5, 0, 'five', -5), (5, 0, 'five', -5)]

-----------
QUERY:



--
-- Inner joins (equi-joins)
--

SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.i);
RESULT:
	postgres: [(0, None, 'zero', 0, None), (1, 4, 'one', 1, -1), (2, 3, 'two', 2, 2), (2, 3, 'two', 2, 4), (3, 2, 'three', 3, -3), (5, 0, 'five', 5, -5), (5, 0, 'five', 5, -5)]

-----------
QUERY:


SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i = J2_TBL.k);
RESULT:
	postgres: [(0, None, 'zero', None, 0), (2, 3, 'two', 2, 2), (4, 1, 'four', 2, 4)]

-----------
QUERY:



--
-- Non-equi-joins
--

SELECT *
  FROM J1_TBL JOIN J2_TBL ON (J1_TBL.i <= J2_TBL.k);
RESULT:
	postgres: [(1, 4, 'one', 2, 2), (2, 3, 'two', 2, 2), (0, None, 'zero', 2, 2), (1, 4, 'one', 2, 4), (2, 3, 'two', 2, 4), (3, 2, 'three', 2, 4), (4, 1, 'four', 2, 4), (0, None, 'zero', 2, 4), (0, None, 'zero', None, 0)]

-----------
QUERY:



--
-- Outer joins
-- Note that OUTER is a noise word
--

SELECT *
  FROM J1_TBL LEFT OUTER JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (4, 1, 'four', None), (5, 0, 'five', -5), (5, 0, 'five', -5), (6, 6, 'six', None), (7, 7, 'seven', None), (8, 8, 'eight', None), (None, None, 'null', None), (None, 0, 'zero', None)]

-----------
QUERY:


SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (4, 1, 'four', None), (5, 0, 'five', -5), (5, 0, 'five', -5), (6, 6, 'six', None), (7, 7, 'seven', None), (8, 8, 'eight', None), (None, None, 'null', None), (None, 0, 'zero', None)]

-----------
QUERY:


SELECT *
  FROM J1_TBL RIGHT OUTER JOIN J2_TBL USING (i);
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (5, 0, 'five', -5), (5, 0, 'five', -5), (None, None, None, None), (None, None, None, 0)]

-----------
QUERY:


SELECT *
  FROM J1_TBL RIGHT JOIN J2_TBL USING (i);
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (5, 0, 'five', -5), (5, 0, 'five', -5), (None, None, None, None), (None, None, None, 0)]

-----------
QUERY:


SELECT *
  FROM J1_TBL FULL OUTER JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (4, 1, 'four', None), (5, 0, 'five', -5), (5, 0, 'five', -5), (6, 6, 'six', None), (7, 7, 'seven', None), (8, 8, 'eight', None), (None, None, None, 0), (None, None, 'null', None), (None, 0, 'zero', None), (None, None, None, None)]

-----------
QUERY:


SELECT *
  FROM J1_TBL FULL JOIN J2_TBL USING (i)
  ORDER BY i, k, t;
RESULT:
	postgres: [(0, None, 'zero', None), (1, 4, 'one', -1), (2, 3, 'two', 2), (2, 3, 'two', 4), (3, 2, 'three', -3), (4, 1, 'four', None), (5, 0, 'five', -5), (5, 0, 'five', -5), (6, 6, 'six', None), (7, 7, 'seven', None), (8, 8, 'eight', None), (None, None, None, 0), (None, None, 'null', None), (None, 0, 'zero', None), (None, None, None, None)]

-----------
QUERY:


SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (k = 1);
RESULT:
	postgres: []

-----------
QUERY:


SELECT *
  FROM J1_TBL LEFT JOIN J2_TBL USING (i) WHERE (i = 1);
RESULT:
	postgres: [(1, 4, 'one', -1)]

-----------
QUERY:


--
-- semijoin selectivity for <>
--
explain (costs off)
select * from int4_tbl i4, tenk1 a
where exists(select * from tenk1 b
             where a.twothousand = b.twothousand and a.fivethous <> b.fivethous)
      and i4.f1 = a.tenthous;
RESULT:
	postgres: [('Hash Semi Join',), ('  Hash Cond: (a.twothousand = b.twothousand)',), ('  Join Filter: (a.fivethous <> b.fivethous)',), ('  ->  Hash Join',), ('        Hash Cond: (a.tenthous = i4.f1)',), ('        ->  Seq Scan on tenk1 a',), ('        ->  Hash',), ('              ->  Seq Scan on int4_tbl i4',), ('  ->  Hash',), ('        ->  Seq Scan on tenk1 b',)]

-----------
QUERY:



--
-- More complicated constructs
--

--
-- Multiway full join
--

CREATE TABLE t1 (name TEXT, n INTEGER);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE t2 (name TEXT, n INTEGER);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE t3 (name TEXT, n INTEGER);
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO t1 VALUES ( 'bb', 11 );
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t2 VALUES ( 'bb', 12 );
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t2 VALUES ( 'cc', 22 );
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t2 VALUES ( 'ee', 42 );
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t3 VALUES ( 'bb', 13 );
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t3 VALUES ( 'cc', 23 );
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t3 VALUES ( 'dd', 33 );
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM t1 FULL JOIN t2 USING (name) FULL JOIN t3 USING (name);
RESULT:
	postgres: [('bb', 11, 12, 13), ('cc', None, 22, 23), ('dd', None, None, 33), ('ee', None, 42, None)]

-----------
QUERY:


--
-- Test interactions of join syntax and subqueries
--

-- Basic cases (we expect planner to pull up the subquery here)
SELECT * FROM
(SELECT * FROM t2) as s2
INNER JOIN
(SELECT * FROM t3) s3
USING (name);
RESULT:
	postgres: [('bb', 12, 13), ('cc', 22, 23)]

-----------
QUERY:


SELECT * FROM
(SELECT * FROM t2) as s2
LEFT JOIN
(SELECT * FROM t3) s3
USING (name);
RESULT:
	postgres: [('bb', 12, 13), ('cc', 22, 23), ('ee', 42, None)]

-----------
QUERY:


SELECT * FROM
(SELECT * FROM t2) as s2
FULL JOIN
(SELECT * FROM t3) s3
USING (name);
RESULT:
	postgres: [('bb', 12, 13), ('cc', 22, 23), ('dd', None, 33), ('ee', 42, None)]

-----------
QUERY:


-- Cases with non-nullable expressions in subquery results /* REPLACED */,
-- make sure these go to null as expected
SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL INNER JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
RESULT:
	postgres: [('bb', 12, 2, 13, 3), ('cc', 22, 2, 23, 3)]

-----------
QUERY:


SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL LEFT JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
RESULT:
	postgres: [('bb', 12, 2, 13, 3), ('cc', 22, 2, 23, 3), ('ee', 42, 2, None, None)]

-----------
QUERY:


SELECT * FROM
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL FULL JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
RESULT:
	postgres: [('bb', 12, 2, 13, 3), ('cc', 22, 2, 23, 3), ('dd', None, None, 33, 3), ('ee', 42, 2, None, None)]

-----------
QUERY:


SELECT * FROM
(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
NATURAL INNER JOIN
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL INNER JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
RESULT:
	postgres: [('bb', 11, 1, 12, 2, 13, 3)]

-----------
QUERY:


SELECT * FROM
(SELECT name, n as s1_n, 1 as s1_1 FROM t1) as s1
NATURAL FULL JOIN
(SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
NATURAL FULL JOIN
(SELECT name, n as s3_n, 3 as s3_2 FROM t3) s3;
RESULT:
	postgres: [('bb', 11, 1, 12, 2, 13, 3), ('cc', None, None, 22, 2, 23, 3), ('dd', None, None, None, None, 33, 3), ('ee', None, None, 42, 2, None, None)]

-----------
QUERY:


SELECT * FROM
(SELECT name, n as s1_n FROM t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT name, n as s2_n FROM t2) as s2
    NATURAL FULL JOIN
    (SELECT name, n as s3_n FROM t3) as s3
  ) ss2;
RESULT:
	postgres: [('bb', 11, 12, 13), ('cc', None, 22, 23), ('dd', None, None, 33), ('ee', None, 42, None)]

-----------
QUERY:


SELECT * FROM
(SELECT name, n as s1_n FROM t1) as s1
NATURAL FULL JOIN
  (SELECT * FROM
    (SELECT name, n as s2_n, 2 as s2_2 FROM t2) as s2
    NATURAL FULL JOIN
    (SELECT name, n as s3_n FROM t3) as s3
  ) ss2;
RESULT:
	postgres: [('bb', 11, 12, 2, 13), ('cc', None, 22, 2, 23), ('dd', None, None, None, 33), ('ee', None, 42, 2, None)]

-----------
QUERY:


-- Constants as join keys can also be problematic
SELECT * FROM
  (SELECT name, n as s1_n FROM t1) as s1
FULL JOIN
  (SELECT name, 2 as s2_n FROM t2) as s2
ON (s1_n = s2_n);
RESULT:
	postgres: [(None, None, 'bb', 2), (None, None, 'cc', 2), (None, None, 'ee', 2), ('bb', 11, None, None)]

-----------
QUERY:



-- Test for propagation of nullability constraints into sub-joins

create temp table x (x1 int, x2 int);
RESULT:
	postgres: None

-----------
QUERY:

insert into x values (1,11);
RESULT:
	postgres: None

-----------
QUERY:

insert into x values (2,22);
RESULT:
	postgres: None

-----------
QUERY:

insert into x values (3,null);
RESULT:
	postgres: None

-----------
QUERY:

insert into x values (4,44);
RESULT:
	postgres: None

-----------
QUERY:

insert into x values (5,null);
RESULT:
	postgres: None

-----------
QUERY:


create temp table y (y1 int, y2 int);
RESULT:
	postgres: None

-----------
QUERY:

insert into y values (1,111);
RESULT:
	postgres: None

-----------
QUERY:

insert into y values (2,222);
RESULT:
	postgres: None

-----------
QUERY:

insert into y values (3,333);
RESULT:
	postgres: None

-----------
QUERY:

insert into y values (4,null);
RESULT:
	postgres: None

-----------
QUERY:


select * from x;
RESULT:
	postgres: [(1, 11), (2, 22), (3, None), (4, 44), (5, None)]

-----------
QUERY:

select * from y;
RESULT:
	postgres: [(1, 111), (2, 222), (3, 333), (4, None)]

-----------
QUERY:


select * from x left join y on (x1 = y1 and x2 is not null);
RESULT:
	postgres: [(1, 11, 1, 111), (2, 22, 2, 222), (3, None, None, None), (4, 44, 4, None), (5, None, None, None)]

-----------
QUERY:

select * from x left join y on (x1 = y1 and y2 is not null);
RESULT:
	postgres: [(1, 11, 1, 111), (2, 22, 2, 222), (3, None, 3, 333), (4, 44, None, None), (5, None, None, None)]

-----------
QUERY:


select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1);
RESULT:
	postgres: [(1, 11, 1, 111, 1, 11), (2, 22, 2, 222, 2, 22), (3, None, 3, 333, 3, None), (4, 44, 4, None, 4, 44), (5, None, None, None, 5, None)]

-----------
QUERY:

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1 and x2 is not null);
RESULT:
	postgres: [(1, 11, 1, 111, 1, 11), (2, 22, 2, 222, 2, 22), (3, None, 3, 333, None, None), (4, 44, 4, None, 4, 44), (5, None, None, None, None, None)]

-----------
QUERY:

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1 and y2 is not null);
RESULT:
	postgres: [(1, 11, 1, 111, 1, 11), (2, 22, 2, 222, 2, 22), (3, None, 3, 333, 3, None), (4, 44, 4, None, None, None), (5, None, None, None, None, None)]

-----------
QUERY:

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1 and xx2 is not null);
RESULT:
	postgres: [(1, 11, 1, 111, 1, 11), (2, 22, 2, 222, 2, 22), (3, None, 3, 333, None, None), (4, 44, 4, None, 4, 44), (5, None, None, None, None, None)]

-----------
QUERY:

-- these should NOT give the same answers as above
select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1) where (x2 is not null);
RESULT:
	postgres: [(1, 11, 1, 111, 1, 11), (2, 22, 2, 222, 2, 22), (4, 44, 4, None, 4, 44)]

-----------
QUERY:

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1) where (y2 is not null);
RESULT:
	postgres: [(1, 11, 1, 111, 1, 11), (2, 22, 2, 222, 2, 22), (3, None, 3, 333, 3, None)]

-----------
QUERY:

select * from (x left join y on (x1 = y1)) left join x xx(xx1,xx2)
on (x1 = xx1) where (xx2 is not null);
RESULT:
	postgres: [(1, 11, 1, 111, 1, 11), (2, 22, 2, 222, 2, 22), (4, 44, 4, None, 4, 44)]

-----------
QUERY:


--
-- regression test: check for bug with propagation of implied equality
-- to outside an IN
--
select count(*) from tenk1 a where unique1 in
  (select unique1 from tenk1 b join tenk1 c using (unique1)
   where b.unique2 = 42);
RESULT:
	postgres: [(1,)]

-----------
QUERY:


--
-- regression test: check for failure to generate a plan with multiple
-- degenerate IN clauses
--
select count(*) from tenk1 x where
  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
  x.unique1 = 0 and
  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
RESULT:
	postgres: [(1,)]

-----------
QUERY:


-- try that with GEQO too
begin;
RESULT:
	postgres: None

-----------
QUERY:

set geqo = on;
RESULT:
	postgres: None

-----------
QUERY:

set geqo_threshold = 2;
RESULT:
	postgres: None

-----------
QUERY:

select count(*) from tenk1 x where
  x.unique1 in (select a.f1 from int4_tbl a,float8_tbl b where a.f1=b.f1) and
  x.unique1 = 0 and
  x.unique1 in (select aa.f1 from int4_tbl aa,float8_tbl bb where aa.f1=bb.f1);
RESULT:
	postgres: [(1,)]

-----------
QUERY:

rollback;
RESULT:
	postgres: None

-----------
QUERY:


--
-- regression test: be sure we cope with proven-dummy append rels
--
explain (costs off)
select aa, bb, unique1, unique1
  from tenk1 right join b_star on aa = unique1
  where bb < bb and bb is null;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


select aa, bb, unique1, unique1
  from tenk1 right join b_star on aa = unique1
  where bb < bb and bb is null;
RESULT:
	postgres: []

-----------
QUERY:


--
-- regression test: check handling of empty-FROM subquery underneath outer join
--
explain (costs off)
select * from int8_tbl i1 left join (int8_tbl i2 join
  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
order by 1, 2;
RESULT:
	postgres: [('Sort',), ('  Sort Key: i1.q1, i1.q2',), ('  ->  Hash Left Join',), ('        Hash Cond: (i1.q2 = i2.q2)',), ('        ->  Seq Scan on int8_tbl i1',), ('        ->  Hash',), ('              ->  Seq Scan on int8_tbl i2',), ('                    Filter: (q1 = 123)',)]

-----------
QUERY:


select * from int8_tbl i1 left join (int8_tbl i2 join
  (select 123 as x) ss on i2.q1 = x) on i1.q2 = i2.q2
order by 1, 2;
RESULT:
	postgres: [(123, 456, 123, 456, 123), (123, 4567890123456789, 123, 4567890123456789, 123), (4567890123456789, -4567890123456789, None, None, None), (4567890123456789, 123, None, None, None), (4567890123456789, 4567890123456789, 123, 4567890123456789, 123)]

-----------
QUERY:


--
-- regression test: check a case where join_clause_is_movable_into()
-- used to give an imprecise result, causing an assertion failure
--
select count(*)
from
  (select t3.tenthous as x1, coalesce(t1.stringu1, t2.stringu1) as x2
   from tenk1 t1
   left join tenk1 t2 on t1.unique1 = t2.unique1
   join tenk1 t3 on t1.unique2 = t3.unique2) ss,
  tenk1 t4,
  tenk1 t5
where t4.thousand = t5.unique1 and ss.x1 = t4.tenthous and ss.x2 = t5.stringu1;
RESULT:
	postgres: [(1000,)]

-----------
QUERY:


--
-- regression test: check a case where we formerly missed including an EC
-- enforcement clause because it was expected to be handled at scan level
--
explain (costs off)
select a.f1, b.f1, t.thousand, t.tenthous from
  tenk1 t,
  (select sum(f1)+1 as f1 from int4_tbl i4a) a,
  (select sum(f1) as f1 from int4_tbl i4b) b
where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Nested Loop',), ('        Join Filter: ((sum(i4b.f1)) = ((sum(i4a.f1) + 1)))',), ('        ->  Aggregate',), ('              ->  Seq Scan on int4_tbl i4a',), ('        ->  Aggregate',), ('              ->  Seq Scan on int4_tbl i4b',), ('  ->  Index Only Scan using tenk1_thous_tenthous on tenk1 t',), ('        Index Cond: ((thousand = (sum(i4b.f1))) AND (tenthous = ((((sum(i4a.f1) + 1)) + (sum(i4b.f1))) + 999)))',)]

-----------
QUERY:


select a.f1, b.f1, t.thousand, t.tenthous from
  tenk1 t,
  (select sum(f1)+1 as f1 from int4_tbl i4a) a,
  (select sum(f1) as f1 from int4_tbl i4b) b
where b.f1 = t.thousand and a.f1 = b.f1 and (a.f1+b.f1+999) = t.tenthous;
RESULT:
	postgres: []

-----------
QUERY:


--
-- checks for correct handling of quals in multiway outer joins
--
explain (costs off)
select t1.f1
from int4_tbl t1, int4_tbl t2
  left join int4_tbl t3 on t3.f1 > 0
  left join int4_tbl t4 on t3.f1 > 1
where t4.f1 is null;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Nested Loop Left Join',), ('        Filter: (t4.f1 IS NULL)',), ('        ->  Seq Scan on int4_tbl t2',), ('        ->  Materialize',), ('              ->  Nested Loop Left Join',), ('                    Join Filter: (t3.f1 > 1)',), ('                    ->  Seq Scan on int4_tbl t3',), ('                          Filter: (f1 > 0)',), ('                    ->  Materialize',), ('                          ->  Seq Scan on int4_tbl t4',), ('  ->  Seq Scan on int4_tbl t1',)]

-----------
QUERY:


select t1.f1
from int4_tbl t1, int4_tbl t2
  left join int4_tbl t3 on t3.f1 > 0
  left join int4_tbl t4 on t3.f1 > 1
where t4.f1 is null;
RESULT:
	postgres: []

-----------
QUERY:


explain (costs off)
select *
from int4_tbl t1 left join int4_tbl t2 on true
  left join int4_tbl t3 on t2.f1 > 0
  left join int4_tbl t4 on t3.f1 > 0;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on int4_tbl t1',), ('  ->  Materialize',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (t3.f1 > 0)',), ('              ->  Nested Loop Left Join',), ('                    Join Filter: (t2.f1 > 0)',), ('                    ->  Seq Scan on int4_tbl t2',), ('                    ->  Materialize',), ('                          ->  Seq Scan on int4_tbl t3',), ('              ->  Materialize',), ('                    ->  Seq Scan on int4_tbl t4',)]

-----------
QUERY:


explain (costs off)
select * from onek t1
  left join onek t2 on t1.unique1 = t2.unique1
  left join onek t3 on t2.unique1 != t3.unique1
  left join onek t4 on t3.unique1 = t4.unique1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: (t2.unique1 <> t3.unique1)',), ('  ->  Hash Left Join',), ('        Hash Cond: (t1.unique1 = t2.unique1)',), ('        ->  Seq Scan on onek t1',), ('        ->  Hash',), ('              ->  Seq Scan on onek t2',), ('  ->  Materialize',), ('        ->  Hash Left Join',), ('              Hash Cond: (t3.unique1 = t4.unique1)',), ('              ->  Seq Scan on onek t3',), ('              ->  Hash',), ('                    ->  Seq Scan on onek t4',)]

-----------
QUERY:


explain (costs off)
select * from int4_tbl t1
  left join (select now() from int4_tbl t2
             left join int4_tbl t3 on t2.f1 = t3.f1
             left join int4_tbl t4 on t3.f1 = t4.f1) s on true
  inner join int4_tbl t5 on true;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Nested Loop Left Join',), ('        ->  Seq Scan on int4_tbl t1',), ('        ->  Materialize',), ('              ->  Hash Left Join',), ('                    Hash Cond: (t3.f1 = t4.f1)',), ('                    ->  Hash Left Join',), ('                          Hash Cond: (t2.f1 = t3.f1)',), ('                          ->  Seq Scan on int4_tbl t2',), ('                          ->  Hash',), ('                                ->  Seq Scan on int4_tbl t3',), ('                    ->  Hash',), ('                          ->  Seq Scan on int4_tbl t4',), ('  ->  Materialize',), ('        ->  Seq Scan on int4_tbl t5',)]

-----------
QUERY:


explain (costs off)
select * from int4_tbl t1
  left join int4_tbl t2 on true
  left join int4_tbl t3 on true
  left join int4_tbl t4 on t2.f1 = t3.f1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: (t2.f1 = t3.f1)',), ('  ->  Nested Loop Left Join',), ('        ->  Nested Loop Left Join',), ('              ->  Seq Scan on int4_tbl t1',), ('              ->  Materialize',), ('                    ->  Seq Scan on int4_tbl t2',), ('        ->  Materialize',), ('              ->  Seq Scan on int4_tbl t3',), ('  ->  Materialize',), ('        ->  Seq Scan on int4_tbl t4',)]

-----------
QUERY:


explain (costs off)
select * from int4_tbl t1
  left join int4_tbl t2 on true
  left join int4_tbl t3 on t2.f1 = t3.f1
  left join int4_tbl t4 on t3.f1 != t4.f1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on int4_tbl t1',), ('  ->  Materialize',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (t3.f1 <> t4.f1)',), ('              ->  Hash Left Join',), ('                    Hash Cond: (t2.f1 = t3.f1)',), ('                    ->  Seq Scan on int4_tbl t2',), ('                    ->  Hash',), ('                          ->  Seq Scan on int4_tbl t3',), ('              ->  Materialize',), ('                    ->  Seq Scan on int4_tbl t4',)]

-----------
QUERY:


explain (costs off)
select * from int4_tbl t1
  left join (int4_tbl t2 left join int4_tbl t3 on t2.f1 > 0) on t2.f1 > 1
  left join int4_tbl t4 on t2.f1 > 2 and t3.f1 > 3
where t1.f1 = coalesce(t2.f1, 1);
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: ((t2.f1 > 2) AND (t3.f1 > 3))',), ('  ->  Nested Loop Left Join',), ('        Join Filter: (t2.f1 > 0)',), ('        ->  Nested Loop Left Join',), ('              Filter: (t1.f1 = COALESCE(t2.f1, 1))',), ('              ->  Seq Scan on int4_tbl t1',), ('              ->  Materialize',), ('                    ->  Seq Scan on int4_tbl t2',), ('                          Filter: (f1 > 1)',), ('        ->  Seq Scan on int4_tbl t3',), ('  ->  Materialize',), ('        ->  Seq Scan on int4_tbl t4',)]

-----------
QUERY:


explain (costs off)
select * from int4_tbl t1
  left join ((select t2.f1 from int4_tbl t2
                left join int4_tbl t3 on t2.f1 > 0
                where t3.f1 is null) s
             left join tenk1 t4 on s.f1 > 1)
    on s.f1 = t1.f1;
RESULT:
	postgres: [('Hash Right Join',), ('  Hash Cond: (t2.f1 = t1.f1)',), ('  ->  Nested Loop Left Join',), ('        Join Filter: (t2.f1 > 1)',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (t2.f1 > 0)',), ('              Filter: (t3.f1 IS NULL)',), ('              ->  Seq Scan on int4_tbl t2',), ('              ->  Materialize',), ('                    ->  Seq Scan on int4_tbl t3',), ('        ->  Seq Scan on tenk1 t4',), ('  ->  Hash',), ('        ->  Seq Scan on int4_tbl t1',)]

-----------
QUERY:


explain (costs off)
select * from int4_tbl t1
  left join ((select t2.f1 from int4_tbl t2
                left join int4_tbl t3 on t2.f1 > 0
                where t2.f1 <> coalesce(t3.f1, -1)) s
             left join tenk1 t4 on s.f1 > 1)
    on s.f1 = t1.f1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: (t2.f1 > 1)',), ('  ->  Hash Right Join',), ('        Hash Cond: (t2.f1 = t1.f1)',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (t2.f1 > 0)',), ("              Filter: (t2.f1 <> COALESCE(t3.f1, '-1'::integer))",), ('              ->  Seq Scan on int4_tbl t2',), ('              ->  Materialize',), ('                    ->  Seq Scan on int4_tbl t3',), ('        ->  Hash',), ('              ->  Seq Scan on int4_tbl t1',), ('  ->  Materialize',), ('        ->  Seq Scan on tenk1 t4',)]

-----------
QUERY:


explain (costs off)
select * from onek t1
    left join onek t2 on t1.unique1 = t2.unique1
    left join onek t3 on t2.unique1 = t3.unique1
    left join onek t4 on t3.unique1 = t4.unique1 and t2.unique2 = t4.unique2;
RESULT:
	postgres: [('Hash Left Join',), ('  Hash Cond: ((t3.unique1 = t4.unique1) AND (t2.unique2 = t4.unique2))',), ('  ->  Hash Left Join',), ('        Hash Cond: (t2.unique1 = t3.unique1)',), ('        ->  Hash Left Join',), ('              Hash Cond: (t1.unique1 = t2.unique1)',), ('              ->  Seq Scan on onek t1',), ('              ->  Hash',), ('                    ->  Seq Scan on onek t2',), ('        ->  Hash',), ('              ->  Seq Scan on onek t3',), ('  ->  Hash',), ('        ->  Seq Scan on onek t4',)]

-----------
QUERY:


explain (costs off)
select * from int8_tbl t1 left join
    (int8_tbl t2 left join int8_tbl t3 full join int8_tbl t4 on false on false)
    left join int8_tbl t5 on t2.q1 = t5.q1
on t2.q2 = 123;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on int8_tbl t1',), ('  ->  Materialize',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (t2.q1 = t5.q1)',), ('              ->  Nested Loop Left Join',), ('                    Join Filter: false',), ('                    ->  Seq Scan on int8_tbl t2',), ('                          Filter: (q2 = 123)',), ('                    ->  Result',), ('                          One-Time Filter: false',), ('              ->  Seq Scan on int8_tbl t5',)]

-----------
QUERY:


explain (costs off)
select * from int8_tbl t1
    left join int8_tbl t2 on true
    left join lateral
      (select * from int8_tbl t3 where t3.q1 = t2.q1 offset 0) s
      on t2.q1 = 1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on int8_tbl t1',), ('  ->  Materialize',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (t2.q1 = 1)',), ('              ->  Seq Scan on int8_tbl t2',), ('              ->  Seq Scan on int8_tbl t3',), ('                    Filter: (q1 = t2.q1)',)]

-----------
QUERY:


explain (costs off)
select * from int8_tbl t1
    left join int8_tbl t2 on true
    left join lateral
      (select * from generate_series(t2.q1, 100)) s
      on t2.q1 = 1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on int8_tbl t1',), ('  ->  Materialize',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (t2.q1 = 1)',), ('              ->  Seq Scan on int8_tbl t2',), ('              ->  Function Scan on generate_series',)]

-----------
QUERY:


explain (costs off)
select * from int8_tbl t1
    left join int8_tbl t2 on true
    left join lateral
      (select t2.q1 from int8_tbl t3) s
      on t2.q1 = 1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on int8_tbl t1',), ('  ->  Materialize',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (t2.q1 = 1)',), ('              ->  Seq Scan on int8_tbl t2',), ('              ->  Seq Scan on int8_tbl t3',)]

-----------
QUERY:


explain (costs off)
select * from onek t1
    left join onek t2 on true
    left join lateral
      (select * from onek t3 where t3.two = t2.two offset 0) s
      on t2.unique1 = 1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on onek t1',), ('  ->  Materialize',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (t2.unique1 = 1)',), ('              ->  Seq Scan on onek t2',), ('              ->  Memoize',), ('                    Cache Key: t2.two',), ('                    Cache Mode: binary',), ('                    ->  Seq Scan on onek t3',), ('                          Filter: (two = t2.two)',)]

-----------
QUERY:


--
-- check a case where we formerly got confused by conflicting sort orders
-- in redundant merge join path keys
--
explain (costs off)
select * from
  j1_tbl full join
  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl
  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
RESULT:
	postgres: [('Merge Full Join',), ('  Merge Cond: ((j2_tbl.i = j1_tbl.i) AND (j2_tbl.k = j1_tbl.i))',), ('  ->  Sort',), ('        Sort Key: j2_tbl.i DESC, j2_tbl.k',), ('        ->  Seq Scan on j2_tbl',), ('  ->  Sort',), ('        Sort Key: j1_tbl.i DESC',), ('        ->  Seq Scan on j1_tbl',)]

-----------
QUERY:


select * from
  j1_tbl full join
  (select * from j2_tbl order by j2_tbl.i desc, j2_tbl.k asc) j2_tbl
  on j1_tbl.i = j2_tbl.i and j1_tbl.i = j2_tbl.k;
RESULT:
	postgres: [(None, None, None, None, 0), (None, None, None, None, None), (None, 0, 'zero', None, None), (None, None, 'null', None, None), (8, 8, 'eight', None, None), (7, 7, 'seven', None, None), (6, 6, 'six', None, None), (None, None, None, 5, -5), (None, None, None, 5, -5), (5, 0, 'five', None, None), (4, 1, 'four', None, None), (None, None, None, 3, -3), (3, 2, 'three', None, None), (2, 3, 'two', 2, 2), (None, None, None, 2, 4), (None, None, None, 1, -1), (None, None, None, 0, None), (1, 4, 'one', None, None), (0, None, 'zero', None, None)]

-----------
QUERY:


--
-- a different check for handling of redundant sort keys in merge joins
--
explain (costs off)
select count(*) from
  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x
  left join
  (select * from tenk1 y order by y.unique2) y
  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;
RESULT:
	postgres: [('Aggregate',), ('  ->  Merge Left Join',), ('        Merge Cond: (x.thousand = y.unique2)',), ('        Join Filter: ((x.twothousand = y.hundred) AND (x.fivethous = y.unique2))',), ('        ->  Sort',), ('              Sort Key: x.thousand, x.twothousand, x.fivethous',), ('              ->  Seq Scan on tenk1 x',), ('        ->  Materialize',), ('              ->  Index Scan using tenk1_unique2 on tenk1 y',)]

-----------
QUERY:


select count(*) from
  (select * from tenk1 x order by x.thousand, x.twothousand, x.fivethous) x
  left join
  (select * from tenk1 y order by y.unique2) y
  on x.thousand = y.unique2 and x.twothousand = y.hundred and x.fivethous = y.unique2;
RESULT:
	postgres: [(10000,)]

-----------
QUERY:


set enable_hashjoin = 0;
RESULT:
	postgres: None

-----------
QUERY:

set enable_nestloop = 0;
RESULT:
	postgres: None

-----------
QUERY:

set enable_hashagg = 0;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Check that we use the pathkeys from a prefix of the group by / order by
-- clause for the join pathkeys when that prefix covers all join quals.  We
-- expect this to lead to an incremental sort for the group by / order by.
--
explain (costs off)
select x.thousand, x.twothousand, count(*)
from tenk1 x inner join tenk1 y on x.thousand = y.thousand
group by x.thousand, x.twothousand
order by x.thousand desc, x.twothousand;
RESULT:
	postgres: [('GroupAggregate',), ('  Group Key: x.thousand, x.twothousand',), ('  ->  Incremental Sort',), ('        Sort Key: x.thousand DESC, x.twothousand',), ('        Presorted Key: x.thousand',), ('        ->  Merge Join',), ('              Merge Cond: (y.thousand = x.thousand)',), ('              ->  Index Only Scan Backward using tenk1_thous_tenthous on tenk1 y',), ('              ->  Sort',), ('                    Sort Key: x.thousand DESC',), ('                    ->  Seq Scan on tenk1 x',)]

-----------
QUERY:


reset enable_hashagg;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_nestloop;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_hashjoin;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Clean up
--

DROP TABLE t1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE t2;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE t3;
RESULT:
	postgres: None

-----------
QUERY:


DROP TABLE J1_TBL;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE J2_TBL;
RESULT:
	postgres: None

-----------
QUERY:


-- Both DELETE and UPDATE allow the specification of additional tables
-- to /* REPLACED */''join/* REPLACED */'' against to determine which rows should be modified.

CREATE TEMP TABLE t1 (a int, b int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEMP TABLE t2 (a int, b int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEMP TABLE t3 (x int, y int);
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO t1 VALUES (5, 10);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t1 VALUES (15, 20);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t1 VALUES (100, 100);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t1 VALUES (200, 1000);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t2 VALUES (200, 2000);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t3 VALUES (5, 20);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t3 VALUES (6, 7);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t3 VALUES (7, 8);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t3 VALUES (500, 100);
RESULT:
	postgres: None

-----------
QUERY:


DELETE FROM t3 USING t1 table1 WHERE t3.x = table1.a;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM t3;
RESULT:
	postgres: [(6, 7), (7, 8), (500, 100)]

-----------
QUERY:

DELETE FROM t3 USING t1 JOIN t2 USING (a) WHERE t3.x > t1.a;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM t3;
RESULT:
	postgres: [(6, 7), (7, 8)]

-----------
QUERY:

DELETE FROM t3 USING t3 t3_other WHERE t3.x = t3_other.x AND t3.y = t3_other.y;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM t3;
RESULT:
	postgres: []

-----------
QUERY:


-- Test join against inheritance tree

create temp table t2a () inherits (t2);
RESULT:
	postgres: None

-----------
QUERY:


insert into t2a values (200, 2001);
RESULT:
	postgres: None

-----------
QUERY:


select * from t1 left join t2 on (t1.a = t2.a);
RESULT:
	postgres: [(5, 10, None, None), (15, 20, None, None), (100, 100, None, None), (200, 1000, 200, 2000), (200, 1000, 200, 2001)]

-----------
QUERY:


-- Test matching of column name with wrong alias

select t1.x from t1 join t3 on (t1.a = t3.x);
RESULT:
	postgres: column t1.x does not exist
LINE 5: select t1.x from t1 join t3 on (t1.a = t3.x);
               ^
HINT:  Perhaps you meant to reference the column "t3.x".


-----------
QUERY:


-- Test matching of locking clause with wrong alias

select t1.*, t2.*, unnamed_join.* from
  t1 join t2 on (t1.a = t2.a), t3 as unnamed_join
  for update of unnamed_join;
RESULT:
	postgres: []

-----------
QUERY:


select foo.*, unnamed_join.* from
  t1 join t2 using (a) as foo, t3 as unnamed_join
  for update of unnamed_join;
RESULT:
	postgres: []

-----------
QUERY:


select foo.*, unnamed_join.* from
  t1 join t2 using (a) as foo, t3 as unnamed_join
  for update of foo;
RESULT:
	postgres: FOR UPDATE cannot be applied to a join
LINE 5:   for update of foo;
                        ^


-----------
QUERY:


select bar.*, unnamed_join.* from
  (t1 join t2 using (a) as foo) as bar, t3 as unnamed_join
  for update of foo;
RESULT:
	postgres: relation "foo" in FOR UPDATE clause not found in FROM clause
LINE 5:   for update of foo;
                        ^


-----------
QUERY:


select bar.*, unnamed_join.* from
  (t1 join t2 using (a) as foo) as bar, t3 as unnamed_join
  for update of bar;
RESULT:
	postgres: FOR UPDATE cannot be applied to a join
LINE 5:   for update of bar;
                        ^


-----------
QUERY:


--
-- regression test for 8.1 merge right join bug
--

CREATE TEMP TABLE tt1 ( tt1_id int4, joincol int4 );
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO tt1 VALUES (1, 11);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO tt1 VALUES (2, NULL);
RESULT:
	postgres: None

-----------
QUERY:


CREATE TEMP TABLE tt2 ( tt2_id int4, joincol int4 );
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO tt2 VALUES (21, 11);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO tt2 VALUES (22, 11);
RESULT:
	postgres: None

-----------
QUERY:


set enable_hashjoin to off;
RESULT:
	postgres: None

-----------
QUERY:

set enable_nestloop to off;
RESULT:
	postgres: None

-----------
QUERY:


-- these should give the same results

select tt1.*, tt2.* from tt1 left join tt2 on tt1.joincol = tt2.joincol;
RESULT:
	postgres: [(1, 11, 21, 11), (1, 11, 22, 11), (2, None, None, None)]

-----------
QUERY:


select tt1.*, tt2.* from tt2 right join tt1 on tt1.joincol = tt2.joincol;
RESULT:
	postgres: [(1, 11, 21, 11), (1, 11, 22, 11), (2, None, None, None)]

-----------
QUERY:


reset enable_hashjoin;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_nestloop;
RESULT:
	postgres: None

-----------
QUERY:


--
-- regression test for bug #13908 (hash join with skew tuples & nbatch increase)
--

set work_mem to '64kB';
RESULT:
	postgres: None

-----------
QUERY:

set enable_mergejoin to off;
RESULT:
	postgres: None

-----------
QUERY:

set enable_memoize to off;
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select count(*) from tenk1 a, tenk1 b
  where a.hundred = b.thousand and (b.fivethous % 10) < 10;
RESULT:
	postgres: [('Aggregate',), ('  ->  Hash Join',), ('        Hash Cond: (a.hundred = b.thousand)',), ('        ->  Index Only Scan using tenk1_hundred on tenk1 a',), ('        ->  Hash',), ('              ->  Seq Scan on tenk1 b',), ('                    Filter: ((fivethous % 10) < 10)',)]

-----------
QUERY:

select count(*) from tenk1 a, tenk1 b
  where a.hundred = b.thousand and (b.fivethous % 10) < 10;
RESULT:
	postgres: [(100000,)]

-----------
QUERY:


reset work_mem;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_mergejoin;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_memoize;
RESULT:
	postgres: None

-----------
QUERY:


--
-- regression test for 8.2 bug with improper re-ordering of left joins
--

create temp table tt3(f1 int, f2 text);
RESULT:
	postgres: None

-----------
QUERY:

insert into tt3 select x, repeat('xyzzy', 100) from generate_series(1,10000) x;
RESULT:
	postgres: None

-----------
QUERY:

analyze tt3;
RESULT:
	postgres: None

-----------
QUERY:


create temp table tt4(f1 int);
RESULT:
	postgres: None

-----------
QUERY:

insert into tt4 values (0),(1),(9999);
RESULT:
	postgres: None

-----------
QUERY:

analyze tt4;
RESULT:
	postgres: None

-----------
QUERY:


set enable_nestloop to off;
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT a.f1
FROM tt4 a
LEFT JOIN (
        SELECT b.f1
        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)
        WHERE COALESCE(c.f1, 0) = 0
) AS d ON (a.f1 = d.f1)
WHERE COALESCE(d.f1, 0) = 0
ORDER BY 1;
RESULT:
	postgres: [('Sort',), ('  Sort Key: a.f1',), ('  ->  Hash Right Join',), ('        Hash Cond: (b.f1 = a.f1)',), ('        Filter: (COALESCE(b.f1, 0) = 0)',), ('        ->  Hash Left Join',), ('              Hash Cond: (b.f1 = c.f1)',), ('              Filter: (COALESCE(c.f1, 0) = 0)',), ('              ->  Seq Scan on tt3 b',), ('              ->  Hash',), ('                    ->  Seq Scan on tt3 c',), ('        ->  Hash',), ('              ->  Seq Scan on tt4 a',)]

-----------
QUERY:


SELECT a.f1
FROM tt4 a
LEFT JOIN (
        SELECT b.f1
        FROM tt3 b LEFT JOIN tt3 c ON (b.f1 = c.f1)
        WHERE COALESCE(c.f1, 0) = 0
) AS d ON (a.f1 = d.f1)
WHERE COALESCE(d.f1, 0) = 0
ORDER BY 1;
RESULT:
	postgres: [(0,), (1,), (9999,)]

-----------
QUERY:


reset enable_nestloop;
RESULT:
	postgres: None

-----------
QUERY:


--
-- basic semijoin and antijoin recognition tests
--

explain (costs off)
select a.* from tenk1 a
where unique1 in (select unique2 from tenk1 b);
RESULT:
	postgres: [('Hash Semi Join',), ('  Hash Cond: (a.unique1 = b.unique2)',), ('  ->  Seq Scan on tenk1 a',), ('  ->  Hash',), ('        ->  Index Only Scan using tenk1_unique2 on tenk1 b',)]

-----------
QUERY:


-- sadly, this is not an antijoin
explain (costs off)
select a.* from tenk1 a
where unique1 not in (select unique2 from tenk1 b);
RESULT:
	postgres: [('Seq Scan on tenk1 a',), ('  Filter: (NOT (ANY (unique1 = (hashed SubPlan 1).col1)))',), ('  SubPlan 1',), ('    ->  Index Only Scan using tenk1_unique2 on tenk1 b',)]

-----------
QUERY:


explain (costs off)
select a.* from tenk1 a
where exists (select 1 from tenk1 b where a.unique1 = b.unique2);
RESULT:
	postgres: [('Hash Semi Join',), ('  Hash Cond: (a.unique1 = b.unique2)',), ('  ->  Seq Scan on tenk1 a',), ('  ->  Hash',), ('        ->  Index Only Scan using tenk1_unique2 on tenk1 b',)]

-----------
QUERY:


explain (costs off)
select a.* from tenk1 a
where not exists (select 1 from tenk1 b where a.unique1 = b.unique2);
RESULT:
	postgres: [('Hash Anti Join',), ('  Hash Cond: (a.unique1 = b.unique2)',), ('  ->  Seq Scan on tenk1 a',), ('  ->  Hash',), ('        ->  Index Only Scan using tenk1_unique2 on tenk1 b',)]

-----------
QUERY:


explain (costs off)
select a.* from tenk1 a left join tenk1 b on a.unique1 = b.unique2
where b.unique2 is null;
RESULT:
	postgres: [('Hash Anti Join',), ('  Hash Cond: (a.unique1 = b.unique2)',), ('  ->  Seq Scan on tenk1 a',), ('  ->  Hash',), ('        ->  Index Only Scan using tenk1_unique2 on tenk1 b',)]

-----------
QUERY:


--
-- regression test for proper handling of outer joins within antijoins
--

create temp table tt4x(c1 int, c2 int, c3 int);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select * from tt4x t1
where not exists (
  select 1 from tt4x t2
    left join tt4x t3 on t2.c3 = t3.c1
    left join ( select t5.c1 as c1
                from tt4x t4 left join tt4x t5 on t4.c2 = t5.c1
              ) a1 on t3.c2 = a1.c1
  where t1.c1 = t2.c2
);
RESULT:
	postgres: [('Hash Anti Join',), ('  Hash Cond: (t1.c1 = t2.c2)',), ('  ->  Seq Scan on tt4x t1',), ('  ->  Hash',), ('        ->  Merge Right Join',), ('              Merge Cond: (t5.c1 = t3.c2)',), ('              ->  Merge Join',), ('                    Merge Cond: (t4.c2 = t5.c1)',), ('                    ->  Sort',), ('                          Sort Key: t4.c2',), ('                          ->  Seq Scan on tt4x t4',), ('                    ->  Sort',), ('                          Sort Key: t5.c1',), ('                          ->  Seq Scan on tt4x t5',), ('              ->  Sort',), ('                    Sort Key: t3.c2',), ('                    ->  Merge Left Join',), ('                          Merge Cond: (t2.c3 = t3.c1)',), ('                          ->  Sort',), ('                                Sort Key: t2.c3',), ('                                ->  Seq Scan on tt4x t2',), ('                          ->  Sort',), ('                                Sort Key: t3.c1',), ('                                ->  Seq Scan on tt4x t3',)]

-----------
QUERY:


--
-- regression test for problems of the sort depicted in bug #3494
--

create temp table tt5(f1 int, f2 int);
RESULT:
	postgres: None

-----------
QUERY:

create temp table tt6(f1 int, f2 int);
RESULT:
	postgres: None

-----------
QUERY:


insert into tt5 values(1, 10);
RESULT:
	postgres: None

-----------
QUERY:

insert into tt5 values(1, 11);
RESULT:
	postgres: None

-----------
QUERY:


insert into tt6 values(1, 9);
RESULT:
	postgres: None

-----------
QUERY:

insert into tt6 values(1, 2);
RESULT:
	postgres: None

-----------
QUERY:

insert into tt6 values(2, 9);
RESULT:
	postgres: None

-----------
QUERY:


select * from tt5,tt6 where tt5.f1 = tt6.f1 and tt5.f1 = tt5.f2 - tt6.f2;
RESULT:
	postgres: [(1, 10, 1, 9)]

-----------
QUERY:


--
-- regression test for problems of the sort depicted in bug #3588
--

create temp table xx (pkxx int);
RESULT:
	postgres: None

-----------
QUERY:

create temp table yy (pkyy int, pkxx int);
RESULT:
	postgres: None

-----------
QUERY:


insert into xx values (1);
RESULT:
	postgres: None

-----------
QUERY:

insert into xx values (2);
RESULT:
	postgres: None

-----------
QUERY:

insert into xx values (3);
RESULT:
	postgres: None

-----------
QUERY:


insert into yy values (101, 1);
RESULT:
	postgres: None

-----------
QUERY:

insert into yy values (201, 2);
RESULT:
	postgres: None

-----------
QUERY:

insert into yy values (301, NULL);
RESULT:
	postgres: None

-----------
QUERY:


select yy.pkyy as yy_pkyy, yy.pkxx as yy_pkxx, yya.pkyy as yya_pkyy,
       xxa.pkxx as xxa_pkxx, xxb.pkxx as xxb_pkxx
from yy
     left join (SELECT * FROM yy where pkyy = 101) as yya ON yy.pkyy = yya.pkyy
     left join xx xxa on yya.pkxx = xxa.pkxx
     left join xx xxb on coalesce (xxa.pkxx, 1) = xxb.pkxx;
RESULT:
	postgres: [(101, 1, 101, 1, 1), (201, 2, None, None, 1), (301, None, None, None, 1)]

-----------
QUERY:


--
-- regression test for improper pushing of constants across outer-join clauses
-- (as seen in early 8.2.x releases)
--

create temp table zt1 (f1 int primary key);
RESULT:
	postgres: None

-----------
QUERY:

create temp table zt2 (f2 int primary key);
RESULT:
	postgres: None

-----------
QUERY:

create temp table zt3 (f3 int primary key);
RESULT:
	postgres: None

-----------
QUERY:

insert into zt1 values(53);
RESULT:
	postgres: None

-----------
QUERY:

insert into zt2 values(53);
RESULT:
	postgres: None

-----------
QUERY:


select * from
  zt2 left join zt3 on (f2 = f3)
      left join zt1 on (f3 = f1)
where f2 = 53;
RESULT:
	postgres: [(53, None, None)]

-----------
QUERY:


create temp view zv1 as select *,'dummy'::text AS junk from zt1;
RESULT:
	postgres: None

-----------
QUERY:


select * from
  zt2 left join zt3 on (f2 = f3)
      left join zv1 on (f3 = f1)
where f2 = 53;
RESULT:
	postgres: [(53, None, None, None)]

-----------
QUERY:


--
-- regression test for improper extraction of OR indexqual conditions
-- (as seen in early 8.3.x releases)
--

select a.unique2, a.ten, b.tenthous, b.unique2, b.hundred
from tenk1 a left join tenk1 b on a.unique2 = b.tenthous
where a.unique1 = 42 and
      ((b.unique2 is null and a.ten = 2) or b.hundred = 3);
RESULT:
	postgres: []

-----------
QUERY:


--
-- test proper positioning of one-time quals in EXISTS (8.4devel bug)
--
prepare foo(bool) as
  select count(*) from tenk1 a left join tenk1 b
    on (a.unique2 = b.unique1 and exists
        (select 1 from tenk1 c where c.thousand = b.unique2 and $1));
RESULT:
	postgres: None

-----------
QUERY:

execute foo(true);
RESULT:
	postgres: [(10000,)]

-----------
QUERY:

execute foo(false);
RESULT:
	postgres: [(10000,)]

-----------
QUERY:


--
-- test for sane behavior with noncanonical merge clauses, per bug #4926
--

begin;
RESULT:
	postgres: None

-----------
QUERY:


set enable_mergejoin = 1;
RESULT:
	postgres: None

-----------
QUERY:

set enable_hashjoin = 0;
RESULT:
	postgres: None

-----------
QUERY:

set enable_nestloop = 0;
RESULT:
	postgres: None

-----------
QUERY:


create temp table a (i integer);
RESULT:
	postgres: None

-----------
QUERY:

create temp table b (x integer, y integer);
RESULT:
	postgres: None

-----------
QUERY:


select * from a left join b on i = x and i = y and x = i;
RESULT:
	postgres: []

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


--
-- test handling of merge clauses using record_ops
--
begin;
RESULT:
	postgres: None

-----------
QUERY:


create type mycomptype as (id int, v bigint);
RESULT:
	postgres: None

-----------
QUERY:


create temp table tidv (idv mycomptype);
RESULT:
	postgres: None

-----------
QUERY:

create index on tidv (idv);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
RESULT:
	postgres: [('Merge Join',), ('  Merge Cond: (a.idv = b.idv)',), ('  ->  Index Only Scan using tidv_idv_idx on tidv a',), ('  ->  Materialize',), ('        ->  Index Only Scan using tidv_idv_idx on tidv b',)]

-----------
QUERY:


set enable_mergejoin = 0;
RESULT:
	postgres: None

-----------
QUERY:

set enable_hashjoin = 0;
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select a.idv, b.idv from tidv a, tidv b where a.idv = b.idv;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Seq Scan on tidv a',), ('  ->  Index Only Scan using tidv_idv_idx on tidv b',), ('        Index Cond: (idv = a.idv)',)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


--
-- test NULL behavior of whole-row Vars, per bug #5025
--
select t1.q2, count(t2.*)
from int8_tbl t1 left join int8_tbl t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
RESULT:
	postgres: [(-4567890123456789, 0), (123, 2), (456, 0), (4567890123456789, 6)]

-----------
QUERY:


select t1.q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
RESULT:
	postgres: [(-4567890123456789, 0), (123, 2), (456, 0), (4567890123456789, 6)]

-----------
QUERY:


select t1.q2, count(t2.*)
from int8_tbl t1 left join (select * from int8_tbl offset 0) t2 on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
RESULT:
	postgres: [(-4567890123456789, 0), (123, 2), (456, 0), (4567890123456789, 6)]

-----------
QUERY:


select t1.q2, count(t2.*)
from int8_tbl t1 left join
  (select q1, case when q2=1 then 1 else q2 end as q2 from int8_tbl) t2
  on (t1.q2 = t2.q1)
group by t1.q2 order by 1;
RESULT:
	postgres: [(-4567890123456789, 0), (123, 2), (456, 0), (4567890123456789, 6)]

-----------
QUERY:


--
-- test incorrect failure to NULL pulled-up subexpressions
--
begin;
RESULT:
	postgres: None

-----------
QUERY:


create temp table a (
     code char not null,
     constraint a_pk primary key (code)
);
RESULT:
	postgres: None

-----------
QUERY:

create temp table b (
     a char not null,
     num integer not null,
     constraint b_pk primary key (a, num)
);
RESULT:
	postgres: None

-----------
QUERY:

create temp table c (
     name char not null,
     a char,
     constraint c_pk primary key (name)
);
RESULT:
	postgres: None

-----------
QUERY:


insert into a (code) values ('p');
RESULT:
	postgres: None

-----------
QUERY:

insert into a (code) values ('q');
RESULT:
	postgres: None

-----------
QUERY:

insert into b (a, num) values ('p', 1);
RESULT:
	postgres: None

-----------
QUERY:

insert into b (a, num) values ('p', 2);
RESULT:
	postgres: None

-----------
QUERY:

insert into c (name, a) values ('A', 'p');
RESULT:
	postgres: None

-----------
QUERY:

insert into c (name, a) values ('B', 'q');
RESULT:
	postgres: None

-----------
QUERY:

insert into c (name, a) values ('C', null);
RESULT:
	postgres: None

-----------
QUERY:


select c.name, ss.code, ss.b_cnt, ss.const
from c left join
  (select a.code, coalesce(b_grp.cnt, 0) as b_cnt, -1 as const
   from a left join
     (select count(1) as cnt, b.a from b group by b.a) as b_grp
     on a.code = b_grp.a
  ) as ss
  on (c.a = ss.code)
order by c.name;
RESULT:
	postgres: [('A', 'p', 2, -1), ('B', 'q', 0, -1), ('C', None, None, None)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


--
-- test incorrect handling of placeholders that only appear in targetlists,
-- per bug #6154
--
SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, sub4.value2, COALESCE(sub4.value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
RESULT:
	postgres: [(1, 1, 1, 1)]

-----------
QUERY:


-- test the path using join aliases, too
SELECT * FROM
( SELECT 1 as key1 ) sub1
LEFT JOIN
( SELECT sub3.key3, value2, COALESCE(value2, 66) as value3 FROM
    ( SELECT 1 as key3 ) sub3
    LEFT JOIN
    ( SELECT sub5.key5, COALESCE(sub6.value1, 1) as value2 FROM
        ( SELECT 1 as key5 ) sub5
        LEFT JOIN
        ( SELECT 2 as key6, 42 as value1 ) sub6
        ON sub5.key5 = sub6.key6
    ) sub4
    ON sub4.key5 = sub3.key3
) sub2
ON sub1.key1 = sub2.key3;
RESULT:
	postgres: [(1, 1, 1, 1)]

-----------
QUERY:


--
-- test case where a PlaceHolderVar is used as a nestloop parameter
--

EXPLAIN (COSTS OFF)
SELECT qq, unique1
  FROM
  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
  FULL OUTER JOIN
  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
  USING (qq)
  INNER JOIN tenk1 c ON qq = unique2;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Hash Full Join',), ("        Hash Cond: ((COALESCE(a.q1, '0'::bigint)) = (COALESCE(b.q2, '-1'::bigint)))",), ('        ->  Seq Scan on int8_tbl a',), ('        ->  Hash',), ('              ->  Seq Scan on int8_tbl b',), ('  ->  Index Scan using tenk1_unique2 on tenk1 c',), ("        Index Cond: (unique2 = COALESCE((COALESCE(a.q1, '0'::bigint)), (COALESCE(b.q2, '-1'::bigint))))",)]

-----------
QUERY:


SELECT qq, unique1
  FROM
  ( SELECT COALESCE(q1, 0) AS qq FROM int8_tbl a ) AS ss1
  FULL OUTER JOIN
  ( SELECT COALESCE(q2, -1) AS qq FROM int8_tbl b ) AS ss2
  USING (qq)
  INNER JOIN tenk1 c ON qq = unique2;
RESULT:
	postgres: [(123, 4596), (123, 4596), (456, 7318)]

-----------
QUERY:


--
-- nested nestloops can require nested PlaceHolderVars
--

create temp table nt1 (
  id int primary key,
  a1 boolean,
  a2 boolean
);
RESULT:
	postgres: None

-----------
QUERY:

create temp table nt2 (
  id int primary key,
  nt1_id int,
  b1 boolean,
  b2 boolean,
  foreign key (nt1_id) references nt1(id)
);
RESULT:
	postgres: None

-----------
QUERY:

create temp table nt3 (
  id int primary key,
  nt2_id int,
  c1 boolean,
  foreign key (nt2_id) references nt2(id)
);
RESULT:
	postgres: None

-----------
QUERY:


insert into nt1 values (1,true,true);
RESULT:
	postgres: None

-----------
QUERY:

insert into nt1 values (2,true,false);
RESULT:
	postgres: None

-----------
QUERY:

insert into nt1 values (3,false,false);
RESULT:
	postgres: None

-----------
QUERY:

insert into nt2 values (1,1,true,true);
RESULT:
	postgres: None

-----------
QUERY:

insert into nt2 values (2,2,true,false);
RESULT:
	postgres: None

-----------
QUERY:

insert into nt2 values (3,3,false,false);
RESULT:
	postgres: None

-----------
QUERY:

insert into nt3 values (1,1,true);
RESULT:
	postgres: None

-----------
QUERY:

insert into nt3 values (2,2,false);
RESULT:
	postgres: None

-----------
QUERY:

insert into nt3 values (3,3,true);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 and ss1.a3) AS b3
     from nt2 as nt2
       left join
         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
         on ss1.id = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Nested Loop',), ('        ->  Index Scan using nt3_pkey on nt3',), ('              Index Cond: (id = 1)',), ('        ->  Index Scan using nt2_pkey on nt2',), ('              Index Cond: (id = nt3.nt2_id)',), ('  ->  Index Only Scan using nt1_pkey on nt1',), ('        Index Cond: (id = nt2.nt1_id)',), ('        Filter: (nt2.b1 AND (id IS NOT NULL))',)]

-----------
QUERY:


select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 and ss1.a3) AS b3
     from nt2 as nt2
       left join
         (select nt1.*, (nt1.id is not null) as a3 from nt1) as ss1
         on ss1.id = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
RESULT:
	postgres: [(1,)]

-----------
QUERY:


--
-- test case where a PlaceHolderVar is propagated into a subquery
--

explain (costs off)
select * from
  int8_tbl t1 left join
  (select q1 as x, 42 as y from int8_tbl t2) ss
  on t1.q2 = ss.x
where
  1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
order by 1,2;
RESULT:
	postgres: [('Sort',), ('  Sort Key: t1.q1, t1.q2',), ('  ->  Hash Left Join',), ('        Hash Cond: (t1.q2 = t2.q1)',), ('        Filter: (1 = (SubPlan 1))',), ('        ->  Seq Scan on int8_tbl t1',), ('        ->  Hash',), ('              ->  Seq Scan on int8_tbl t2',), ('        SubPlan 1',), ('          ->  Limit',), ('                ->  Result',), ('                      One-Time Filter: ((42) IS NOT NULL)',), ('                      ->  Seq Scan on int8_tbl t3',)]

-----------
QUERY:


select * from
  int8_tbl t1 left join
  (select q1 as x, 42 as y from int8_tbl t2) ss
  on t1.q2 = ss.x
where
  1 = (select 1 from int8_tbl t3 where ss.y is not null limit 1)
order by 1,2;
RESULT:
	postgres: [(123, 4567890123456789, 4567890123456789, 42), (123, 4567890123456789, 4567890123456789, 42), (123, 4567890123456789, 4567890123456789, 42), (4567890123456789, 123, 123, 42), (4567890123456789, 123, 123, 42), (4567890123456789, 4567890123456789, 4567890123456789, 42), (4567890123456789, 4567890123456789, 4567890123456789, 42), (4567890123456789, 4567890123456789, 4567890123456789, 42)]

-----------
QUERY:


--
-- variant where a PlaceHolderVar is needed at a join, but not above the join
--

explain (costs off)
select * from
  int4_tbl as i41,
  lateral
    (select 1 as x from
      (select i41.f1 as lat,
              i42.f1 as loc from
         int8_tbl as i81, int4_tbl as i42) as ss1
      right join int4_tbl as i43 on (i43.f1 > 1)
      where ss1.loc = ss1.lat) as ss2
where i41.f1 > 0;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Nested Loop',), ('        ->  Seq Scan on int4_tbl i41',), ('              Filter: (f1 > 0)',), ('        ->  Nested Loop',), ('              Join Filter: (i42.f1 = i41.f1)',), ('              ->  Seq Scan on int8_tbl i81',), ('              ->  Materialize',), ('                    ->  Seq Scan on int4_tbl i42',), ('  ->  Materialize',), ('        ->  Seq Scan on int4_tbl i43',), ('              Filter: (f1 > 1)',)]

-----------
QUERY:


select * from
  int4_tbl as i41,
  lateral
    (select 1 as x from
      (select i41.f1 as lat,
              i42.f1 as loc from
         int8_tbl as i81, int4_tbl as i42) as ss1
      right join int4_tbl as i43 on (i43.f1 > 1)
      where ss1.loc = ss1.lat) as ss2
where i41.f1 > 0;
RESULT:
	postgres: [(123456, 1), (123456, 1), (123456, 1), (123456, 1), (123456, 1), (123456, 1), (123456, 1), (123456, 1), (123456, 1), (123456, 1), (2147483647, 1), (2147483647, 1), (2147483647, 1), (2147483647, 1), (2147483647, 1), (2147483647, 1), (2147483647, 1), (2147483647, 1), (2147483647, 1), (2147483647, 1)]

-----------
QUERY:


--
-- test the corner cases FULL JOIN ON TRUE and FULL JOIN ON FALSE
--
select * from int4_tbl a full join int4_tbl b on true;
RESULT:
	postgres: [(0, 0), (0, 123456), (0, -123456), (0, 2147483647), (0, -2147483647), (123456, 0), (123456, 123456), (123456, -123456), (123456, 2147483647), (123456, -2147483647), (-123456, 0), (-123456, 123456), (-123456, -123456), (-123456, 2147483647), (-123456, -2147483647), (2147483647, 0), (2147483647, 123456), (2147483647, -123456), (2147483647, 2147483647), (2147483647, -2147483647), (-2147483647, 0), (-2147483647, 123456), (-2147483647, -123456), (-2147483647, 2147483647), (-2147483647, -2147483647)]

-----------
QUERY:

select * from int4_tbl a full join int4_tbl b on false;
RESULT:
	postgres: [(None, 0), (None, 123456), (None, -123456), (None, 2147483647), (None, -2147483647), (0, None), (123456, None), (-123456, None), (2147483647, None), (-2147483647, None)]

-----------
QUERY:


--
-- test for ability to use a cartesian join when necessary
--

create temp table q1 as select 1 as q1;
RESULT:
	postgres: None

-----------
QUERY:

create temp table q2 as select 0 as q2;
RESULT:
	postgres: None

-----------
QUERY:

analyze q1;
RESULT:
	postgres: None

-----------
QUERY:

analyze q2;
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select * from
  tenk1 join int4_tbl on f1 = twothousand,
  q1, q2
where q1 = thousand or q2 = thousand;
RESULT:
	postgres: [('Hash Join',), ('  Hash Cond: (tenk1.twothousand = int4_tbl.f1)',), ('  ->  Nested Loop',), ('        ->  Nested Loop',), ('              ->  Seq Scan on q1',), ('              ->  Seq Scan on q2',), ('        ->  Bitmap Heap Scan on tenk1',), ('              Recheck Cond: ((q1.q1 = thousand) OR (q2.q2 = thousand))',), ('              ->  BitmapOr',), ('                    ->  Bitmap Index Scan on tenk1_thous_tenthous',), ('                          Index Cond: (thousand = q1.q1)',), ('                    ->  Bitmap Index Scan on tenk1_thous_tenthous',), ('                          Index Cond: (thousand = q2.q2)',), ('  ->  Hash',), ('        ->  Seq Scan on int4_tbl',)]

-----------
QUERY:


explain (costs off)
select * from
  tenk1 join int4_tbl on f1 = twothousand,
  q1, q2
where thousand = (q1 + q2);
RESULT:
	postgres: [('Hash Join',), ('  Hash Cond: (tenk1.twothousand = int4_tbl.f1)',), ('  ->  Nested Loop',), ('        ->  Nested Loop',), ('              ->  Seq Scan on q1',), ('              ->  Seq Scan on q2',), ('        ->  Bitmap Heap Scan on tenk1',), ('              Recheck Cond: (thousand = (q1.q1 + q2.q2))',), ('              ->  Bitmap Index Scan on tenk1_thous_tenthous',), ('                    Index Cond: (thousand = (q1.q1 + q2.q2))',), ('  ->  Hash',), ('        ->  Seq Scan on int4_tbl',)]

-----------
QUERY:


--
-- test ability to generate a suitable plan for a star-schema query
--

explain (costs off)
select * from
  tenk1, int8_tbl a, int8_tbl b
where thousand = a.q1 and tenthous = b.q1 and a.q2 = 1 and b.q2 = 2;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Seq Scan on int8_tbl b',), ('        Filter: (q2 = 2)',), ('  ->  Nested Loop',), ('        ->  Seq Scan on int8_tbl a',), ('              Filter: (q2 = 1)',), ('        ->  Index Scan using tenk1_thous_tenthous on tenk1',), ('              Index Cond: ((thousand = a.q1) AND (tenthous = b.q1))',)]

-----------
QUERY:


--
-- test a corner case in which we shouldn/* REPLACED */''t apply the star-schema optimization
--

explain (costs off)
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (select 1,0 from onerow) v1(x1,x2)
               left join (select 3,1 from onerow) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Nested Loop',), ('        Join Filter: (t1.stringu1 > t2.stringu2)',), ('        ->  Nested Loop',), ('              ->  Nested Loop',), ('                    ->  Seq Scan on onerow',), ('                    ->  Seq Scan on onerow onerow_1',), ('              ->  Index Scan using tenk1_unique2 on tenk1 t1',), ('                    Index Cond: ((unique2 = (11)) AND (unique2 < 42))',), ('        ->  Index Scan using tenk1_unique1 on tenk1 t2',), ('              Index Cond: (unique1 = (3))',), ('  ->  Seq Scan on int4_tbl i1',), ('        Filter: (f1 = 0)',)]

-----------
QUERY:


select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (select 1,0 from onerow) v1(x1,x2)
               left join (select 3,1 from onerow) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
RESULT:
	postgres: [(11, 'WFAAAA', 3, 'LKIAAA')]

-----------
QUERY:


-- variant that isn/* REPLACED */''t quite a star-schema case

select ss1.d1 from
  tenk1 as t1
  inner join tenk1 as t2
  on t1.tenthous = t2.ten
  inner join
    int8_tbl as i8
    left join int4_tbl as i4
      inner join (select 64::information_schema.cardinal_number as d1
                  from tenk1 t3,
                       lateral (select abs(t3.unique1) + random()) ss0(x)
                  where t3.fivethous < 0) as ss1
      on i4.f1 = ss1.d1
    on i8.q1 = i4.f1
  on t1.tenthous = ss1.d1
where t1.unique1 < i4.f1;
RESULT:
	postgres: []

-----------
QUERY:


-- this variant is foldable by the remove-useless-RESULT-RTEs code

explain (costs off)
select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (t1.stringu1 > t2.stringu2)',), ('  ->  Nested Loop',), ('        ->  Seq Scan on int4_tbl i1',), ('              Filter: (f1 = 0)',), ('        ->  Index Scan using tenk1_unique2 on tenk1 t1',), ('              Index Cond: ((unique2 = (11)) AND (unique2 < 42))',), ('  ->  Index Scan using tenk1_unique1 on tenk1 t2',), ('        Index Cond: (unique1 = (3))',)]

-----------
QUERY:


select t1.unique2, t1.stringu1, t2.unique1, t2.stringu2 from
  tenk1 t1
  inner join int4_tbl i1
    left join (select v1.x2, v2.y1, 11 AS d1
               from (values(1,0)) v1(x1,x2)
               left join (values(3,1)) v2(y1,y2)
               on v1.x1 = v2.y2) subq1
    on (i1.f1 = subq1.x2)
  on (t1.unique2 = subq1.d1)
  left join tenk1 t2
  on (subq1.y1 = t2.unique1)
where t1.unique2 < 42 and t1.stringu1 > t2.stringu2;
RESULT:
	postgres: [(11, 'WFAAAA', 3, 'LKIAAA')]

-----------
QUERY:


-- Here/* REPLACED */''s a variant that we can/* REPLACED */''t fold too aggressively, though,
-- or we end up with noplace to evaluate the lateral PHV
explain (verbose, costs off)
select * from
  (select 1 as x) ss1 left join (select 2 as y) ss2 on (true),
  lateral (select ss2.y as z limit 1) ss3;
RESULT:
	postgres: [('Nested Loop',), ('  Output: 1, (2), ((2))',), ('  ->  Result',), ('        Output: 2',), ('  ->  Limit',), ('        Output: ((2))',), ('        ->  Result',), ('              Output: (2)',)]

-----------
QUERY:

select * from
  (select 1 as x) ss1 left join (select 2 as y) ss2 on (true),
  lateral (select ss2.y as z limit 1) ss3;
RESULT:
	postgres: [(1, 2, 2)]

-----------
QUERY:


-- Test proper handling of appendrel PHVs during useless-RTE removal
explain (costs off)
select * from
  (select 0 as z) as t1
  left join
  (select true as a) as t2
  on true,
  lateral (select true as b
           union all
           select a as b) as t3
where b;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Result',), ('  ->  Append',), ('        ->  Result',), ('        ->  Result',), ('              One-Time Filter: (true)',)]

-----------
QUERY:


select * from
  (select 0 as z) as t1
  left join
  (select true as a) as t2
  on true,
  lateral (select true as b
           union all
           select a as b) as t3
where b;
RESULT:
	postgres: [(0, True, True), (0, True, True)]

-----------
QUERY:


-- Test PHV in a semijoin qual, which confused useless-RTE removal (bug #17700)
explain (verbose, costs off)
with ctetable as not materialized ( select 1 as f1 )
select * from ctetable c1
where f1 in ( select c3.f1 from ctetable c2 full join ctetable c3 on true );
RESULT:
	postgres: [('Result',), ('  Output: 1',), ('  One-Time Filter: (1 = 1)',)]

-----------
QUERY:


with ctetable as not materialized ( select 1 as f1 )
select * from ctetable c1
where f1 in ( select c3.f1 from ctetable c2 full join ctetable c3 on true );
RESULT:
	postgres: [(1,)]

-----------
QUERY:


-- Test PHV that winds up in a Result node, despite having nonempty nullingrels
explain (verbose, costs off)
select table_catalog, table_name
from int4_tbl t1
  inner join (int8_tbl t2
              left join information_schema.column_udt_usage on null)
  on null;
RESULT:
	postgres: [('Result',), ('  Output: (current_database())::information_schema.sql_identifier, (c.relname)::information_schema.sql_identifier',), ('  One-Time Filter: false',)]

-----------
QUERY:


-- Test handling of qual pushdown to appendrel members with non-Var outputs
explain (verbose, costs off)
select * from int4_tbl left join (
  select text 'foo' union all select text 'bar'
) ss(x) on true
where ss.x is null;
RESULT:
	postgres: [('Nested Loop Left Join',), ("  Output: int4_tbl.f1, ('foo'::text)",), ("  Filter: (('foo'::text) IS NULL)",), ('  ->  Seq Scan on public.int4_tbl',), ('        Output: int4_tbl.f1',), ('  ->  Materialize',), ("        Output: ('foo'::text)",), ('        ->  Append',), ('              ->  Result',), ("                    Output: 'foo'::text",), ('              ->  Result',), ("                    Output: 'bar'::text",)]

-----------
QUERY:


--
-- test inlining of immutable functions
--
create function f_immutable_int4(i integer) returns integer as
$$ begin return i; end; $$ language plpgsql immutable;
RESULT:
	postgres: None

-----------
QUERY:


-- check optimization of function scan with join
explain (costs off)
select unique1 from tenk1, (select * from f_immutable_int4(1) x) x
where x = unique1;
RESULT:
	postgres: [('Index Only Scan using tenk1_unique1 on tenk1',), ('  Index Cond: (unique1 = 1)',)]

-----------
QUERY:


explain (verbose, costs off)
select unique1, x.*
from tenk1, (select *, random() from f_immutable_int4(1) x) x
where x = unique1;
RESULT:
	postgres: [('Nested Loop',), ('  Output: tenk1.unique1, (1), (random())',), ('  ->  Result',), ('        Output: 1, random()',), ('  ->  Index Only Scan using tenk1_unique1 on public.tenk1',), ('        Output: tenk1.unique1',), ('        Index Cond: (tenk1.unique1 = (1))',)]

-----------
QUERY:


explain (costs off)
select unique1 from tenk1, f_immutable_int4(1) x where x = unique1;
RESULT:
	postgres: [('Index Only Scan using tenk1_unique1 on tenk1',), ('  Index Cond: (unique1 = 1)',)]

-----------
QUERY:


explain (costs off)
select unique1 from tenk1, lateral f_immutable_int4(1) x where x = unique1;
RESULT:
	postgres: [('Index Only Scan using tenk1_unique1 on tenk1',), ('  Index Cond: (unique1 = 1)',)]

-----------
QUERY:


explain (costs off)
select unique1 from tenk1, lateral f_immutable_int4(1) x where x in (select 17);
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


explain (costs off)
select unique1, x from tenk1 join f_immutable_int4(1) x on unique1 = x;
RESULT:
	postgres: [('Index Only Scan using tenk1_unique1 on tenk1',), ('  Index Cond: (unique1 = 1)',)]

-----------
QUERY:


explain (costs off)
select unique1, x from tenk1 left join f_immutable_int4(1) x on unique1 = x;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: (tenk1.unique1 = 1)',), ('  ->  Index Only Scan using tenk1_unique1 on tenk1',), ('  ->  Materialize',), ('        ->  Result',)]

-----------
QUERY:


explain (costs off)
select unique1, x from tenk1 right join f_immutable_int4(1) x on unique1 = x;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Result',), ('  ->  Index Only Scan using tenk1_unique1 on tenk1',), ('        Index Cond: (unique1 = 1)',)]

-----------
QUERY:


explain (costs off)
select unique1, x from tenk1 full join f_immutable_int4(1) x on unique1 = x;
RESULT:
	postgres: [('Merge Full Join',), ('  Merge Cond: (tenk1.unique1 = (1))',), ('  ->  Index Only Scan using tenk1_unique1 on tenk1',), ('  ->  Sort',), ('        Sort Key: (1)',), ('        ->  Result',)]

-----------
QUERY:


-- check that pullup of a const function allows further const-folding
explain (costs off)
select unique1 from tenk1, f_immutable_int4(1) x where x = 42;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


-- test inlining of immutable functions with PlaceHolderVars
explain (costs off)
select nt3.id
from nt3 as nt3
  left join
    (select nt2.*, (nt2.b1 or i4 = 42) AS b3
     from nt2 as nt2
       left join
         f_immutable_int4(0) i4
         on i4 = nt2.nt1_id
    ) as ss2
    on ss2.id = nt3.nt2_id
where nt3.id = 1 and ss2.b3;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Filter: ((nt2.b1 OR ((0) = 42)))',), ('  ->  Index Scan using nt3_pkey on nt3',), ('        Index Cond: (id = 1)',), ('  ->  Nested Loop Left Join',), ('        Join Filter: (0 = nt2.nt1_id)',), ('        ->  Index Scan using nt2_pkey on nt2',), ('              Index Cond: (id = nt3.nt2_id)',), ('        ->  Result',)]

-----------
QUERY:


drop function f_immutable_int4(int);
RESULT:
	postgres: None

-----------
QUERY:


-- test inlining when function returns composite

create function mki8(bigint, bigint) returns int8_tbl as
$$select row($1,$2)::int8_tbl$$ language sql;
RESULT:
	postgres: None

-----------
QUERY:


create function mki4(int) returns int4_tbl as
$$select row($1)::int4_tbl$$ language sql;
RESULT:
	postgres: None

-----------
QUERY:


explain (verbose, costs off)
select * from mki8(1,2);
RESULT:
	postgres: [('Function Scan on mki8',), ('  Output: q1, q2',), ("  Function Call: '(1,2)'::int8_tbl",)]

-----------
QUERY:

select * from mki8(1,2);
RESULT:
	postgres: [(1, 2)]

-----------
QUERY:


explain (verbose, costs off)
select * from mki4(42);
RESULT:
	postgres: [('Function Scan on mki4',), ('  Output: f1',), ("  Function Call: '(42)'::int4_tbl",)]

-----------
QUERY:

select * from mki4(42);
RESULT:
	postgres: [(42,)]

-----------
QUERY:


drop function mki8(bigint, bigint);
RESULT:
	postgres: None

-----------
QUERY:

drop function mki4(int);
RESULT:
	postgres: None

-----------
QUERY:


-- test const-folding of a whole-row Var into a per-field Var
-- (need to inline a function to reach this case, else parser does it)
create function f_field_select(t onek) returns int4 as
$$ select t.unique2; $$ language sql immutable;
RESULT:
	postgres: None

-----------
QUERY:


explain (verbose, costs off)
select (t2.*).unique1, f_field_select(t2) from tenk1 t1
    left join onek t2 on t1.unique1 = t2.unique1
    left join int8_tbl t3 on true;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: t2.unique1, t2.unique2',), ('  ->  Hash Left Join',), ('        Output: t2.unique1, t2.unique2',), ('        Hash Cond: (t1.unique1 = t2.unique1)',), ('        ->  Index Only Scan using tenk1_unique1 on public.tenk1 t1',), ('              Output: t1.unique1',), ('        ->  Hash',), ('              Output: t2.unique1, t2.unique2',), ('              ->  Seq Scan on public.onek t2',), ('                    Output: t2.unique1, t2.unique2',), ('  ->  Materialize',), ('        ->  Seq Scan on public.int8_tbl t3',)]

-----------
QUERY:


drop function f_field_select(t onek);
RESULT:
	postgres: None

-----------
QUERY:


--
-- test extraction of restriction OR clauses from join OR clause
-- (we used to only do this for indexable clauses)
--

explain (costs off)
select * from tenk1 a join tenk1 b on
  (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.hundred = 4);
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.hundred = 4)))',), ('  ->  Bitmap Heap Scan on tenk1 b',), ('        Recheck Cond: ((unique1 = 2) OR (hundred = 4))',), ('        ->  BitmapOr',), ('              ->  Bitmap Index Scan on tenk1_unique1',), ('                    Index Cond: (unique1 = 2)',), ('              ->  Bitmap Index Scan on tenk1_hundred',), ('                    Index Cond: (hundred = 4)',), ('  ->  Materialize',), ('        ->  Bitmap Heap Scan on tenk1 a',), ('              Recheck Cond: ((unique1 = 1) OR (unique2 = 3))',), ('              ->  BitmapOr',), ('                    ->  Bitmap Index Scan on tenk1_unique1',), ('                          Index Cond: (unique1 = 1)',), ('                    ->  Bitmap Index Scan on tenk1_unique2',), ('                          Index Cond: (unique2 = 3)',)]

-----------
QUERY:

explain (costs off)
select * from tenk1 a join tenk1 b on
  (a.unique1 = 1 and b.unique1 = 2) or (a.unique2 = 3 and b.ten = 4);
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR ((a.unique2 = 3) AND (b.ten = 4)))',), ('  ->  Seq Scan on tenk1 b',), ('        Filter: ((unique1 = 2) OR (ten = 4))',), ('  ->  Materialize',), ('        ->  Bitmap Heap Scan on tenk1 a',), ('              Recheck Cond: ((unique1 = 1) OR (unique2 = 3))',), ('              ->  BitmapOr',), ('                    ->  Bitmap Index Scan on tenk1_unique1',), ('                          Index Cond: (unique1 = 1)',), ('                    ->  Bitmap Index Scan on tenk1_unique2',), ('                          Index Cond: (unique2 = 3)',)]

-----------
QUERY:

explain (costs off)
select * from tenk1 a join tenk1 b on
  (a.unique1 = 1 and b.unique1 = 2) or
  ((a.unique2 = 3 or a.unique2 = 7) and b.hundred = 4);
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (((a.unique1 = 1) AND (b.unique1 = 2)) OR (((a.unique2 = 3) OR (a.unique2 = 7)) AND (b.hundred = 4)))',), ('  ->  Bitmap Heap Scan on tenk1 b',), ('        Recheck Cond: ((unique1 = 2) OR (hundred = 4))',), ('        ->  BitmapOr',), ('              ->  Bitmap Index Scan on tenk1_unique1',), ('                    Index Cond: (unique1 = 2)',), ('              ->  Bitmap Index Scan on tenk1_hundred',), ('                    Index Cond: (hundred = 4)',), ('  ->  Materialize',), ('        ->  Bitmap Heap Scan on tenk1 a',), ('              Recheck Cond: ((unique1 = 1) OR (unique2 = 3) OR (unique2 = 7))',), ('              ->  BitmapOr',), ('                    ->  Bitmap Index Scan on tenk1_unique1',), ('                          Index Cond: (unique1 = 1)',), ('                    ->  Bitmap Index Scan on tenk1_unique2',), ('                          Index Cond: (unique2 = 3)',), ('                    ->  Bitmap Index Scan on tenk1_unique2',), ('                          Index Cond: (unique2 = 7)',)]

-----------
QUERY:


--
-- test placement of movable quals in a parameterized join tree
--

explain (costs off)
select * from tenk1 t1 left join
  (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
  on t1.hundred = t2.hundred and t1.ten = t3.ten
where t1.unique1 = 1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Index Scan using tenk1_unique1 on tenk1 t1',), ('        Index Cond: (unique1 = 1)',), ('  ->  Nested Loop',), ('        Join Filter: (t1.ten = t3.ten)',), ('        ->  Bitmap Heap Scan on tenk1 t2',), ('              Recheck Cond: (t1.hundred = hundred)',), ('              ->  Bitmap Index Scan on tenk1_hundred',), ('                    Index Cond: (hundred = t1.hundred)',), ('        ->  Index Scan using tenk1_unique2 on tenk1 t3',), ('              Index Cond: (unique2 = t2.thousand)',)]

-----------
QUERY:


explain (costs off)
select * from tenk1 t1 left join
  (tenk1 t2 join tenk1 t3 on t2.thousand = t3.unique2)
  on t1.hundred = t2.hundred and t1.ten + t2.ten = t3.ten
where t1.unique1 = 1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Index Scan using tenk1_unique1 on tenk1 t1',), ('        Index Cond: (unique1 = 1)',), ('  ->  Nested Loop',), ('        Join Filter: ((t1.ten + t2.ten) = t3.ten)',), ('        ->  Bitmap Heap Scan on tenk1 t2',), ('              Recheck Cond: (t1.hundred = hundred)',), ('              ->  Bitmap Index Scan on tenk1_hundred',), ('                    Index Cond: (hundred = t1.hundred)',), ('        ->  Index Scan using tenk1_unique2 on tenk1 t3',), ('              Index Cond: (unique2 = t2.thousand)',)]

-----------
QUERY:


explain (costs off)
select count(*) from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
  join int4_tbl on b.thousand = f1;
RESULT:
	postgres: [('Aggregate',), ('  ->  Nested Loop Left Join',), ('        Join Filter: (a.unique2 = b.unique1)',), ('        ->  Nested Loop',), ('              ->  Nested Loop',), ('                    ->  Seq Scan on int4_tbl',), ('                    ->  Bitmap Heap Scan on tenk1 b',), ('                          Recheck Cond: (thousand = int4_tbl.f1)',), ('                          ->  Bitmap Index Scan on tenk1_thous_tenthous',), ('                                Index Cond: (thousand = int4_tbl.f1)',), ('              ->  Index Scan using tenk1_unique1 on tenk1 a',), ('                    Index Cond: (unique1 = b.unique2)',), ('        ->  Index Only Scan using tenk1_thous_tenthous on tenk1 c',), ('              Index Cond: (thousand = a.thousand)',)]

-----------
QUERY:


select count(*) from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on a.unique2 = b.unique1 and c.thousand = a.thousand
  join int4_tbl on b.thousand = f1;
RESULT:
	postgres: [(10,)]

-----------
QUERY:


explain (costs off)
select b.unique1 from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
  join int4_tbl i1 on b.thousand = f1
  right join int4_tbl i2 on i2.f1 = b.tenthous
  order by 1;
RESULT:
	postgres: [('Sort',), ('  Sort Key: b.unique1',), ('  ->  Nested Loop Left Join',), ('        ->  Seq Scan on int4_tbl i2',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (b.unique1 = 42)',), ('              ->  Nested Loop',), ('                    ->  Nested Loop',), ('                          ->  Seq Scan on int4_tbl i1',), ('                          ->  Index Scan using tenk1_thous_tenthous on tenk1 b',), ('                                Index Cond: ((thousand = i1.f1) AND (tenthous = i2.f1))',), ('                    ->  Index Scan using tenk1_unique1 on tenk1 a',), ('                          Index Cond: (unique1 = b.unique2)',), ('              ->  Index Only Scan using tenk1_thous_tenthous on tenk1 c',), ('                    Index Cond: (thousand = a.thousand)',)]

-----------
QUERY:


select b.unique1 from
  tenk1 a join tenk1 b on a.unique1 = b.unique2
  left join tenk1 c on b.unique1 = 42 and c.thousand = a.thousand
  join int4_tbl i1 on b.thousand = f1
  right join int4_tbl i2 on i2.f1 = b.tenthous
  order by 1;
RESULT:
	postgres: [(0,), (None,), (None,), (None,), (None,)]

-----------
QUERY:


explain (costs off)
select * from
(
  select unique1, q1, coalesce(unique1, -1) + q1 as fault
  from int8_tbl left join tenk1 on (q2 = unique2)
) ss
where fault = 122
order by fault;
RESULT:
	postgres: [('Nested Loop Left Join',), ("  Filter: ((COALESCE(tenk1.unique1, '-1'::integer) + int8_tbl.q1) = 122)",), ('  ->  Seq Scan on int8_tbl',), ('  ->  Index Scan using tenk1_unique2 on tenk1',), ('        Index Cond: (unique2 = int8_tbl.q2)',)]

-----------
QUERY:


select * from
(
  select unique1, q1, coalesce(unique1, -1) + q1 as fault
  from int8_tbl left join tenk1 on (q2 = unique2)
) ss
where fault = 122
order by fault;
RESULT:
	postgres: [(None, 123, 122)]

-----------
QUERY:


explain (costs off)
select * from
(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x
left join unnest(v1ys) as u1(u1y) on u1y = v2y;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Values Scan on "*VALUES*"',), ('  ->  Hash Right Join',), ('        Hash Cond: (u1.u1y = "*VALUES*_1".column2)',), ('        Filter: ("*VALUES*_1".column1 = "*VALUES*".column1)',), ('        ->  Function Scan on unnest u1',), ('        ->  Hash',), ('              ->  Values Scan on "*VALUES*_1"',)]

-----------
QUERY:


select * from
(values (1, array[10,20]), (2, array[20,30])) as v1(v1x,v1ys)
left join (values (1, 10), (2, 20)) as v2(v2x,v2y) on v2x = v1x
left join unnest(v1ys) as u1(u1y) on u1y = v2y;
RESULT:
	postgres: [(1, [10, 20], 1, 10, 10), (2, [20, 30], 2, 20, 20)]

-----------
QUERY:


--
-- test handling of potential equivalence clauses above outer joins
--

explain (costs off)
select q1, unique2, thousand, hundred
  from int8_tbl a left join tenk1 b on q1 = unique2
  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Filter: ((COALESCE(b.thousand, 123) = COALESCE(b.hundred, 123)) AND (a.q1 = COALESCE(b.hundred, 123)))',), ('  ->  Seq Scan on int8_tbl a',), ('  ->  Index Scan using tenk1_unique2 on tenk1 b',), ('        Index Cond: (unique2 = a.q1)',)]

-----------
QUERY:


select q1, unique2, thousand, hundred
  from int8_tbl a left join tenk1 b on q1 = unique2
  where coalesce(thousand,123) = q1 and q1 = coalesce(hundred,123);
RESULT:
	postgres: []

-----------
QUERY:


explain (costs off)
select f1, unique2, case when unique2 is null then f1 else 0 end
  from int4_tbl a left join tenk1 b on f1 = unique2
  where (case when unique2 is null then f1 else 0 end) = 0;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Filter: (CASE WHEN (b.unique2 IS NULL) THEN a.f1 ELSE 0 END = 0)',), ('  ->  Seq Scan on int4_tbl a',), ('  ->  Index Only Scan using tenk1_unique2 on tenk1 b',), ('        Index Cond: (unique2 = a.f1)',)]

-----------
QUERY:


select f1, unique2, case when unique2 is null then f1 else 0 end
  from int4_tbl a left join tenk1 b on f1 = unique2
  where (case when unique2 is null then f1 else 0 end) = 0;
RESULT:
	postgres: [(0, 0, 0)]

-----------
QUERY:


--
-- another case with equivalence clauses above outer joins (bug #8591)
--

explain (costs off)
select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Nested Loop Left Join',), ('        Filter: (COALESCE(b.twothousand, a.twothousand) = 44)',), ('        ->  Index Scan using tenk1_unique2 on tenk1 a',), ('              Index Cond: (unique2 < 10)',), ('        ->  Bitmap Heap Scan on tenk1 b',), ('              Recheck Cond: (thousand = a.unique1)',), ('              ->  Bitmap Index Scan on tenk1_thous_tenthous',), ('                    Index Cond: (thousand = a.unique1)',), ('  ->  Index Scan using tenk1_unique2 on tenk1 c',), ('        Index Cond: (unique2 = 44)',)]

-----------
QUERY:


select a.unique1, b.unique1, c.unique1, coalesce(b.twothousand, a.twothousand)
  from tenk1 a left join tenk1 b on b.thousand = a.unique1                        left join tenk1 c on c.unique2 = coalesce(b.twothousand, a.twothousand)
  where a.unique2 < 10 and coalesce(b.twothousand, a.twothousand) = 44;
RESULT:
	postgres: []

-----------
QUERY:


-- related case

explain (costs off)
select * from int8_tbl t1 left join int8_tbl t2 on t1.q2 = t2.q1,
  lateral (select * from int8_tbl t3 where t2.q1 = t2.q2) ss;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Hash Left Join',), ('        Hash Cond: (t1.q2 = t2.q1)',), ('        Filter: (t2.q1 = t2.q2)',), ('        ->  Seq Scan on int8_tbl t1',), ('        ->  Hash',), ('              ->  Seq Scan on int8_tbl t2',), ('  ->  Seq Scan on int8_tbl t3',)]

-----------
QUERY:


select * from int8_tbl t1 left join int8_tbl t2 on t1.q2 = t2.q1,
  lateral (select * from int8_tbl t3 where t2.q1 = t2.q2) ss;
RESULT:
	postgres: [(123, 4567890123456789, 4567890123456789, 4567890123456789, 123, 456), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123, 4567890123456789), (123, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (123, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, -4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 123, 456), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 123, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 123), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, -4567890123456789)]

-----------
QUERY:


--
-- check handling of join aliases when flattening multiple levels of subquery
--

explain (verbose, costs off)
select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
  (values (0),(1)) foo1(join_key)
left join
  (select join_key, bug_field from
    (select ss1.join_key, ss1.bug_field from
      (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
    ) foo2
   left join
    (select unique2 as join_key from tenk1 i2) ss2
   using (join_key)
  ) foo3
using (join_key);
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: "*VALUES*".column1, i1.f1, (666)',), ('  Join Filter: ("*VALUES*".column1 = i1.f1)',), ('  ->  Values Scan on "*VALUES*"',), ('        Output: "*VALUES*".column1',), ('  ->  Materialize',), ('        Output: i1.f1, (666)',), ('        ->  Nested Loop Left Join',), ('              Output: i1.f1, 666',), ('              ->  Seq Scan on public.int4_tbl i1',), ('                    Output: i1.f1',), ('              ->  Index Only Scan using tenk1_unique2 on public.tenk1 i2',), ('                    Output: i2.unique2',), ('                    Index Cond: (i2.unique2 = i1.f1)',)]

-----------
QUERY:


select foo1.join_key as foo1_id, foo3.join_key AS foo3_id, bug_field from
  (values (0),(1)) foo1(join_key)
left join
  (select join_key, bug_field from
    (select ss1.join_key, ss1.bug_field from
      (select f1 as join_key, 666 as bug_field from int4_tbl i1) ss1
    ) foo2
   left join
    (select unique2 as join_key from tenk1 i2) ss2
   using (join_key)
  ) foo3
using (join_key);
RESULT:
	postgres: [(0, 0, 666), (1, None, None)]

-----------
QUERY:


--
-- check handling of a variable-free join alias
--
explain (verbose, costs off)
select * from
int4_tbl i0 left join
( (select *, 123 as x from int4_tbl i1) ss1
  left join
  (select *, q2 as x from int8_tbl i2) ss2
  using (x)
) ss0
on (i0.f1 = ss0.f1)
order by i0.f1, x;
RESULT:
	postgres: [('Sort',), ("  Output: i0.f1, ('123'::bigint), i1.f1, i2.q1, i2.q2",), ("  Sort Key: i0.f1, ('123'::bigint)",), ('  ->  Hash Right Join',), ("        Output: i0.f1, ('123'::bigint), i1.f1, i2.q1, i2.q2",), ('        Hash Cond: (i1.f1 = i0.f1)',), ('        ->  Nested Loop Left Join',), ("              Output: i1.f1, i2.q1, i2.q2, '123'::bigint",), ('              ->  Seq Scan on public.int4_tbl i1',), ('                    Output: i1.f1',), ('              ->  Materialize',), ('                    Output: i2.q1, i2.q2',), ('                    ->  Seq Scan on public.int8_tbl i2',), ('                          Output: i2.q1, i2.q2',), ('                          Filter: (123 = i2.q2)',), ('        ->  Hash',), ('              Output: i0.f1',), ('              ->  Seq Scan on public.int4_tbl i0',), ('                    Output: i0.f1',)]

-----------
QUERY:


select * from
int4_tbl i0 left join
( (select *, 123 as x from int4_tbl i1) ss1
  left join
  (select *, q2 as x from int8_tbl i2) ss2
  using (x)
) ss0
on (i0.f1 = ss0.f1)
order by i0.f1, x;
RESULT:
	postgres: [(-2147483647, 123, -2147483647, 4567890123456789, 123), (-123456, 123, -123456, 4567890123456789, 123), (0, 123, 0, 4567890123456789, 123), (123456, 123, 123456, 4567890123456789, 123), (2147483647, 123, 2147483647, 4567890123456789, 123)]

-----------
QUERY:


--
-- test successful handling of nested outer joins with degenerate join quals
--

explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
RESULT:
	postgres: [('Hash Left Join',), ('  Output: t1.f1',), ('  Hash Cond: (i8.q2 = i4.f1)',), ('  ->  Nested Loop Left Join',), ('        Output: t1.f1, i8.q2',), ("        Join Filter: (t1.f1 = '***'::text)",), ('        ->  Seq Scan on public.text_tbl t1',), ('              Output: t1.f1',), ('        ->  Materialize',), ('              Output: i8.q2',), ('              ->  Hash Right Join',), ('                    Output: i8.q2',), ('                    Hash Cond: ((NULL::integer) = i8b1.q2)',), ('                    ->  Hash Join',), ('                          Output: i8.q2, (NULL::integer)',), ('                          Hash Cond: (i8.q1 = i8b2.q1)',), ('                          ->  Seq Scan on public.int8_tbl i8',), ('                                Output: i8.q1, i8.q2',), ('                          ->  Hash',), ('                                Output: i8b2.q1, (NULL::integer)',), ('                                ->  Seq Scan on public.int8_tbl i8b2',), ('                                      Output: i8b2.q1, NULL::integer',), ('                    ->  Hash',), ('                          Output: i8b1.q2',), ('                          ->  Seq Scan on public.int8_tbl i8b1',), ('                                Output: i8b1.q2',), ('  ->  Hash',), ('        Output: i4.f1',), ('        ->  Seq Scan on public.int4_tbl i4',), ('              Output: i4.f1',)]

-----------
QUERY:


select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
RESULT:
	postgres: [('doh!',), ('hi de ho neighbor',)]

-----------
QUERY:


explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
RESULT:
	postgres: [('Hash Left Join',), ('  Output: t1.f1',), ('  Hash Cond: (i8.q2 = i4.f1)',), ('  ->  Nested Loop Left Join',), ('        Output: t1.f1, i8.q2',), ("        Join Filter: (t1.f1 = '***'::text)",), ('        ->  Seq Scan on public.text_tbl t1',), ('              Output: t1.f1',), ('        ->  Materialize',), ('              Output: i8.q2',), ('              ->  Hash Right Join',), ('                    Output: i8.q2',), ('                    Hash Cond: ((NULL::integer) = i8b1.q2)',), ('                    ->  Hash Right Join',), ('                          Output: i8.q2, (NULL::integer)',), ('                          Hash Cond: (i8b2.q1 = i8.q1)',), ('                          ->  Nested Loop',), ('                                Output: i8b2.q1, NULL::integer',), ('                                ->  Seq Scan on public.int8_tbl i8b2',), ('                                      Output: i8b2.q1, i8b2.q2',), ('                                ->  Materialize',), ('                                      ->  Seq Scan on public.int4_tbl i4b2',), ('                          ->  Hash',), ('                                Output: i8.q1, i8.q2',), ('                                ->  Seq Scan on public.int8_tbl i8',), ('                                      Output: i8.q1, i8.q2',), ('                    ->  Hash',), ('                          Output: i8b1.q2',), ('                          ->  Seq Scan on public.int8_tbl i8b1',), ('                                Output: i8b1.q2',), ('  ->  Hash',), ('        Output: i4.f1',), ('        ->  Seq Scan on public.int4_tbl i4',), ('              Output: i4.f1',)]

-----------
QUERY:


select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
RESULT:
	postgres: [('doh!',), ('hi de ho neighbor',)]

-----------
QUERY:


explain (verbose, costs off)
select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2
                 where q1 = f1) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
RESULT:
	postgres: [('Hash Left Join',), ('  Output: t1.f1',), ('  Hash Cond: (i8.q2 = i4.f1)',), ('  ->  Nested Loop Left Join',), ('        Output: t1.f1, i8.q2',), ("        Join Filter: (t1.f1 = '***'::text)",), ('        ->  Seq Scan on public.text_tbl t1',), ('              Output: t1.f1',), ('        ->  Materialize',), ('              Output: i8.q2',), ('              ->  Hash Right Join',), ('                    Output: i8.q2',), ('                    Hash Cond: ((NULL::integer) = i8b1.q2)',), ('                    ->  Hash Right Join',), ('                          Output: i8.q2, (NULL::integer)',), ('                          Hash Cond: (i8b2.q1 = i8.q1)',), ('                          ->  Hash Join',), ('                                Output: i8b2.q1, NULL::integer',), ('                                Hash Cond: (i8b2.q1 = i4b2.f1)',), ('                                ->  Seq Scan on public.int8_tbl i8b2',), ('                                      Output: i8b2.q1, i8b2.q2',), ('                                ->  Hash',), ('                                      Output: i4b2.f1',), ('                                      ->  Seq Scan on public.int4_tbl i4b2',), ('                                            Output: i4b2.f1',), ('                          ->  Hash',), ('                                Output: i8.q1, i8.q2',), ('                                ->  Seq Scan on public.int8_tbl i8',), ('                                      Output: i8.q1, i8.q2',), ('                    ->  Hash',), ('                          Output: i8b1.q2',), ('                          ->  Seq Scan on public.int8_tbl i8b1',), ('                                Output: i8b1.q2',), ('  ->  Hash',), ('        Output: i4.f1',), ('        ->  Seq Scan on public.int4_tbl i4',), ('              Output: i4.f1',)]

-----------
QUERY:


select t1.* from
  text_tbl t1
  left join (select *, '***'::text as d1 from int8_tbl i8b1) b1
    left join int8_tbl i8
      left join (select *, null::int as d2 from int8_tbl i8b2, int4_tbl i4b2
                 where q1 = f1) b2
      on (i8.q1 = b2.q1)
    on (b2.d2 = b1.q2)
  on (t1.f1 = b1.d1)
  left join int4_tbl i4
  on (i8.q2 = i4.f1);
RESULT:
	postgres: [('doh!',), ('hi de ho neighbor',)]

-----------
QUERY:


explain (verbose, costs off)
select * from
  text_tbl t1
  inner join int8_tbl i8
  on i8.q2 = 456
  right join text_tbl t2
  on t1.f1 = 'doh!'
  left join int4_tbl i4
  on i8.q1 = i4.f1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: t1.f1, i8.q1, i8.q2, t2.f1, i4.f1',), ('  ->  Seq Scan on public.text_tbl t2',), ('        Output: t2.f1',), ('  ->  Materialize',), ('        Output: i8.q1, i8.q2, i4.f1, t1.f1',), ('        ->  Nested Loop',), ('              Output: i8.q1, i8.q2, i4.f1, t1.f1',), ('              ->  Nested Loop Left Join',), ('                    Output: i8.q1, i8.q2, i4.f1',), ('                    Join Filter: (i8.q1 = i4.f1)',), ('                    ->  Seq Scan on public.int8_tbl i8',), ('                          Output: i8.q1, i8.q2',), ('                          Filter: (i8.q2 = 456)',), ('                    ->  Seq Scan on public.int4_tbl i4',), ('                          Output: i4.f1',), ('              ->  Seq Scan on public.text_tbl t1',), ('                    Output: t1.f1',), ("                    Filter: (t1.f1 = 'doh!'::text)",)]

-----------
QUERY:


select * from
  text_tbl t1
  inner join int8_tbl i8
  on i8.q2 = 456
  right join text_tbl t2
  on t1.f1 = 'doh!'
  left join int4_tbl i4
  on i8.q1 = i4.f1;
RESULT:
	postgres: [('doh!', 123, 456, 'doh!', None), ('doh!', 123, 456, 'hi de ho neighbor', None)]

-----------
QUERY:


-- check handling of a variable-free qual for a non-commutable outer join
explain (costs off)
select nspname
from (select 1 as x) ss1
left join
( select n.nspname, c.relname
  from pg_class c left join pg_namespace n on n.oid = c.relnamespace
  where c.relkind = 'r'
) ss2 on false;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: false',), ('  ->  Result',), ('  ->  Result',), ('        One-Time Filter: false',)]

-----------
QUERY:


-- check handling of apparently-commutable outer joins with non-commutable
-- joins between them
explain (costs off)
select 1 from
  int4_tbl i4
  left join int8_tbl i8 on i4.f1 is not null
  left join (select 1 as a) ss1 on null
  join int4_tbl i42 on ss1.a is null or i8.q1 <> i8.q2
  right join (select 2 as b) ss2
  on ss2.b < i4.f1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Result',), ('  ->  Nested Loop',), ('        ->  Nested Loop Left Join',), ('              Join Filter: NULL::boolean',), ('              Filter: (((1) IS NULL) OR (i8.q1 <> i8.q2))',), ('              ->  Nested Loop Left Join',), ('                    Join Filter: (i4.f1 IS NOT NULL)',), ('                    ->  Seq Scan on int4_tbl i4',), ('                          Filter: (2 < f1)',), ('                    ->  Materialize',), ('                          ->  Seq Scan on int8_tbl i8',), ('              ->  Result',), ('                    One-Time Filter: false',), ('        ->  Materialize',), ('              ->  Seq Scan on int4_tbl i42',)]

-----------
QUERY:


--
-- test for appropriate join order in the presence of lateral references
--

explain (verbose, costs off)
select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss
where t1.f1 = ss.f1;
RESULT:
	postgres: [('Nested Loop',), ('  Output: t1.f1, i8.q1, i8.q2, (i8.q1), t2.f1',), ('  Join Filter: (t1.f1 = t2.f1)',), ('  ->  Nested Loop Left Join',), ('        Output: t1.f1, i8.q1, i8.q2',), ('        ->  Seq Scan on public.text_tbl t1',), ('              Output: t1.f1',), ('        ->  Materialize',), ('              Output: i8.q1, i8.q2',), ('              ->  Seq Scan on public.int8_tbl i8',), ('                    Output: i8.q1, i8.q2',), ('                    Filter: (i8.q2 = 123)',), ('  ->  Memoize',), ('        Output: (i8.q1), t2.f1',), ('        Cache Key: i8.q1',), ('        Cache Mode: binary',), ('        ->  Limit',), ('              Output: (i8.q1), t2.f1',), ('              ->  Seq Scan on public.text_tbl t2',), ('                    Output: i8.q1, t2.f1',)]

-----------
QUERY:


select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss
where t1.f1 = ss.f1;
RESULT:
	postgres: [('doh!', 4567890123456789, 123, 4567890123456789, 'doh!')]

-----------
QUERY:


explain (verbose, costs off)
select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
  lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;
RESULT:
	postgres: [('Nested Loop',), ('  Output: t1.f1, i8.q1, i8.q2, (i8.q1), t2.f1, ((i8.q1)), (t2.f1)',), ('  Join Filter: (t1.f1 = (t2.f1))',), ('  ->  Nested Loop',), ('        Output: t1.f1, i8.q1, i8.q2, (i8.q1), t2.f1',), ('        ->  Nested Loop Left Join',), ('              Output: t1.f1, i8.q1, i8.q2',), ('              ->  Seq Scan on public.text_tbl t1',), ('                    Output: t1.f1',), ('              ->  Materialize',), ('                    Output: i8.q1, i8.q2',), ('                    ->  Seq Scan on public.int8_tbl i8',), ('                          Output: i8.q1, i8.q2',), ('                          Filter: (i8.q2 = 123)',), ('        ->  Memoize',), ('              Output: (i8.q1), t2.f1',), ('              Cache Key: i8.q1',), ('              Cache Mode: binary',), ('              ->  Limit',), ('                    Output: (i8.q1), t2.f1',), ('                    ->  Seq Scan on public.text_tbl t2',), ('                          Output: i8.q1, t2.f1',), ('  ->  Memoize',), ('        Output: ((i8.q1)), (t2.f1)',), ('        Cache Key: (i8.q1), t2.f1',), ('        Cache Mode: binary',), ('        ->  Limit',), ('              Output: ((i8.q1)), (t2.f1)',), ('              ->  Seq Scan on public.text_tbl t3',), ('                    Output: (i8.q1), t2.f1',)]

-----------
QUERY:


select * from
  text_tbl t1
  left join int8_tbl i8
  on i8.q2 = 123,
  lateral (select i8.q1, t2.f1 from text_tbl t2 limit 1) as ss1,
  lateral (select ss1.* from text_tbl t3 limit 1) as ss2
where t1.f1 = ss2.f1;
RESULT:
	postgres: [('doh!', 4567890123456789, 123, 4567890123456789, 'doh!', 4567890123456789, 'doh!')]

-----------
QUERY:


explain (verbose, costs off)
select 1 from
  text_tbl as tt1
  inner join text_tbl as tt2 on (tt1.f1 = 'foo')
  left join text_tbl as tt3 on (tt3.f1 = 'foo')
  left join text_tbl as tt4 on (tt3.f1 = tt4.f1),
  lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1
where tt1.f1 = ss1.c0;
RESULT:
	postgres: [('Nested Loop',), ('  Output: 1',), ('  ->  Nested Loop Left Join',), ('        Output: tt1.f1, tt4.f1',), ('        ->  Nested Loop',), ('              Output: tt1.f1',), ('              ->  Seq Scan on public.text_tbl tt1',), ('                    Output: tt1.f1',), ("                    Filter: (tt1.f1 = 'foo'::text)",), ('              ->  Seq Scan on public.text_tbl tt2',), ('                    Output: tt2.f1',), ('        ->  Materialize',), ('              Output: tt4.f1',), ('              ->  Nested Loop Left Join',), ('                    Output: tt4.f1',), ('                    ->  Seq Scan on public.text_tbl tt3',), ('                          Output: tt3.f1',), ("                          Filter: (tt3.f1 = 'foo'::text)",), ('                    ->  Seq Scan on public.text_tbl tt4',), ('                          Output: tt4.f1',), ("                          Filter: (tt4.f1 = 'foo'::text)",), ('  ->  Memoize',), ('        Output: ss1.c0',), ('        Cache Key: tt4.f1',), ('        Cache Mode: binary',), ('        ->  Subquery Scan on ss1',), ('              Output: ss1.c0',), ("              Filter: (ss1.c0 = 'foo'::text)",), ('              ->  Limit',), ('                    Output: (tt4.f1)',), ('                    ->  Seq Scan on public.text_tbl tt5',), ('                          Output: tt4.f1',)]

-----------
QUERY:


select 1 from
  text_tbl as tt1
  inner join text_tbl as tt2 on (tt1.f1 = 'foo')
  left join text_tbl as tt3 on (tt3.f1 = 'foo')
  left join text_tbl as tt4 on (tt3.f1 = tt4.f1),
  lateral (select tt4.f1 as c0 from text_tbl as tt5 limit 1) as ss1
where tt1.f1 = ss1.c0;
RESULT:
	postgres: []

-----------
QUERY:


explain (verbose, costs off)
select 1 from
  int4_tbl as i4
  inner join
    ((select 42 as n from int4_tbl x1 left join int8_tbl x2 on f1 = q1) as ss1
     right join (select 1 as z) as ss2 on true)
  on false,
  lateral (select i4.f1, ss1.n from int8_tbl as i8 limit 1) as ss3;
RESULT:
	postgres: [('Result',), ('  Output: 1',), ('  One-Time Filter: false',)]

-----------
QUERY:


select 1 from
  int4_tbl as i4
  inner join
    ((select 42 as n from int4_tbl x1 left join int8_tbl x2 on f1 = q1) as ss1
     right join (select 1 as z) as ss2 on true)
  on false,
  lateral (select i4.f1, ss1.n from int8_tbl as i8 limit 1) as ss3;
RESULT:
	postgres: []

-----------
QUERY:


--
-- check a case where we formerly generated invalid parameterized paths
--

begin;
RESULT:
	postgres: None

-----------
QUERY:


create temp table t (a int unique);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select 1 from t t1
  join lateral (select t1.a from (select 1) foo offset 0) as s1 on true
  join
    (select 1 from t t2
       inner join (t t3
                   left join (t t4 left join t t5 on t4.a = 1)
                   on t3.a = t4.a)
       on false
     where t3.a = coalesce(t5.a,1)) as s2
  on true;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


--
-- check a case in which a PlaceHolderVar forces join order
--

explain (verbose, costs off)
select ss2.* from
  int4_tbl i41
  left join int8_tbl i8
    join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
          from int4_tbl i42, int4_tbl i43) ss1
    on i8.q1 = ss1.c2
  on i41.f1 = ss1.c1,
  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where ss1.c2 = 0;
RESULT:
	postgres: [('Nested Loop',), ('  Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))',), ('  ->  Hash Join',), ('        Output: i41.f1, i42.f1, i8.q1, i8.q2, i43.f1, 42',), ('        Hash Cond: (i41.f1 = i42.f1)',), ('        ->  Nested Loop',), ('              Output: i8.q1, i8.q2, i43.f1, i41.f1',), ('              ->  Nested Loop',), ('                    Output: i8.q1, i8.q2, i43.f1',), ('                    ->  Seq Scan on public.int8_tbl i8',), ('                          Output: i8.q1, i8.q2',), ('                          Filter: (i8.q1 = 0)',), ('                    ->  Seq Scan on public.int4_tbl i43',), ('                          Output: i43.f1',), ('                          Filter: (i43.f1 = 0)',), ('              ->  Seq Scan on public.int4_tbl i41',), ('                    Output: i41.f1',), ('        ->  Hash',), ('              Output: i42.f1',), ('              ->  Seq Scan on public.int4_tbl i42',), ('                    Output: i42.f1',), ('  ->  Limit',), ('        Output: (i41.f1), (i8.q1), (i8.q2), (i42.f1), (i43.f1), ((42))',), ('        ->  Seq Scan on public.text_tbl',), ('              Output: i41.f1, i8.q1, i8.q2, i42.f1, i43.f1, (42)',)]

-----------
QUERY:


select ss2.* from
  int4_tbl i41
  left join int8_tbl i8
    join (select i42.f1 as c1, i43.f1 as c2, 42 as c3
          from int4_tbl i42, int4_tbl i43) ss1
    on i8.q1 = ss1.c2
  on i41.f1 = ss1.c1,
  lateral (select i41.*, i8.*, ss1.* from text_tbl limit 1) ss2
where ss1.c2 = 0;
RESULT:
	postgres: []

-----------
QUERY:


--
-- test successful handling of full join underneath left join (bug #14105)
--

explain (costs off)
select * from
  (select 1 as id) as xx
  left join
    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))
  on (xx.id = coalesce(yy.id));
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Result',), ('  ->  Hash Full Join',), ('        Hash Cond: (a1.unique1 = (1))',), ('        Filter: (1 = COALESCE((1)))',), ('        ->  Seq Scan on tenk1 a1',), ('        ->  Hash',), ('              ->  Result',)]

-----------
QUERY:


select * from
  (select 1 as id) as xx
  left join
    (tenk1 as a1 full join (select 1 as id) as yy on (a1.unique1 = yy.id))
  on (xx.id = coalesce(yy.id));
RESULT:
	postgres: [(1, 1, 2838, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 'BAAAAA', 'EFEAAA', 'OOOOxx', 1)]

-----------
QUERY:


--
-- test ability to push constants through outer join clauses
--

explain (costs off)
  select * from int4_tbl a left join tenk1 b on f1 = unique2 where f1 = 0;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on int4_tbl a',), ('        Filter: (f1 = 0)',), ('  ->  Index Scan using tenk1_unique2 on tenk1 b',), ('        Index Cond: (unique2 = 0)',)]

-----------
QUERY:


explain (costs off)
  select * from tenk1 a full join tenk1 b using(unique2) where unique2 = 42;
RESULT:
	postgres: [('Merge Full Join',), ('  ->  Index Scan using tenk1_unique2 on tenk1 a',), ('        Index Cond: (unique2 = 42)',), ('  ->  Index Scan using tenk1_unique2 on tenk1 b',), ('        Index Cond: (unique2 = 42)',)]

-----------
QUERY:


--
-- test that quals attached to an outer join have correct semantics,
-- specifically that they don/* REPLACED */''t re-use expressions computed below the join /* REPLACED */,
-- we force a mergejoin so that coalesce(b.q1, 1) appears as a join input
--

set enable_hashjoin to off;
RESULT:
	postgres: None

-----------
QUERY:

set enable_nestloop to off;
RESULT:
	postgres: None

-----------
QUERY:


explain (verbose, costs off)
  select a.q2, b.q1
    from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)
    where coalesce(b.q1, 1) > 0;
RESULT:
	postgres: [('Merge Left Join',), ('  Output: a.q2, b.q1',), ("  Merge Cond: (a.q2 = (COALESCE(b.q1, '1'::bigint)))",), ("  Filter: (COALESCE(b.q1, '1'::bigint) > 0)",), ('  ->  Sort',), ('        Output: a.q2',), ('        Sort Key: a.q2',), ('        ->  Seq Scan on public.int8_tbl a',), ('              Output: a.q2',), ('  ->  Sort',), ("        Output: b.q1, (COALESCE(b.q1, '1'::bigint))",), ("        Sort Key: (COALESCE(b.q1, '1'::bigint))",), ('        ->  Seq Scan on public.int8_tbl b',), ("              Output: b.q1, COALESCE(b.q1, '1'::bigint)",)]

-----------
QUERY:

select a.q2, b.q1
  from int8_tbl a left join int8_tbl b on a.q2 = coalesce(b.q1, 1)
  where coalesce(b.q1, 1) > 0;
RESULT:
	postgres: [(-4567890123456789, None), (123, 123), (123, 123), (456, None), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789)]

-----------
QUERY:


reset enable_hashjoin;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_nestloop;
RESULT:
	postgres: None

-----------
QUERY:


--
-- test join strength reduction with a SubPlan providing the proof
--

explain (costs off)
select a.unique1, b.unique2
  from onek a left join onek b on a.unique1 = b.unique2
  where (b.unique2, random() > 0) = any (select q1, random() > 0 from int8_tbl c where c.q1 < b.unique1);
RESULT:
	postgres: [('Hash Join',), ('  Hash Cond: (b.unique2 = a.unique1)',), ('  ->  Seq Scan on onek b',), ("        Filter: (ANY ((unique2 = (SubPlan 1).col1) AND ((random() > '0'::double precision) = (SubPlan 1).col2)))",), ('        SubPlan 1',), ('          ->  Seq Scan on int8_tbl c',), ('                Filter: (q1 < b.unique1)',), ('  ->  Hash',), ('        ->  Index Only Scan using onek_unique1 on onek a',)]

-----------
QUERY:


select a.unique1, b.unique2
  from onek a left join onek b on a.unique1 = b.unique2
  where (b.unique2, random() > 0) = any (select q1, random() > 0 from int8_tbl c where c.q1 < b.unique1);
RESULT:
	postgres: [(123, 123)]

-----------
QUERY:


--
-- test full-join strength reduction
--

explain (costs off)
select a.unique1, b.unique2
  from onek a full join onek b on a.unique1 = b.unique2
  where a.unique1 = 42;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Index Only Scan using onek_unique1 on onek a',), ('        Index Cond: (unique1 = 42)',), ('  ->  Index Only Scan using onek_unique2 on onek b',), ('        Index Cond: (unique2 = 42)',)]

-----------
QUERY:


select a.unique1, b.unique2
  from onek a full join onek b on a.unique1 = b.unique2
  where a.unique1 = 42;
RESULT:
	postgres: [(42, 42)]

-----------
QUERY:


explain (costs off)
select a.unique1, b.unique2
  from onek a full join onek b on a.unique1 = b.unique2
  where b.unique2 = 43;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Index Only Scan using onek_unique2 on onek b',), ('        Index Cond: (unique2 = 43)',), ('  ->  Index Only Scan using onek_unique1 on onek a',), ('        Index Cond: (unique1 = 43)',)]

-----------
QUERY:


select a.unique1, b.unique2
  from onek a full join onek b on a.unique1 = b.unique2
  where b.unique2 = 43;
RESULT:
	postgres: [(43, 43)]

-----------
QUERY:


explain (costs off)
select a.unique1, b.unique2
  from onek a full join onek b on a.unique1 = b.unique2
  where a.unique1 = 42 and b.unique2 = 42;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Index Only Scan using onek_unique1 on onek a',), ('        Index Cond: (unique1 = 42)',), ('  ->  Index Only Scan using onek_unique2 on onek b',), ('        Index Cond: (unique2 = 42)',)]

-----------
QUERY:


select a.unique1, b.unique2
  from onek a full join onek b on a.unique1 = b.unique2
  where a.unique1 = 42 and b.unique2 = 42;
RESULT:
	postgres: [(42, 42)]

-----------
QUERY:


--
-- test result-RTE removal underneath a full join
--

explain (costs off)
select * from
  (select * from int8_tbl i81 join (values(123,2)) v(v1,v2) on q2=v1) ss1
full join
  (select * from (values(456,2)) w(v1,v2) join int8_tbl i82 on q2=v1) ss2
on true;
RESULT:
	postgres: [('Merge Full Join',), ('  ->  Seq Scan on int8_tbl i81',), ('        Filter: (q2 = 123)',), ('  ->  Materialize',), ('        ->  Seq Scan on int8_tbl i82',), ('              Filter: (q2 = 456)',)]

-----------
QUERY:


select * from
  (select * from int8_tbl i81 join (values(123,2)) v(v1,v2) on q2=v1) ss1
full join
  (select * from (values(456,2)) w(v1,v2) join int8_tbl i82 on q2=v1) ss2
on true;
RESULT:
	postgres: [(4567890123456789, 123, 123, 2, 456, 2, 123, 456)]

-----------
QUERY:


--
-- test join removal
--

begin;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TEMP TABLE a (id int PRIMARY KEY, b_id int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEMP TABLE b (id int PRIMARY KEY, c_id int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEMP TABLE c (id int PRIMARY KEY);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEMP TABLE d (a int, b int);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO a VALUES (0, 0), (1, NULL);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO b VALUES (0, 0), (1, NULL);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO c VALUES (0), (1);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO d VALUES (1,3), (2,2), (3,1);
RESULT:
	postgres: None

-----------
QUERY:


-- all three cases should be optimizable into a simple seqscan
explain (costs off) SELECT a.* FROM a LEFT JOIN b ON a.b_id = b.id;
RESULT:
	postgres: [('Seq Scan on a',)]

-----------
QUERY:

explain (costs off) SELECT b.* FROM b LEFT JOIN c ON b.c_id = c.id;
RESULT:
	postgres: [('Seq Scan on b',)]

-----------
QUERY:

explain (costs off)
  SELECT a.* FROM a LEFT JOIN (b left join c on b.c_id = c.id)
  ON (a.b_id = b.id);
RESULT:
	postgres: [('Seq Scan on a',)]

-----------
QUERY:


-- check optimization of outer join within another special join
explain (costs off)
select id from a where id in (
	select b.id from b left join c on b.id = c.id
);
RESULT:
	postgres: [('Hash Join',), ('  Hash Cond: (a.id = b.id)',), ('  ->  Seq Scan on a',), ('  ->  Hash',), ('        ->  Seq Scan on b',)]

-----------
QUERY:


-- check optimization with oddly-nested outer joins
explain (costs off)
select a1.id from
  (a a1 left join a a2 on true)
  left join
  (a a3 left join a a4 on a3.id = a4.id)
  on a2.id = a3.id;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on a a1',), ('  ->  Materialize',), ('        ->  Seq Scan on a a2',)]

-----------
QUERY:


explain (costs off)
select a1.id from
  (a a1 left join a a2 on a1.id = a2.id)
  left join
  (a a3 left join a a4 on a3.id = a4.id)
  on a2.id = a3.id;
RESULT:
	postgres: [('Seq Scan on a a1',)]

-----------
QUERY:


explain (costs off)
select 1 from a t1
    left join a t2 on true
   inner join a t3 on true
    left join a t4 on t2.id = t4.id and t2.id = t3.id;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Nested Loop Left Join',), ('        ->  Seq Scan on a t1',), ('        ->  Materialize',), ('              ->  Seq Scan on a t2',), ('  ->  Materialize',), ('        ->  Seq Scan on a t3',)]

-----------
QUERY:


-- another example (bug #17781)
explain (costs off)
select ss1.f1
from int4_tbl as t1
  left join (int4_tbl as t2
             right join int4_tbl as t3 on null
             left join (int4_tbl as t4
                        right join int8_tbl as t5 on null)
               on t2.f1 = t4.f1
             left join ((select null as f1 from int4_tbl as t6) as ss1
                        inner join int8_tbl as t7 on null)
               on t5.q1 = t7.q2)
    on false;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: false',), ('  ->  Seq Scan on int4_tbl t1',), ('  ->  Result',), ('        One-Time Filter: false',)]

-----------
QUERY:


-- variant with Var rather than PHV coming from t6
explain (costs off)
select ss1.f1
from int4_tbl as t1
  left join (int4_tbl as t2
             right join int4_tbl as t3 on null
             left join (int4_tbl as t4
                        right join int8_tbl as t5 on null)
               on t2.f1 = t4.f1
             left join ((select f1 from int4_tbl as t6) as ss1
                        inner join int8_tbl as t7 on null)
               on t5.q1 = t7.q2)
    on false;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: false',), ('  ->  Seq Scan on int4_tbl t1',), ('  ->  Result',), ('        One-Time Filter: false',)]

-----------
QUERY:


-- per further discussion of bug #17781
explain (costs off)
select ss1.x
from (select f1/2 as x from int4_tbl i4 left join a on a.id = i4.f1) ss1
     right join int8_tbl i8 on true
where current_user is not null;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: (CURRENT_USER IS NOT NULL)',), ('  ->  Nested Loop Left Join',), ('        ->  Seq Scan on int8_tbl i8',), ('        ->  Materialize',), ('              ->  Seq Scan on int4_tbl i4',)]

-----------
QUERY:
  -- this is to add a Result node

-- and further discussion of bug #17781
explain (costs off)
select *
from int8_tbl t1
  left join (int8_tbl t2 left join onek t3 on t2.q1 > t3.unique1)
    on t1.q2 = t2.q2
  left join onek t4
    on t2.q2 < t3.unique2;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: (t2.q2 < t3.unique2)',), ('  ->  Nested Loop Left Join',), ('        Join Filter: (t2.q1 > t3.unique1)',), ('        ->  Hash Left Join',), ('              Hash Cond: (t1.q2 = t2.q2)',), ('              ->  Seq Scan on int8_tbl t1',), ('              ->  Hash',), ('                    ->  Seq Scan on int8_tbl t2',), ('        ->  Materialize',), ('              ->  Seq Scan on onek t3',), ('  ->  Materialize',), ('        ->  Seq Scan on onek t4',)]

-----------
QUERY:


-- More tests of correct placement of pseudoconstant quals

-- simple constant-false condition
explain (costs off)
select * from int8_tbl t1 left join
  (int8_tbl t2 inner join int8_tbl t3 on false
   left join int8_tbl t4 on t2.q2 = t4.q2)
on t1.q1 = t2.q1;
RESULT:
	postgres: [('Hash Left Join',), ('  Hash Cond: (t1.q1 = q1)',), ('  ->  Seq Scan on int8_tbl t1',), ('  ->  Hash',), ('        ->  Result',), ('              One-Time Filter: false',)]

-----------
QUERY:


-- deduce constant-false from an EquivalenceClass
explain (costs off)
select * from int8_tbl t1 left join
  (int8_tbl t2 inner join int8_tbl t3 on (t2.q1-t3.q2) = 0 and (t2.q1-t3.q2) = 1
   left join int8_tbl t4 on t2.q2 = t4.q2)
on t1.q1 = t2.q1;
RESULT:
	postgres: [('Hash Left Join',), ('  Hash Cond: (t1.q1 = q1)',), ('  ->  Seq Scan on int8_tbl t1',), ('  ->  Hash',), ('        ->  Result',), ('              One-Time Filter: false',)]

-----------
QUERY:


-- pseudoconstant based on an outer-level Param
explain (costs off)
select exists(
  select * from int8_tbl t1 left join
    (int8_tbl t2 inner join int8_tbl t3 on x0.f1 = 1
     left join int8_tbl t4 on t2.q2 = t4.q2)
  on t1.q1 = t2.q1
) from int4_tbl x0;
RESULT:
	postgres: [('Seq Scan on int4_tbl x0',), ('  SubPlan 1',), ('    ->  Nested Loop Left Join',), ('          Join Filter: (t2.q2 = t4.q2)',), ('          ->  Nested Loop Left Join',), ('                Join Filter: (t1.q1 = t2.q1)',), ('                ->  Seq Scan on int8_tbl t1',), ('                ->  Materialize',), ('                      ->  Result',), ('                            One-Time Filter: (x0.f1 = 1)',), ('                            ->  Nested Loop',), ('                                  ->  Seq Scan on int8_tbl t2',), ('                                  ->  Materialize',), ('                                        ->  Seq Scan on int8_tbl t3',), ('          ->  Materialize',), ('                ->  Seq Scan on int8_tbl t4',)]

-----------
QUERY:


-- check that join removal works for a left join when joining a subquery
-- that is guaranteed to be unique by its GROUP BY clause
explain (costs off)
select d.* from d left join (select * from b group by b.id, b.c_id) s
  on d.a = s.id and d.b = s.c_id;
RESULT:
	postgres: [('Seq Scan on d',)]

-----------
QUERY:


-- similarly, but keying off a DISTINCT clause
explain (costs off)
select d.* from d left join (select distinct * from b) s
  on d.a = s.id and d.b = s.c_id;
RESULT:
	postgres: [('Seq Scan on d',)]

-----------
QUERY:


-- join removal is not possible when the GROUP BY contains a column that is
-- not in the join condition.  (Note: as of 9.6, we notice that b.id is a
-- primary key and so drop b.c_id from the GROUP BY of the resulting plan /* REPLACED */,
-- but this happens too late for join removal in the outer plan level.)
explain (costs off)
select d.* from d left join (select * from b group by b.id, b.c_id) s
  on d.a = s.id;
RESULT:
	postgres: [('Merge Right Join',), ('  Merge Cond: (b.id = d.a)',), ('  ->  Group',), ('        Group Key: b.id',), ('        ->  Index Scan using b_pkey on b',), ('  ->  Sort',), ('        Sort Key: d.a',), ('        ->  Seq Scan on d',)]

-----------
QUERY:


-- similarly, but keying off a DISTINCT clause
explain (costs off)
select d.* from d left join (select distinct * from b) s
  on d.a = s.id;
RESULT:
	postgres: [('Merge Right Join',), ('  Merge Cond: (b.id = d.a)',), ('  ->  Unique',), ('        ->  Sort',), ('              Sort Key: b.id, b.c_id',), ('              ->  Seq Scan on b',), ('  ->  Sort',), ('        Sort Key: d.a',), ('        ->  Seq Scan on d',)]

-----------
QUERY:


-- join removal is not possible here
explain (costs off)
select 1 from a t1
  left join (a t2 left join a t3 on t2.id = 1) on t2.id = 1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on a t1',), ('  ->  Materialize',), ('        ->  Nested Loop Left Join',), ('              Join Filter: (t2.id = 1)',), ('              ->  Index Only Scan using a_pkey on a t2',), ('                    Index Cond: (id = 1)',), ('              ->  Seq Scan on a t3',)]

-----------
QUERY:


-- check join removal works when uniqueness of the join condition is enforced
-- by a UNION
explain (costs off)
select d.* from d left join (select id from a union select id from b) s
  on d.a = s.id;
RESULT:
	postgres: [('Seq Scan on d',)]

-----------
QUERY:


-- check join removal with a cross-type comparison operator
explain (costs off)
select i8.* from int8_tbl i8 left join (select f1 from int4_tbl group by f1) i4
  on i8.q1 = i4.f1;
RESULT:
	postgres: [('Seq Scan on int8_tbl i8',)]

-----------
QUERY:


-- check join removal with lateral references
explain (costs off)
select 1 from (select a.id FROM a left join b on a.b_id = b.id) q,
			  lateral generate_series(1, q.id) gs(i) where q.id = gs.i;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Seq Scan on a',), ('  ->  Function Scan on generate_series gs',), ('        Filter: (a.id = i)',)]

-----------
QUERY:


-- check join removal within RHS of an outer join
explain (costs off)
select c.id, ss.a from c
  left join (select d.a from onerow, d left join b on d.a = b.id) ss
  on c.id = ss.a;
RESULT:
	postgres: [('Hash Right Join',), ('  Hash Cond: (d.a = c.id)',), ('  ->  Nested Loop',), ('        ->  Seq Scan on onerow',), ('        ->  Seq Scan on d',), ('  ->  Hash',), ('        ->  Seq Scan on c',)]

-----------
QUERY:


CREATE TEMP TABLE parted_b (id int PRIMARY KEY) partition by range(id);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEMP TABLE parted_b1 partition of parted_b for values from (0) to (10);
RESULT:
	postgres: None

-----------
QUERY:


-- test join removals on a partitioned table
explain (costs off)
select a.* from a left join parted_b pb on a.b_id = pb.id;
RESULT:
	postgres: [('Seq Scan on a',)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


create temp table parent (k int primary key, pd int);
RESULT:
	postgres: None

-----------
QUERY:

create temp table child (k int unique, cd int);
RESULT:
	postgres: None

-----------
QUERY:

insert into parent values (1, 10), (2, 20), (3, 30);
RESULT:
	postgres: None

-----------
QUERY:

insert into child values (1, 100), (4, 400);
RESULT:
	postgres: None

-----------
QUERY:


-- this case is optimizable
select p.* from parent p left join child c on (p.k = c.k);
RESULT:
	postgres: [(1, 10), (2, 20), (3, 30)]

-----------
QUERY:

explain (costs off)
  select p.* from parent p left join child c on (p.k = c.k);
RESULT:
	postgres: [('Seq Scan on parent p',)]

-----------
QUERY:


-- this case is not
select p.*, linked from parent p
  left join (select c.*, true as linked from child c) as ss
  on (p.k = ss.k);
RESULT:
	postgres: [(1, 10, True), (2, 20, None), (3, 30, None)]

-----------
QUERY:

explain (costs off)
  select p.*, linked from parent p
    left join (select c.*, true as linked from child c) as ss
    on (p.k = ss.k);
RESULT:
	postgres: [('Hash Left Join',), ('  Hash Cond: (p.k = c.k)',), ('  ->  Seq Scan on parent p',), ('  ->  Hash',), ('        ->  Seq Scan on child c',)]

-----------
QUERY:


-- check for a 9.0rc1 bug: join removal breaks pseudoconstant qual handling
select p.* from
  parent p left join child c on (p.k = c.k)
  where p.k = 1 and p.k = 2;
RESULT:
	postgres: []

-----------
QUERY:

explain (costs off)
select p.* from
  parent p left join child c on (p.k = c.k)
  where p.k = 1 and p.k = 2;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


select p.* from
  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
  where p.k = 1 and p.k = 2;
RESULT:
	postgres: []

-----------
QUERY:

explain (costs off)
select p.* from
  (parent p left join child c on (p.k = c.k)) join parent x on p.k = x.k
  where p.k = 1 and p.k = 2;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


-- bug 5255: this is not optimizable by join removal
begin;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TEMP TABLE a (id int PRIMARY KEY);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TEMP TABLE b (id int PRIMARY KEY, a_id int);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO a VALUES (0), (1);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO b VALUES (0, 0), (1, NULL);
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
RESULT:
	postgres: [(1, None, None)]

-----------
QUERY:

SELECT b.* FROM b LEFT JOIN a ON (b.a_id = a.id) WHERE (a.id IS NULL OR a.id > 0);
RESULT:
	postgres: [(1, None)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


-- another join removal bug: this is not optimizable, either
begin;
RESULT:
	postgres: None

-----------
QUERY:


create temp table innertab (id int8 primary key, dat1 int8);
RESULT:
	postgres: None

-----------
QUERY:

insert into innertab values(123, 42);
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM
    (SELECT 1 AS x) ss1
  LEFT JOIN
    (SELECT q1, q2, COALESCE(dat1, q1) AS y
     FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss2
  ON true;
RESULT:
	postgres: [(1, 123, 456, 123), (1, 123, 4567890123456789, 123), (1, 4567890123456789, 123, 42), (1, 4567890123456789, 4567890123456789, 4567890123456789), (1, 4567890123456789, -4567890123456789, 4567890123456789)]

-----------
QUERY:


-- join removal bug #17769: can/* REPLACED */''t remove if there/* REPLACED */''s a pushed-down reference
EXPLAIN (COSTS OFF)
SELECT q2 FROM
  (SELECT *
   FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss
 WHERE COALESCE(dat1, 0) = q1;
RESULT:
	postgres: [('Nested Loop Left Join',), ("  Filter: (COALESCE(innertab.dat1, '0'::bigint) = int8_tbl.q1)",), ('  ->  Seq Scan on int8_tbl',), ('  ->  Index Scan using innertab_pkey on innertab',), ('        Index Cond: (id = int8_tbl.q2)',)]

-----------
QUERY:


-- join removal bug #17773: otherwise-removable PHV appears in a qual condition
EXPLAIN (VERBOSE, COSTS OFF)
SELECT q2 FROM
  (SELECT q2, 'constant'::text AS x
   FROM int8_tbl LEFT JOIN innertab ON q2 = id) ss
  RIGHT JOIN int4_tbl ON NULL
 WHERE x >= x;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: q2',), ('  Join Filter: NULL::boolean',), ("  Filter: (('constant'::text) >= ('constant'::text))",), ('  ->  Seq Scan on public.int4_tbl',), ('        Output: int4_tbl.f1',), ('  ->  Result',), ("        Output: q2, 'constant'::text",), ('        One-Time Filter: false',)]

-----------
QUERY:


-- join removal bug #17786: check that OR conditions are cleaned up
EXPLAIN (COSTS OFF)
SELECT f1, x
FROM int4_tbl
     JOIN ((SELECT 42 AS x FROM int8_tbl LEFT JOIN innertab ON q1 = id) AS ss1
           RIGHT JOIN tenk1 ON NULL)
        ON tenk1.unique1 = ss1.x OR tenk1.unique2 = ss1.x;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Seq Scan on int4_tbl',), ('  ->  Materialize',), ('        ->  Nested Loop Left Join',), ('              Join Filter: NULL::boolean',), ('              Filter: ((tenk1.unique1 = (42)) OR (tenk1.unique2 = (42)))',), ('              ->  Seq Scan on tenk1',), ('              ->  Result',), ('                    One-Time Filter: false',)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


-- another join removal bug: we must clean up correctly when removing a PHV
begin;
RESULT:
	postgres: None

-----------
QUERY:


create temp table uniquetbl (f1 text unique);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select t1.* from
  uniquetbl as t1
  left join (select *, '***'::text as d1 from uniquetbl) t2
  on t1.f1 = t2.f1
  left join uniquetbl t3
  on t2.d1 = t3.f1;
RESULT:
	postgres: [('Seq Scan on uniquetbl t1',)]

-----------
QUERY:


explain (costs off)
select t0.*
from
 text_tbl t0
 left join
   (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,
           t1.stringu2
     from tenk1 t1
     join int4_tbl i4 ON i4.f1 = t1.unique2
     left join uniquetbl u1 ON u1.f1 = t1.string4) ss
  on t0.f1 = ss.case1
where ss.stringu2 !~* ss.case1;
RESULT:
	postgres: [('Nested Loop',), ("  Join Filter: (t0.f1 = CASE t1.ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END)",), ('  ->  Nested Loop',), ('        ->  Seq Scan on int4_tbl i4',), ('        ->  Index Scan using tenk1_unique2 on tenk1 t1',), ('              Index Cond: (unique2 = i4.f1)',), ("              Filter: (stringu2 !~* CASE ten WHEN 0 THEN 'doh!'::text ELSE NULL::text END)",), ('  ->  Materialize',), ('        ->  Seq Scan on text_tbl t0',)]

-----------
QUERY:


select t0.*
from
 text_tbl t0
 left join
   (select case t1.ten when 0 then 'doh!'::text else null::text end as case1,
           t1.stringu2
     from tenk1 t1
     join int4_tbl i4 ON i4.f1 = t1.unique2
     left join uniquetbl u1 ON u1.f1 = t1.string4) ss
  on t0.f1 = ss.case1
where ss.stringu2 !~* ss.case1;
RESULT:
	postgres: [('doh!',)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


-- another join removal bug: we must clean up EquivalenceClasses too
begin;
RESULT:
	postgres: None

-----------
QUERY:


create temp table t (a int unique);
RESULT:
	postgres: None

-----------
QUERY:

insert into t values (1);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select 1
from t t1
  left join (select 2 as c
             from t t2 left join t t3 on t2.a = t3.a) s
    on true
where t1.a = s.c;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Filter: (t1.a = (2))',), ('  ->  Seq Scan on t t1',), ('  ->  Materialize',), ('        ->  Seq Scan on t t2',)]

-----------
QUERY:


select 1
from t t1
  left join (select 2 as c
             from t t2 left join t t3 on t2.a = t3.a) s
    on true
where t1.a = s.c;
RESULT:
	postgres: []

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


-- test cases where we can remove a join, but not a PHV computed at it
begin;
RESULT:
	postgres: None

-----------
QUERY:


create temp table t (a int unique, b int);
RESULT:
	postgres: None

-----------
QUERY:

insert into t values (1,1), (2,2);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select 1
from t t1
  left join (select t2.a, 1 as c
             from t t2 left join t t3 on t2.a = t3.a) s
  on true
  left join t t4 on true
where s.a < s.c;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Nested Loop',), ('        ->  Seq Scan on t t1',), ('        ->  Materialize',), ('              ->  Seq Scan on t t2',), ('                    Filter: (a < 1)',), ('  ->  Materialize',), ('        ->  Seq Scan on t t4',)]

-----------
QUERY:


explain (costs off)
select t1.a, s.*
from t t1
  left join lateral (select t2.a, coalesce(t1.a, 1) as c
                     from t t2 left join t t3 on t2.a = t3.a) s
  on true
  left join t t4 on true
where s.a < s.c;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Nested Loop',), ('        ->  Seq Scan on t t1',), ('        ->  Seq Scan on t t2',), ('              Filter: (a < COALESCE(t1.a, 1))',), ('  ->  Materialize',), ('        ->  Seq Scan on t t4',)]

-----------
QUERY:


select t1.a, s.*
from t t1
  left join lateral (select t2.a, coalesce(t1.a, 1) as c
                     from t t2 left join t t3 on t2.a = t3.a) s
  on true
  left join t t4 on true
where s.a < s.c;
RESULT:
	postgres: [(2, 1, 2), (2, 1, 2)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


-- test case to expose miscomputation of required relid set for a PHV
explain (verbose, costs off)
select i8.*, ss.v, t.unique2
  from int8_tbl i8
    left join int4_tbl i4 on i4.f1 = 1
    left join lateral (select i4.f1 + 1 as v) as ss on true
    left join tenk1 t on t.unique2 = ss.v
where q2 = 456;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: i8.q1, i8.q2, ((i4.f1 + 1)), t.unique2',), ('  ->  Nested Loop Left Join',), ('        Output: i8.q1, i8.q2, (i4.f1 + 1)',), ('        ->  Seq Scan on public.int8_tbl i8',), ('              Output: i8.q1, i8.q2',), ('              Filter: (i8.q2 = 456)',), ('        ->  Seq Scan on public.int4_tbl i4',), ('              Output: i4.f1',), ('              Filter: (i4.f1 = 1)',), ('  ->  Index Only Scan using tenk1_unique2 on public.tenk1 t',), ('        Output: t.unique2',), ('        Index Cond: (t.unique2 = ((i4.f1 + 1)))',)]

-----------
QUERY:


select i8.*, ss.v, t.unique2
  from int8_tbl i8
    left join int4_tbl i4 on i4.f1 = 1
    left join lateral (select i4.f1 + 1 as v) as ss on true
    left join tenk1 t on t.unique2 = ss.v
where q2 = 456;
RESULT:
	postgres: [(123, 456, None, None)]

-----------
QUERY:


-- and check a related issue where we miscompute required relids for
-- a PHV that/* REPLACED */''s been translated to a child rel
create temp table parttbl (a integer primary key) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create temp table parttbl1 partition of parttbl for values from (1) to (100);
RESULT:
	postgres: None

-----------
QUERY:

insert into parttbl values (11), (12);
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off)
select * from
  (select *, 12 as phv from parttbl) as ss
  right join int4_tbl on true
where ss.a = ss.phv and f1 = 0;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Seq Scan on int4_tbl',), ('        Filter: (f1 = 0)',), ('  ->  Seq Scan on parttbl1 parttbl',), ('        Filter: (a = 12)',)]

-----------
QUERY:


select * from
  (select *, 12 as phv from parttbl) as ss
  right join int4_tbl on true
where ss.a = ss.phv and f1 = 0;
RESULT:
	postgres: [(12, 12, 0)]

-----------
QUERY:


-- bug #8444: we/* REPLACED */''ve historically allowed duplicate aliases within aliased JOINs

select * from
  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1;
RESULT:
	postgres: column reference "f1" is ambiguous
LINE 6: ..._tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = f1;
                                                                    ^


-----------
QUERY:
 -- error
select * from
  int8_tbl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1;
RESULT:
	postgres: invalid reference to FROM-clause entry for table "y"
LINE 3: ...bl x join (int4_tbl x cross join int4_tbl y) j on q1 = y.f1;
                                                                  ^
DETAIL:  There is an entry for table "y", but it cannot be referenced from this part of the query.


-----------
QUERY:
 -- error
select * from
  int8_tbl x join (int4_tbl x cross join int4_tbl y(ff)) j on q1 = f1;
RESULT:
	postgres: []

-----------
QUERY:
 -- ok

--
-- test that semi- or inner self-joins on a unique column are removed
--

-- enable only nestloop to get more predictable plans
set enable_hashjoin to off;
RESULT:
	postgres: None

-----------
QUERY:

set enable_mergejoin to off;
RESULT:
	postgres: None

-----------
QUERY:


create table sj (a int unique, b int, c int unique);
RESULT:
	postgres: None

-----------
QUERY:

insert into sj values (1, null, 2), (null, 2, null), (2, 1, 1);
RESULT:
	postgres: None

-----------
QUERY:

analyze sj;
RESULT:
	postgres: None

-----------
QUERY:


-- Trivial self-join case.
explain (costs off)
select p.* from sj p, sj q where q.a = p.a and q.b = q.a - 1;
RESULT:
	postgres: [('Seq Scan on sj q',), ('  Filter: ((a IS NOT NULL) AND (b = (a - 1)))',)]

-----------
QUERY:

select p.* from sj p, sj q where q.a = p.a and q.b = q.a - 1;
RESULT:
	postgres: [(2, 1, 1)]

-----------
QUERY:


-- Self-join removal performs after a subquery pull-up process and could remove
-- such kind of self-join too. Check this option.
explain (costs off)
select * from sj p
where exists (select * from sj q
              where q.a = p.a and q.b < 10);
RESULT:
	postgres: [('Seq Scan on sj q',), ('  Filter: ((a IS NOT NULL) AND (b < 10))',)]

-----------
QUERY:

select * from sj p
where exists (select * from sj q
              where q.a = p.a and q.b < 10);
RESULT:
	postgres: [(2, 1, 1)]

-----------
QUERY:


-- Don/* REPLACED */''t remove self-join for the case of equality of two different unique columns.
explain (costs off)
select * from sj t1, sj t2 where t1.a = t2.c and t1.b is not null;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (t1.a = t2.c)',), ('  ->  Seq Scan on sj t2',), ('  ->  Materialize',), ('        ->  Seq Scan on sj t1',), ('              Filter: (b IS NOT NULL)',)]

-----------
QUERY:


-- Degenerated case.
explain (costs off)
select * from
  (select a as x from sj where false) as q1,
  (select a as y from sj where false) as q2
where q1.x = q2.y;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


-- We can/* REPLACED */''t use a cross-EC generated self join qual because of current logic of
-- the generate_join_implied_equalities routine.
explain (costs off)
select * from sj t1, sj t2 where t1.a = t1.b and t1.b = t2.b and t2.b = t2.a;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (t1.a = t2.b)',), ('  ->  Seq Scan on sj t1',), ('        Filter: (a = b)',), ('  ->  Seq Scan on sj t2',), ('        Filter: (b = a)',)]

-----------
QUERY:

explain (costs off)
select * from sj t1, sj t2, sj t3
where t1.a = t1.b and t1.b = t2.b and t2.b = t2.a and
      t1.b = t3.b and t3.b = t3.a;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (t1.a = t3.b)',), ('  ->  Nested Loop',), ('        Join Filter: (t1.a = t2.b)',), ('        ->  Seq Scan on sj t1',), ('              Filter: (a = b)',), ('        ->  Seq Scan on sj t2',), ('              Filter: (b = a)',), ('  ->  Seq Scan on sj t3',), ('        Filter: (b = a)',)]

-----------
QUERY:


-- Double self-join removal.
-- Use a condition on /* REPLACED */''b + 1/* REPLACED */'', not on /* REPLACED */''b/* REPLACED */'', for the second join, so that
-- the equivalence class is different from the first one, and we can
-- test the non-ec code path.
explain (costs off)
select *
from  sj t1
      join sj t2 on t1.a = t2.a and t1.b = t2.b
	  join sj t3 on t2.a = t3.a and t2.b + 1 = t3.b + 1;
RESULT:
	postgres: [('Seq Scan on sj t3',), ('  Filter: ((a IS NOT NULL) AND (b IS NOT NULL) AND ((b + 1) IS NOT NULL))',)]

-----------
QUERY:


-- subselect that references the removed relation
explain (costs off)
select t1.a, (select a from sj where a = t2.a and a = t1.a)
from sj t1, sj t2
where t1.a = t2.a;
RESULT:
	postgres: [('Seq Scan on sj t2',), ('  Filter: (a IS NOT NULL)',), ('  SubPlan 1',), ('    ->  Result',), ('          One-Time Filter: (t2.a = t2.a)',), ('          ->  Seq Scan on sj',), ('                Filter: (a = t2.a)',)]

-----------
QUERY:


-- self-join under outer join
explain (costs off)
select * from sj x join sj y on x.a = y.a
left join int8_tbl z on x.a = z.q1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: (y.a = z.q1)',), ('  ->  Seq Scan on sj y',), ('        Filter: (a IS NOT NULL)',), ('  ->  Materialize',), ('        ->  Seq Scan on int8_tbl z',)]

-----------
QUERY:


explain (costs off)
select * from sj x join sj y on x.a = y.a
left join int8_tbl z on y.a = z.q1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: (y.a = z.q1)',), ('  ->  Seq Scan on sj y',), ('        Filter: (a IS NOT NULL)',), ('  ->  Materialize',), ('        ->  Seq Scan on int8_tbl z',)]

-----------
QUERY:


explain (costs off)
select * from (
  select t1.*, t2.a as ax from sj t1 join sj t2
  on (t1.a = t2.a and t1.c * t1.c = t2.c + 2 and t2.b is null)
) as q1
left join
  (select t3.* from sj t3, sj t4 where t3.c = t4.c) as q2
on q1.ax = q2.a;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: (t2.a = t4.a)',), ('  ->  Seq Scan on sj t2',), ('        Filter: ((b IS NULL) AND (a IS NOT NULL) AND ((c * c) = (c + 2)))',), ('  ->  Seq Scan on sj t4',), ('        Filter: (c IS NOT NULL)',)]

-----------
QUERY:


-- Test that placeholders are updated correctly after join removal
explain (costs off)
select * from (values (1)) x
left join (select coalesce(y.q1, 1) from int8_tbl y
	right join sj j1 inner join sj j2 on j1.a = j2.a
	on true) z
on true;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Result',), ('  ->  Nested Loop Left Join',), ('        ->  Seq Scan on sj j2',), ('              Filter: (a IS NOT NULL)',), ('        ->  Materialize',), ('              ->  Seq Scan on int8_tbl y',)]

-----------
QUERY:


-- Test that references to the removed rel in lateral subqueries are replaced
-- correctly after join removal
explain (verbose, costs off)
select t3.a from sj t1
	join sj t2 on t1.a = t2.a
	join lateral (select t1.a offset 0) t3 on true;
RESULT:
	postgres: [('Nested Loop',), ('  Output: (t2.a)',), ('  ->  Seq Scan on public.sj t2',), ('        Output: t2.a, t2.b, t2.c',), ('        Filter: (t2.a IS NOT NULL)',), ('  ->  Result',), ('        Output: t2.a',)]

-----------
QUERY:


explain (verbose, costs off)
select t3.a from sj t1
	join sj t2 on t1.a = t2.a
	join lateral (select * from (select t1.a offset 0) offset 0) t3 on true;
RESULT:
	postgres: [('Nested Loop',), ('  Output: (t2.a)',), ('  ->  Seq Scan on public.sj t2',), ('        Output: t2.a, t2.b, t2.c',), ('        Filter: (t2.a IS NOT NULL)',), ('  ->  Result',), ('        Output: t2.a',)]

-----------
QUERY:


explain (verbose, costs off)
select t4.a from sj t1
	join sj t2 on t1.a = t2.a
	join lateral (select t3.a from sj t3, (select t1.a) offset 0) t4 on true;
RESULT:
	postgres: [('Nested Loop',), ('  Output: t3.a',), ('  ->  Seq Scan on public.sj t2',), ('        Output: t2.a, t2.b, t2.c',), ('        Filter: (t2.a IS NOT NULL)',), ('  ->  Seq Scan on public.sj t3',), ('        Output: t3.a',)]

-----------
QUERY:


-- Check updating of Lateral links from top-level query to the removing relation
explain (COSTS OFF)
SELECT * FROM pg_am am WHERE am.amname IN (
  SELECT c1.relname AS relname
  FROM pg_class c1
    JOIN pg_class c2
    ON c1.oid=c2.oid AND c1.oid < 10
);
RESULT:
	postgres: [('Nested Loop Semi Join',), ('  Join Filter: (am.amname = c2.relname)',), ('  ->  Seq Scan on pg_am am',), ('  ->  Materialize',), ('        ->  Index Scan using pg_class_oid_index on pg_class c2',), ("              Index Cond: (oid < '10'::oid)",)]

-----------
QUERY:


--
-- SJE corner case: uniqueness of an inner is [partially] derived from
-- baserestrictinfo clauses.
-- XXX: We really should allow SJE for these corner cases?
--

INSERT INTO sj VALUES (3, 1, 3);
RESULT:
	postgres: None

-----------
QUERY:


-- Don/* REPLACED */''t remove SJ
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 2 AND j2.a = 3;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (j1.b = j2.b)',), ('  ->  Seq Scan on sj j1',), ('        Filter: (a = 2)',), ('  ->  Seq Scan on sj j2',), ('        Filter: (a = 3)',)]

-----------
QUERY:

-- Return one row
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 2 AND j2.a = 3;
RESULT:
	postgres: [(2, 1, 1, 3, 1, 3)]

-----------
QUERY:


-- Remove SJ, define uniqueness by a constant
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 2 AND j2.a = 2;
RESULT:
	postgres: [('Seq Scan on sj j2',), ('  Filter: ((b IS NOT NULL) AND (a = 2))',)]

-----------
QUERY:

-- Return one row
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 2 AND j2.a = 2;
RESULT:
	postgres: [(2, 1, 1, 2, 1, 1)]

-----------
QUERY:


-- Remove SJ, define uniqueness by a constant expression
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2
WHERE j1.b = j2.b
  AND j1.a = (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int
  AND (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int = j2.a;
RESULT:
	postgres: [('Seq Scan on sj j2',), ("  Filter: ((b IS NOT NULL) AND (a = (((EXTRACT(dow FROM CURRENT_TIMESTAMP(0)) / '15'::numeric) + '3'::numeric))::integer))",)]

-----------
QUERY:

-- Return one row
SELECT * FROM sj j1, sj j2
WHERE j1.b = j2.b
  AND j1.a = (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int
  AND (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int = j2.a;
RESULT:
	postgres: [(3, 1, 3, 3, 1, 3)]

-----------
QUERY:


-- Remove SJ
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 1 AND j2.a = 1;
RESULT:
	postgres: [('Seq Scan on sj j2',), ('  Filter: ((b IS NOT NULL) AND (a = 1))',)]

-----------
QUERY:

-- Return no rows
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 1 AND j2.a = 1;
RESULT:
	postgres: []

-----------
QUERY:


-- Shuffle a clause. Remove SJ
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND 1 = j1.a AND j2.a = 1;
RESULT:
	postgres: [('Seq Scan on sj j2',), ('  Filter: ((b IS NOT NULL) AND (a = 1))',)]

-----------
QUERY:

-- Return no rows
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND 1 = j1.a AND j2.a = 1;
RESULT:
	postgres: []

-----------
QUERY:


-- SJE Corner case: a /* REPLACED */''a.x=a.x/* REPLACED */'' clause, have replaced with /* REPLACED */''a.x IS NOT NULL/* REPLACED */''
-- after SJ elimination it shouldn/* REPLACED */''t be a mergejoinable clause.
EXPLAIN (COSTS OFF)
SELECT t4.*
FROM (SELECT t1.*, t2.a AS a1 FROM sj t1, sj t2 WHERE t1.b = t2.b) AS t3
JOIN sj t4 ON (t4.a = t3.a) WHERE t3.a1 = 42;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (t1.b = t2.b)',), ('  ->  Seq Scan on sj t2',), ('        Filter: (a = 42)',), ('  ->  Seq Scan on sj t1',), ('        Filter: (a IS NOT NULL)',)]

-----------
QUERY:

SELECT t4.*
FROM (SELECT t1.*, t2.a AS a1 FROM sj t1, sj t2 WHERE t1.b = t2.b) AS t3
JOIN sj t4 ON (t4.a = t3.a) WHERE t3.a1 = 42;
RESULT:
	postgres: []

-----------
QUERY:


-- Functional index
CREATE UNIQUE INDEX sj_fn_idx ON sj((a * a));
RESULT:
	postgres: None

-----------
QUERY:


-- Remove SJ
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2
	WHERE j1.b = j2.b AND j1.a*j1.a = 1 AND j2.a*j2.a = 1;
RESULT:
	postgres: [('Seq Scan on sj j2',), ('  Filter: ((b IS NOT NULL) AND ((a * a) = 1))',)]

-----------
QUERY:

-- Don/* REPLACED */''t remove SJ
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2
	WHERE j1.b = j2.b AND j1.a*j1.a = 1 AND j2.a*j2.a = 2;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (j1.b = j2.b)',), ('  ->  Seq Scan on sj j1',), ('        Filter: ((a * a) = 1)',), ('  ->  Seq Scan on sj j2',), ('        Filter: ((a * a) = 2)',)]

-----------
QUERY:


-- Restriction contains expressions in both sides, Remove SJ.
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2
WHERE j1.b = j2.b
  AND (j1.a*j1.a) = (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int
  AND (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int = (j2.a*j2.a);
RESULT:
	postgres: [('Seq Scan on sj j2',), ("  Filter: ((b IS NOT NULL) AND ((a * a) = (((EXTRACT(dow FROM CURRENT_TIMESTAMP(0)) / '15'::numeric) + '3'::numeric))::integer))",)]

-----------
QUERY:

-- Empty set of rows should be returned
SELECT * FROM sj j1, sj j2
WHERE j1.b = j2.b
  AND (j1.a*j1.a) = (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int
  AND (EXTRACT(DOW FROM current_timestamp(0))/15 + 3)::int = (j2.a*j2.a);
RESULT:
	postgres: []

-----------
QUERY:


-- Restriction contains volatile function - disable SJE feature.
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2
WHERE j1.b = j2.b
  AND (j1.a*j1.c/3) = (random()/3 + 3)::int
  AND (random()/3 + 3)::int = (j2.a*j2.c/3);
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (j1.b = j2.b)',), ('  ->  Seq Scan on sj j1',), ("        Filter: (((a * c) / 3) = (((random() / '3'::double precision) + '3'::double precision))::integer)",), ('  ->  Seq Scan on sj j2',), ("        Filter: ((((random() / '3'::double precision) + '3'::double precision))::integer = ((a * c) / 3))",)]

-----------
QUERY:

-- Return one row
SELECT * FROM sj j1, sj j2
WHERE j1.b = j2.b
  AND (j1.a*j1.c/3) = (random()/3 + 3)::int
  AND (random()/3 + 3)::int = (j2.a*j2.c/3);
RESULT:
	postgres: [(3, 1, 3, 3, 1, 3)]

-----------
QUERY:


-- Multiple filters
CREATE UNIQUE INDEX sj_temp_idx1 ON sj(a,b,c);
RESULT:
	postgres: None

-----------
QUERY:


-- Remove SJ
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2
	WHERE j1.b = j2.b AND j1.a = 2 AND j1.c = 3 AND j2.a = 2 AND 3 = j2.c;
RESULT:
	postgres: [('Seq Scan on sj j2',), ('  Filter: ((b IS NOT NULL) AND (a = 2) AND (c = 3))',)]

-----------
QUERY:


-- Don/* REPLACED */''t remove SJ
EXPLAIN (COSTS OFF)
	SELECT * FROM sj j1, sj j2
	WHERE j1.b = j2.b AND 2 = j1.a AND j1.c = 3 AND j2.a = 1 AND 3 = j2.c;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (j1.b = j2.b)',), ('  ->  Seq Scan on sj j1',), ('        Filter: ((2 = a) AND (c = 3))',), ('  ->  Seq Scan on sj j2',), ('        Filter: ((c = 3) AND (a = 1))',)]

-----------
QUERY:


CREATE UNIQUE INDEX sj_temp_idx ON sj(a,b);
RESULT:
	postgres: None

-----------
QUERY:


-- Don/* REPLACED */''t remove SJ
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND j1.a = 2;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (j1.b = j2.b)',), ('  ->  Seq Scan on sj j1',), ('        Filter: (a = 2)',), ('  ->  Seq Scan on sj j2',)]

-----------
QUERY:


-- Don/* REPLACED */''t remove SJ
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND 2 = j2.a;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (j1.b = j2.b)',), ('  ->  Seq Scan on sj j2',), ('        Filter: (2 = a)',), ('  ->  Seq Scan on sj j1',)]

-----------
QUERY:


-- Don/* REPLACED */''t remove SJ
EXPLAIN (COSTS OFF)
SELECT * FROM sj j1, sj j2 WHERE j1.b = j2.b AND (j1.a = 1 OR j2.a = 1);
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: ((j1.b = j2.b) AND ((j1.a = 1) OR (j2.a = 1)))',), ('  ->  Seq Scan on sj j1',), ('  ->  Materialize',), ('        ->  Seq Scan on sj j2',)]

-----------
QUERY:


DROP INDEX sj_fn_idx, sj_temp_idx1, sj_temp_idx;
RESULT:
	postgres: None

-----------
QUERY:


-- Test that OR predicated are updated correctly after join removal
CREATE TABLE tab_with_flag ( id INT PRIMARY KEY, is_flag SMALLINT);
RESULT:
	postgres: None

-----------
QUERY:

CREATE INDEX idx_test_is_flag ON tab_with_flag (is_flag);
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT COUNT(*) FROM tab_with_flag
WHERE
	(is_flag IS NULL OR is_flag = 0)
	AND id IN (SELECT id FROM tab_with_flag WHERE id IN (2, 3));
RESULT:
	postgres: [('Aggregate',), ('  ->  Bitmap Heap Scan on tab_with_flag',), ("        Recheck Cond: (id = ANY ('{2,3}'::integer[]))",), ('        Filter: ((is_flag IS NULL) OR (is_flag = 0))',), ('        ->  Bitmap Index Scan on tab_with_flag_pkey',), ("              Index Cond: (id = ANY ('{2,3}'::integer[]))",)]

-----------
QUERY:

DROP TABLE tab_with_flag;
RESULT:
	postgres: None

-----------
QUERY:


-- HAVING clause
explain (costs off)
select p.b from sj p join sj q on p.a = q.a group by p.b having sum(p.a) = 1;
RESULT:
	postgres: [('HashAggregate',), ('  Group Key: q.b',), ('  Filter: (sum(q.a) = 1)',), ('  ->  Seq Scan on sj q',), ('        Filter: (a IS NOT NULL)',)]

-----------
QUERY:


-- update lateral references and range table entry reference
explain (verbose, costs off)
select 1 from (select x.* from sj x, sj y where x.a = y.a) q,
  lateral generate_series(1, q.a) gs(i);
RESULT:
	postgres: [('Nested Loop',), ('  Output: 1',), ('  ->  Seq Scan on public.sj y',), ('        Output: y.a, y.b, y.c',), ('        Filter: (y.a IS NOT NULL)',), ('  ->  Function Scan on pg_catalog.generate_series gs',), ('        Output: gs.i',), ('        Function Call: generate_series(1, y.a)',)]

-----------
QUERY:


explain (verbose, costs off)
select 1 from (select y.* from sj x, sj y where x.a = y.a) q,
  lateral generate_series(1, q.a) gs(i);
RESULT:
	postgres: [('Nested Loop',), ('  Output: 1',), ('  ->  Seq Scan on public.sj y',), ('        Output: y.a, y.b, y.c',), ('        Filter: (y.a IS NOT NULL)',), ('  ->  Function Scan on pg_catalog.generate_series gs',), ('        Output: gs.i',), ('        Function Call: generate_series(1, y.a)',)]

-----------
QUERY:


-- Test that a non-EC-derived join clause is processed correctly. Use an
-- outer join so that we can/* REPLACED */''t form an EC.
explain (costs off) select * from sj p join sj q on p.a = q.a
  left join sj r on p.a + q.a = r.a;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: ((q.a + q.a) = r.a)',), ('  ->  Seq Scan on sj q',), ('        Filter: (a IS NOT NULL)',), ('  ->  Materialize',), ('        ->  Seq Scan on sj r',)]

-----------
QUERY:


-- FIXME this constant false filter doesn/* REPLACED */''t look good. Should we merge
-- equivalence classes?
explain (costs off)
select * from sj p, sj q where p.a = q.a and p.b = 1 and q.b = 2;
RESULT:
	postgres: [('Seq Scan on sj q',), ('  Filter: ((a IS NOT NULL) AND (b = 2) AND (b = 1))',)]

-----------
QUERY:


-- Check that attr_needed is updated correctly after self-join removal. In this
-- test, the join of j1 with j2 is removed. k1.b is required at either j1 or j2.
-- If this info is lost, join targetlist for (k1, k2) will not contain k1.b.
-- Use index scan for k1 so that we don/* REPLACED */''t get /* REPLACED */''b/* REPLACED */'' from physical tlist used for
-- seqscan. Also disable reordering of joins because this test depends on a
-- particular join tree.
create table sk (a int, b int);
RESULT:
	postgres: None

-----------
QUERY:

create index on sk(a);
RESULT:
	postgres: None

-----------
QUERY:

set join_collapse_limit to 1;
RESULT:
	postgres: None

-----------
QUERY:

set enable_seqscan to off;
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select 1 from
	(sk k1 join sk k2 on k1.a = k2.a)
	join (sj j1 join sj j2 on j1.a = j2.a) on j1.b = k1.b;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (k1.b = j2.b)',), ('  ->  Nested Loop',), ('        ->  Index Scan using sk_a_idx on sk k1',), ('        ->  Index Only Scan using sk_a_idx on sk k2',), ('              Index Cond: (a = k1.a)',), ('  ->  Materialize',), ('        ->  Index Scan using sj_a_key on sj j2',), ('              Index Cond: (a IS NOT NULL)',)]

-----------
QUERY:

explain (costs off) select 1 from
	(sk k1 join sk k2 on k1.a = k2.a)
	join (sj j1 join sj j2 on j1.a = j2.a) on j2.b = k1.b;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (k1.b = j2.b)',), ('  ->  Nested Loop',), ('        ->  Index Scan using sk_a_idx on sk k1',), ('        ->  Index Only Scan using sk_a_idx on sk k2',), ('              Index Cond: (a = k1.a)',), ('  ->  Materialize',), ('        ->  Index Scan using sj_a_key on sj j2',), ('              Index Cond: (a IS NOT NULL)',)]

-----------
QUERY:

reset join_collapse_limit;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_seqscan;
RESULT:
	postgres: None

-----------
QUERY:


-- Check that clauses from the join filter list is not lost on the self-join removal
CREATE TABLE emp1 (id SERIAL PRIMARY KEY NOT NULL, code int);
RESULT:
	postgres: None

-----------
QUERY:

EXPLAIN (VERBOSE, COSTS OFF)
SELECT * FROM emp1 e1, emp1 e2 WHERE e1.id = e2.id AND e2.code <> e1.code;
RESULT:
	postgres: [('Seq Scan on public.emp1 e2',), ('  Output: e2.id, e2.code, e2.id, e2.code',), ('  Filter: (e2.code <> e2.code)',)]

-----------
QUERY:


-- Shuffle self-joined relations. Only in the case of iterative deletion
-- attempts explains of these queries will be identical.
CREATE UNIQUE INDEX ON emp1((id*id));
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM emp1 c1, emp1 c2, emp1 c3
WHERE c1.id=c2.id AND c1.id*c2.id=c3.id*c3.id;
RESULT:
	postgres: [('Aggregate',), ('  ->  Seq Scan on emp1 c3',), ('        Filter: ((id * id) IS NOT NULL)',)]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM emp1 c1, emp1 c2, emp1 c3
WHERE c1.id=c3.id AND c1.id*c3.id=c2.id*c2.id;
RESULT:
	postgres: [('Aggregate',), ('  ->  Seq Scan on emp1 c3',), ('        Filter: ((id * id) IS NOT NULL)',)]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT count(*) FROM emp1 c1, emp1 c2, emp1 c3
WHERE c3.id=c2.id AND c3.id*c2.id=c1.id*c1.id;
RESULT:
	postgres: [('Aggregate',), ('  ->  Seq Scan on emp1 c3',), ('        Filter: ((id * id) IS NOT NULL)',)]

-----------
QUERY:


-- Check the usage of a parse tree by the set operations (bug #18170)
EXPLAIN (COSTS OFF)
SELECT c1.code FROM emp1 c1 LEFT JOIN emp1 c2 ON c1.id = c2.id
WHERE c2.id IS NOT NULL
EXCEPT ALL
SELECT c3.code FROM emp1 c3;
RESULT:
	postgres: [('HashSetOp Except All',), ('  ->  Append',), ('        ->  Subquery Scan on "*SELECT* 1"',), ('              ->  Seq Scan on emp1 c2',), ('        ->  Subquery Scan on "*SELECT* 2"',), ('              ->  Seq Scan on emp1 c3',)]

-----------
QUERY:


-- Check that SJE removes references from PHVs correctly
explain (costs off)
select * from emp1 t1 left join
    (select coalesce(t3.code, 1) from emp1 t2
        left join (emp1 t3 join emp1 t4 on t3.id = t4.id)
        on true)
on true;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on emp1 t1',), ('  ->  Materialize',), ('        ->  Nested Loop Left Join',), ('              ->  Seq Scan on emp1 t2',), ('              ->  Materialize',), ('                    ->  Seq Scan on emp1 t4',)]

-----------
QUERY:


-- Check that SJE removes the whole PHVs correctly
explain (verbose, costs off)
select 1 from emp1 t1 left join
    ((select 1 as x, * from emp1 t2) s1 inner join
        (select * from emp1 t3) s2 on s1.id = s2.id)
    on true
where s1.x = 1;
RESULT:
	postgres: [('Nested Loop',), ('  Output: 1',), ('  ->  Seq Scan on public.emp1 t1',), ('        Output: t1.id, t1.code',), ('  ->  Materialize',), ('        Output: t3.id',), ('        ->  Seq Scan on public.emp1 t3',), ('              Output: t3.id',), ('              Filter: (1 = 1)',)]

-----------
QUERY:


-- Check that PHVs do not impose any constraints on removing self joins
explain (verbose, costs off)
select * from emp1 t1 join emp1 t2 on t1.id = t2.id left join
    lateral (select t1.id as t1id, * from generate_series(1,1) t3) s on true;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: t2.id, t2.code, t2.id, t2.code, (t2.id), t3.t3',), ('  ->  Seq Scan on public.emp1 t2',), ('        Output: t2.id, t2.code',), ('  ->  Function Scan on pg_catalog.generate_series t3',), ('        Output: t3.t3, t2.id',), ('        Function Call: generate_series(1, 1)',)]

-----------
QUERY:


explain (verbose, costs off)
select * from generate_series(1,10) t1(id) left join
    lateral (select t1.id as t1id, t2.id from emp1 t2 join emp1 t3 on t2.id = t3.id)
on true;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: t1.id, (t1.id), t3.id',), ('  ->  Function Scan on pg_catalog.generate_series t1',), ('        Output: t1.id',), ('        Function Call: generate_series(1, 10)',), ('  ->  Seq Scan on public.emp1 t3',), ('        Output: t3.id, t1.id',)]

-----------
QUERY:


-- Check that SJE replaces join clauses involving the removed rel correctly
explain (costs off)
select * from emp1 t1
   inner join emp1 t2 on t1.id = t2.id
    left join emp1 t3 on t1.id > 1 and t1.id < 2;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Join Filter: ((t2.id > 1) AND (t2.id < 2))',), ('  ->  Seq Scan on emp1 t2',), ('  ->  Materialize',), ('        ->  Seq Scan on emp1 t3',)]

-----------
QUERY:


-- Check that SJE doesn/* REPLACED */''t replace the target relation
EXPLAIN (COSTS OFF)
WITH t1 AS (SELECT * FROM emp1)
UPDATE emp1 SET code = t1.code + 1 FROM t1
WHERE t1.id = emp1.id RETURNING emp1.id, emp1.code, t1.code;
RESULT:
	postgres: [('Update on emp1',), ('  ->  Nested Loop',), ('        ->  Seq Scan on emp1',), ('        ->  Index Scan using emp1_pkey on emp1 emp1_1',), ('              Index Cond: (id = emp1.id)',)]

-----------
QUERY:


INSERT INTO emp1 VALUES (1, 1), (2, 1);
RESULT:
	postgres: None

-----------
QUERY:


WITH t1 AS (SELECT * FROM emp1)
UPDATE emp1 SET code = t1.code + 1 FROM t1
WHERE t1.id = emp1.id RETURNING emp1.id, emp1.code, t1.code;
RESULT:
	postgres: [(1, 2, 1), (2, 2, 1)]

-----------
QUERY:


TRUNCATE emp1;
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (COSTS OFF)
UPDATE sj sq SET b = 1 FROM sj as sz WHERE sq.a = sz.a;
RESULT:
	postgres: [('Update on sj sq',), ('  ->  Nested Loop',), ('        Join Filter: (sq.a = sz.a)',), ('        ->  Seq Scan on sj sq',), ('        ->  Materialize',), ('              ->  Seq Scan on sj sz',)]

-----------
QUERY:


CREATE RULE sj_del_rule AS ON DELETE TO sj
  DO INSTEAD
    UPDATE sj SET a = 1 WHERE a = old.a;
RESULT:
	postgres: None

-----------
QUERY:

EXPLAIN (COSTS OFF) DELETE FROM sj;
RESULT:
	postgres: [('Update on sj sj_1',), ('  ->  Nested Loop',), ('        Join Filter: (sj.a = sj_1.a)',), ('        ->  Seq Scan on sj sj_1',), ('        ->  Materialize',), ('              ->  Seq Scan on sj',)]

-----------
QUERY:

DROP RULE sj_del_rule ON sj CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- Check that SJE does not mistakenly omit qual clauses (bug #18187)
insert into emp1 values (1, 1);
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off)
select 1 from emp1 full join
    (select * from emp1 t1 join
        emp1 t2 join emp1 t3 on t2.id = t3.id
        on true
    where false) s on true
where false;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

select 1 from emp1 full join
    (select * from emp1 t1 join
        emp1 t2 join emp1 t3 on t2.id = t3.id
        on true
    where false) s on true
where false;
RESULT:
	postgres: []

-----------
QUERY:


-- Check that SJE does not mistakenly re-use knowledge of relation uniqueness
-- made with different set of quals
insert into emp1 values (2, 1);
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off)
select * from emp1 t1 where exists (select * from emp1 t2
                                    where t2.id = t1.code and t2.code > 0);
RESULT:
	postgres: [('Nested Loop',), ('  ->  Seq Scan on emp1 t1',), ('  ->  Index Scan using emp1_pkey on emp1 t2',), ('        Index Cond: (id = t1.code)',), ('        Filter: (code > 0)',)]

-----------
QUERY:

select * from emp1 t1 where exists (select * from emp1 t2
                                    where t2.id = t1.code and t2.code > 0);
RESULT:
	postgres: [(1, 1), (2, 1)]

-----------
QUERY:


-- We can remove the join even if we find the join can/* REPLACED */''t duplicate rows and
-- the base quals of each side are different.  In the following case we end up
-- moving quals over to s1 to make it so it can/* REPLACED */''t match any rows.
create table sl(a int, b int, c int);
RESULT:
	postgres: None

-----------
QUERY:

create unique index on sl(a, b);
RESULT:
	postgres: None

-----------
QUERY:

vacuum analyze sl;
RESULT:
	postgres: None

-----------
QUERY:


-- Both sides are unique, but base quals are different
explain (costs off)
select * from sl t1, sl t2 where t1.a = t2.a and t1.b = 1 and t2.b = 2;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (t1.a = t2.a)',), ('  ->  Seq Scan on sl t1',), ('        Filter: (b = 1)',), ('  ->  Seq Scan on sl t2',), ('        Filter: (b = 2)',)]

-----------
QUERY:


-- Check NullTest in baserestrictinfo list
explain (costs off)
select * from sl t1, sl t2
where t1.a = t2.a and t1.b = 1 and t2.b = 2
  and t1.c IS NOT NULL and t2.c IS NOT NULL
  and t2.b IS NOT NULL and t1.b IS NOT NULL
  and t1.a IS NOT NULL and t2.a IS NOT NULL;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (t1.a = t2.a)',), ('  ->  Seq Scan on sl t1',), ('        Filter: ((c IS NOT NULL) AND (b IS NOT NULL) AND (a IS NOT NULL) AND (b = 1))',), ('  ->  Seq Scan on sl t2',), ('        Filter: ((c IS NOT NULL) AND (b IS NOT NULL) AND (a IS NOT NULL) AND (b = 2))',)]

-----------
QUERY:

explain (verbose, costs off)
select * from sl t1, sl t2
where t1.b = t2.b and t2.a = 3 and t1.a = 3
  and t1.c IS NOT NULL and t2.c IS NOT NULL
  and t2.b IS NOT NULL and t1.b IS NOT NULL
  and t1.a IS NOT NULL and t2.a IS NOT NULL;
RESULT:
	postgres: [('Seq Scan on public.sl t2',), ('  Output: t2.a, t2.b, t2.c, t2.a, t2.b, t2.c',), ('  Filter: ((t2.c IS NOT NULL) AND (t2.b IS NOT NULL) AND (t2.a IS NOT NULL) AND (t2.a = 3))',)]

-----------
QUERY:


-- Join qual isn/* REPLACED */''t mergejoinable, but inner is unique.
EXPLAIN (COSTS OFF)
SELECT n2.a FROM sj n1, sj n2 WHERE n1.a <> n2.a AND n2.a = 1;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (n1.a <> n2.a)',), ('  ->  Seq Scan on sj n2',), ('        Filter: (a = 1)',), ('  ->  Seq Scan on sj n1',)]

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT * FROM
(SELECT n2.a FROM sj n1, sj n2 WHERE n1.a <> n2.a) q0, sl
WHERE q0.a = 1;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (n1.a <> n2.a)',), ('  ->  Nested Loop',), ('        ->  Seq Scan on sl',), ('        ->  Seq Scan on sj n2',), ('              Filter: (a = 1)',), ('  ->  Seq Scan on sj n1',)]

-----------
QUERY:


-- Check optimization disabling if it will violate special join conditions.
-- Two identical joined relations satisfies self join removal conditions but
-- stay in different special join infos.
CREATE TABLE sj_t1 (id serial, a int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE sj_t2 (id serial, a int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE sj_t3 (id serial, a int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE sj_t4 (id serial, a int);
RESULT:
	postgres: None

-----------
QUERY:


CREATE UNIQUE INDEX ON sj_t3 USING btree (a,id);
RESULT:
	postgres: None

-----------
QUERY:

CREATE UNIQUE INDEX ON sj_t2 USING btree (id);
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (COSTS OFF)
SELECT * FROM sj_t1
JOIN (
	SELECT sj_t2.id AS id FROM sj_t2
	WHERE EXISTS
		(
		SELECT TRUE FROM sj_t3,sj_t4 WHERE sj_t3.a = 1 AND sj_t3.id = sj_t2.id
		)
	) t2t3t4
ON sj_t1.id = t2t3t4.id
JOIN (
	SELECT sj_t2.id AS id FROM sj_t2
	WHERE EXISTS
		(
		SELECT TRUE FROM sj_t3,sj_t4 WHERE sj_t3.a = 1 AND sj_t3.id = sj_t2.id
		)
	) _t2t3t4
ON sj_t1.id = _t2t3t4.id;
RESULT:
	postgres: [('Nested Loop',), ('  Join Filter: (sj_t3.id = sj_t1.id)',), ('  ->  Nested Loop',), ('        Join Filter: (sj_t2.id = sj_t3.id)',), ('        ->  Nested Loop Semi Join',), ('              ->  Nested Loop',), ('                    ->  HashAggregate',), ('                          Group Key: sj_t3.id',), ('                          ->  Nested Loop',), ('                                ->  Seq Scan on sj_t4',), ('                                ->  Materialize',), ('                                      ->  Bitmap Heap Scan on sj_t3',), ('                                            Recheck Cond: (a = 1)',), ('                                            ->  Bitmap Index Scan on sj_t3_a_id_idx',), ('                                                  Index Cond: (a = 1)',), ('                    ->  Index Only Scan using sj_t2_id_idx on sj_t2 sj_t2_1',), ('                          Index Cond: (id = sj_t3.id)',), ('              ->  Nested Loop',), ('                    ->  Index Only Scan using sj_t3_a_id_idx on sj_t3 sj_t3_1',), ('                          Index Cond: ((a = 1) AND (id = sj_t3.id))',), ('                    ->  Seq Scan on sj_t4 sj_t4_1',), ('        ->  Index Only Scan using sj_t2_id_idx on sj_t2',), ('              Index Cond: (id = sj_t2_1.id)',), ('  ->  Seq Scan on sj_t1',)]

-----------
QUERY:


--
-- Test RowMarks-related code
--

-- Both sides have explicit LockRows marks
EXPLAIN (COSTS OFF)
SELECT a1.a FROM sj a1,sj a2 WHERE (a1.a=a2.a) FOR UPDATE;
RESULT:
	postgres: [('LockRows',), ('  ->  Seq Scan on sj a2',), ('        Filter: (a IS NOT NULL)',)]

-----------
QUERY:


reset enable_hashjoin;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_mergejoin;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test hints given on incorrect column references are useful
--

select t1.uunique1 from
  tenk1 t1 join tenk2 t2 on t1.two = t2.two;
RESULT:
	postgres: column t1.uunique1 does not exist
LINE 7: select t1.uunique1 from
               ^
HINT:  Perhaps you meant to reference the column "t1.unique1".


-----------
QUERY:
 -- error, prefer /* REPLACED */''t1/* REPLACED */'' suggestion
select t2.uunique1 from
  tenk1 t1 join tenk2 t2 on t1.two = t2.two;
RESULT:
	postgres: column t2.uunique1 does not exist
LINE 2: select t2.uunique1 from
               ^
HINT:  Perhaps you meant to reference the column "t2.unique1".


-----------
QUERY:
 -- error, prefer /* REPLACED */''t2/* REPLACED */'' suggestion
select uunique1 from
  tenk1 t1 join tenk2 t2 on t1.two = t2.two;
RESULT:
	postgres: column "uunique1" does not exist
LINE 2: select uunique1 from
               ^
HINT:  Perhaps you meant to reference the column "t1.unique1" or the column "t2.unique1".


-----------
QUERY:
 -- error, suggest both at once
select ctid from
  tenk1 t1 join tenk2 t2 on t1.two = t2.two;
RESULT:
	postgres: column "ctid" does not exist
LINE 2: select ctid from
               ^
DETAIL:  There are columns named "ctid", but they are in tables that cannot be referenced from this part of the query.
HINT:  Try using a table-qualified name.


-----------
QUERY:
 -- error, need qualification

--
-- Take care to reference the correct RTE
--

select atts.relid::regclass, s.* from pg_stats s join
    pg_attribute a on s.attname = a.attname and s.tablename =
    a.attrelid::regclass::text join (select unnest(indkey) attnum,
    indexrelid from pg_index i) atts on atts.attnum = a.attnum where
    schemaname != 'pg_catalog';
RESULT:
	postgres: column atts.relid does not exist
LINE 7: select atts.relid::regclass, s.* from pg_stats s join
               ^


-----------
QUERY:


-- Test bug in rangetable flattening
explain (verbose, costs off)
select 1 from
  (select * from int8_tbl where q1 <> (select 42) offset 0) ss
where false;
RESULT:
	postgres: [('Result',), ('  Output: 1',), ('  One-Time Filter: false',)]

-----------
QUERY:


--
-- Test LATERAL
--

select unique2, x.*
from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
RESULT:
	postgres: [(9998, 0)]

-----------
QUERY:

explain (costs off)
  select unique2, x.*
  from tenk1 a, lateral (select * from int4_tbl b where f1 = a.unique1) x;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Seq Scan on int4_tbl b',), ('  ->  Index Scan using tenk1_unique1 on tenk1 a',), ('        Index Cond: (unique1 = b.f1)',)]

-----------
QUERY:

select unique2, x.*
from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
RESULT:
	postgres: [(9998, 0)]

-----------
QUERY:

explain (costs off)
  select unique2, x.*
  from int4_tbl x, lateral (select unique2 from tenk1 where f1 = unique1) ss;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Seq Scan on int4_tbl x',), ('  ->  Index Scan using tenk1_unique1 on tenk1',), ('        Index Cond: (unique1 = x.f1)',)]

-----------
QUERY:

explain (costs off)
  select unique2, x.*
  from int4_tbl x cross join lateral (select unique2 from tenk1 where f1 = unique1) ss;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Seq Scan on int4_tbl x',), ('  ->  Index Scan using tenk1_unique1 on tenk1',), ('        Index Cond: (unique1 = x.f1)',)]

-----------
QUERY:

select unique2, x.*
from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
RESULT:
	postgres: [(9998, 0), (None, 123456), (None, -123456), (None, 2147483647), (None, -2147483647)]

-----------
QUERY:

explain (costs off)
  select unique2, x.*
  from int4_tbl x left join lateral (select unique1, unique2 from tenk1 where f1 = unique1) ss on true;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Seq Scan on int4_tbl x',), ('  ->  Index Scan using tenk1_unique1 on tenk1',), ('        Index Cond: (unique1 = x.f1)',)]

-----------
QUERY:


-- check scoping of lateral versus parent references
-- the first of these should return int8_tbl.q2, the second int8_tbl.q1
select *, (select r from (select q1 as q2) x, (select q2 as r) y) from int8_tbl;
RESULT:
	postgres: [(123, 456, 456), (123, 4567890123456789, 4567890123456789), (4567890123456789, 123, 123), (4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, -4567890123456789)]

-----------
QUERY:

select *, (select r from (select q1 as q2) x, lateral (select q2 as r) y) from int8_tbl;
RESULT:
	postgres: [(123, 456, 123), (123, 4567890123456789, 123), (4567890123456789, 123, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, 4567890123456789)]

-----------
QUERY:


-- lateral with function in FROM
select count(*) from tenk1 a, lateral generate_series(1,two) g;
RESULT:
	postgres: [(5000,)]

-----------
QUERY:

explain (costs off)
  select count(*) from tenk1 a, lateral generate_series(1,two) g;
RESULT:
	postgres: [('Aggregate',), ('  ->  Nested Loop',), ('        ->  Seq Scan on tenk1 a',), ('        ->  Memoize',), ('              Cache Key: a.two',), ('              Cache Mode: binary',), ('              ->  Function Scan on generate_series g',)]

-----------
QUERY:

explain (costs off)
  select count(*) from tenk1 a cross join lateral generate_series(1,two) g;
RESULT:
	postgres: [('Aggregate',), ('  ->  Nested Loop',), ('        ->  Seq Scan on tenk1 a',), ('        ->  Memoize',), ('              Cache Key: a.two',), ('              Cache Mode: binary',), ('              ->  Function Scan on generate_series g',)]

-----------
QUERY:

-- don/* REPLACED */''t need the explicit LATERAL keyword for functions
explain (costs off)
  select count(*) from tenk1 a, generate_series(1,two) g;
RESULT:
	postgres: [('Aggregate',), ('  ->  Nested Loop',), ('        ->  Seq Scan on tenk1 a',), ('        ->  Memoize',), ('              Cache Key: a.two',), ('              Cache Mode: binary',), ('              ->  Function Scan on generate_series g',)]

-----------
QUERY:


-- lateral with UNION ALL subselect
explain (costs off)
  select * from generate_series(100,200) g,
    lateral (select * from int8_tbl a where g = q1 union all
             select * from int8_tbl b where g = q2) ss;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Function Scan on generate_series g',), ('  ->  Append',), ('        ->  Seq Scan on int8_tbl a',), ('              Filter: (g.g = q1)',), ('        ->  Seq Scan on int8_tbl b',), ('              Filter: (g.g = q2)',)]

-----------
QUERY:

select * from generate_series(100,200) g,
  lateral (select * from int8_tbl a where g = q1 union all
           select * from int8_tbl b where g = q2) ss;
RESULT:
	postgres: [(123, 123, 456), (123, 123, 4567890123456789), (123, 4567890123456789, 123)]

-----------
QUERY:


-- lateral with VALUES
explain (costs off)
  select count(*) from tenk1 a,
    tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
RESULT:
	postgres: [('Aggregate',), ('  ->  Merge Join',), ('        Merge Cond: (a.unique1 = b.unique2)',), ('        ->  Index Only Scan using tenk1_unique1 on tenk1 a',), ('        ->  Index Only Scan using tenk1_unique2 on tenk1 b',)]

-----------
QUERY:

select count(*) from tenk1 a,
  tenk1 b join lateral (values(a.unique1)) ss(x) on b.unique2 = ss.x;
RESULT:
	postgres: [(10000,)]

-----------
QUERY:


-- lateral with VALUES, no flattening possible
explain (costs off)
  select count(*) from tenk1 a,
    tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
RESULT:
	postgres: [('Aggregate',), ('  ->  Nested Loop',), ('        ->  Nested Loop',), ('              ->  Index Only Scan using tenk1_unique1 on tenk1 a',), ('              ->  Values Scan on "*VALUES*"',), ('        ->  Memoize',), ('              Cache Key: "*VALUES*".column1',), ('              Cache Mode: logical',), ('              ->  Index Only Scan using tenk1_unique2 on tenk1 b',), ('                    Index Cond: (unique2 = "*VALUES*".column1)',)]

-----------
QUERY:

select count(*) from tenk1 a,
  tenk1 b join lateral (values(a.unique1),(-1)) ss(x) on b.unique2 = ss.x;
RESULT:
	postgres: [(10000,)]

-----------
QUERY:


-- lateral injecting a strange outer join condition
explain (costs off)
  select * from int8_tbl a,
    int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
      on x.q2 = ss.z
  order by a.q1, a.q2, x.q1, x.q2, ss.z;
RESULT:
	postgres: [('Sort',), ('  Sort Key: a.q1, a.q2, x.q1, x.q2, (a.q1)',), ('  ->  Nested Loop',), ('        ->  Seq Scan on int8_tbl a',), ('        ->  Hash Left Join',), ('              Hash Cond: (x.q2 = (a.q1))',), ('              ->  Seq Scan on int8_tbl x',), ('              ->  Hash',), ('                    ->  Seq Scan on int4_tbl y',)]

-----------
QUERY:

select * from int8_tbl a,
  int8_tbl x left join lateral (select a.q1 from int4_tbl y) ss(z)
    on x.q2 = ss.z
  order by a.q1, a.q2, x.q1, x.q2, ss.z;
RESULT:
	postgres: [(123, 456, 123, 456, None), (123, 456, 123, 4567890123456789, None), (123, 456, 4567890123456789, -4567890123456789, None), (123, 456, 4567890123456789, 123, 123), (123, 456, 4567890123456789, 123, 123), (123, 456, 4567890123456789, 123, 123), (123, 456, 4567890123456789, 123, 123), (123, 456, 4567890123456789, 123, 123), (123, 456, 4567890123456789, 4567890123456789, None), (123, 4567890123456789, 123, 456, None), (123, 4567890123456789, 123, 4567890123456789, None), (123, 4567890123456789, 4567890123456789, -4567890123456789, None), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, None), (4567890123456789, -4567890123456789, 123, 456, None), (4567890123456789, -4567890123456789, 123, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, 123, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, 123, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, 123, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, 123, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, 4567890123456789, -4567890123456789, None), (4567890123456789, -4567890123456789, 4567890123456789, 123, None), (4567890123456789, -4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 123, 123, 456, None), (4567890123456789, 123, 123, 4567890123456789, 4567890123456789), (4567890123456789, 123, 123, 4567890123456789, 4567890123456789), (4567890123456789, 123, 123, 4567890123456789, 4567890123456789), (4567890123456789, 123, 123, 4567890123456789, 4567890123456789), (4567890123456789, 123, 123, 4567890123456789, 4567890123456789), (4567890123456789, 123, 4567890123456789, -4567890123456789, None), (4567890123456789, 123, 4567890123456789, 123, None), (4567890123456789, 123, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 123, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 123, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 123, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 123, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 123, 456, None), (4567890123456789, 4567890123456789, 123, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 123, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 123, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 123, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 123, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, -4567890123456789, None), (4567890123456789, 4567890123456789, 4567890123456789, 123, None), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789)]

-----------
QUERY:


-- lateral reference to a join alias variable
select * from (select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
  lateral (select x) ss2(y);
RESULT:
	postgres: [(0, 0, 0)]

-----------
QUERY:

select * from (select f1 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1,
  lateral (values(x)) ss2(y);
RESULT:
	postgres: [(0, 0, 0), (123456, 123456, 123456), (-123456, -123456, -123456), (2147483647, 2147483647, 2147483647), (-2147483647, -2147483647, -2147483647)]

-----------
QUERY:

select * from ((select f1/2 as x from int4_tbl) ss1 join int4_tbl i4 on x = f1) j,
  lateral (select x) ss2(y);
RESULT:
	postgres: [(0, 0, 0)]

-----------
QUERY:


-- lateral references requiring pullup
select * from (values(1)) x(lb),
  lateral generate_series(lb,4) x4;
RESULT:
	postgres: [(1, 1), (1, 2), (1, 3), (1, 4)]

-----------
QUERY:

select * from (select f1/1000000000 from int4_tbl) x(lb),
  lateral generate_series(lb,4) x4;
RESULT:
	postgres: [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (2, 2), (2, 3), (2, 4), (-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2), (-2, 3), (-2, 4)]

-----------
QUERY:

select * from (values(1)) x(lb),
  lateral (values(lb)) y(lbcopy);
RESULT:
	postgres: [(1, 1)]

-----------
QUERY:

select * from (values(1)) x(lb),
  lateral (select lb from int4_tbl) y(lbcopy);
RESULT:
	postgres: [(1, 1), (1, 1), (1, 1), (1, 1), (1, 1)]

-----------
QUERY:

select * from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (values(x.q1,y.q1,y.q2)) v(xq1,yq1,yq2);
RESULT:
	postgres: [(123, 456, None, None, 123, None, None), (123, 4567890123456789, 4567890123456789, -4567890123456789, 123, 4567890123456789, -4567890123456789), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123, 4567890123456789, 4567890123456789), (123, 4567890123456789, 4567890123456789, 123, 123, 4567890123456789, 123), (4567890123456789, 123, 123, 4567890123456789, 4567890123456789, 123, 4567890123456789), (4567890123456789, 123, 123, 456, 4567890123456789, 123, 456), (4567890123456789, 4567890123456789, 4567890123456789, -4567890123456789, 4567890123456789, 4567890123456789, -4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 123, 4567890123456789, 4567890123456789, 123), (4567890123456789, -4567890123456789, None, None, 4567890123456789, None, None)]

-----------
QUERY:

select * from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
RESULT:
	postgres: [(123, 456, None, None, 123, None, None), (123, 4567890123456789, 4567890123456789, -4567890123456789, 123, 4567890123456789, -4567890123456789), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123, 4567890123456789, 4567890123456789), (123, 4567890123456789, 4567890123456789, 123, 123, 4567890123456789, 123), (4567890123456789, 123, 123, 4567890123456789, 4567890123456789, 123, 4567890123456789), (4567890123456789, 123, 123, 456, 4567890123456789, 123, 456), (4567890123456789, 4567890123456789, 4567890123456789, -4567890123456789, 4567890123456789, 4567890123456789, -4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 123, 4567890123456789, 4567890123456789, 123), (4567890123456789, -4567890123456789, None, None, 4567890123456789, None, None)]

-----------
QUERY:

select x.* from
  int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1,
  lateral (select x.q1,y.q1,y.q2) v(xq1,yq1,yq2);
RESULT:
	postgres: [(123, 456), (123, 4567890123456789), (123, 4567890123456789), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 123), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789)]

-----------
QUERY:

select v.* from
  (int8_tbl x left join (select q1,coalesce(q2,0) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
RESULT:
	postgres: [(123, None), (456, None), (123, 4567890123456789), (4567890123456789, -4567890123456789), (123, 4567890123456789), (4567890123456789, 4567890123456789), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 123), (123, 4567890123456789), (4567890123456789, 123), (123, 456), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 123), (4567890123456789, None), (-4567890123456789, None)]

-----------
QUERY:

select v.* from
  (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 union all select x.q2,y.q2) v(vx,vy);
RESULT:
	postgres: [(4567890123456789, 123), (123, 456), (4567890123456789, 123), (123, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 123), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (123, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789), (123, 4567890123456789), (4567890123456789, -4567890123456789), (123, None), (456, None), (4567890123456789, None), (-4567890123456789, None)]

-----------
QUERY:

select v.* from
  (int8_tbl x left join (select q1,(select coalesce(q2,0)) q2 from int8_tbl) y on x.q2 = y.q1)
  left join int4_tbl z on z.f1 = x.q2,
  lateral (select x.q1,y.q1 from onerow union all select x.q2,y.q2 from onerow) v(vx,vy);
RESULT:
	postgres: [(4567890123456789, 123), (123, 456), (4567890123456789, 123), (123, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 123), (123, 4567890123456789), (4567890123456789, 123), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (123, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789), (123, 4567890123456789), (4567890123456789, -4567890123456789), (123, None), (456, None), (4567890123456789, None), (-4567890123456789, None)]

-----------
QUERY:


explain (verbose, costs off)
select * from
  int8_tbl a left join
  lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: a.q1, a.q2, b.q1, b.q2, (a.q2)',), ('  ->  Seq Scan on public.int8_tbl a',), ('        Output: a.q1, a.q2',), ('  ->  Seq Scan on public.int8_tbl b',), ('        Output: b.q1, b.q2, a.q2',), ('        Filter: (a.q2 = b.q1)',)]

-----------
QUERY:

select * from
  int8_tbl a left join
  lateral (select *, a.q2 as x from int8_tbl b) ss on a.q2 = ss.q1;
RESULT:
	postgres: [(123, 456, None, None, None), (123, 4567890123456789, 4567890123456789, 123, 4567890123456789), (123, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (123, 4567890123456789, 4567890123456789, -4567890123456789, 4567890123456789), (4567890123456789, 123, 123, 456, 123), (4567890123456789, 123, 123, 4567890123456789, 123), (4567890123456789, 4567890123456789, 4567890123456789, 123, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, -4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, None, None, None)]

-----------
QUERY:

explain (verbose, costs off)
select * from
  int8_tbl a left join
  lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
RESULT:
	postgres: [('Nested Loop Left Join',), ("  Output: a.q1, a.q2, b.q1, b.q2, (COALESCE(a.q2, '42'::bigint))",), ('  ->  Seq Scan on public.int8_tbl a',), ('        Output: a.q1, a.q2',), ('  ->  Seq Scan on public.int8_tbl b',), ("        Output: b.q1, b.q2, COALESCE(a.q2, '42'::bigint)",), ('        Filter: (a.q2 = b.q1)',)]

-----------
QUERY:

select * from
  int8_tbl a left join
  lateral (select *, coalesce(a.q2, 42) as x from int8_tbl b) ss on a.q2 = ss.q1;
RESULT:
	postgres: [(123, 456, None, None, None), (123, 4567890123456789, 4567890123456789, 123, 4567890123456789), (123, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (123, 4567890123456789, 4567890123456789, -4567890123456789, 4567890123456789), (4567890123456789, 123, 123, 456, 123), (4567890123456789, 123, 123, 4567890123456789, 123), (4567890123456789, 4567890123456789, 4567890123456789, 123, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, -4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, None, None, None)]

-----------
QUERY:


-- lateral can result in join conditions appearing below their
-- real semantic level
explain (verbose, costs off)
select * from int4_tbl i left join
  lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
RESULT:
	postgres: [('Hash Left Join',), ('  Output: i.f1, j.f1',), ('  Hash Cond: (i.f1 = j.f1)',), ('  ->  Seq Scan on public.int4_tbl i',), ('        Output: i.f1',), ('  ->  Hash',), ('        Output: j.f1',), ('        ->  Seq Scan on public.int2_tbl j',), ('              Output: j.f1',)]

-----------
QUERY:

select * from int4_tbl i left join
  lateral (select * from int2_tbl j where i.f1 = j.f1) k on true;
RESULT:
	postgres: [(0, 0), (123456, None), (-123456, None), (2147483647, None), (-2147483647, None)]

-----------
QUERY:

explain (verbose, costs off)
select * from int4_tbl i left join
  lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: i.f1, (COALESCE(i.*))',), ('  ->  Seq Scan on public.int4_tbl i',), ('        Output: i.f1, i.*',), ('  ->  Seq Scan on public.int2_tbl j',), ('        Output: j.f1, COALESCE(i.*)',), ('        Filter: (i.f1 = j.f1)',)]

-----------
QUERY:

select * from int4_tbl i left join
  lateral (select coalesce(i) from int2_tbl j where i.f1 = j.f1) k on true;
RESULT:
	postgres: [(0, '(0)'), (123456, None), (-123456, None), (2147483647, None), (-2147483647, None)]

-----------
QUERY:

explain (verbose, costs off)
select * from int4_tbl a,
  lateral (
    select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
  ) ss;
RESULT:
	postgres: [('Nested Loop',), ('  Output: a.f1, b.f1, c.q1, c.q2',), ('  ->  Seq Scan on public.int4_tbl a',), ('        Output: a.f1',), ('  ->  Hash Left Join',), ('        Output: b.f1, c.q1, c.q2',), ('        Hash Cond: (b.f1 = c.q1)',), ('        ->  Seq Scan on public.int4_tbl b',), ('              Output: b.f1',), ('        ->  Hash',), ('              Output: c.q1, c.q2',), ('              ->  Seq Scan on public.int8_tbl c',), ('                    Output: c.q1, c.q2',), ('                    Filter: (a.f1 = c.q2)',)]

-----------
QUERY:

select * from int4_tbl a,
  lateral (
    select * from int4_tbl b left join int8_tbl c on (b.f1 = q1 and a.f1 = q2)
  ) ss;
RESULT:
	postgres: [(0, 0, None, None), (0, 123456, None, None), (0, -123456, None, None), (0, 2147483647, None, None), (0, -2147483647, None, None), (123456, 0, None, None), (123456, 123456, None, None), (123456, -123456, None, None), (123456, 2147483647, None, None), (123456, -2147483647, None, None), (-123456, 0, None, None), (-123456, 123456, None, None), (-123456, -123456, None, None), (-123456, 2147483647, None, None), (-123456, -2147483647, None, None), (2147483647, 0, None, None), (2147483647, 123456, None, None), (2147483647, -123456, None, None), (2147483647, 2147483647, None, None), (2147483647, -2147483647, None, None), (-2147483647, 0, None, None), (-2147483647, 123456, None, None), (-2147483647, -123456, None, None), (-2147483647, 2147483647, None, None), (-2147483647, -2147483647, None, None)]

-----------
QUERY:


-- lateral reference in a PlaceHolderVar evaluated at join level
explain (verbose, costs off)
select * from
  int8_tbl a left join lateral
  (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
   int8_tbl b cross join int8_tbl c) ss
  on a.q2 = ss.bq1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: a.q1, a.q2, b.q1, c.q1, (LEAST(a.q1, b.q1, c.q1))',), ('  ->  Seq Scan on public.int8_tbl a',), ('        Output: a.q1, a.q2',), ('  ->  Nested Loop',), ('        Output: b.q1, c.q1, LEAST(a.q1, b.q1, c.q1)',), ('        ->  Seq Scan on public.int8_tbl b',), ('              Output: b.q1, b.q2',), ('              Filter: (a.q2 = b.q1)',), ('        ->  Seq Scan on public.int8_tbl c',), ('              Output: c.q1, c.q2',)]

-----------
QUERY:

select * from
  int8_tbl a left join lateral
  (select b.q1 as bq1, c.q1 as cq1, least(a.q1,b.q1,c.q1) from
   int8_tbl b cross join int8_tbl c) ss
  on a.q2 = ss.bq1;
RESULT:
	postgres: [(123, 456, None, None, None), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 123, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123), (123, 4567890123456789, 4567890123456789, 4567890123456789, 123), (4567890123456789, 123, 123, 123, 123), (4567890123456789, 123, 123, 123, 123), (4567890123456789, 123, 123, 4567890123456789, 123), (4567890123456789, 123, 123, 4567890123456789, 123), (4567890123456789, 123, 123, 4567890123456789, 123), (4567890123456789, 123, 123, 123, 123), (4567890123456789, 123, 123, 123, 123), (4567890123456789, 123, 123, 4567890123456789, 123), (4567890123456789, 123, 123, 4567890123456789, 123), (4567890123456789, 123, 123, 4567890123456789, 123), (4567890123456789, 4567890123456789, 4567890123456789, 123, 123), (4567890123456789, 4567890123456789, 4567890123456789, 123, 123), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 123, 123), (4567890123456789, 4567890123456789, 4567890123456789, 123, 123), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 123, 123), (4567890123456789, 4567890123456789, 4567890123456789, 123, 123), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (4567890123456789, -4567890123456789, None, None, None)]

-----------
QUERY:


-- case requiring nested PlaceHolderVars
explain (verbose, costs off)
select * from
  int8_tbl c left join (
    int8_tbl a left join (select q1, coalesce(q2,42) as x from int8_tbl b) ss1
      on a.q2 = ss1.q1
    cross join
    lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
  ) on c.q2 = ss2.q1,
  lateral (select ss2.y offset 0) ss3;
RESULT:
	postgres: [('Nested Loop',), ("  Output: c.q1, c.q2, a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint)), d.q1, (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)), ((COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)))",), ('  ->  Hash Right Join',), ("        Output: c.q1, c.q2, a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint)), d.q1, (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))",), ('        Hash Cond: (d.q1 = c.q2)',), ('        ->  Nested Loop',), ("              Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint)), d.q1, (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))",), ('              ->  Hash Left Join',), ("                    Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, '42'::bigint))",), ('                    Hash Cond: (a.q2 = b.q1)',), ('                    ->  Seq Scan on public.int8_tbl a',), ('                          Output: a.q1, a.q2',), ('                    ->  Hash',), ("                          Output: b.q1, (COALESCE(b.q2, '42'::bigint))",), ('                          ->  Seq Scan on public.int8_tbl b',), ("                                Output: b.q1, COALESCE(b.q2, '42'::bigint)",), ('              ->  Seq Scan on public.int8_tbl d',), ("                    Output: d.q1, COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2)",), ('        ->  Hash',), ('              Output: c.q1, c.q2',), ('              ->  Seq Scan on public.int8_tbl c',), ('                    Output: c.q1, c.q2',), ('  ->  Result',), ("        Output: (COALESCE((COALESCE(b.q2, '42'::bigint)), d.q2))",)]

-----------
QUERY:


-- another case requiring nested PlaceHolderVars
explain (verbose, costs off)
select * from
  (select 0 as val0) as ss0
  left join (select 1 as val) as ss1 on true
  left join lateral (select ss1.val as val_filtered where false) as ss2 on true;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: 0, (1), ((1))',), ('  Join Filter: false',), ('  ->  Result',), ('        Output: 1',), ('  ->  Result',), ('        Output: (1)',), ('        One-Time Filter: false',)]

-----------
QUERY:


select * from
  (select 0 as val0) as ss0
  left join (select 1 as val) as ss1 on true
  left join lateral (select ss1.val as val_filtered where false) as ss2 on true;
RESULT:
	postgres: [(0, 1, None)]

-----------
QUERY:


-- case that breaks the old ph_may_need optimization
explain (verbose, costs off)
select c.*,a.*,ss1.q1,ss2.q1,ss3.* from
  int8_tbl c left join (
    int8_tbl a left join
      (select q1, coalesce(q2,f1) as x from int8_tbl b, int4_tbl b2
       where q1 < f1) ss1
      on a.q2 = ss1.q1
    cross join
    lateral (select q1, coalesce(ss1.x,q2) as y from int8_tbl d) ss2
  ) on c.q2 = ss2.q1,
  lateral (select * from int4_tbl i where ss2.y > f1) ss3;
RESULT:
	postgres: [('Nested Loop',), ('  Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, i.f1',), ('  Join Filter: ((COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)) > i.f1)',), ('  ->  Hash Right Join',), ('        Output: c.q1, c.q2, a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))',), ('        Hash Cond: (d.q1 = c.q2)',), ('        ->  Nested Loop',), ('              Output: a.q1, a.q2, b.q1, d.q1, (COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2))',), ('              ->  Hash Right Join',), ('                    Output: a.q1, a.q2, b.q1, (COALESCE(b.q2, (b2.f1)::bigint))',), ('                    Hash Cond: (b.q1 = a.q2)',), ('                    ->  Nested Loop',), ('                          Output: b.q1, COALESCE(b.q2, (b2.f1)::bigint)',), ('                          Join Filter: (b.q1 < b2.f1)',), ('                          ->  Seq Scan on public.int8_tbl b',), ('                                Output: b.q1, b.q2',), ('                          ->  Materialize',), ('                                Output: b2.f1',), ('                                ->  Seq Scan on public.int4_tbl b2',), ('                                      Output: b2.f1',), ('                    ->  Hash',), ('                          Output: a.q1, a.q2',), ('                          ->  Seq Scan on public.int8_tbl a',), ('                                Output: a.q1, a.q2',), ('              ->  Seq Scan on public.int8_tbl d',), ('                    Output: d.q1, COALESCE((COALESCE(b.q2, (b2.f1)::bigint)), d.q2)',), ('        ->  Hash',), ('              Output: c.q1, c.q2',), ('              ->  Seq Scan on public.int8_tbl c',), ('                    Output: c.q1, c.q2',), ('  ->  Materialize',), ('        Output: i.f1',), ('        ->  Seq Scan on public.int4_tbl i',), ('              Output: i.f1',)]

-----------
QUERY:


-- check processing of postponed quals (bug #9041)
explain (verbose, costs off)
select * from
  (select 1 as x offset 0) x cross join (select 2 as y offset 0) y
  left join lateral (
    select * from (select 3 as z offset 0) z where z.z = x.x
  ) zz on zz.z = y.y;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: (1), (2), (3)',), ('  Join Filter: (((3) = (1)) AND ((3) = (2)))',), ('  ->  Nested Loop',), ('        Output: (1), (2)',), ('        ->  Result',), ('              Output: 1',), ('        ->  Result',), ('              Output: 2',), ('  ->  Result',), ('        Output: 3',)]

-----------
QUERY:


-- a new postponed-quals issue (bug #17768)
explain (costs off)
select * from int4_tbl t1,
  lateral (select * from int4_tbl t2 inner join int4_tbl t3 on t1.f1 = 1
           inner join (int4_tbl t4 left join int4_tbl t5 on true) on true) ss;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Nested Loop',), ('        ->  Nested Loop',), ('              ->  Nested Loop',), ('                    ->  Seq Scan on int4_tbl t1',), ('                          Filter: (f1 = 1)',), ('                    ->  Seq Scan on int4_tbl t2',), ('              ->  Materialize',), ('                    ->  Seq Scan on int4_tbl t3',), ('        ->  Materialize',), ('              ->  Seq Scan on int4_tbl t4',), ('  ->  Materialize',), ('        ->  Seq Scan on int4_tbl t5',)]

-----------
QUERY:


-- check dummy rels with lateral references (bug #15694)
explain (verbose, costs off)
select * from int8_tbl i8 left join lateral
  (select *, i8.q2 from int4_tbl where false) ss on true;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: i8.q1, i8.q2, f1, (i8.q2)',), ('  Join Filter: false',), ('  ->  Seq Scan on public.int8_tbl i8',), ('        Output: i8.q1, i8.q2',), ('  ->  Result',), ('        Output: f1, i8.q2',), ('        One-Time Filter: false',)]

-----------
QUERY:

explain (verbose, costs off)
select * from int8_tbl i8 left join lateral
  (select *, i8.q2 from int4_tbl i1, int4_tbl i2 where false) ss on true;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: i8.q1, i8.q2, f1, f1, (i8.q2)',), ('  ->  Seq Scan on public.int8_tbl i8',), ('        Output: i8.q1, i8.q2',), ('  ->  Result',), ('        Output: f1, f1, i8.q2',), ('        One-Time Filter: false',)]

-----------
QUERY:


-- check handling of nested appendrels inside LATERAL
select * from
  ((select 2 as v) union all (select 3 as v)) as q1
  cross join lateral
  ((select * from
      ((select 4 as v) union all (select 5 as v)) as q3)
   union all
   (select q1.v)
  ) as q2;
RESULT:
	postgres: [(2, 4), (2, 5), (2, 2), (3, 4), (3, 5), (3, 3)]

-----------
QUERY:


-- check the number of columns specified
SELECT * FROM (int8_tbl i cross join int4_tbl j) ss(a,b,c,d);
RESULT:
	postgres: join expression "ss" has 3 columns available but 4 columns specified


-----------
QUERY:


-- check we don/* REPLACED */''t try to do a unique-ified semijoin with LATERAL
explain (verbose, costs off)
select * from
  (values (0,9998), (1,1000)) v(id,x),
  lateral (select f1 from int4_tbl
           where f1 = any (select unique1 from tenk1
                           where unique2 = v.x offset 0)) ss;
RESULT:
	postgres: [('Nested Loop',), ('  Output: "*VALUES*".column1, "*VALUES*".column2, int4_tbl.f1',), ('  ->  Values Scan on "*VALUES*"',), ('        Output: "*VALUES*".column1, "*VALUES*".column2',), ('  ->  Nested Loop Semi Join',), ('        Output: int4_tbl.f1',), ('        Join Filter: (int4_tbl.f1 = tenk1.unique1)',), ('        ->  Seq Scan on public.int4_tbl',), ('              Output: int4_tbl.f1',), ('        ->  Materialize',), ('              Output: tenk1.unique1',), ('              ->  Index Scan using tenk1_unique2 on public.tenk1',), ('                    Output: tenk1.unique1',), ('                    Index Cond: (tenk1.unique2 = "*VALUES*".column2)',)]

-----------
QUERY:

select * from
  (values (0,9998), (1,1000)) v(id,x),
  lateral (select f1 from int4_tbl
           where f1 = any (select unique1 from tenk1
                           where unique2 = v.x offset 0)) ss;
RESULT:
	postgres: [(0, 9998, 0)]

-----------
QUERY:


-- check proper extParam/allParam handling (this isn/* REPLACED */''t exactly a LATERAL issue,
-- but we can make the test case much more compact with LATERAL)
explain (verbose, costs off)
select * from (values (0), (1)) v(id),
lateral (select * from int8_tbl t1,
         lateral (select * from
                    (select * from int8_tbl t2
                     where (q1, random() > 0) = any (select q2, random() > 0 from int8_tbl t3
                                     where q2 = (select greatest(t1.q1,t2.q2))
                                       and (select v.id=0)) offset 0) ss2) ss
         where t1.q1 = ss.q2) ss0;
RESULT:
	postgres: [('Nested Loop',), ('  Output: "*VALUES*".column1, t1.q1, t1.q2, ss2.q1, ss2.q2',), ('  ->  Seq Scan on public.int8_tbl t1',), ('        Output: t1.q1, t1.q2',), ('  ->  Nested Loop',), ('        Output: "*VALUES*".column1, ss2.q1, ss2.q2',), ('        ->  Values Scan on "*VALUES*"',), ('              Output: "*VALUES*".column1',), ('        ->  Subquery Scan on ss2',), ('              Output: ss2.q1, ss2.q2',), ('              Filter: (t1.q1 = ss2.q2)',), ('              ->  Seq Scan on public.int8_tbl t2',), ('                    Output: t2.q1, t2.q2',), ("                    Filter: (ANY ((t2.q1 = (SubPlan 3).col1) AND ((random() > '0'::double precision) = (SubPlan 3).col2)))",), ('                    SubPlan 3',), ('                      ->  Result',), ("                            Output: t3.q2, (random() > '0'::double precision)",), ('                            One-Time Filter: (InitPlan 2).col1',), ('                            InitPlan 1',), ('                              ->  Result',), ('                                    Output: GREATEST(t1.q1, t2.q2)',), ('                            InitPlan 2',), ('                              ->  Result',), ('                                    Output: ("*VALUES*".column1 = 0)',), ('                            ->  Seq Scan on public.int8_tbl t3',), ('                                  Output: t3.q1, t3.q2',), ('                                  Filter: (t3.q2 = (InitPlan 1).col1)',)]

-----------
QUERY:


select * from (values (0), (1)) v(id),
lateral (select * from int8_tbl t1,
         lateral (select * from
                    (select * from int8_tbl t2
                     where (q1, random() > 0) = any (select q2, random() > 0 from int8_tbl t3
                                     where q2 = (select greatest(t1.q1,t2.q2))
                                       and (select v.id=0)) offset 0) ss2) ss
         where t1.q1 = ss.q2) ss0;
RESULT:
	postgres: [(0, 4567890123456789, 123, 4567890123456789, 4567890123456789), (0, 4567890123456789, 4567890123456789, 4567890123456789, 4567890123456789), (0, 4567890123456789, -4567890123456789, 4567890123456789, 4567890123456789)]

-----------
QUERY:


-- test some error cases where LATERAL should have been used but wasn/* REPLACED */''t
select f1,g from int4_tbl a, (select f1 as g) ss;
RESULT:
	postgres: column "f1" does not exist
LINE 4: select f1,g from int4_tbl a, (select f1 as g) ss;
                                             ^
DETAIL:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
HINT:  To reference that column, you must mark this subquery with LATERAL.


-----------
QUERY:

select f1,g from int4_tbl a, (select a.f1 as g) ss;
RESULT:
	postgres: invalid reference to FROM-clause entry for table "a"
LINE 2: select f1,g from int4_tbl a, (select a.f1 as g) ss;
                                             ^
DETAIL:  There is an entry for table "a", but it cannot be referenced from this part of the query.
HINT:  To reference that table, you must mark this subquery with LATERAL.


-----------
QUERY:

select f1,g from int4_tbl a cross join (select f1 as g) ss;
RESULT:
	postgres: column "f1" does not exist
LINE 2: select f1,g from int4_tbl a cross join (select f1 as g) ss;
                                                       ^
DETAIL:  There is a column named "f1" in table "a", but it cannot be referenced from this part of the query.
HINT:  To reference that column, you must mark this subquery with LATERAL.


-----------
QUERY:

select f1,g from int4_tbl a cross join (select a.f1 as g) ss;
RESULT:
	postgres: invalid reference to FROM-clause entry for table "a"
LINE 2: select f1,g from int4_tbl a cross join (select a.f1 as g) ss...
                                                       ^
DETAIL:  There is an entry for table "a", but it cannot be referenced from this part of the query.
HINT:  To reference that table, you must mark this subquery with LATERAL.


-----------
QUERY:

-- SQL:2008 says the left table is in scope but illegal to access here
select f1,g from int4_tbl a right join lateral generate_series(0, a.f1) g on true;
RESULT:
	postgres: invalid reference to FROM-clause entry for table "a"
LINE 3: ... int4_tbl a right join lateral generate_series(0, a.f1) g on...
                                                             ^
DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.


-----------
QUERY:

select f1,g from int4_tbl a full join lateral generate_series(0, a.f1) g on true;
RESULT:
	postgres: invalid reference to FROM-clause entry for table "a"
LINE 2: ...m int4_tbl a full join lateral generate_series(0, a.f1) g on...
                                                             ^
DETAIL:  The combining JOIN type must be INNER or LEFT for a LATERAL reference.


-----------
QUERY:

-- check we complain about ambiguous table references
select * from
  int8_tbl x cross join (int4_tbl x cross join lateral (select x.f1) ss);
RESULT:
	postgres: table reference "x" is ambiguous
LINE 4: ...cross join (int4_tbl x cross join lateral (select x.f1) ss);
                                                             ^


-----------
QUERY:

-- LATERAL can be used to put an aggregate into the FROM clause of its query
select 1 from tenk1 a, lateral (select max(a.unique1) from int4_tbl b) ss;
RESULT:
	postgres: aggregate functions are not allowed in FROM clause of their own query level
LINE 3: select 1 from tenk1 a, lateral (select max(a.unique1) from i...
                                               ^


-----------
QUERY:


-- check behavior of LATERAL in UPDATE/DELETE

create temp table xx1 as select f1 as x1, -f1 as x2 from int4_tbl;
RESULT:
	postgres: None

-----------
QUERY:


-- error, can/* REPLACED */''t do this:
update xx1 set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
RESULT:
	postgres: column "x1" does not exist
LINE 4: ... set x2 = f1 from (select * from int4_tbl where f1 = x1) ss;
                                                                ^
DETAIL:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.


-----------
QUERY:

update xx1 set x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss;
RESULT:
	postgres: invalid reference to FROM-clause entry for table "xx1"
LINE 2: ...t x2 = f1 from (select * from int4_tbl where f1 = xx1.x1) ss...
                                                             ^
DETAIL:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.


-----------
QUERY:

-- can/* REPLACED */''t do it even with LATERAL:
update xx1 set x2 = f1 from lateral (select * from int4_tbl where f1 = x1) ss;
RESULT:
	postgres: invalid reference to FROM-clause entry for table "xx1"
LINE 3: ...= f1 from lateral (select * from int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.


-----------
QUERY:

-- we might in future allow something like this, but for now it/* REPLACED */''s an error:
update xx1 set x2 = f1 from xx1, lateral (select * from int4_tbl where f1 = x1) ss;
RESULT:
	postgres: table name "xx1" specified more than once


-----------
QUERY:


-- also errors:
delete from xx1 using (select * from int4_tbl where f1 = x1) ss;
RESULT:
	postgres: column "x1" does not exist
LINE 4: ...te from xx1 using (select * from int4_tbl where f1 = x1) ss;
                                                                ^
DETAIL:  There is a column named "x1" in table "xx1", but it cannot be referenced from this part of the query.


-----------
QUERY:

delete from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss;
RESULT:
	postgres: invalid reference to FROM-clause entry for table "xx1"
LINE 2: ...from xx1 using (select * from int4_tbl where f1 = xx1.x1) ss...
                                                             ^
DETAIL:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.


-----------
QUERY:

delete from xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
RESULT:
	postgres: invalid reference to FROM-clause entry for table "xx1"
LINE 2: ...xx1 using lateral (select * from int4_tbl where f1 = x1) ss;
                                                                ^
HINT:  There is an entry for table "xx1", but it cannot be referenced from this part of the query.


-----------
QUERY:


--
-- test LATERAL reference propagation down a multi-level inheritance hierarchy
-- produced for a multi-level partitioned table hierarchy.
--
create table join_pt1 (a int, b int, c varchar) partition by range(a);
RESULT:
	postgres: None

-----------
QUERY:

create table join_pt1p1 partition of join_pt1 for values from (0) to (100) partition by range(b);
RESULT:
	postgres: None

-----------
QUERY:

create table join_pt1p2 partition of join_pt1 for values from (100) to (200);
RESULT:
	postgres: None

-----------
QUERY:

create table join_pt1p1p1 partition of join_pt1p1 for values from (0) to (100);
RESULT:
	postgres: None

-----------
QUERY:

insert into join_pt1 values (1, 1, 'x'), (101, 101, 'y');
RESULT:
	postgres: None

-----------
QUERY:

create table join_ut1 (a int, b int, c varchar);
RESULT:
	postgres: None

-----------
QUERY:

insert into join_ut1 values (101, 101, 'y'), (2, 2, 'z');
RESULT:
	postgres: None

-----------
QUERY:

explain (verbose, costs off)
select t1.b, ss.phv from join_ut1 t1 left join lateral
              (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv
					  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss
              on t1.a = ss.t2a order by t1.a;
RESULT:
	postgres: [('Sort',), ('  Output: t1.b, (LEAST(t1.a, t2.a, t3.a)), t1.a',), ('  Sort Key: t1.a',), ('  ->  Nested Loop Left Join',), ('        Output: t1.b, (LEAST(t1.a, t2.a, t3.a)), t1.a',), ('        ->  Seq Scan on public.join_ut1 t1',), ('              Output: t1.a, t1.b, t1.c',), ('        ->  Hash Join',), ('              Output: t2.a, LEAST(t1.a, t2.a, t3.a)',), ('              Hash Cond: (t3.b = t2.a)',), ('              ->  Seq Scan on public.join_ut1 t3',), ('                    Output: t3.a, t3.b, t3.c',), ('              ->  Hash',), ('                    Output: t2.a',), ('                    ->  Append',), ('                          ->  Seq Scan on public.join_pt1p1p1 t2_1',), ('                                Output: t2_1.a',), ('                                Filter: (t1.a = t2_1.a)',), ('                          ->  Seq Scan on public.join_pt1p2 t2_2',), ('                                Output: t2_2.a',), ('                                Filter: (t1.a = t2_2.a)',)]

-----------
QUERY:

select t1.b, ss.phv from join_ut1 t1 left join lateral
              (select t2.a as t2a, t3.a t3a, least(t1.a, t2.a, t3.a) phv
					  from join_pt1 t2 join join_ut1 t3 on t2.a = t3.b) ss
              on t1.a = ss.t2a order by t1.a;
RESULT:
	postgres: [(2, None), (101, 101)]

-----------
QUERY:


drop table join_pt1;
RESULT:
	postgres: None

-----------
QUERY:

drop table join_ut1;
RESULT:
	postgres: None

-----------
QUERY:


--
-- test estimation behavior with multi-column foreign key and constant qual
--

begin;
RESULT:
	postgres: None

-----------
QUERY:


create table fkest (x integer, x10 integer, x10b integer, x100 integer);
RESULT:
	postgres: None

-----------
QUERY:

insert into fkest select x, x/10, x/10, x/100 from generate_series(1,1000) x;
RESULT:
	postgres: None

-----------
QUERY:

create unique index on fkest(x, x10, x100);
RESULT:
	postgres: None

-----------
QUERY:

analyze fkest;
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select * from fkest f1
  join fkest f2 on (f1.x = f2.x and f1.x10 = f2.x10b and f1.x100 = f2.x100)
  join fkest f3 on f1.x = f3.x
  where f1.x100 = 2;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Hash Join',), ('        Hash Cond: ((f2.x = f1.x) AND (f2.x10b = f1.x10))',), ('        ->  Seq Scan on fkest f2',), ('              Filter: (x100 = 2)',), ('        ->  Hash',), ('              ->  Seq Scan on fkest f1',), ('                    Filter: (x100 = 2)',), ('  ->  Index Scan using fkest_x_x10_x100_idx on fkest f3',), ('        Index Cond: (x = f1.x)',)]

-----------
QUERY:


alter table fkest add constraint fk
  foreign key (x, x10b, x100) references fkest (x, x10, x100);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select * from fkest f1
  join fkest f2 on (f1.x = f2.x and f1.x10 = f2.x10b and f1.x100 = f2.x100)
  join fkest f3 on f1.x = f3.x
  where f1.x100 = 2;
RESULT:
	postgres: [('Hash Join',), ('  Hash Cond: ((f2.x = f1.x) AND (f2.x10b = f1.x10))',), ('  ->  Hash Join',), ('        Hash Cond: (f3.x = f2.x)',), ('        ->  Seq Scan on fkest f3',), ('        ->  Hash',), ('              ->  Seq Scan on fkest f2',), ('                    Filter: (x100 = 2)',), ('  ->  Hash',), ('        ->  Seq Scan on fkest f1',), ('              Filter: (x100 = 2)',)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


--
-- test that foreign key join estimation performs sanely for outer joins
--

begin;
RESULT:
	postgres: None

-----------
QUERY:


create table fkest (a int, b int, c int unique, primary key(a,b));
RESULT:
	postgres: None

-----------
QUERY:

create table fkest1 (a int, b int, primary key(a,b));
RESULT:
	postgres: None

-----------
QUERY:


insert into fkest select x/10, x%10, x from generate_series(1,1000) x;
RESULT:
	postgres: None

-----------
QUERY:

insert into fkest1 select x/10, x%10 from generate_series(1,1000) x;
RESULT:
	postgres: None

-----------
QUERY:


alter table fkest1
  add constraint fkest1_a_b_fkey foreign key (a,b) references fkest;
RESULT:
	postgres: None

-----------
QUERY:


analyze fkest;
RESULT:
	postgres: None

-----------
QUERY:

analyze fkest1;
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select *
from fkest f
  left join fkest1 f1 on f.a = f1.a and f.b = f1.b
  left join fkest1 f2 on f.a = f2.a and f.b = f2.b
  left join fkest1 f3 on f.a = f3.a and f.b = f3.b
where f.c = 1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  ->  Nested Loop Left Join',), ('        ->  Nested Loop Left Join',), ('              ->  Index Scan using fkest_c_key on fkest f',), ('                    Index Cond: (c = 1)',), ('              ->  Index Only Scan using fkest1_pkey on fkest1 f1',), ('                    Index Cond: ((a = f.a) AND (b = f.b))',), ('        ->  Index Only Scan using fkest1_pkey on fkest1 f2',), ('              Index Cond: ((a = f.a) AND (b = f.b))',), ('  ->  Index Only Scan using fkest1_pkey on fkest1 f3',), ('        Index Cond: ((a = f.a) AND (b = f.b))',)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


--
-- test planner/* REPLACED */''s ability to mark joins as unique
--

create table j1 (id int primary key);
RESULT:
	postgres: None

-----------
QUERY:

create table j2 (id int primary key);
RESULT:
	postgres: None

-----------
QUERY:

create table j3 (id int);
RESULT:
	postgres: None

-----------
QUERY:


insert into j1 values(1),(2),(3);
RESULT:
	postgres: None

-----------
QUERY:

insert into j2 values(1),(2),(3);
RESULT:
	postgres: None

-----------
QUERY:

insert into j3 values(1),(1);
RESULT:
	postgres: None

-----------
QUERY:


analyze j1;
RESULT:
	postgres: None

-----------
QUERY:

analyze j2;
RESULT:
	postgres: None

-----------
QUERY:

analyze j3;
RESULT:
	postgres: None

-----------
QUERY:


-- ensure join is properly marked as unique
explain (verbose, costs off)
select * from j1 inner join j2 on j1.id = j2.id;
RESULT:
	postgres: [('Hash Join',), ('  Output: j1.id, j2.id',), ('  Inner Unique: true',), ('  Hash Cond: (j1.id = j2.id)',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id',), ('  ->  Hash',), ('        Output: j2.id',), ('        ->  Seq Scan on public.j2',), ('              Output: j2.id',)]

-----------
QUERY:


-- ensure join is not unique when not an equi-join
explain (verbose, costs off)
select * from j1 inner join j2 on j1.id > j2.id;
RESULT:
	postgres: [('Nested Loop',), ('  Output: j1.id, j2.id',), ('  Join Filter: (j1.id > j2.id)',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id',), ('  ->  Materialize',), ('        Output: j2.id',), ('        ->  Seq Scan on public.j2',), ('              Output: j2.id',)]

-----------
QUERY:


-- ensure non-unique rel is not chosen as inner
explain (verbose, costs off)
select * from j1 inner join j3 on j1.id = j3.id;
RESULT:
	postgres: [('Hash Join',), ('  Output: j1.id, j3.id',), ('  Inner Unique: true',), ('  Hash Cond: (j3.id = j1.id)',), ('  ->  Seq Scan on public.j3',), ('        Output: j3.id',), ('  ->  Hash',), ('        Output: j1.id',), ('        ->  Seq Scan on public.j1',), ('              Output: j1.id',)]

-----------
QUERY:


-- ensure left join is marked as unique
explain (verbose, costs off)
select * from j1 left join j2 on j1.id = j2.id;
RESULT:
	postgres: [('Hash Left Join',), ('  Output: j1.id, j2.id',), ('  Inner Unique: true',), ('  Hash Cond: (j1.id = j2.id)',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id',), ('  ->  Hash',), ('        Output: j2.id',), ('        ->  Seq Scan on public.j2',), ('              Output: j2.id',)]

-----------
QUERY:


-- ensure right join is marked as unique
explain (verbose, costs off)
select * from j1 right join j2 on j1.id = j2.id;
RESULT:
	postgres: [('Hash Left Join',), ('  Output: j1.id, j2.id',), ('  Inner Unique: true',), ('  Hash Cond: (j2.id = j1.id)',), ('  ->  Seq Scan on public.j2',), ('        Output: j2.id',), ('  ->  Hash',), ('        Output: j1.id',), ('        ->  Seq Scan on public.j1',), ('              Output: j1.id',)]

-----------
QUERY:


-- ensure full join is marked as unique
explain (verbose, costs off)
select * from j1 full join j2 on j1.id = j2.id;
RESULT:
	postgres: [('Hash Full Join',), ('  Output: j1.id, j2.id',), ('  Inner Unique: true',), ('  Hash Cond: (j1.id = j2.id)',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id',), ('  ->  Hash',), ('        Output: j2.id',), ('        ->  Seq Scan on public.j2',), ('              Output: j2.id',)]

-----------
QUERY:


-- a clauseless (cross) join can/* REPLACED */''t be unique
explain (verbose, costs off)
select * from j1 cross join j2;
RESULT:
	postgres: [('Nested Loop',), ('  Output: j1.id, j2.id',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id',), ('  ->  Materialize',), ('        Output: j2.id',), ('        ->  Seq Scan on public.j2',), ('              Output: j2.id',)]

-----------
QUERY:


-- ensure a natural join is marked as unique
explain (verbose, costs off)
select * from j1 natural join j2;
RESULT:
	postgres: [('Hash Join',), ('  Output: j1.id',), ('  Inner Unique: true',), ('  Hash Cond: (j1.id = j2.id)',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id',), ('  ->  Hash',), ('        Output: j2.id',), ('        ->  Seq Scan on public.j2',), ('              Output: j2.id',)]

-----------
QUERY:


-- ensure a distinct clause allows the inner to become unique
explain (verbose, costs off)
select * from j1
inner join (select distinct id from j3) j3 on j1.id = j3.id;
RESULT:
	postgres: [('Nested Loop',), ('  Output: j1.id, j3.id',), ('  Inner Unique: true',), ('  Join Filter: (j1.id = j3.id)',), ('  ->  Unique',), ('        Output: j3.id',), ('        ->  Sort',), ('              Output: j3.id',), ('              Sort Key: j3.id',), ('              ->  Seq Scan on public.j3',), ('                    Output: j3.id',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id',)]

-----------
QUERY:


-- ensure group by clause allows the inner to become unique
explain (verbose, costs off)
select * from j1
inner join (select id from j3 group by id) j3 on j1.id = j3.id;
RESULT:
	postgres: [('Nested Loop',), ('  Output: j1.id, j3.id',), ('  Inner Unique: true',), ('  Join Filter: (j1.id = j3.id)',), ('  ->  Group',), ('        Output: j3.id',), ('        Group Key: j3.id',), ('        ->  Sort',), ('              Output: j3.id',), ('              Sort Key: j3.id',), ('              ->  Seq Scan on public.j3',), ('                    Output: j3.id',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id',)]

-----------
QUERY:


drop table j1;
RESULT:
	postgres: None

-----------
QUERY:

drop table j2;
RESULT:
	postgres: None

-----------
QUERY:

drop table j3;
RESULT:
	postgres: None

-----------
QUERY:


-- test more complex permutations of unique joins

create table j1 (id1 int, id2 int, primary key(id1,id2));
RESULT:
	postgres: None

-----------
QUERY:

create table j2 (id1 int, id2 int, primary key(id1,id2));
RESULT:
	postgres: None

-----------
QUERY:

create table j3 (id1 int, id2 int, primary key(id1,id2));
RESULT:
	postgres: None

-----------
QUERY:


insert into j1 values(1,1),(1,2);
RESULT:
	postgres: None

-----------
QUERY:

insert into j2 values(1,1);
RESULT:
	postgres: None

-----------
QUERY:

insert into j3 values(1,1);
RESULT:
	postgres: None

-----------
QUERY:


analyze j1;
RESULT:
	postgres: None

-----------
QUERY:

analyze j2;
RESULT:
	postgres: None

-----------
QUERY:

analyze j3;
RESULT:
	postgres: None

-----------
QUERY:


-- ensure there/* REPLACED */''s no unique join when not all columns which are part of the
-- unique index are seen in the join clause
explain (verbose, costs off)
select * from j1
inner join j2 on j1.id1 = j2.id1;
RESULT:
	postgres: [('Nested Loop',), ('  Output: j1.id1, j1.id2, j2.id1, j2.id2',), ('  Join Filter: (j1.id1 = j2.id1)',), ('  ->  Seq Scan on public.j2',), ('        Output: j2.id1, j2.id2',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id1, j1.id2',)]

-----------
QUERY:


-- ensure proper unique detection with multiple join quals
explain (verbose, costs off)
select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2;
RESULT:
	postgres: [('Nested Loop',), ('  Output: j1.id1, j1.id2, j2.id1, j2.id2',), ('  Inner Unique: true',), ('  Join Filter: ((j1.id1 = j2.id1) AND (j1.id2 = j2.id2))',), ('  ->  Seq Scan on public.j2',), ('        Output: j2.id1, j2.id2',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id1, j1.id2',)]

-----------
QUERY:


-- ensure we don/* REPLACED */''t detect the join to be unique when quals are not part of the
-- join condition
explain (verbose, costs off)
select * from j1
inner join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
RESULT:
	postgres: [('Nested Loop',), ('  Output: j1.id1, j1.id2, j2.id1, j2.id2',), ('  Join Filter: (j1.id1 = j2.id1)',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id1, j1.id2',), ('        Filter: (j1.id2 = 1)',), ('  ->  Seq Scan on public.j2',), ('        Output: j2.id1, j2.id2',)]

-----------
QUERY:


-- as above, but for left joins.
explain (verbose, costs off)
select * from j1
left join j2 on j1.id1 = j2.id1 where j1.id2 = 1;
RESULT:
	postgres: [('Nested Loop Left Join',), ('  Output: j1.id1, j1.id2, j2.id1, j2.id2',), ('  Join Filter: (j1.id1 = j2.id1)',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id1, j1.id2',), ('        Filter: (j1.id2 = 1)',), ('  ->  Seq Scan on public.j2',), ('        Output: j2.id1, j2.id2',)]

-----------
QUERY:


create unique index j1_id2_idx on j1(id2) where id2 is not null;
RESULT:
	postgres: None

-----------
QUERY:


-- ensure we don/* REPLACED */''t use a partial unique index as unique proofs
explain (verbose, costs off)
select * from j1
inner join j2 on j1.id2 = j2.id2;
RESULT:
	postgres: [('Nested Loop',), ('  Output: j1.id1, j1.id2, j2.id1, j2.id2',), ('  Join Filter: (j2.id2 = j1.id2)',), ('  ->  Seq Scan on public.j2',), ('        Output: j2.id1, j2.id2',), ('  ->  Seq Scan on public.j1',), ('        Output: j1.id1, j1.id2',)]

-----------
QUERY:


drop index j1_id2_idx;
RESULT:
	postgres: None

-----------
QUERY:


-- validate logic in merge joins which skips mark and restore.
-- it should only do this if all quals which were used to detect the unique
-- are present as join quals, and not plain quals.
set enable_nestloop to 0;
RESULT:
	postgres: None

-----------
QUERY:

set enable_hashjoin to 0;
RESULT:
	postgres: None

-----------
QUERY:

set enable_sort to 0;
RESULT:
	postgres: None

-----------
QUERY:


-- create indexes that will be preferred over the PKs to perform the join
create index j1_id1_idx on j1 (id1) where id1 % 1000 = 1;
RESULT:
	postgres: None

-----------
QUERY:

create index j2_id1_idx on j2 (id1) where id1 % 1000 = 1;
RESULT:
	postgres: None

-----------
QUERY:


-- need an additional row in j2, if we want j2_id1_idx to be preferred
insert into j2 values(1,2);
RESULT:
	postgres: None

-----------
QUERY:

analyze j2;
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
RESULT:
	postgres: [('Merge Join',), ('  Merge Cond: (j1.id1 = j2.id1)',), ('  Join Filter: (j2.id2 = j1.id2)',), ('  ->  Index Scan using j1_id1_idx on j1',), ('  ->  Index Scan using j2_id1_idx on j2',)]

-----------
QUERY:


select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1;
RESULT:
	postgres: [(1, 1, 1, 1), (1, 2, 1, 2)]

-----------
QUERY:


-- Exercise array keys mark/restore B-Tree code
explain (costs off) select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1 and j2.id1 = any (array[1]);
RESULT:
	postgres: [('Merge Join',), ('  Merge Cond: (j1.id1 = j2.id1)',), ('  Join Filter: (j2.id2 = j1.id2)',), ('  ->  Index Scan using j1_id1_idx on j1',), ('  ->  Index Scan using j2_id1_idx on j2',), ("        Index Cond: (id1 = ANY ('{1}'::integer[]))",)]

-----------
QUERY:


select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1 and j2.id1 = any (array[1]);
RESULT:
	postgres: [(1, 1, 1, 1), (1, 2, 1, 2)]

-----------
QUERY:


-- Exercise array keys /* REPLACED */''find extreme element/* REPLACED */'' B-Tree code
explain (costs off) select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1 and j2.id1 >= any (array[1,5]);
RESULT:
	postgres: [('Merge Join',), ('  Merge Cond: (j1.id1 = j2.id1)',), ('  Join Filter: (j2.id2 = j1.id2)',), ('  ->  Index Scan using j1_id1_idx on j1',), ('  ->  Index Only Scan using j2_pkey on j2',), ("        Index Cond: (id1 >= ANY ('{1,5}'::integer[]))",), ('        Filter: ((id1 % 1000) = 1)',)]

-----------
QUERY:


select * from j1
inner join j2 on j1.id1 = j2.id1 and j1.id2 = j2.id2
where j1.id1 % 1000 = 1 and j2.id1 % 1000 = 1 and j2.id1 >= any (array[1,5]);
RESULT:
	postgres: [(1, 1, 1, 1), (1, 2, 1, 2)]

-----------
QUERY:


reset enable_nestloop;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_hashjoin;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_sort;
RESULT:
	postgres: None

-----------
QUERY:


drop table j1;
RESULT:
	postgres: None

-----------
QUERY:

drop table j2;
RESULT:
	postgres: None

-----------
QUERY:

drop table j3;
RESULT:
	postgres: None

-----------
QUERY:


-- check that semijoin inner is not seen as unique for a portion of the outerrel
explain (verbose, costs off)
select t1.unique1, t2.hundred
from onek t1, tenk1 t2
where exists (select 1 from tenk1 t3
              where t3.thousand = t1.unique1 and t3.tenthous = t2.hundred)
      and t1.unique1 < 1;
RESULT:
	postgres: [('Nested Loop',), ('  Output: t1.unique1, t2.hundred',), ('  ->  Hash Join',), ('        Output: t1.unique1, t3.tenthous',), ('        Hash Cond: (t3.thousand = t1.unique1)',), ('        ->  HashAggregate',), ('              Output: t3.thousand, t3.tenthous',), ('              Group Key: t3.thousand, t3.tenthous',), ('              ->  Index Only Scan using tenk1_thous_tenthous on public.tenk1 t3',), ('                    Output: t3.thousand, t3.tenthous',), ('        ->  Hash',), ('              Output: t1.unique1',), ('              ->  Index Only Scan using onek_unique1 on public.onek t1',), ('                    Output: t1.unique1',), ('                    Index Cond: (t1.unique1 < 1)',), ('  ->  Index Only Scan using tenk1_hundred on public.tenk1 t2',), ('        Output: t2.hundred',), ('        Index Cond: (t2.hundred = t3.tenthous)',)]

-----------
QUERY:


-- ... unless it actually is unique
create table j3 as select unique1, tenthous from onek;
RESULT:
	postgres: None

-----------
QUERY:

vacuum analyze j3;
RESULT:
	postgres: None

-----------
QUERY:

create unique index on j3(unique1, tenthous);
RESULT:
	postgres: None

-----------
QUERY:


explain (verbose, costs off)
select t1.unique1, t2.hundred
from onek t1, tenk1 t2
where exists (select 1 from j3
              where j3.unique1 = t1.unique1 and j3.tenthous = t2.hundred)
      and t1.unique1 < 1;
RESULT:
	postgres: [('Nested Loop',), ('  Output: t1.unique1, t2.hundred',), ('  ->  Nested Loop',), ('        Output: t1.unique1, j3.tenthous',), ('        ->  Index Only Scan using onek_unique1 on public.onek t1',), ('              Output: t1.unique1',), ('              Index Cond: (t1.unique1 < 1)',), ('        ->  Index Only Scan using j3_unique1_tenthous_idx on public.j3',), ('              Output: j3.unique1, j3.tenthous',), ('              Index Cond: (j3.unique1 = t1.unique1)',), ('  ->  Index Only Scan using tenk1_hundred on public.tenk1 t2',), ('        Output: t2.hundred',), ('        Index Cond: (t2.hundred = j3.tenthous)',)]

-----------
QUERY:


drop table j3;
RESULT:
	postgres: None
