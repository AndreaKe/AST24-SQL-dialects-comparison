
-----------
QUERY:
--
-- Test partitioning planner code
--

-- Force generic plans to be used for all prepared statements in this file.
set plan_cache_mode = force_generic_plan;
RESULT:
	postgres: None

-----------
QUERY:


create table lp (a char) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table lp_default partition of lp default;
RESULT:
	postgres: None

-----------
QUERY:

create table lp_ef partition of lp for values in ('e', 'f');
RESULT:
	postgres: None

-----------
QUERY:

create table lp_ad partition of lp for values in ('a', 'd');
RESULT:
	postgres: None

-----------
QUERY:

create table lp_bc partition of lp for values in ('b', 'c');
RESULT:
	postgres: None

-----------
QUERY:

create table lp_g partition of lp for values in ('g');
RESULT:
	postgres: None

-----------
QUERY:

create table lp_null partition of lp for values in (null);
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from lp;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_ad lp_1',), ('  ->  Seq Scan on lp_bc lp_2',), ('  ->  Seq Scan on lp_ef lp_3',), ('  ->  Seq Scan on lp_g lp_4',), ('  ->  Seq Scan on lp_null lp_5',), ('  ->  Seq Scan on lp_default lp_6',)]

-----------
QUERY:

explain (costs off) select * from lp where a > 'a' and a < 'd';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_bc lp_1',), ("        Filter: ((a > 'a'::bpchar) AND (a < 'd'::bpchar))",), ('  ->  Seq Scan on lp_default lp_2',), ("        Filter: ((a > 'a'::bpchar) AND (a < 'd'::bpchar))",)]

-----------
QUERY:

explain (costs off) select * from lp where a > 'a' and a <= 'd';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_ad lp_1',), ("        Filter: ((a > 'a'::bpchar) AND (a <= 'd'::bpchar))",), ('  ->  Seq Scan on lp_bc lp_2',), ("        Filter: ((a > 'a'::bpchar) AND (a <= 'd'::bpchar))",), ('  ->  Seq Scan on lp_default lp_3',), ("        Filter: ((a > 'a'::bpchar) AND (a <= 'd'::bpchar))",)]

-----------
QUERY:

explain (costs off) select * from lp where a = 'a';
RESULT:
	postgres: [('Seq Scan on lp_ad lp',), ("  Filter: (a = 'a'::bpchar)",)]

-----------
QUERY:

explain (costs off) select * from lp where 'a' = a;
RESULT:
	postgres: [('Seq Scan on lp_ad lp',), ("  Filter: ('a'::bpchar = a)",)]

-----------
QUERY:
	/* commuted */
explain (costs off) select * from lp where a is not null;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_ad lp_1',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on lp_bc lp_2',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on lp_ef lp_3',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on lp_g lp_4',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on lp_default lp_5',), ('        Filter: (a IS NOT NULL)',)]

-----------
QUERY:

explain (costs off) select * from lp where a is null;
RESULT:
	postgres: [('Seq Scan on lp_null lp',), ('  Filter: (a IS NULL)',)]

-----------
QUERY:

explain (costs off) select * from lp where a = 'a' or a = 'c';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_ad lp_1',), ("        Filter: ((a = 'a'::bpchar) OR (a = 'c'::bpchar))",), ('  ->  Seq Scan on lp_bc lp_2',), ("        Filter: ((a = 'a'::bpchar) OR (a = 'c'::bpchar))",)]

-----------
QUERY:

explain (costs off) select * from lp where a is not null and (a = 'a' or a = 'c');
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_ad lp_1',), ("        Filter: ((a IS NOT NULL) AND ((a = 'a'::bpchar) OR (a = 'c'::bpchar)))",), ('  ->  Seq Scan on lp_bc lp_2',), ("        Filter: ((a IS NOT NULL) AND ((a = 'a'::bpchar) OR (a = 'c'::bpchar)))",)]

-----------
QUERY:

explain (costs off) select * from lp where a <> 'g';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_ad lp_1',), ("        Filter: (a <> 'g'::bpchar)",), ('  ->  Seq Scan on lp_bc lp_2',), ("        Filter: (a <> 'g'::bpchar)",), ('  ->  Seq Scan on lp_ef lp_3',), ("        Filter: (a <> 'g'::bpchar)",), ('  ->  Seq Scan on lp_default lp_4',), ("        Filter: (a <> 'g'::bpchar)",)]

-----------
QUERY:

explain (costs off) select * from lp where a <> 'a' and a <> 'd';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_bc lp_1',), ("        Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))",), ('  ->  Seq Scan on lp_ef lp_2',), ("        Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))",), ('  ->  Seq Scan on lp_g lp_3',), ("        Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))",), ('  ->  Seq Scan on lp_default lp_4',), ("        Filter: ((a <> 'a'::bpchar) AND (a <> 'd'::bpchar))",)]

-----------
QUERY:

explain (costs off) select * from lp where a not in ('a', 'd');
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_bc lp_1',), ("        Filter: (a <> ALL ('{a,d}'::bpchar[]))",), ('  ->  Seq Scan on lp_ef lp_2',), ("        Filter: (a <> ALL ('{a,d}'::bpchar[]))",), ('  ->  Seq Scan on lp_g lp_3',), ("        Filter: (a <> ALL ('{a,d}'::bpchar[]))",), ('  ->  Seq Scan on lp_default lp_4',), ("        Filter: (a <> ALL ('{a,d}'::bpchar[]))",)]

-----------
QUERY:


-- collation matches the partitioning collation, pruning works
create table coll_pruning (a text collate "C") partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table coll_pruning_a partition of coll_pruning for values in ('a');
RESULT:
	postgres: None

-----------
QUERY:

create table coll_pruning_b partition of coll_pruning for values in ('b');
RESULT:
	postgres: None

-----------
QUERY:

create table coll_pruning_def partition of coll_pruning default;
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from coll_pruning where a collate "C" = 'a' collate "C";
RESULT:
	postgres: [('Seq Scan on coll_pruning_a coll_pruning',), ('  Filter: (a = \'a\'::text COLLATE "C")',)]

-----------
QUERY:

-- collation doesn/* REPLACED */''t match the partitioning collation, no pruning occurs
explain (costs off) select * from coll_pruning where a collate "POSIX" = 'a' collate "POSIX";
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on coll_pruning_a coll_pruning_1',), ('        Filter: ((a)::text = \'a\'::text COLLATE "POSIX")',), ('  ->  Seq Scan on coll_pruning_b coll_pruning_2',), ('        Filter: ((a)::text = \'a\'::text COLLATE "POSIX")',), ('  ->  Seq Scan on coll_pruning_def coll_pruning_3',), ('        Filter: ((a)::text = \'a\'::text COLLATE "POSIX")',)]

-----------
QUERY:


create table rlp (a int, b varchar) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table rlp_default partition of rlp default partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table rlp_default_default partition of rlp_default default;
RESULT:
	postgres: None

-----------
QUERY:

create table rlp_default_10 partition of rlp_default for values in (10);
RESULT:
	postgres: None

-----------
QUERY:

create table rlp_default_30 partition of rlp_default for values in (30);
RESULT:
	postgres: None

-----------
QUERY:

create table rlp_default_null partition of rlp_default for values in (null);
RESULT:
	postgres: None

-----------
QUERY:

create table rlp1 partition of rlp for values from (minvalue) to (1);
RESULT:
	postgres: None

-----------
QUERY:

create table rlp2 partition of rlp for values from (1) to (10);
RESULT:
	postgres: None

-----------
QUERY:


create table rlp3 (b varchar, a int) partition by list (b varchar_ops);
RESULT:
	postgres: None

-----------
QUERY:

create table rlp3_default partition of rlp3 default;
RESULT:
	postgres: None

-----------
QUERY:

create table rlp3abcd partition of rlp3 for values in ('ab', 'cd');
RESULT:
	postgres: None

-----------
QUERY:

create table rlp3efgh partition of rlp3 for values in ('ef', 'gh');
RESULT:
	postgres: None

-----------
QUERY:

create table rlp3nullxy partition of rlp3 for values in (null, 'xy');
RESULT:
	postgres: None

-----------
QUERY:

alter table rlp attach partition rlp3 for values from (15) to (20);
RESULT:
	postgres: None

-----------
QUERY:


create table rlp4 partition of rlp for values from (20) to (30) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table rlp4_default partition of rlp4 default;
RESULT:
	postgres: None

-----------
QUERY:

create table rlp4_1 partition of rlp4 for values from (20) to (25);
RESULT:
	postgres: None

-----------
QUERY:

create table rlp4_2 partition of rlp4 for values from (25) to (29);
RESULT:
	postgres: None

-----------
QUERY:


create table rlp5 partition of rlp for values from (31) to (maxvalue) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table rlp5_default partition of rlp5 default;
RESULT:
	postgres: None

-----------
QUERY:

create table rlp5_1 partition of rlp5 for values from (31) to (40);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from rlp where a < 1;
RESULT:
	postgres: [('Seq Scan on rlp1 rlp',), ('  Filter: (a < 1)',)]

-----------
QUERY:

explain (costs off) select * from rlp where 1 > a;
RESULT:
	postgres: [('Seq Scan on rlp1 rlp',), ('  Filter: (1 > a)',)]

-----------
QUERY:
	/* commuted */
explain (costs off) select * from rlp where a <= 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp1 rlp_1',), ('        Filter: (a <= 1)',), ('  ->  Seq Scan on rlp2 rlp_2',), ('        Filter: (a <= 1)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 1;
RESULT:
	postgres: [('Seq Scan on rlp2 rlp',), ('  Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 1::bigint;
RESULT:
	postgres: [('Seq Scan on rlp2 rlp',), ("  Filter: (a = '1'::bigint)",)]

-----------
QUERY:
		/* same as above */
explain (costs off) select * from rlp where a = 1::numeric;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp1 rlp_1',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp2 rlp_2',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp3abcd rlp_3',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp3efgh rlp_4',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp3nullxy rlp_5',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp3_default rlp_6',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp4_1 rlp_7',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp4_2 rlp_8',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp4_default rlp_9',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp5_1 rlp_10',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp5_default rlp_11',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp_default_10 rlp_12',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp_default_30 rlp_13',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp_default_null rlp_14',), ("        Filter: ((a)::numeric = '1'::numeric)",), ('  ->  Seq Scan on rlp_default_default rlp_15',), ("        Filter: ((a)::numeric = '1'::numeric)",)]

-----------
QUERY:
		/* no pruning */
explain (costs off) select * from rlp where a <= 10;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp1 rlp_1',), ('        Filter: (a <= 10)',), ('  ->  Seq Scan on rlp2 rlp_2',), ('        Filter: (a <= 10)',), ('  ->  Seq Scan on rlp_default_10 rlp_3',), ('        Filter: (a <= 10)',), ('  ->  Seq Scan on rlp_default_default rlp_4',), ('        Filter: (a <= 10)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a > 10;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp3abcd rlp_1',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on rlp3efgh rlp_2',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on rlp3nullxy rlp_3',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on rlp3_default rlp_4',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on rlp4_1 rlp_5',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on rlp4_2 rlp_6',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on rlp4_default rlp_7',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on rlp5_1 rlp_8',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on rlp5_default rlp_9',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on rlp_default_30 rlp_10',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on rlp_default_default rlp_11',), ('        Filter: (a > 10)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a < 15;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp1 rlp_1',), ('        Filter: (a < 15)',), ('  ->  Seq Scan on rlp2 rlp_2',), ('        Filter: (a < 15)',), ('  ->  Seq Scan on rlp_default_10 rlp_3',), ('        Filter: (a < 15)',), ('  ->  Seq Scan on rlp_default_default rlp_4',), ('        Filter: (a < 15)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a <= 15;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp1 rlp_1',), ('        Filter: (a <= 15)',), ('  ->  Seq Scan on rlp2 rlp_2',), ('        Filter: (a <= 15)',), ('  ->  Seq Scan on rlp3abcd rlp_3',), ('        Filter: (a <= 15)',), ('  ->  Seq Scan on rlp3efgh rlp_4',), ('        Filter: (a <= 15)',), ('  ->  Seq Scan on rlp3nullxy rlp_5',), ('        Filter: (a <= 15)',), ('  ->  Seq Scan on rlp3_default rlp_6',), ('        Filter: (a <= 15)',), ('  ->  Seq Scan on rlp_default_10 rlp_7',), ('        Filter: (a <= 15)',), ('  ->  Seq Scan on rlp_default_default rlp_8',), ('        Filter: (a <= 15)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a > 15 and b = 'ab';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp3abcd rlp_1',), ("        Filter: ((a > 15) AND ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp4_1 rlp_2',), ("        Filter: ((a > 15) AND ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp4_2 rlp_3',), ("        Filter: ((a > 15) AND ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp4_default rlp_4',), ("        Filter: ((a > 15) AND ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp5_1 rlp_5',), ("        Filter: ((a > 15) AND ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp5_default rlp_6',), ("        Filter: ((a > 15) AND ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp_default_30 rlp_7',), ("        Filter: ((a > 15) AND ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp_default_default rlp_8',), ("        Filter: ((a > 15) AND ((b)::text = 'ab'::text))",)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 16;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp3abcd rlp_1',), ('        Filter: (a = 16)',), ('  ->  Seq Scan on rlp3efgh rlp_2',), ('        Filter: (a = 16)',), ('  ->  Seq Scan on rlp3nullxy rlp_3',), ('        Filter: (a = 16)',), ('  ->  Seq Scan on rlp3_default rlp_4',), ('        Filter: (a = 16)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 16 and b in ('not', 'in', 'here');
RESULT:
	postgres: [('Seq Scan on rlp3_default rlp',), ("  Filter: ((a = 16) AND ((b)::text = ANY ('{not,in,here}'::text[])))",)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 16 and b < 'ab';
RESULT:
	postgres: [('Seq Scan on rlp3_default rlp',), ("  Filter: (((b)::text < 'ab'::text) AND (a = 16))",)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 16 and b <= 'ab';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp3abcd rlp_1',), ("        Filter: (((b)::text <= 'ab'::text) AND (a = 16))",), ('  ->  Seq Scan on rlp3_default rlp_2',), ("        Filter: (((b)::text <= 'ab'::text) AND (a = 16))",)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 16 and b is null;
RESULT:
	postgres: [('Seq Scan on rlp3nullxy rlp',), ('  Filter: ((b IS NULL) AND (a = 16))',)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 16 and b is not null;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp3abcd rlp_1',), ('        Filter: ((b IS NOT NULL) AND (a = 16))',), ('  ->  Seq Scan on rlp3efgh rlp_2',), ('        Filter: ((b IS NOT NULL) AND (a = 16))',), ('  ->  Seq Scan on rlp3nullxy rlp_3',), ('        Filter: ((b IS NOT NULL) AND (a = 16))',), ('  ->  Seq Scan on rlp3_default rlp_4',), ('        Filter: ((b IS NOT NULL) AND (a = 16))',)]

-----------
QUERY:

explain (costs off) select * from rlp where a is null;
RESULT:
	postgres: [('Seq Scan on rlp_default_null rlp',), ('  Filter: (a IS NULL)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a is not null;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp1 rlp_1',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp2 rlp_2',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp3abcd rlp_3',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp3efgh rlp_4',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp3nullxy rlp_5',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp3_default rlp_6',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp4_1 rlp_7',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp4_2 rlp_8',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp4_default rlp_9',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp5_1 rlp_10',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp5_default rlp_11',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp_default_10 rlp_12',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp_default_30 rlp_13',), ('        Filter: (a IS NOT NULL)',), ('  ->  Seq Scan on rlp_default_default rlp_14',), ('        Filter: (a IS NOT NULL)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a > 30;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp5_1 rlp_1',), ('        Filter: (a > 30)',), ('  ->  Seq Scan on rlp5_default rlp_2',), ('        Filter: (a > 30)',), ('  ->  Seq Scan on rlp_default_default rlp_3',), ('        Filter: (a > 30)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 30;
RESULT:
	postgres: [('Seq Scan on rlp_default_30 rlp',), ('  Filter: (a = 30)',)]

-----------
QUERY:
	/* only default is scanned */
explain (costs off) select * from rlp where a <= 31;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp1 rlp_1',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp2 rlp_2',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp3abcd rlp_3',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp3efgh rlp_4',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp3nullxy rlp_5',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp3_default rlp_6',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp4_1 rlp_7',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp4_2 rlp_8',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp4_default rlp_9',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp5_1 rlp_10',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp_default_10 rlp_11',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp_default_30 rlp_12',), ('        Filter: (a <= 31)',), ('  ->  Seq Scan on rlp_default_default rlp_13',), ('        Filter: (a <= 31)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 1 or a = 7;
RESULT:
	postgres: [('Seq Scan on rlp2 rlp',), ('  Filter: ((a = 1) OR (a = 7))',)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 1 or b = 'ab';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp1 rlp_1',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp2 rlp_2',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp3abcd rlp_3',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp4_1 rlp_4',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp4_2 rlp_5',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp4_default rlp_6',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp5_1 rlp_7',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp5_default rlp_8',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp_default_10 rlp_9',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp_default_30 rlp_10',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp_default_null rlp_11',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",), ('  ->  Seq Scan on rlp_default_default rlp_12',), ("        Filter: ((a = 1) OR ((b)::text = 'ab'::text))",)]

-----------
QUERY:


explain (costs off) select * from rlp where a > 20 and a < 27;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp4_1 rlp_1',), ('        Filter: ((a > 20) AND (a < 27))',), ('  ->  Seq Scan on rlp4_2 rlp_2',), ('        Filter: ((a > 20) AND (a < 27))',)]

-----------
QUERY:

explain (costs off) select * from rlp where a = 29;
RESULT:
	postgres: [('Seq Scan on rlp4_default rlp',), ('  Filter: (a = 29)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a >= 29;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp4_default rlp_1',), ('        Filter: (a >= 29)',), ('  ->  Seq Scan on rlp5_1 rlp_2',), ('        Filter: (a >= 29)',), ('  ->  Seq Scan on rlp5_default rlp_3',), ('        Filter: (a >= 29)',), ('  ->  Seq Scan on rlp_default_30 rlp_4',), ('        Filter: (a >= 29)',), ('  ->  Seq Scan on rlp_default_default rlp_5',), ('        Filter: (a >= 29)',)]

-----------
QUERY:

explain (costs off) select * from rlp where a < 1 or (a > 20 and a < 25);
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp1 rlp_1',), ('        Filter: ((a < 1) OR ((a > 20) AND (a < 25)))',), ('  ->  Seq Scan on rlp4_1 rlp_2',), ('        Filter: ((a < 1) OR ((a > 20) AND (a < 25)))',)]

-----------
QUERY:


-- where clause contradicts sub-partition/* REPLACED */''s constraint
explain (costs off) select * from rlp where a = 20 or a = 40;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp4_1 rlp_1',), ('        Filter: ((a = 20) OR (a = 40))',), ('  ->  Seq Scan on rlp5_default rlp_2',), ('        Filter: ((a = 20) OR (a = 40))',)]

-----------
QUERY:

explain (costs off) select * from rlp3 where a = 20;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:
   /* empty */

-- redundant clauses are eliminated
explain (costs off) select * from rlp where a > 1 and a = 10;
RESULT:
	postgres: [('Seq Scan on rlp_default_10 rlp',), ('  Filter: ((a > 1) AND (a = 10))',)]

-----------
QUERY:
	/* only default */
explain (costs off) select * from rlp where a > 1 and a >=15;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp3abcd rlp_1',), ('        Filter: ((a > 1) AND (a >= 15))',), ('  ->  Seq Scan on rlp3efgh rlp_2',), ('        Filter: ((a > 1) AND (a >= 15))',), ('  ->  Seq Scan on rlp3nullxy rlp_3',), ('        Filter: ((a > 1) AND (a >= 15))',), ('  ->  Seq Scan on rlp3_default rlp_4',), ('        Filter: ((a > 1) AND (a >= 15))',), ('  ->  Seq Scan on rlp4_1 rlp_5',), ('        Filter: ((a > 1) AND (a >= 15))',), ('  ->  Seq Scan on rlp4_2 rlp_6',), ('        Filter: ((a > 1) AND (a >= 15))',), ('  ->  Seq Scan on rlp4_default rlp_7',), ('        Filter: ((a > 1) AND (a >= 15))',), ('  ->  Seq Scan on rlp5_1 rlp_8',), ('        Filter: ((a > 1) AND (a >= 15))',), ('  ->  Seq Scan on rlp5_default rlp_9',), ('        Filter: ((a > 1) AND (a >= 15))',), ('  ->  Seq Scan on rlp_default_30 rlp_10',), ('        Filter: ((a > 1) AND (a >= 15))',), ('  ->  Seq Scan on rlp_default_default rlp_11',), ('        Filter: ((a > 1) AND (a >= 15))',)]

-----------
QUERY:
	/* rlp3 onwards, including default */
explain (costs off) select * from rlp where a = 1 and a = 3;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:
	/* empty */
explain (costs off) select * from rlp where (a = 1 and a = 3) or (a > 1 and a = 15);
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp2 rlp_1',), ('        Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))',), ('  ->  Seq Scan on rlp3abcd rlp_2',), ('        Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))',), ('  ->  Seq Scan on rlp3efgh rlp_3',), ('        Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))',), ('  ->  Seq Scan on rlp3nullxy rlp_4',), ('        Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))',), ('  ->  Seq Scan on rlp3_default rlp_5',), ('        Filter: (((a = 1) AND (a = 3)) OR ((a > 1) AND (a = 15)))',)]

-----------
QUERY:


-- multi-column keys
create table mc3p (a int, b int, c int) partition by range (a, abs(b), c);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p_default partition of mc3p default;
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p0 partition of mc3p for values from (minvalue, minvalue, minvalue) to (1, 1, 1);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p1 partition of mc3p for values from (1, 1, 1) to (10, 5, 10);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p2 partition of mc3p for values from (10, 5, 10) to (10, 10, 10);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p3 partition of mc3p for values from (10, 10, 10) to (10, 10, 20);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p4 partition of mc3p for values from (10, 10, 20) to (10, maxvalue, maxvalue);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p5 partition of mc3p for values from (11, 1, 1) to (20, 10, 10);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p6 partition of mc3p for values from (20, 10, 10) to (20, 20, 20);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p7 partition of mc3p for values from (20, 20, 20) to (maxvalue, maxvalue, maxvalue);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from mc3p where a = 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: (a = 1)',), ('  ->  Seq Scan on mc3p1 mc3p_2',), ('        Filter: (a = 1)',), ('  ->  Seq Scan on mc3p_default mc3p_3',), ('        Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a = 1 and abs(b) < 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: ((a = 1) AND (abs(b) < 1))',), ('  ->  Seq Scan on mc3p_default mc3p_2',), ('        Filter: ((a = 1) AND (abs(b) < 1))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a = 1 and abs(b) = 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: ((a = 1) AND (abs(b) = 1))',), ('  ->  Seq Scan on mc3p1 mc3p_2',), ('        Filter: ((a = 1) AND (abs(b) = 1))',), ('  ->  Seq Scan on mc3p_default mc3p_3',), ('        Filter: ((a = 1) AND (abs(b) = 1))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a = 1 and abs(b) = 1 and c < 8;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: ((c < 8) AND (a = 1) AND (abs(b) = 1))',), ('  ->  Seq Scan on mc3p1 mc3p_2',), ('        Filter: ((c < 8) AND (a = 1) AND (abs(b) = 1))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a = 10 and abs(b) between 5 and 35;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p1 mc3p_1',), ('        Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))',), ('  ->  Seq Scan on mc3p2 mc3p_2',), ('        Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))',), ('  ->  Seq Scan on mc3p3 mc3p_3',), ('        Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))',), ('  ->  Seq Scan on mc3p4 mc3p_4',), ('        Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))',), ('  ->  Seq Scan on mc3p_default mc3p_5',), ('        Filter: ((a = 10) AND (abs(b) >= 5) AND (abs(b) <= 35))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a > 10;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p5 mc3p_1',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on mc3p6 mc3p_2',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on mc3p7 mc3p_3',), ('        Filter: (a > 10)',), ('  ->  Seq Scan on mc3p_default mc3p_4',), ('        Filter: (a > 10)',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a >= 10;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p1 mc3p_1',), ('        Filter: (a >= 10)',), ('  ->  Seq Scan on mc3p2 mc3p_2',), ('        Filter: (a >= 10)',), ('  ->  Seq Scan on mc3p3 mc3p_3',), ('        Filter: (a >= 10)',), ('  ->  Seq Scan on mc3p4 mc3p_4',), ('        Filter: (a >= 10)',), ('  ->  Seq Scan on mc3p5 mc3p_5',), ('        Filter: (a >= 10)',), ('  ->  Seq Scan on mc3p6 mc3p_6',), ('        Filter: (a >= 10)',), ('  ->  Seq Scan on mc3p7 mc3p_7',), ('        Filter: (a >= 10)',), ('  ->  Seq Scan on mc3p_default mc3p_8',), ('        Filter: (a >= 10)',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a < 10;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: (a < 10)',), ('  ->  Seq Scan on mc3p1 mc3p_2',), ('        Filter: (a < 10)',), ('  ->  Seq Scan on mc3p_default mc3p_3',), ('        Filter: (a < 10)',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a <= 10 and abs(b) < 10;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: ((a <= 10) AND (abs(b) < 10))',), ('  ->  Seq Scan on mc3p1 mc3p_2',), ('        Filter: ((a <= 10) AND (abs(b) < 10))',), ('  ->  Seq Scan on mc3p2 mc3p_3',), ('        Filter: ((a <= 10) AND (abs(b) < 10))',), ('  ->  Seq Scan on mc3p_default mc3p_4',), ('        Filter: ((a <= 10) AND (abs(b) < 10))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a = 11 and abs(b) = 0;
RESULT:
	postgres: [('Seq Scan on mc3p_default mc3p',), ('  Filter: ((a = 11) AND (abs(b) = 0))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a = 20 and abs(b) = 10 and c = 100;
RESULT:
	postgres: [('Seq Scan on mc3p6 mc3p',), ('  Filter: ((a = 20) AND (c = 100) AND (abs(b) = 10))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a > 20;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p7 mc3p_1',), ('        Filter: (a > 20)',), ('  ->  Seq Scan on mc3p_default mc3p_2',), ('        Filter: (a > 20)',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a >= 20;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p5 mc3p_1',), ('        Filter: (a >= 20)',), ('  ->  Seq Scan on mc3p6 mc3p_2',), ('        Filter: (a >= 20)',), ('  ->  Seq Scan on mc3p7 mc3p_3',), ('        Filter: (a >= 20)',), ('  ->  Seq Scan on mc3p_default mc3p_4',), ('        Filter: (a >= 20)',)]

-----------
QUERY:

explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20);
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p1 mc3p_1',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))',), ('  ->  Seq Scan on mc3p2 mc3p_2',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))',), ('  ->  Seq Scan on mc3p5 mc3p_3',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))',), ('  ->  Seq Scan on mc3p_default mc3p_4',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20) or a < 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))',), ('  ->  Seq Scan on mc3p1 mc3p_2',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))',), ('  ->  Seq Scan on mc3p2 mc3p_3',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))',), ('  ->  Seq Scan on mc3p5 mc3p_4',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))',), ('  ->  Seq Scan on mc3p_default mc3p_5',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1 and c = 1) or (a = 10 and abs(b) = 5 and c = 10) or (a > 11 and a < 20) or a < 1 or a = 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))',), ('  ->  Seq Scan on mc3p1 mc3p_2',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))',), ('  ->  Seq Scan on mc3p2 mc3p_3',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))',), ('  ->  Seq Scan on mc3p5 mc3p_4',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))',), ('  ->  Seq Scan on mc3p_default mc3p_5',), ('        Filter: (((a = 1) AND (abs(b) = 1) AND (c = 1)) OR ((a = 10) AND (abs(b) = 5) AND (c = 10)) OR ((a > 11) AND (a < 20)) OR (a < 1) OR (a = 1))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where a = 1 or abs(b) = 1 or c = 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))',), ('  ->  Seq Scan on mc3p1 mc3p_2',), ('        Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))',), ('  ->  Seq Scan on mc3p2 mc3p_3',), ('        Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))',), ('  ->  Seq Scan on mc3p3 mc3p_4',), ('        Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))',), ('  ->  Seq Scan on mc3p4 mc3p_5',), ('        Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))',), ('  ->  Seq Scan on mc3p5 mc3p_6',), ('        Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))',), ('  ->  Seq Scan on mc3p6 mc3p_7',), ('        Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))',), ('  ->  Seq Scan on mc3p7 mc3p_8',), ('        Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))',), ('  ->  Seq Scan on mc3p_default mc3p_9',), ('        Filter: ((a = 1) OR (abs(b) = 1) OR (c = 1))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 and abs(b) = 10);
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))',), ('  ->  Seq Scan on mc3p1 mc3p_2',), ('        Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))',), ('  ->  Seq Scan on mc3p2 mc3p_3',), ('        Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))',), ('  ->  Seq Scan on mc3p3 mc3p_4',), ('        Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))',), ('  ->  Seq Scan on mc3p4 mc3p_5',), ('        Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))',), ('  ->  Seq Scan on mc3p_default mc3p_6',), ('        Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 10)))',)]

-----------
QUERY:

explain (costs off) select * from mc3p where (a = 1 and abs(b) = 1) or (a = 10 and abs(b) = 9);
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc3p0 mc3p_1',), ('        Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))',), ('  ->  Seq Scan on mc3p1 mc3p_2',), ('        Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))',), ('  ->  Seq Scan on mc3p2 mc3p_3',), ('        Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))',), ('  ->  Seq Scan on mc3p_default mc3p_4',), ('        Filter: (((a = 1) AND (abs(b) = 1)) OR ((a = 10) AND (abs(b) = 9)))',)]

-----------
QUERY:


-- a simpler multi-column keys case
create table mc2p (a int, b int) partition by range (a, b);
RESULT:
	postgres: None

-----------
QUERY:

create table mc2p_default partition of mc2p default;
RESULT:
	postgres: None

-----------
QUERY:

create table mc2p0 partition of mc2p for values from (minvalue, minvalue) to (1, minvalue);
RESULT:
	postgres: None

-----------
QUERY:

create table mc2p1 partition of mc2p for values from (1, minvalue) to (1, 1);
RESULT:
	postgres: None

-----------
QUERY:

create table mc2p2 partition of mc2p for values from (1, 1) to (2, minvalue);
RESULT:
	postgres: None

-----------
QUERY:

create table mc2p3 partition of mc2p for values from (2, minvalue) to (2, 1);
RESULT:
	postgres: None

-----------
QUERY:

create table mc2p4 partition of mc2p for values from (2, 1) to (2, maxvalue);
RESULT:
	postgres: None

-----------
QUERY:

create table mc2p5 partition of mc2p for values from (2, maxvalue) to (maxvalue, maxvalue);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from mc2p where a < 2;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc2p0 mc2p_1',), ('        Filter: (a < 2)',), ('  ->  Seq Scan on mc2p1 mc2p_2',), ('        Filter: (a < 2)',), ('  ->  Seq Scan on mc2p2 mc2p_3',), ('        Filter: (a < 2)',), ('  ->  Seq Scan on mc2p_default mc2p_4',), ('        Filter: (a < 2)',)]

-----------
QUERY:

explain (costs off) select * from mc2p where a = 2 and b < 1;
RESULT:
	postgres: [('Seq Scan on mc2p3 mc2p',), ('  Filter: ((b < 1) AND (a = 2))',)]

-----------
QUERY:

explain (costs off) select * from mc2p where a > 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on mc2p2 mc2p_1',), ('        Filter: (a > 1)',), ('  ->  Seq Scan on mc2p3 mc2p_2',), ('        Filter: (a > 1)',), ('  ->  Seq Scan on mc2p4 mc2p_3',), ('        Filter: (a > 1)',), ('  ->  Seq Scan on mc2p5 mc2p_4',), ('        Filter: (a > 1)',), ('  ->  Seq Scan on mc2p_default mc2p_5',), ('        Filter: (a > 1)',)]

-----------
QUERY:

explain (costs off) select * from mc2p where a = 1 and b > 1;
RESULT:
	postgres: [('Seq Scan on mc2p2 mc2p',), ('  Filter: ((b > 1) AND (a = 1))',)]

-----------
QUERY:


-- all partitions but the default one should be pruned
explain (costs off) select * from mc2p where a = 1 and b is null;
RESULT:
	postgres: [('Seq Scan on mc2p_default mc2p',), ('  Filter: ((b IS NULL) AND (a = 1))',)]

-----------
QUERY:

explain (costs off) select * from mc2p where a is null and b is null;
RESULT:
	postgres: [('Seq Scan on mc2p_default mc2p',), ('  Filter: ((a IS NULL) AND (b IS NULL))',)]

-----------
QUERY:

explain (costs off) select * from mc2p where a is null and b = 1;
RESULT:
	postgres: [('Seq Scan on mc2p_default mc2p',), ('  Filter: ((a IS NULL) AND (b = 1))',)]

-----------
QUERY:

explain (costs off) select * from mc2p where a is null;
RESULT:
	postgres: [('Seq Scan on mc2p_default mc2p',), ('  Filter: (a IS NULL)',)]

-----------
QUERY:

explain (costs off) select * from mc2p where b is null;
RESULT:
	postgres: [('Seq Scan on mc2p_default mc2p',), ('  Filter: (b IS NULL)',)]

-----------
QUERY:


-- boolean partitioning
create table boolpart (a bool) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table boolpart_default partition of boolpart default;
RESULT:
	postgres: None

-----------
QUERY:

create table boolpart_t partition of boolpart for values in ('true');
RESULT:
	postgres: None

-----------
QUERY:

create table boolpart_f partition of boolpart for values in ('false');
RESULT:
	postgres: None

-----------
QUERY:

insert into boolpart values (true), (false), (null);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from boolpart where a in (true, false);
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on boolpart_f boolpart_1',), ("        Filter: (a = ANY ('{t,f}'::boolean[]))",), ('  ->  Seq Scan on boolpart_t boolpart_2',), ("        Filter: (a = ANY ('{t,f}'::boolean[]))",)]

-----------
QUERY:

explain (costs off) select * from boolpart where a = false;
RESULT:
	postgres: [('Seq Scan on boolpart_f boolpart',), ('  Filter: (NOT a)',)]

-----------
QUERY:

explain (costs off) select * from boolpart where not a = false;
RESULT:
	postgres: [('Seq Scan on boolpart_t boolpart',), ('  Filter: a',)]

-----------
QUERY:

explain (costs off) select * from boolpart where a is true or a is not true;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on boolpart_f boolpart_1',), ('        Filter: ((a IS TRUE) OR (a IS NOT TRUE))',), ('  ->  Seq Scan on boolpart_t boolpart_2',), ('        Filter: ((a IS TRUE) OR (a IS NOT TRUE))',), ('  ->  Seq Scan on boolpart_default boolpart_3',), ('        Filter: ((a IS TRUE) OR (a IS NOT TRUE))',)]

-----------
QUERY:

explain (costs off) select * from boolpart where a is not true;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on boolpart_f boolpart_1',), ('        Filter: (a IS NOT TRUE)',), ('  ->  Seq Scan on boolpart_default boolpart_2',), ('        Filter: (a IS NOT TRUE)',)]

-----------
QUERY:

explain (costs off) select * from boolpart where a is not true and a is not false;
RESULT:
	postgres: [('Seq Scan on boolpart_default boolpart',), ('  Filter: ((a IS NOT TRUE) AND (a IS NOT FALSE))',)]

-----------
QUERY:

explain (costs off) select * from boolpart where a is unknown;
RESULT:
	postgres: [('Seq Scan on boolpart_default boolpart',), ('  Filter: (a IS UNKNOWN)',)]

-----------
QUERY:

explain (costs off) select * from boolpart where a is not unknown;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on boolpart_f boolpart_1',), ('        Filter: (a IS NOT UNKNOWN)',), ('  ->  Seq Scan on boolpart_t boolpart_2',), ('        Filter: (a IS NOT UNKNOWN)',), ('  ->  Seq Scan on boolpart_default boolpart_3',), ('        Filter: (a IS NOT UNKNOWN)',)]

-----------
QUERY:


select * from boolpart where a in (true, false);
RESULT:
	postgres: [(False,), (True,)]

-----------
QUERY:

select * from boolpart where a = false;
RESULT:
	postgres: [(False,)]

-----------
QUERY:

select * from boolpart where not a = false;
RESULT:
	postgres: [(True,)]

-----------
QUERY:

select * from boolpart where a is true or a is not true;
RESULT:
	postgres: [(False,), (True,), (None,)]

-----------
QUERY:

select * from boolpart where a is not true;
RESULT:
	postgres: [(False,), (None,)]

-----------
QUERY:

select * from boolpart where a is not true and a is not false;
RESULT:
	postgres: [(None,)]

-----------
QUERY:

select * from boolpart where a is unknown;
RESULT:
	postgres: [(None,)]

-----------
QUERY:

select * from boolpart where a is not unknown;
RESULT:
	postgres: [(False,), (True,)]

-----------
QUERY:


-- try some other permutations with a NULL partition instead of a DEFAULT
delete from boolpart where a is null;
RESULT:
	postgres: None

-----------
QUERY:

create table boolpart_null partition of boolpart for values in (null);
RESULT:
	postgres: None

-----------
QUERY:

insert into boolpart values(null);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from boolpart where a is not true;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on boolpart_f boolpart_1',), ('        Filter: (a IS NOT TRUE)',), ('  ->  Seq Scan on boolpart_null boolpart_2',), ('        Filter: (a IS NOT TRUE)',)]

-----------
QUERY:

explain (costs off) select * from boolpart where a is not true and a is not false;
RESULT:
	postgres: [('Seq Scan on boolpart_null boolpart',), ('  Filter: ((a IS NOT TRUE) AND (a IS NOT FALSE))',)]

-----------
QUERY:

explain (costs off) select * from boolpart where a is not false;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on boolpart_t boolpart_1',), ('        Filter: (a IS NOT FALSE)',), ('  ->  Seq Scan on boolpart_null boolpart_2',), ('        Filter: (a IS NOT FALSE)',)]

-----------
QUERY:

explain (costs off) select * from boolpart where a is not unknown;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on boolpart_f boolpart_1',), ('        Filter: (a IS NOT UNKNOWN)',), ('  ->  Seq Scan on boolpart_t boolpart_2',), ('        Filter: (a IS NOT UNKNOWN)',), ('  ->  Seq Scan on boolpart_default boolpart_3',), ('        Filter: (a IS NOT UNKNOWN)',)]

-----------
QUERY:


select * from boolpart where a is not true;
RESULT:
	postgres: [(False,), (None,)]

-----------
QUERY:

select * from boolpart where a is not true and a is not false;
RESULT:
	postgres: [(None,)]

-----------
QUERY:

select * from boolpart where a is not false;
RESULT:
	postgres: [(True,), (None,)]

-----------
QUERY:

select * from boolpart where a is not unknown;
RESULT:
	postgres: [(False,), (True,)]

-----------
QUERY:


-- check that all partitions are pruned when faced with conflicting clauses
explain (costs off) select * from boolpart where a is not unknown and a is unknown;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

explain (costs off) select * from boolpart where a is false and a is unknown;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

explain (costs off) select * from boolpart where a is true and a is unknown;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


-- inverse boolean partitioning - a seemingly unlikely design, but we/* REPLACED */''ve got
-- code for it, so we/* REPLACED */''d better test it.
create table iboolpart (a bool) partition by list ((not a));
RESULT:
	postgres: None

-----------
QUERY:

create table iboolpart_default partition of iboolpart default;
RESULT:
	postgres: None

-----------
QUERY:

create table iboolpart_f partition of iboolpart for values in ('true');
RESULT:
	postgres: None

-----------
QUERY:

create table iboolpart_t partition of iboolpart for values in ('false');
RESULT:
	postgres: None

-----------
QUERY:

insert into iboolpart values (true), (false), (null);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from iboolpart where a in (true, false);
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on iboolpart_t iboolpart_1',), ("        Filter: (a = ANY ('{t,f}'::boolean[]))",), ('  ->  Seq Scan on iboolpart_f iboolpart_2',), ("        Filter: (a = ANY ('{t,f}'::boolean[]))",), ('  ->  Seq Scan on iboolpart_default iboolpart_3',), ("        Filter: (a = ANY ('{t,f}'::boolean[]))",)]

-----------
QUERY:

explain (costs off) select * from iboolpart where a = false;
RESULT:
	postgres: [('Seq Scan on iboolpart_f iboolpart',), ('  Filter: (NOT a)',)]

-----------
QUERY:

explain (costs off) select * from iboolpart where not a = false;
RESULT:
	postgres: [('Seq Scan on iboolpart_t iboolpart',), ('  Filter: a',)]

-----------
QUERY:

explain (costs off) select * from iboolpart where a is true or a is not true;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on iboolpart_t iboolpart_1',), ('        Filter: ((a IS TRUE) OR (a IS NOT TRUE))',), ('  ->  Seq Scan on iboolpart_f iboolpart_2',), ('        Filter: ((a IS TRUE) OR (a IS NOT TRUE))',), ('  ->  Seq Scan on iboolpart_default iboolpart_3',), ('        Filter: ((a IS TRUE) OR (a IS NOT TRUE))',)]

-----------
QUERY:

explain (costs off) select * from iboolpart where a is not true;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on iboolpart_t iboolpart_1',), ('        Filter: (a IS NOT TRUE)',), ('  ->  Seq Scan on iboolpart_f iboolpart_2',), ('        Filter: (a IS NOT TRUE)',), ('  ->  Seq Scan on iboolpart_default iboolpart_3',), ('        Filter: (a IS NOT TRUE)',)]

-----------
QUERY:

explain (costs off) select * from iboolpart where a is not true and a is not false;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on iboolpart_t iboolpart_1',), ('        Filter: ((a IS NOT TRUE) AND (a IS NOT FALSE))',), ('  ->  Seq Scan on iboolpart_f iboolpart_2',), ('        Filter: ((a IS NOT TRUE) AND (a IS NOT FALSE))',), ('  ->  Seq Scan on iboolpart_default iboolpart_3',), ('        Filter: ((a IS NOT TRUE) AND (a IS NOT FALSE))',)]

-----------
QUERY:

explain (costs off) select * from iboolpart where a is unknown;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on iboolpart_t iboolpart_1',), ('        Filter: (a IS UNKNOWN)',), ('  ->  Seq Scan on iboolpart_f iboolpart_2',), ('        Filter: (a IS UNKNOWN)',), ('  ->  Seq Scan on iboolpart_default iboolpart_3',), ('        Filter: (a IS UNKNOWN)',)]

-----------
QUERY:

explain (costs off) select * from iboolpart where a is not unknown;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on iboolpart_t iboolpart_1',), ('        Filter: (a IS NOT UNKNOWN)',), ('  ->  Seq Scan on iboolpart_f iboolpart_2',), ('        Filter: (a IS NOT UNKNOWN)',), ('  ->  Seq Scan on iboolpart_default iboolpart_3',), ('        Filter: (a IS NOT UNKNOWN)',)]

-----------
QUERY:


select * from iboolpart where a in (true, false);
RESULT:
	postgres: [(True,), (False,)]

-----------
QUERY:

select * from iboolpart where a = false;
RESULT:
	postgres: [(False,)]

-----------
QUERY:

select * from iboolpart where not a = false;
RESULT:
	postgres: [(True,)]

-----------
QUERY:

select * from iboolpart where a is true or a is not true;
RESULT:
	postgres: [(True,), (False,), (None,)]

-----------
QUERY:

select * from iboolpart where a is not true;
RESULT:
	postgres: [(False,), (None,)]

-----------
QUERY:

select * from iboolpart where a is not true and a is not false;
RESULT:
	postgres: [(None,)]

-----------
QUERY:

select * from iboolpart where a is unknown;
RESULT:
	postgres: [(None,)]

-----------
QUERY:

select * from iboolpart where a is not unknown;
RESULT:
	postgres: [(True,), (False,)]

-----------
QUERY:


-- Try some other permutations with a NULL partition instead of a DEFAULT
delete from iboolpart where a is null;
RESULT:
	postgres: None

-----------
QUERY:

create table iboolpart_null partition of iboolpart for values in (null);
RESULT:
	postgres: None

-----------
QUERY:

insert into iboolpart values(null);
RESULT:
	postgres: None

-----------
QUERY:


-- Pruning shouldn/* REPLACED */''t take place for these.  Just check the result is correct
select * from iboolpart where a is not true;
RESULT:
	postgres: [(False,), (None,)]

-----------
QUERY:

select * from iboolpart where a is not true and a is not false;
RESULT:
	postgres: [(None,)]

-----------
QUERY:

select * from iboolpart where a is not false;
RESULT:
	postgres: [(True,), (None,)]

-----------
QUERY:


create table boolrangep (a bool, b bool, c int) partition by range (a,b,c);
RESULT:
	postgres: None

-----------
QUERY:

create table boolrangep_tf partition of boolrangep for values from ('true', 'false', 0) to ('true', 'false', 100);
RESULT:
	postgres: None

-----------
QUERY:

create table boolrangep_ft partition of boolrangep for values from ('false', 'true', 0) to ('false', 'true', 100);
RESULT:
	postgres: None

-----------
QUERY:

create table boolrangep_ff1 partition of boolrangep for values from ('false', 'false', 0) to ('false', 'false', 50);
RESULT:
	postgres: None

-----------
QUERY:

create table boolrangep_ff2 partition of boolrangep for values from ('false', 'false', 50) to ('false', 'false', 100);
RESULT:
	postgres: None

-----------
QUERY:

create table boolrangep_null partition of boolrangep default;
RESULT:
	postgres: None

-----------
QUERY:


-- try a more complex case that/* REPLACED */''s been known to trip up pruning in the past
explain (costs off)  select * from boolrangep where not a and not b and c = 25;
RESULT:
	postgres: [('Seq Scan on boolrangep_ff1 boolrangep',), ('  Filter: ((NOT a) AND (NOT b) AND (c = 25))',)]

-----------
QUERY:


-- ensure we prune boolrangep_tf
explain (costs off)  select * from boolrangep where a is not true and not b and c = 25;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on boolrangep_ff1 boolrangep_1',), ('        Filter: ((a IS NOT TRUE) AND (NOT b) AND (c = 25))',), ('  ->  Seq Scan on boolrangep_ff2 boolrangep_2',), ('        Filter: ((a IS NOT TRUE) AND (NOT b) AND (c = 25))',), ('  ->  Seq Scan on boolrangep_ft boolrangep_3',), ('        Filter: ((a IS NOT TRUE) AND (NOT b) AND (c = 25))',), ('  ->  Seq Scan on boolrangep_null boolrangep_4',), ('        Filter: ((a IS NOT TRUE) AND (NOT b) AND (c = 25))',)]

-----------
QUERY:


-- ensure we prune everything apart from boolrangep_tf and boolrangep_null
explain (costs off)  select * from boolrangep where a is not false and not b and c = 25;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on boolrangep_tf boolrangep_1',), ('        Filter: ((a IS NOT FALSE) AND (NOT b) AND (c = 25))',), ('  ->  Seq Scan on boolrangep_null boolrangep_2',), ('        Filter: ((a IS NOT FALSE) AND (NOT b) AND (c = 25))',)]

-----------
QUERY:


-- test scalar-to-array operators
create table coercepart (a varchar) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table coercepart_ab partition of coercepart for values in ('ab');
RESULT:
	postgres: None

-----------
QUERY:

create table coercepart_bc partition of coercepart for values in ('bc');
RESULT:
	postgres: None

-----------
QUERY:

create table coercepart_cd partition of coercepart for values in ('cd');
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from coercepart where a in ('ab', to_char(125, '999'));
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on coercepart_ab coercepart_1',), ("        Filter: ((a)::text = ANY ((ARRAY['ab'::character varying, (to_char(125, '999'::text))::character varying])::text[]))",), ('  ->  Seq Scan on coercepart_bc coercepart_2',), ("        Filter: ((a)::text = ANY ((ARRAY['ab'::character varying, (to_char(125, '999'::text))::character varying])::text[]))",), ('  ->  Seq Scan on coercepart_cd coercepart_3',), ("        Filter: ((a)::text = ANY ((ARRAY['ab'::character varying, (to_char(125, '999'::text))::character varying])::text[]))",)]

-----------
QUERY:

explain (costs off) select * from coercepart where a ~ any ('{ab}');
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on coercepart_ab coercepart_1',), ("        Filter: ((a)::text ~ ANY ('{ab}'::text[]))",), ('  ->  Seq Scan on coercepart_bc coercepart_2',), ("        Filter: ((a)::text ~ ANY ('{ab}'::text[]))",), ('  ->  Seq Scan on coercepart_cd coercepart_3',), ("        Filter: ((a)::text ~ ANY ('{ab}'::text[]))",)]

-----------
QUERY:

explain (costs off) select * from coercepart where a !~ all ('{ab}');
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on coercepart_ab coercepart_1',), ("        Filter: ((a)::text !~ ALL ('{ab}'::text[]))",), ('  ->  Seq Scan on coercepart_bc coercepart_2',), ("        Filter: ((a)::text !~ ALL ('{ab}'::text[]))",), ('  ->  Seq Scan on coercepart_cd coercepart_3',), ("        Filter: ((a)::text !~ ALL ('{ab}'::text[]))",)]

-----------
QUERY:

explain (costs off) select * from coercepart where a ~ any ('{ab,bc}');
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on coercepart_ab coercepart_1',), ("        Filter: ((a)::text ~ ANY ('{ab,bc}'::text[]))",), ('  ->  Seq Scan on coercepart_bc coercepart_2',), ("        Filter: ((a)::text ~ ANY ('{ab,bc}'::text[]))",), ('  ->  Seq Scan on coercepart_cd coercepart_3',), ("        Filter: ((a)::text ~ ANY ('{ab,bc}'::text[]))",)]

-----------
QUERY:

explain (costs off) select * from coercepart where a !~ all ('{ab,bc}');
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on coercepart_ab coercepart_1',), ("        Filter: ((a)::text !~ ALL ('{ab,bc}'::text[]))",), ('  ->  Seq Scan on coercepart_bc coercepart_2',), ("        Filter: ((a)::text !~ ALL ('{ab,bc}'::text[]))",), ('  ->  Seq Scan on coercepart_cd coercepart_3',), ("        Filter: ((a)::text !~ ALL ('{ab,bc}'::text[]))",)]

-----------
QUERY:

explain (costs off) select * from coercepart where a = any ('{ab,bc}');
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on coercepart_ab coercepart_1',), ("        Filter: ((a)::text = ANY ('{ab,bc}'::text[]))",), ('  ->  Seq Scan on coercepart_bc coercepart_2',), ("        Filter: ((a)::text = ANY ('{ab,bc}'::text[]))",)]

-----------
QUERY:

explain (costs off) select * from coercepart where a = any ('{ab,null}');
RESULT:
	postgres: [('Seq Scan on coercepart_ab coercepart',), ("  Filter: ((a)::text = ANY ('{ab,NULL}'::text[]))",)]

-----------
QUERY:

explain (costs off) select * from coercepart where a = any (null::text[]);
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

explain (costs off) select * from coercepart where a = all ('{ab}');
RESULT:
	postgres: [('Seq Scan on coercepart_ab coercepart',), ("  Filter: ((a)::text = ALL ('{ab}'::text[]))",)]

-----------
QUERY:

explain (costs off) select * from coercepart where a = all ('{ab,bc}');
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

explain (costs off) select * from coercepart where a = all ('{ab,null}');
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

explain (costs off) select * from coercepart where a = all (null::text[]);
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


drop table coercepart;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE part (a INT, b INT) PARTITION BY LIST (a);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE part_p1 PARTITION OF part FOR VALUES IN (-2,-1,0,1,2);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE part_p2 PARTITION OF part DEFAULT PARTITION BY RANGE(a);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE part_p2_p1 PARTITION OF part_p2 DEFAULT;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE part_rev (b INT, c INT, a INT);
RESULT:
	postgres: None

-----------
QUERY:

ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);
RESULT:
	postgres: table "part_rev" contains column "c" not found in parent "part"
DETAIL:  The new partition may contain only the columns present in parent.


-----------
QUERY:
  -- fail
ALTER TABLE part_rev DROP COLUMN c;
RESULT:
	postgres: None

-----------
QUERY:

ALTER TABLE part ATTACH PARTITION part_rev FOR VALUES IN (3);
RESULT:
	postgres: None

-----------
QUERY:
  -- now it/* REPLACED */''s ok
INSERT INTO part VALUES (-1,-1), (1,1), (2,NULL), (NULL,-2),(NULL,NULL);
RESULT:
	postgres: None

-----------
QUERY:

EXPLAIN (COSTS OFF) SELECT tableoid::regclass as part, a, b FROM part WHERE a IS NULL ORDER BY 1, 2, 3;
RESULT:
	postgres: [('Sort',), ('  Sort Key: ((part.tableoid)::regclass), part.a, part.b',), ('  ->  Seq Scan on part_p2_p1 part',), ('        Filter: (a IS NULL)',)]

-----------
QUERY:

EXPLAIN (VERBOSE, COSTS OFF) SELECT * FROM part p(x) ORDER BY x;
RESULT:
	postgres: [('Sort',), ('  Output: p.x, p.b',), ('  Sort Key: p.x',), ('  ->  Append',), ('        ->  Seq Scan on public.part_p1 p_1',), ('              Output: p_1.x, p_1.b',), ('        ->  Seq Scan on public.part_rev p_2',), ('              Output: p_2.x, p_2.b',), ('        ->  Seq Scan on public.part_p2_p1 p_3',), ('              Output: p_3.x, p_3.b',)]

-----------
QUERY:


--
-- some more cases
--

--
-- pruning for partitioned table appearing inside a sub-query
--
-- pruning won/* REPLACED */''t work for mc3p, because some keys are Params
explain (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.a = t1.b and abs(t2.b) = 1 and t2.c = 1) s where t1.a = 1;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Append',), ('        ->  Seq Scan on mc2p1 t1_1',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on mc2p2 t1_2',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on mc2p_default t1_3',), ('              Filter: (a = 1)',), ('  ->  Aggregate',), ('        ->  Append',), ('              ->  Seq Scan on mc3p0 t2_1',), ('                    Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))',), ('              ->  Seq Scan on mc3p1 t2_2',), ('                    Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))',), ('              ->  Seq Scan on mc3p2 t2_3',), ('                    Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))',), ('              ->  Seq Scan on mc3p3 t2_4',), ('                    Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))',), ('              ->  Seq Scan on mc3p4 t2_5',), ('                    Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))',), ('              ->  Seq Scan on mc3p5 t2_6',), ('                    Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))',), ('              ->  Seq Scan on mc3p6 t2_7',), ('                    Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))',), ('              ->  Seq Scan on mc3p7 t2_8',), ('                    Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))',), ('              ->  Seq Scan on mc3p_default t2_9',), ('                    Filter: ((a = t1.b) AND (c = 1) AND (abs(b) = 1))',)]

-----------
QUERY:


-- pruning should work fine, because values for a prefix of keys (a, b) are
-- available
explain (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.c = t1.b and abs(t2.b) = 1 and t2.a = 1) s where t1.a = 1;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Append',), ('        ->  Seq Scan on mc2p1 t1_1',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on mc2p2 t1_2',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on mc2p_default t1_3',), ('              Filter: (a = 1)',), ('  ->  Aggregate',), ('        ->  Append',), ('              ->  Seq Scan on mc3p0 t2_1',), ('                    Filter: ((c = t1.b) AND (a = 1) AND (abs(b) = 1))',), ('              ->  Seq Scan on mc3p1 t2_2',), ('                    Filter: ((c = t1.b) AND (a = 1) AND (abs(b) = 1))',), ('              ->  Seq Scan on mc3p_default t2_3',), ('                    Filter: ((c = t1.b) AND (a = 1) AND (abs(b) = 1))',)]

-----------
QUERY:


-- also here, because values for all keys are provided
explain (costs off) select * from mc2p t1, lateral (select count(*) from mc3p t2 where t2.a = 1 and abs(t2.b) = 1 and t2.c = 1) s where t1.a = 1;
RESULT:
	postgres: [('Nested Loop',), ('  ->  Aggregate',), ('        ->  Seq Scan on mc3p1 t2',), ('              Filter: ((a = 1) AND (c = 1) AND (abs(b) = 1))',), ('  ->  Append',), ('        ->  Seq Scan on mc2p1 t1_1',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on mc2p2 t1_2',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on mc2p_default t1_3',), ('              Filter: (a = 1)',)]

-----------
QUERY:


--
-- pruning with clauses containing <> operator
--

-- doesn/* REPLACED */''t prune range partitions
create table rp (a int) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table rp0 partition of rp for values from (minvalue) to (1);
RESULT:
	postgres: None

-----------
QUERY:

create table rp1 partition of rp for values from (1) to (2);
RESULT:
	postgres: None

-----------
QUERY:

create table rp2 partition of rp for values from (2) to (maxvalue);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from rp where a <> 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rp0 rp_1',), ('        Filter: (a <> 1)',), ('  ->  Seq Scan on rp1 rp_2',), ('        Filter: (a <> 1)',), ('  ->  Seq Scan on rp2 rp_3',), ('        Filter: (a <> 1)',)]

-----------
QUERY:

explain (costs off) select * from rp where a <> 1 and a <> 2;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rp0 rp_1',), ('        Filter: ((a <> 1) AND (a <> 2))',), ('  ->  Seq Scan on rp1 rp_2',), ('        Filter: ((a <> 1) AND (a <> 2))',), ('  ->  Seq Scan on rp2 rp_3',), ('        Filter: ((a <> 1) AND (a <> 2))',)]

-----------
QUERY:


-- null partition should be eliminated due to strict <> clause.
explain (costs off) select * from lp where a <> 'a';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_ad lp_1',), ("        Filter: (a <> 'a'::bpchar)",), ('  ->  Seq Scan on lp_bc lp_2',), ("        Filter: (a <> 'a'::bpchar)",), ('  ->  Seq Scan on lp_ef lp_3',), ("        Filter: (a <> 'a'::bpchar)",), ('  ->  Seq Scan on lp_g lp_4',), ("        Filter: (a <> 'a'::bpchar)",), ('  ->  Seq Scan on lp_default lp_5',), ("        Filter: (a <> 'a'::bpchar)",)]

-----------
QUERY:


-- ensure we detect contradictions in clauses /* REPLACED */, a can/* REPLACED */''t be NULL and NOT NULL.
explain (costs off) select * from lp where a <> 'a' and a is null;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

explain (costs off) select * from lp where (a <> 'a' and a <> 'd') or a is null;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on lp_bc lp_1',), ("        Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))",), ('  ->  Seq Scan on lp_ef lp_2',), ("        Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))",), ('  ->  Seq Scan on lp_g lp_3',), ("        Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))",), ('  ->  Seq Scan on lp_null lp_4',), ("        Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))",), ('  ->  Seq Scan on lp_default lp_5',), ("        Filter: (((a <> 'a'::bpchar) AND (a <> 'd'::bpchar)) OR (a IS NULL))",)]

-----------
QUERY:


-- check that it also works for a partitioned table that/* REPLACED */''s not root,
-- which in this case are partitions of rlp that are themselves
-- list-partitioned on b
explain (costs off) select * from rlp where a = 15 and b <> 'ab' and b <> 'cd' and b <> 'xy' and b is not null;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on rlp3efgh rlp_1',), ("        Filter: ((b IS NOT NULL) AND ((b)::text <> 'ab'::text) AND ((b)::text <> 'cd'::text) AND ((b)::text <> 'xy'::text) AND (a = 15))",), ('  ->  Seq Scan on rlp3_default rlp_2',), ("        Filter: ((b IS NOT NULL) AND ((b)::text <> 'ab'::text) AND ((b)::text <> 'cd'::text) AND ((b)::text <> 'xy'::text) AND (a = 15))",)]

-----------
QUERY:


--
-- different collations for different keys with same expression
--
create table coll_pruning_multi (a text) partition by range (substr(a, 1) collate "POSIX", substr(a, 1) collate "C");
RESULT:
	postgres: None

-----------
QUERY:

create table coll_pruning_multi1 partition of coll_pruning_multi for values from ('a', 'a') to ('a', 'e');
RESULT:
	postgres: None

-----------
QUERY:

create table coll_pruning_multi2 partition of coll_pruning_multi for values from ('a', 'e') to ('a', 'z');
RESULT:
	postgres: None

-----------
QUERY:

create table coll_pruning_multi3 partition of coll_pruning_multi for values from ('b', 'a') to ('b', 'e');
RESULT:
	postgres: None

-----------
QUERY:


-- no pruning, because no value for the leading key
explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C";
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on coll_pruning_multi1 coll_pruning_multi_1',), ('        Filter: (substr(a, 1) = \'e\'::text COLLATE "C")',), ('  ->  Seq Scan on coll_pruning_multi2 coll_pruning_multi_2',), ('        Filter: (substr(a, 1) = \'e\'::text COLLATE "C")',), ('  ->  Seq Scan on coll_pruning_multi3 coll_pruning_multi_3',), ('        Filter: (substr(a, 1) = \'e\'::text COLLATE "C")',)]

-----------
QUERY:


-- pruning, with a value provided for the leading key
explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'a' collate "POSIX";
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on coll_pruning_multi1 coll_pruning_multi_1',), ('        Filter: (substr(a, 1) = \'a\'::text COLLATE "POSIX")',), ('  ->  Seq Scan on coll_pruning_multi2 coll_pruning_multi_2',), ('        Filter: (substr(a, 1) = \'a\'::text COLLATE "POSIX")',)]

-----------
QUERY:


-- pruning, with values provided for both keys
explain (costs off) select * from coll_pruning_multi where substr(a, 1) = 'e' collate "C" and substr(a, 1) = 'a' collate "POSIX";
RESULT:
	postgres: [('Seq Scan on coll_pruning_multi2 coll_pruning_multi',), ('  Filter: ((substr(a, 1) = \'e\'::text COLLATE "C") AND (substr(a, 1) = \'a\'::text COLLATE "POSIX"))',)]

-----------
QUERY:


--
-- LIKE operators don/* REPLACED */''t prune
--
create table like_op_noprune (a text) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table like_op_noprune1 partition of like_op_noprune for values in ('ABC');
RESULT:
	postgres: None

-----------
QUERY:

create table like_op_noprune2 partition of like_op_noprune for values in ('BCD');
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from like_op_noprune where a like '%BC';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on like_op_noprune1 like_op_noprune_1',), ("        Filter: (a ~~ '%BC'::text)",), ('  ->  Seq Scan on like_op_noprune2 like_op_noprune_2',), ("        Filter: (a ~~ '%BC'::text)",)]

-----------
QUERY:


--
-- tests wherein clause value requires a cross-type comparison function
--
create table lparted_by_int2 (a smallint) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table lparted_by_int2_1 partition of lparted_by_int2 for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create table lparted_by_int2_16384 partition of lparted_by_int2 for values in (16384);
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from lparted_by_int2 where a = 100_000_000_000_000;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


create table rparted_by_int2 (a smallint) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table rparted_by_int2_1 partition of rparted_by_int2 for values from (1) to (10);
RESULT:
	postgres: None

-----------
QUERY:

create table rparted_by_int2_16384 partition of rparted_by_int2 for values from (10) to (16384);
RESULT:
	postgres: None

-----------
QUERY:

-- all partitions pruned
explain (costs off) select * from rparted_by_int2 where a > 100_000_000_000_000;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

create table rparted_by_int2_maxvalue partition of rparted_by_int2 for values from (16384) to (maxvalue);
RESULT:
	postgres: None

-----------
QUERY:

-- all partitions but rparted_by_int2_maxvalue pruned
explain (costs off) select * from rparted_by_int2 where a > 100_000_000_000_000;
RESULT:
	postgres: [('Seq Scan on rparted_by_int2_maxvalue rparted_by_int2',), ("  Filter: (a > '100000000000000'::bigint)",)]

-----------
QUERY:


drop table lp, coll_pruning, rlp, mc3p, mc2p, boolpart, iboolpart, boolrangep, rp, coll_pruning_multi, like_op_noprune, lparted_by_int2, rparted_by_int2;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test Partition pruning for HASH partitioning
--
-- Use hand-rolled hash functions and operator classes to get predictable
-- result on different machines.  See the definitions of
-- part_test_int4_ops and part_test_text_ops in test_setup.sql.
--

create table hp (a int, b text, c int)
  partition by hash (a part_test_int4_ops, b part_test_text_ops);
RESULT:
	postgres: None

-----------
QUERY:

create table hp0 partition of hp for values with (modulus 4, remainder 0);
RESULT:
	postgres: None

-----------
QUERY:

create table hp3 partition of hp for values with (modulus 4, remainder 3);
RESULT:
	postgres: None

-----------
QUERY:

create table hp1 partition of hp for values with (modulus 4, remainder 1);
RESULT:
	postgres: None

-----------
QUERY:

create table hp2 partition of hp for values with (modulus 4, remainder 2);
RESULT:
	postgres: None

-----------
QUERY:


insert into hp values (null, null, 0);
RESULT:
	postgres: None

-----------
QUERY:

insert into hp values (1, null, 1);
RESULT:
	postgres: None

-----------
QUERY:

insert into hp values (1, 'xxx', 2);
RESULT:
	postgres: None

-----------
QUERY:

insert into hp values (null, 'xxx', 3);
RESULT:
	postgres: None

-----------
QUERY:

insert into hp values (2, 'xxx', 4);
RESULT:
	postgres: None

-----------
QUERY:

insert into hp values (1, 'abcde', 5);
RESULT:
	postgres: None

-----------
QUERY:

select tableoid::regclass, * from hp order by c;
RESULT:
	postgres: [('hp0', None, None, 0), ('hp1', 1, None, 1), ('hp0', 1, 'xxx', 2), ('hp2', None, 'xxx', 3), ('hp3', 2, 'xxx', 4), ('hp2', 1, 'abcde', 5)]

-----------
QUERY:


-- partial keys won/* REPLACED */''t prune, nor would non-equality conditions
explain (costs off) select * from hp where a = 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on hp0 hp_1',), ('        Filter: (a = 1)',), ('  ->  Seq Scan on hp1 hp_2',), ('        Filter: (a = 1)',), ('  ->  Seq Scan on hp2 hp_3',), ('        Filter: (a = 1)',), ('  ->  Seq Scan on hp3 hp_4',), ('        Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) select * from hp where b = 'xxx';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on hp0 hp_1',), ("        Filter: (b = 'xxx'::text)",), ('  ->  Seq Scan on hp1 hp_2',), ("        Filter: (b = 'xxx'::text)",), ('  ->  Seq Scan on hp2 hp_3',), ("        Filter: (b = 'xxx'::text)",), ('  ->  Seq Scan on hp3 hp_4',), ("        Filter: (b = 'xxx'::text)",)]

-----------
QUERY:

explain (costs off) select * from hp where a is null;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on hp0 hp_1',), ('        Filter: (a IS NULL)',), ('  ->  Seq Scan on hp1 hp_2',), ('        Filter: (a IS NULL)',), ('  ->  Seq Scan on hp2 hp_3',), ('        Filter: (a IS NULL)',), ('  ->  Seq Scan on hp3 hp_4',), ('        Filter: (a IS NULL)',)]

-----------
QUERY:

explain (costs off) select * from hp where b is null;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on hp0 hp_1',), ('        Filter: (b IS NULL)',), ('  ->  Seq Scan on hp1 hp_2',), ('        Filter: (b IS NULL)',), ('  ->  Seq Scan on hp2 hp_3',), ('        Filter: (b IS NULL)',), ('  ->  Seq Scan on hp3 hp_4',), ('        Filter: (b IS NULL)',)]

-----------
QUERY:

explain (costs off) select * from hp where a < 1 and b = 'xxx';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on hp0 hp_1',), ("        Filter: ((a < 1) AND (b = 'xxx'::text))",), ('  ->  Seq Scan on hp1 hp_2',), ("        Filter: ((a < 1) AND (b = 'xxx'::text))",), ('  ->  Seq Scan on hp2 hp_3',), ("        Filter: ((a < 1) AND (b = 'xxx'::text))",), ('  ->  Seq Scan on hp3 hp_4',), ("        Filter: ((a < 1) AND (b = 'xxx'::text))",)]

-----------
QUERY:

explain (costs off) select * from hp where a <> 1 and b = 'yyy';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on hp0 hp_1',), ("        Filter: ((a <> 1) AND (b = 'yyy'::text))",), ('  ->  Seq Scan on hp1 hp_2',), ("        Filter: ((a <> 1) AND (b = 'yyy'::text))",), ('  ->  Seq Scan on hp2 hp_3',), ("        Filter: ((a <> 1) AND (b = 'yyy'::text))",), ('  ->  Seq Scan on hp3 hp_4',), ("        Filter: ((a <> 1) AND (b = 'yyy'::text))",)]

-----------
QUERY:

explain (costs off) select * from hp where a <> 1 and b <> 'xxx';
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on hp0 hp_1',), ("        Filter: ((a <> 1) AND (b <> 'xxx'::text))",), ('  ->  Seq Scan on hp1 hp_2',), ("        Filter: ((a <> 1) AND (b <> 'xxx'::text))",), ('  ->  Seq Scan on hp2 hp_3',), ("        Filter: ((a <> 1) AND (b <> 'xxx'::text))",), ('  ->  Seq Scan on hp3 hp_4',), ("        Filter: ((a <> 1) AND (b <> 'xxx'::text))",)]

-----------
QUERY:


-- pruning should work if either a value or a IS NULL clause is provided for
-- each of the keys
explain (costs off) select * from hp where a is null and b is null;
RESULT:
	postgres: [('Seq Scan on hp0 hp',), ('  Filter: ((a IS NULL) AND (b IS NULL))',)]

-----------
QUERY:

explain (costs off) select * from hp where a = 1 and b is null;
RESULT:
	postgres: [('Seq Scan on hp1 hp',), ('  Filter: ((b IS NULL) AND (a = 1))',)]

-----------
QUERY:

explain (costs off) select * from hp where a = 1 and b = 'xxx';
RESULT:
	postgres: [('Seq Scan on hp0 hp',), ("  Filter: ((a = 1) AND (b = 'xxx'::text))",)]

-----------
QUERY:

explain (costs off) select * from hp where a is null and b = 'xxx';
RESULT:
	postgres: [('Seq Scan on hp2 hp',), ("  Filter: ((a IS NULL) AND (b = 'xxx'::text))",)]

-----------
QUERY:

explain (costs off) select * from hp where a = 2 and b = 'xxx';
RESULT:
	postgres: [('Seq Scan on hp3 hp',), ("  Filter: ((a = 2) AND (b = 'xxx'::text))",)]

-----------
QUERY:

explain (costs off) select * from hp where a = 1 and b = 'abcde';
RESULT:
	postgres: [('Seq Scan on hp2 hp',), ("  Filter: ((a = 1) AND (b = 'abcde'::text))",)]

-----------
QUERY:

explain (costs off) select * from hp where (a = 1 and b = 'abcde') or (a = 2 and b = 'xxx') or (a is null and b is null);
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on hp0 hp_1',), ("        Filter: (((a = 1) AND (b = 'abcde'::text)) OR ((a = 2) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))",), ('  ->  Seq Scan on hp2 hp_2',), ("        Filter: (((a = 1) AND (b = 'abcde'::text)) OR ((a = 2) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))",), ('  ->  Seq Scan on hp3 hp_3',), ("        Filter: (((a = 1) AND (b = 'abcde'::text)) OR ((a = 2) AND (b = 'xxx'::text)) OR ((a IS NULL) AND (b IS NULL)))",)]

-----------
QUERY:


-- test pruning when not all the partitions exist
drop table hp1;
RESULT:
	postgres: None

-----------
QUERY:

drop table hp3;
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from hp where a = 1 and b = 'abcde';
RESULT:
	postgres: [('Seq Scan on hp2 hp',), ("  Filter: ((a = 1) AND (b = 'abcde'::text))",)]

-----------
QUERY:

explain (costs off) select * from hp where a = 1 and b = 'abcde' and
  (c = 2 or c = 3);
RESULT:
	postgres: [('Seq Scan on hp2 hp',), ("  Filter: ((a = 1) AND (b = 'abcde'::text) AND ((c = 2) OR (c = 3)))",)]

-----------
QUERY:

drop table hp2;
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from hp where a = 1 and b = 'abcde' and
  (c = 2 or c = 3);
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


--
-- Test runtime partition pruning
--
create table ab (a int not null, b int not null) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a2 partition of ab for values in(2) partition by list (b);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a2_b1 partition of ab_a2 for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a2_b2 partition of ab_a2 for values in (2);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a2_b3 partition of ab_a2 for values in (3);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a1 partition of ab for values in(1) partition by list (b);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a1_b1 partition of ab_a1 for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a1_b2 partition of ab_a1 for values in (2);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a1_b3 partition of ab_a1 for values in (3);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a3 partition of ab for values in(3) partition by list (b);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a3_b1 partition of ab_a3 for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a3_b2 partition of ab_a3 for values in (2);
RESULT:
	postgres: None

-----------
QUERY:

create table ab_a3_b3 partition of ab_a3 for values in (3);
RESULT:
	postgres: None

-----------
QUERY:


-- Disallow index only scans as concurrent transactions may stop visibility
-- bits being set causing /* REPLACED */''Heap Fetches/* REPLACED */'' to be unstable in the EXPLAIN ANALYZE
-- output.
set enable_indexonlyscan = off;
RESULT:
	postgres: None

-----------
QUERY:


prepare ab_q1 (int, int, int) as
select * from ab where a between $1 and $2 and b <= $3;
RESULT:
	postgres: None

-----------
QUERY:


explain (analyze, costs off, summary off, timing off) execute ab_q1 (2, 2, 3);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 6',), ('  ->  Seq Scan on ab_a2_b1 ab_1 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))',), ('  ->  Seq Scan on ab_a2_b2 ab_2 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))',), ('  ->  Seq Scan on ab_a2_b3 ab_3 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))',)]

-----------
QUERY:

explain (analyze, costs off, summary off, timing off) execute ab_q1 (1, 2, 3);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 3',), ('  ->  Seq Scan on ab_a1_b1 ab_1 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))',), ('  ->  Seq Scan on ab_a1_b2 ab_2 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))',), ('  ->  Seq Scan on ab_a1_b3 ab_3 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))',), ('  ->  Seq Scan on ab_a2_b1 ab_4 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))',), ('  ->  Seq Scan on ab_a2_b2 ab_5 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))',), ('  ->  Seq Scan on ab_a2_b3 ab_6 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b <= $3))',)]

-----------
QUERY:


deallocate ab_q1;
RESULT:
	postgres: None

-----------
QUERY:


-- Runtime pruning after optimizer pruning
prepare ab_q1 (int, int) as
select a from ab where a between $1 and $2 and b < 3;
RESULT:
	postgres: None

-----------
QUERY:


explain (analyze, costs off, summary off, timing off) execute ab_q1 (2, 2);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 4',), ('  ->  Seq Scan on ab_a2_b1 ab_1 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b < 3))',), ('  ->  Seq Scan on ab_a2_b2 ab_2 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b < 3))',)]

-----------
QUERY:

explain (analyze, costs off, summary off, timing off) execute ab_q1 (2, 4);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 2',), ('  ->  Seq Scan on ab_a2_b1 ab_1 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b < 3))',), ('  ->  Seq Scan on ab_a2_b2 ab_2 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b < 3))',), ('  ->  Seq Scan on ab_a3_b1 ab_3 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b < 3))',), ('  ->  Seq Scan on ab_a3_b2 ab_4 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b < 3))',)]

-----------
QUERY:


-- Ensure a mix of PARAM_EXTERN and PARAM_EXEC Params work together at
-- different levels of partitioning.
prepare ab_q2 (int, int) as
select a from ab where a between $1 and $2 and b < (select 3);
RESULT:
	postgres: None

-----------
QUERY:


explain (analyze, costs off, summary off, timing off) execute ab_q2 (2, 2);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 6',), ('  InitPlan 1',), ('    ->  Result (actual rows=1 loops=1)',), ('  ->  Seq Scan on ab_a2_b1 ab_1 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b < (InitPlan 1).col1))',), ('  ->  Seq Scan on ab_a2_b2 ab_2 (actual rows=0 loops=1)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b < (InitPlan 1).col1))',), ('  ->  Seq Scan on ab_a2_b3 ab_3 (never executed)',), ('        Filter: ((a >= $1) AND (a <= $2) AND (b < (InitPlan 1).col1))',)]

-----------
QUERY:


-- As above, but swap the PARAM_EXEC Param to the first partition level
prepare ab_q3 (int, int) as
select a from ab where b between $1 and $2 and a < (select 3);
RESULT:
	postgres: None

-----------
QUERY:


explain (analyze, costs off, summary off, timing off) execute ab_q3 (2, 2);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 6',), ('  InitPlan 1',), ('    ->  Result (actual rows=1 loops=1)',), ('  ->  Seq Scan on ab_a1_b2 ab_1 (actual rows=0 loops=1)',), ('        Filter: ((b >= $1) AND (b <= $2) AND (a < (InitPlan 1).col1))',), ('  ->  Seq Scan on ab_a2_b2 ab_2 (actual rows=0 loops=1)',), ('        Filter: ((b >= $1) AND (b <= $2) AND (a < (InitPlan 1).col1))',), ('  ->  Seq Scan on ab_a3_b2 ab_3 (never executed)',), ('        Filter: ((b >= $1) AND (b <= $2) AND (a < (InitPlan 1).col1))',)]

-----------
QUERY:


--
-- Test runtime pruning with hash partitioned tables
--

-- recreate partitions dropped above
create table hp1 partition of hp for values with (modulus 4, remainder 1);
RESULT:
	postgres: None

-----------
QUERY:

create table hp2 partition of hp for values with (modulus 4, remainder 2);
RESULT:
	postgres: None

-----------
QUERY:

create table hp3 partition of hp for values with (modulus 4, remainder 3);
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure we correctly prune unneeded partitions when there is an IS NULL qual
prepare hp_q1 (text) as
select * from hp where a is null and b = $1;
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) execute hp_q1('xxx');
RESULT:
	postgres: [('Append',), ('  Subplans Removed: 3',), ('  ->  Seq Scan on hp2 hp_1',), ('        Filter: ((a IS NULL) AND (b = $1))',)]

-----------
QUERY:


deallocate hp_q1;
RESULT:
	postgres: None

-----------
QUERY:


drop table hp;
RESULT:
	postgres: None

-----------
QUERY:


-- Test a backwards Append scan
create table list_part (a int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table list_part1 partition of list_part for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create table list_part2 partition of list_part for values in (2);
RESULT:
	postgres: None

-----------
QUERY:

create table list_part3 partition of list_part for values in (3);
RESULT:
	postgres: None

-----------
QUERY:

create table list_part4 partition of list_part for values in (4);
RESULT:
	postgres: None

-----------
QUERY:


insert into list_part select generate_series(1,4);
RESULT:
	postgres: None

-----------
QUERY:


begin;
RESULT:
	postgres: None

-----------
QUERY:


-- Don/* REPLACED */''t select an actual value out of the table as the order of the Append/* REPLACED */''s
-- subnodes may not be stable.
declare cur SCROLL CURSOR for select 1 from list_part where a > (select 1) and a < (select 4);
RESULT:
	postgres: None

-----------
QUERY:


-- move beyond the final row
move 3 from cur;
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure we get two rows.
fetch backward all from cur;
RESULT:
	postgres: [(1,), (1,)]

-----------
QUERY:


commit;
RESULT:
	postgres: None

-----------
QUERY:


begin;
RESULT:
	postgres: None

-----------
QUERY:


-- Test run-time pruning using stable functions
create function list_part_fn(int) returns int as $$ begin return $1; end;$$ language plpgsql stable;
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure pruning works using a stable function containing no Vars
explain (analyze, costs off, summary off, timing off) select * from list_part where a = list_part_fn(1);
RESULT:
	postgres: [('Append (actual rows=1 loops=1)',), ('  Subplans Removed: 3',), ('  ->  Seq Scan on list_part1 list_part_1 (actual rows=1 loops=1)',), ('        Filter: (a = list_part_fn(1))',)]

-----------
QUERY:


-- Ensure pruning does not take place when the function has a Var parameter
explain (analyze, costs off, summary off, timing off) select * from list_part where a = list_part_fn(a);
RESULT:
	postgres: [('Append (actual rows=4 loops=1)',), ('  ->  Seq Scan on list_part1 list_part_1 (actual rows=1 loops=1)',), ('        Filter: (a = list_part_fn(a))',), ('  ->  Seq Scan on list_part2 list_part_2 (actual rows=1 loops=1)',), ('        Filter: (a = list_part_fn(a))',), ('  ->  Seq Scan on list_part3 list_part_3 (actual rows=1 loops=1)',), ('        Filter: (a = list_part_fn(a))',), ('  ->  Seq Scan on list_part4 list_part_4 (actual rows=1 loops=1)',), ('        Filter: (a = list_part_fn(a))',)]

-----------
QUERY:


-- Ensure pruning does not take place when the expression contains a Var.
explain (analyze, costs off, summary off, timing off) select * from list_part where a = list_part_fn(1) + a;
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  ->  Seq Scan on list_part1 list_part_1 (actual rows=0 loops=1)',), ('        Filter: (a = (list_part_fn(1) + a))',), ('        Rows Removed by Filter: 1',), ('  ->  Seq Scan on list_part2 list_part_2 (actual rows=0 loops=1)',), ('        Filter: (a = (list_part_fn(1) + a))',), ('        Rows Removed by Filter: 1',), ('  ->  Seq Scan on list_part3 list_part_3 (actual rows=0 loops=1)',), ('        Filter: (a = (list_part_fn(1) + a))',), ('        Rows Removed by Filter: 1',), ('  ->  Seq Scan on list_part4 list_part_4 (actual rows=0 loops=1)',), ('        Filter: (a = (list_part_fn(1) + a))',), ('        Rows Removed by Filter: 1',)]

-----------
QUERY:


rollback;
RESULT:
	postgres: None

-----------
QUERY:


drop table list_part;
RESULT:
	postgres: None

-----------
QUERY:


-- Parallel append

-- Parallel queries won/* REPLACED */''t necessarily get as many workers as the planner
-- asked for.  This affects not only the /* REPLACED */''Workers Launched:/* REPLACED */'' field of EXPLAIN
-- results, but also row counts and loop counts for parallel scans, Gathers,
-- and everything in between.  This function filters out the values we can/* REPLACED */''t
-- rely on to be stable.
-- This removes enough info that you might wonder why bother with EXPLAIN
-- ANALYZE at all.  The answer is that we need to see /* REPLACED */''(never executed)/* REPLACED */''
-- notations because that/* REPLACED */''s the only way to verify runtime pruning.
create function explain_parallel_append(text) returns setof text
language plpgsql as
$$
declare
    ln text;
begin
    for ln in
        execute format('explain (analyze, costs off, summary off, timing off) %s',
            $1)
    loop
        ln := regexp_replace(ln, 'Workers Launched: \d+', 'Workers Launched: N');
        ln := regexp_replace(ln, 'actual rows=\d+ loops=\d+', 'actual rows=N loops=N');
        ln := regexp_replace(ln, 'Rows Removed by Filter: \d+', 'Rows Removed by Filter: N');
        return next ln;
    end loop;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


prepare ab_q4 (int, int) as
select avg(a) from ab where a between $1 and $2 and b < 4;
RESULT:
	postgres: None

-----------
QUERY:


-- Encourage use of parallel plans
set parallel_setup_cost = 0;
RESULT:
	postgres: None

-----------
QUERY:

set parallel_tuple_cost = 0;
RESULT:
	postgres: None

-----------
QUERY:

set min_parallel_table_scan_size = 0;
RESULT:
	postgres: None

-----------
QUERY:

set max_parallel_workers_per_gather = 2;
RESULT:
	postgres: None

-----------
QUERY:


select explain_parallel_append('execute ab_q4 (2, 2)');
RESULT:
	postgres: [('Finalize Aggregate (actual rows=N loops=N)',), ('  ->  Gather (actual rows=N loops=N)',), ('        Workers Planned: 2',), ('        Workers Launched: N',), ('        ->  Partial Aggregate (actual rows=N loops=N)',), ('              ->  Parallel Append (actual rows=N loops=N)',), ('                    Subplans Removed: 6',), ('                    ->  Parallel Seq Scan on ab_a2_b1 ab_1 (actual rows=N loops=N)',), ('                          Filter: ((a >= $1) AND (a <= $2) AND (b < 4))',), ('                    ->  Parallel Seq Scan on ab_a2_b2 ab_2 (actual rows=N loops=N)',), ('                          Filter: ((a >= $1) AND (a <= $2) AND (b < 4))',), ('                    ->  Parallel Seq Scan on ab_a2_b3 ab_3 (actual rows=N loops=N)',), ('                          Filter: ((a >= $1) AND (a <= $2) AND (b < 4))',)]

-----------
QUERY:


-- Test run-time pruning with IN lists.
prepare ab_q5 (int, int, int) as
select avg(a) from ab where a in($1,$2,$3) and b < 4;
RESULT:
	postgres: None

-----------
QUERY:


select explain_parallel_append('execute ab_q5 (1, 1, 1)');
RESULT:
	postgres: [('Finalize Aggregate (actual rows=N loops=N)',), ('  ->  Gather (actual rows=N loops=N)',), ('        Workers Planned: 2',), ('        Workers Launched: N',), ('        ->  Partial Aggregate (actual rows=N loops=N)',), ('              ->  Parallel Append (actual rows=N loops=N)',), ('                    Subplans Removed: 6',), ('                    ->  Parallel Seq Scan on ab_a1_b1 ab_1 (actual rows=N loops=N)',), ('                          Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))',), ('                    ->  Parallel Seq Scan on ab_a1_b2 ab_2 (actual rows=N loops=N)',), ('                          Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))',), ('                    ->  Parallel Seq Scan on ab_a1_b3 ab_3 (actual rows=N loops=N)',), ('                          Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))',)]

-----------
QUERY:

select explain_parallel_append('execute ab_q5 (2, 3, 3)');
RESULT:
	postgres: [('Finalize Aggregate (actual rows=N loops=N)',), ('  ->  Gather (actual rows=N loops=N)',), ('        Workers Planned: 2',), ('        Workers Launched: N',), ('        ->  Partial Aggregate (actual rows=N loops=N)',), ('              ->  Parallel Append (actual rows=N loops=N)',), ('                    Subplans Removed: 3',), ('                    ->  Parallel Seq Scan on ab_a2_b1 ab_1 (actual rows=N loops=N)',), ('                          Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))',), ('                    ->  Parallel Seq Scan on ab_a2_b2 ab_2 (actual rows=N loops=N)',), ('                          Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))',), ('                    ->  Parallel Seq Scan on ab_a2_b3 ab_3 (actual rows=N loops=N)',), ('                          Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))',), ('                    ->  Parallel Seq Scan on ab_a3_b1 ab_4 (actual rows=N loops=N)',), ('                          Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))',), ('                    ->  Parallel Seq Scan on ab_a3_b2 ab_5 (actual rows=N loops=N)',), ('                          Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))',), ('                    ->  Parallel Seq Scan on ab_a3_b3 ab_6 (actual rows=N loops=N)',), ('                          Filter: ((b < 4) AND (a = ANY (ARRAY[$1, $2, $3])))',)]

-----------
QUERY:


-- Try some params whose values do not belong to any partition.
select explain_parallel_append('execute ab_q5 (33, 44, 55)');
RESULT:
	postgres: [('Finalize Aggregate (actual rows=N loops=N)',), ('  ->  Gather (actual rows=N loops=N)',), ('        Workers Planned: 2',), ('        Workers Launched: N',), ('        ->  Partial Aggregate (actual rows=N loops=N)',), ('              ->  Parallel Append (actual rows=N loops=N)',), ('                    Subplans Removed: 9',)]

-----------
QUERY:


-- Test Parallel Append with PARAM_EXEC Params
select explain_parallel_append('select count(*) from ab where (a = (select 1) or a = (select 3)) and b = 2');
RESULT:
	postgres: [('Aggregate (actual rows=N loops=N)',), ('  InitPlan 1',), ('    ->  Result (actual rows=N loops=N)',), ('  InitPlan 2',), ('    ->  Result (actual rows=N loops=N)',), ('  ->  Gather (actual rows=N loops=N)',), ('        Workers Planned: 2',), ('        Workers Launched: N',), ('        ->  Parallel Append (actual rows=N loops=N)',), ('              ->  Parallel Seq Scan on ab_a1_b2 ab_1 (actual rows=N loops=N)',), ('                    Filter: ((b = 2) AND ((a = (InitPlan 1).col1) OR (a = (InitPlan 2).col1)))',), ('              ->  Parallel Seq Scan on ab_a2_b2 ab_2 (never executed)',), ('                    Filter: ((b = 2) AND ((a = (InitPlan 1).col1) OR (a = (InitPlan 2).col1)))',), ('              ->  Parallel Seq Scan on ab_a3_b2 ab_3 (actual rows=N loops=N)',), ('                    Filter: ((b = 2) AND ((a = (InitPlan 1).col1) OR (a = (InitPlan 2).col1)))',)]

-----------
QUERY:


-- Test pruning during parallel nested loop query
create table lprt_a (a int not null);
RESULT:
	postgres: None

-----------
QUERY:

-- Insert some values we won/* REPLACED */''t find in ab
insert into lprt_a select 0 from generate_series(1,100);
RESULT:
	postgres: None

-----------
QUERY:


-- and insert some values that we should find.
insert into lprt_a values(1),(1);
RESULT:
	postgres: None

-----------
QUERY:


analyze lprt_a;
RESULT:
	postgres: None

-----------
QUERY:


create index ab_a2_b1_a_idx on ab_a2_b1 (a);
RESULT:
	postgres: None

-----------
QUERY:

create index ab_a2_b2_a_idx on ab_a2_b2 (a);
RESULT:
	postgres: None

-----------
QUERY:

create index ab_a2_b3_a_idx on ab_a2_b3 (a);
RESULT:
	postgres: None

-----------
QUERY:

create index ab_a1_b1_a_idx on ab_a1_b1 (a);
RESULT:
	postgres: None

-----------
QUERY:

create index ab_a1_b2_a_idx on ab_a1_b2 (a);
RESULT:
	postgres: None

-----------
QUERY:

create index ab_a1_b3_a_idx on ab_a1_b3 (a);
RESULT:
	postgres: None

-----------
QUERY:

create index ab_a3_b1_a_idx on ab_a3_b1 (a);
RESULT:
	postgres: None

-----------
QUERY:

create index ab_a3_b2_a_idx on ab_a3_b2 (a);
RESULT:
	postgres: None

-----------
QUERY:

create index ab_a3_b3_a_idx on ab_a3_b3 (a);
RESULT:
	postgres: None

-----------
QUERY:


set enable_hashjoin = 0;
RESULT:
	postgres: None

-----------
QUERY:

set enable_mergejoin = 0;
RESULT:
	postgres: None

-----------
QUERY:

set enable_memoize = 0;
RESULT:
	postgres: None

-----------
QUERY:


-- Temporarily install some debugging to investigate plan instability.
select c.relname,c.relpages,c.reltuples,i.indisvalid,s.autovacuum_count,s.autoanalyze_count
from pg_class c
left join pg_stat_all_tables s on c.oid = s.relid
left join pg_index i on c.oid = i.indexrelid
where c.relname like 'ab\_%' order by c.relname;
RESULT:
	postgres: [('ab_a1', 0, -1.0, None, 0, 0), ('ab_a1_b1', 0, -1.0, None, 0, 0), ('ab_a1_b1_a_idx', 1, 0.0, True, None, None), ('ab_a1_b2', 0, -1.0, None, 0, 0), ('ab_a1_b2_a_idx', 1, 0.0, True, None, None), ('ab_a1_b3', 0, -1.0, None, 0, 0), ('ab_a1_b3_a_idx', 1, 0.0, True, None, None), ('ab_a2', 0, -1.0, None, 0, 0), ('ab_a2_b1', 0, -1.0, None, 0, 0), ('ab_a2_b1_a_idx', 1, 0.0, True, None, None), ('ab_a2_b2', 0, -1.0, None, 0, 0), ('ab_a2_b2_a_idx', 1, 0.0, True, None, None), ('ab_a2_b3', 0, -1.0, None, 0, 0), ('ab_a2_b3_a_idx', 1, 0.0, True, None, None), ('ab_a3', 0, -1.0, None, 0, 0), ('ab_a3_b1', 0, -1.0, None, 0, 0), ('ab_a3_b1_a_idx', 1, 0.0, True, None, None), ('ab_a3_b2', 0, -1.0, None, 0, 0), ('ab_a3_b2_a_idx', 1, 0.0, True, None, None), ('ab_a3_b3', 0, -1.0, None, 0, 0), ('ab_a3_b3_a_idx', 1, 0.0, True, None, None)]

-----------
QUERY:


select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(0, 0, 1)');
RESULT:
	postgres: [('Finalize Aggregate (actual rows=N loops=N)',), ('  ->  Gather (actual rows=N loops=N)',), ('        Workers Planned: 1',), ('        Workers Launched: N',), ('        ->  Partial Aggregate (actual rows=N loops=N)',), ('              ->  Nested Loop (actual rows=N loops=N)',), ('                    ->  Parallel Seq Scan on lprt_a a (actual rows=N loops=N)',), ("                          Filter: (a = ANY ('{0,0,1}'::integer[]))",), ('                    ->  Append (actual rows=N loops=N)',), ('                          ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 ab_1 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 ab_2 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 ab_3 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 ab_4 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 ab_5 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 ab_6 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 ab_7 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 ab_8 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 ab_9 (never executed)',), ('                                Index Cond: (a = a.a)',)]

-----------
QUERY:


-- Ensure the same partitions are pruned when we make the nested loop
-- parameter an Expr rather than a plain Param.
select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a + 0 where a.a in(0, 0, 1)');
RESULT:
	postgres: [('Finalize Aggregate (actual rows=N loops=N)',), ('  ->  Gather (actual rows=N loops=N)',), ('        Workers Planned: 1',), ('        Workers Launched: N',), ('        ->  Partial Aggregate (actual rows=N loops=N)',), ('              ->  Nested Loop (actual rows=N loops=N)',), ('                    ->  Parallel Seq Scan on lprt_a a (actual rows=N loops=N)',), ("                          Filter: (a = ANY ('{0,0,1}'::integer[]))",), ('                    ->  Append (actual rows=N loops=N)',), ('                          ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 ab_1 (actual rows=N loops=N)',), ('                                Index Cond: (a = (a.a + 0))',), ('                          ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 ab_2 (actual rows=N loops=N)',), ('                                Index Cond: (a = (a.a + 0))',), ('                          ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 ab_3 (actual rows=N loops=N)',), ('                                Index Cond: (a = (a.a + 0))',), ('                          ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 ab_4 (never executed)',), ('                                Index Cond: (a = (a.a + 0))',), ('                          ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 ab_5 (never executed)',), ('                                Index Cond: (a = (a.a + 0))',), ('                          ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 ab_6 (never executed)',), ('                                Index Cond: (a = (a.a + 0))',), ('                          ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 ab_7 (never executed)',), ('                                Index Cond: (a = (a.a + 0))',), ('                          ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 ab_8 (never executed)',), ('                                Index Cond: (a = (a.a + 0))',), ('                          ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 ab_9 (never executed)',), ('                                Index Cond: (a = (a.a + 0))',)]

-----------
QUERY:


insert into lprt_a values(3),(3);
RESULT:
	postgres: None

-----------
QUERY:


select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(1, 0, 3)');
RESULT:
	postgres: [('Finalize Aggregate (actual rows=N loops=N)',), ('  ->  Gather (actual rows=N loops=N)',), ('        Workers Planned: 1',), ('        Workers Launched: N',), ('        ->  Partial Aggregate (actual rows=N loops=N)',), ('              ->  Nested Loop (actual rows=N loops=N)',), ('                    ->  Parallel Seq Scan on lprt_a a (actual rows=N loops=N)',), ("                          Filter: (a = ANY ('{1,0,3}'::integer[]))",), ('                    ->  Append (actual rows=N loops=N)',), ('                          ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 ab_1 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 ab_2 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 ab_3 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 ab_4 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 ab_5 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 ab_6 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 ab_7 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 ab_8 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 ab_9 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',)]

-----------
QUERY:

select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(1, 0, 0)');
RESULT:
	postgres: [('Finalize Aggregate (actual rows=N loops=N)',), ('  ->  Gather (actual rows=N loops=N)',), ('        Workers Planned: 1',), ('        Workers Launched: N',), ('        ->  Partial Aggregate (actual rows=N loops=N)',), ('              ->  Nested Loop (actual rows=N loops=N)',), ('                    ->  Parallel Seq Scan on lprt_a a (actual rows=N loops=N)',), ("                          Filter: (a = ANY ('{1,0,0}'::integer[]))",), ('                          Rows Removed by Filter: N',), ('                    ->  Append (actual rows=N loops=N)',), ('                          ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 ab_1 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 ab_2 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 ab_3 (actual rows=N loops=N)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 ab_4 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 ab_5 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 ab_6 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 ab_7 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 ab_8 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 ab_9 (never executed)',), ('                                Index Cond: (a = a.a)',)]

-----------
QUERY:


delete from lprt_a where a = 1;
RESULT:
	postgres: None

-----------
QUERY:


select explain_parallel_append('select avg(ab.a) from ab inner join lprt_a a on ab.a = a.a where a.a in(1, 0, 0)');
RESULT:
	postgres: [('Finalize Aggregate (actual rows=N loops=N)',), ('  ->  Gather (actual rows=N loops=N)',), ('        Workers Planned: 1',), ('        Workers Launched: N',), ('        ->  Partial Aggregate (actual rows=N loops=N)',), ('              ->  Nested Loop (actual rows=N loops=N)',), ('                    ->  Parallel Seq Scan on lprt_a a (actual rows=N loops=N)',), ("                          Filter: (a = ANY ('{1,0,0}'::integer[]))",), ('                          Rows Removed by Filter: N',), ('                    ->  Append (actual rows=N loops=N)',), ('                          ->  Index Scan using ab_a1_b1_a_idx on ab_a1_b1 ab_1 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a1_b2_a_idx on ab_a1_b2 ab_2 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a1_b3_a_idx on ab_a1_b3 ab_3 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b1_a_idx on ab_a2_b1 ab_4 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b2_a_idx on ab_a2_b2 ab_5 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a2_b3_a_idx on ab_a2_b3 ab_6 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b1_a_idx on ab_a3_b1 ab_7 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b2_a_idx on ab_a3_b2 ab_8 (never executed)',), ('                                Index Cond: (a = a.a)',), ('                          ->  Index Scan using ab_a3_b3_a_idx on ab_a3_b3 ab_9 (never executed)',), ('                                Index Cond: (a = a.a)',)]

-----------
QUERY:


reset enable_hashjoin;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_mergejoin;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_memoize;
RESULT:
	postgres: None

-----------
QUERY:

reset parallel_setup_cost;
RESULT:
	postgres: None

-----------
QUERY:

reset parallel_tuple_cost;
RESULT:
	postgres: None

-----------
QUERY:

reset min_parallel_table_scan_size;
RESULT:
	postgres: None

-----------
QUERY:

reset max_parallel_workers_per_gather;
RESULT:
	postgres: None

-----------
QUERY:


-- Test run-time partition pruning with an initplan
explain (analyze, costs off, summary off, timing off)
select * from ab where a = (select max(a) from lprt_a) and b = (select max(a)-1 from lprt_a);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  InitPlan 1',), ('    ->  Aggregate (actual rows=1 loops=1)',), ('          ->  Seq Scan on lprt_a (actual rows=102 loops=1)',), ('  InitPlan 2',), ('    ->  Aggregate (actual rows=1 loops=1)',), ('          ->  Seq Scan on lprt_a lprt_a_1 (actual rows=102 loops=1)',), ('  ->  Bitmap Heap Scan on ab_a1_b1 ab_1 (never executed)',), ('        Recheck Cond: (a = (InitPlan 1).col1)',), ('        Filter: (b = (InitPlan 2).col1)',), ('        ->  Bitmap Index Scan on ab_a1_b1_a_idx (never executed)',), ('              Index Cond: (a = (InitPlan 1).col1)',), ('  ->  Bitmap Heap Scan on ab_a1_b2 ab_2 (never executed)',), ('        Recheck Cond: (a = (InitPlan 1).col1)',), ('        Filter: (b = (InitPlan 2).col1)',), ('        ->  Bitmap Index Scan on ab_a1_b2_a_idx (never executed)',), ('              Index Cond: (a = (InitPlan 1).col1)',), ('  ->  Bitmap Heap Scan on ab_a1_b3 ab_3 (never executed)',), ('        Recheck Cond: (a = (InitPlan 1).col1)',), ('        Filter: (b = (InitPlan 2).col1)',), ('        ->  Bitmap Index Scan on ab_a1_b3_a_idx (never executed)',), ('              Index Cond: (a = (InitPlan 1).col1)',), ('  ->  Bitmap Heap Scan on ab_a2_b1 ab_4 (never executed)',), ('        Recheck Cond: (a = (InitPlan 1).col1)',), ('        Filter: (b = (InitPlan 2).col1)',), ('        ->  Bitmap Index Scan on ab_a2_b1_a_idx (never executed)',), ('              Index Cond: (a = (InitPlan 1).col1)',), ('  ->  Bitmap Heap Scan on ab_a2_b2 ab_5 (never executed)',), ('        Recheck Cond: (a = (InitPlan 1).col1)',), ('        Filter: (b = (InitPlan 2).col1)',), ('        ->  Bitmap Index Scan on ab_a2_b2_a_idx (never executed)',), ('              Index Cond: (a = (InitPlan 1).col1)',), ('  ->  Bitmap Heap Scan on ab_a2_b3 ab_6 (never executed)',), ('        Recheck Cond: (a = (InitPlan 1).col1)',), ('        Filter: (b = (InitPlan 2).col1)',), ('        ->  Bitmap Index Scan on ab_a2_b3_a_idx (never executed)',), ('              Index Cond: (a = (InitPlan 1).col1)',), ('  ->  Bitmap Heap Scan on ab_a3_b1 ab_7 (never executed)',), ('        Recheck Cond: (a = (InitPlan 1).col1)',), ('        Filter: (b = (InitPlan 2).col1)',), ('        ->  Bitmap Index Scan on ab_a3_b1_a_idx (never executed)',), ('              Index Cond: (a = (InitPlan 1).col1)',), ('  ->  Bitmap Heap Scan on ab_a3_b2 ab_8 (actual rows=0 loops=1)',), ('        Recheck Cond: (a = (InitPlan 1).col1)',), ('        Filter: (b = (InitPlan 2).col1)',), ('        ->  Bitmap Index Scan on ab_a3_b2_a_idx (actual rows=0 loops=1)',), ('              Index Cond: (a = (InitPlan 1).col1)',), ('  ->  Bitmap Heap Scan on ab_a3_b3 ab_9 (never executed)',), ('        Recheck Cond: (a = (InitPlan 1).col1)',), ('        Filter: (b = (InitPlan 2).col1)',), ('        ->  Bitmap Index Scan on ab_a3_b3_a_idx (never executed)',), ('              Index Cond: (a = (InitPlan 1).col1)',)]

-----------
QUERY:


-- Test run-time partition pruning with UNION ALL parents
explain (analyze, costs off, summary off, timing off)
select * from (select * from ab where a = 1 union all select * from ab) ab where b = (select 1);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  InitPlan 1',), ('    ->  Result (actual rows=1 loops=1)',), ('  ->  Append (actual rows=0 loops=1)',), ('        ->  Bitmap Heap Scan on ab_a1_b1 ab_11 (actual rows=0 loops=1)',), ('              Recheck Cond: (a = 1)',), ('              Filter: (b = (InitPlan 1).col1)',), ('              ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)',), ('                    Index Cond: (a = 1)',), ('        ->  Bitmap Heap Scan on ab_a1_b2 ab_12 (never executed)',), ('              Recheck Cond: (a = 1)',), ('              Filter: (b = (InitPlan 1).col1)',), ('              ->  Bitmap Index Scan on ab_a1_b2_a_idx (never executed)',), ('                    Index Cond: (a = 1)',), ('        ->  Bitmap Heap Scan on ab_a1_b3 ab_13 (never executed)',), ('              Recheck Cond: (a = 1)',), ('              Filter: (b = (InitPlan 1).col1)',), ('              ->  Bitmap Index Scan on ab_a1_b3_a_idx (never executed)',), ('                    Index Cond: (a = 1)',), ('  ->  Seq Scan on ab_a1_b1 ab_1 (actual rows=0 loops=1)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a1_b2 ab_2 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a1_b3 ab_3 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a2_b1 ab_4 (actual rows=0 loops=1)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a2_b2 ab_5 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a2_b3 ab_6 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a3_b1 ab_7 (actual rows=0 loops=1)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a3_b2 ab_8 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a3_b3 ab_9 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',)]

-----------
QUERY:


-- A case containing a UNION ALL with a non-partitioned child.
explain (analyze, costs off, summary off, timing off)
select * from (select * from ab where a = 1 union all (values(10,5)) union all select * from ab) ab where b = (select 1);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  InitPlan 1',), ('    ->  Result (actual rows=1 loops=1)',), ('  ->  Append (actual rows=0 loops=1)',), ('        ->  Bitmap Heap Scan on ab_a1_b1 ab_11 (actual rows=0 loops=1)',), ('              Recheck Cond: (a = 1)',), ('              Filter: (b = (InitPlan 1).col1)',), ('              ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)',), ('                    Index Cond: (a = 1)',), ('        ->  Bitmap Heap Scan on ab_a1_b2 ab_12 (never executed)',), ('              Recheck Cond: (a = 1)',), ('              Filter: (b = (InitPlan 1).col1)',), ('              ->  Bitmap Index Scan on ab_a1_b2_a_idx (never executed)',), ('                    Index Cond: (a = 1)',), ('        ->  Bitmap Heap Scan on ab_a1_b3 ab_13 (never executed)',), ('              Recheck Cond: (a = 1)',), ('              Filter: (b = (InitPlan 1).col1)',), ('              ->  Bitmap Index Scan on ab_a1_b3_a_idx (never executed)',), ('                    Index Cond: (a = 1)',), ('  ->  Result (actual rows=0 loops=1)',), ('        One-Time Filter: (5 = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a1_b1 ab_1 (actual rows=0 loops=1)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a1_b2 ab_2 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a1_b3 ab_3 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a2_b1 ab_4 (actual rows=0 loops=1)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a2_b2 ab_5 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a2_b3 ab_6 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a3_b1 ab_7 (actual rows=0 loops=1)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a3_b2 ab_8 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',), ('  ->  Seq Scan on ab_a3_b3 ab_9 (never executed)',), ('        Filter: (b = (InitPlan 1).col1)',)]

-----------
QUERY:


-- Another UNION ALL test, but containing a mix of exec init and exec run-time pruning.
create table xy_1 (x int, y int);
RESULT:
	postgres: None

-----------
QUERY:

insert into xy_1 values(100,-10);
RESULT:
	postgres: None

-----------
QUERY:


set enable_bitmapscan = 0;
RESULT:
	postgres: None

-----------
QUERY:

set enable_indexscan = 0;
RESULT:
	postgres: None

-----------
QUERY:


prepare ab_q6 as
select * from (
	select tableoid::regclass,a,b from ab
union all
	select tableoid::regclass,x,y from xy_1
union all
	select tableoid::regclass,a,b from ab
) ab where a = $1 and b = (select -10);
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure the xy_1 subplan is not pruned.
explain (analyze, costs off, summary off, timing off) execute ab_q6(1);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 12',), ('  InitPlan 1',), ('    ->  Result (actual rows=1 loops=1)',), ('  ->  Seq Scan on ab_a1_b1 ab_1 (never executed)',), ('        Filter: ((a = $1) AND (b = (InitPlan 1).col1))',), ('  ->  Seq Scan on ab_a1_b2 ab_2 (never executed)',), ('        Filter: ((a = $1) AND (b = (InitPlan 1).col1))',), ('  ->  Seq Scan on ab_a1_b3 ab_3 (never executed)',), ('        Filter: ((a = $1) AND (b = (InitPlan 1).col1))',), ('  ->  Seq Scan on xy_1 (actual rows=0 loops=1)',), ('        Filter: ((x = $1) AND (y = (InitPlan 1).col1))',), ('        Rows Removed by Filter: 1',), ('  ->  Seq Scan on ab_a1_b1 ab_4 (never executed)',), ('        Filter: ((a = $1) AND (b = (InitPlan 1).col1))',), ('  ->  Seq Scan on ab_a1_b2 ab_5 (never executed)',), ('        Filter: ((a = $1) AND (b = (InitPlan 1).col1))',), ('  ->  Seq Scan on ab_a1_b3 ab_6 (never executed)',), ('        Filter: ((a = $1) AND (b = (InitPlan 1).col1))',)]

-----------
QUERY:


-- Ensure we see just the xy_1 row.
execute ab_q6(100);
RESULT:
	postgres: [('xy_1', 100, -10)]

-----------
QUERY:


reset enable_bitmapscan;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_indexscan;
RESULT:
	postgres: None

-----------
QUERY:


deallocate ab_q1;
RESULT:
	postgres: None

-----------
QUERY:

deallocate ab_q2;
RESULT:
	postgres: None

-----------
QUERY:

deallocate ab_q3;
RESULT:
	postgres: None

-----------
QUERY:

deallocate ab_q4;
RESULT:
	postgres: None

-----------
QUERY:

deallocate ab_q5;
RESULT:
	postgres: None

-----------
QUERY:

deallocate ab_q6;
RESULT:
	postgres: None

-----------
QUERY:


-- Temporarily install some debugging to investigate plan instability.
select c.relname,c.relpages,c.reltuples,i.indisvalid,s.autovacuum_count,s.autoanalyze_count
from pg_class c
left join pg_stat_all_tables s on c.oid = s.relid
left join pg_index i on c.oid = i.indexrelid
where c.relname like 'ab\_%' order by c.relname;
RESULT:
	postgres: [('ab_a1', 0, -1.0, None, 0, 0), ('ab_a1_b1', 0, -1.0, None, 0, 0), ('ab_a1_b1_a_idx', 1, 0.0, True, None, None), ('ab_a1_b2', 0, -1.0, None, 0, 0), ('ab_a1_b2_a_idx', 1, 0.0, True, None, None), ('ab_a1_b3', 0, -1.0, None, 0, 0), ('ab_a1_b3_a_idx', 1, 0.0, True, None, None), ('ab_a2', 0, -1.0, None, 0, 0), ('ab_a2_b1', 0, -1.0, None, 0, 0), ('ab_a2_b1_a_idx', 1, 0.0, True, None, None), ('ab_a2_b2', 0, -1.0, None, 0, 0), ('ab_a2_b2_a_idx', 1, 0.0, True, None, None), ('ab_a2_b3', 0, -1.0, None, 0, 0), ('ab_a2_b3_a_idx', 1, 0.0, True, None, None), ('ab_a3', 0, -1.0, None, 0, 0), ('ab_a3_b1', 0, -1.0, None, 0, 0), ('ab_a3_b1_a_idx', 1, 0.0, True, None, None), ('ab_a3_b2', 0, -1.0, None, 0, 0), ('ab_a3_b2_a_idx', 1, 0.0, True, None, None), ('ab_a3_b3', 0, -1.0, None, 0, 0), ('ab_a3_b3_a_idx', 1, 0.0, True, None, None)]

-----------
QUERY:


-- UPDATE on a partition subtree has been seen to have problems.
insert into ab values (1,2);
RESULT:
	postgres: None

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
update ab_a1 set b = 3 from ab where ab.a = 1 and ab.a = ab_a1.a;
RESULT:
	postgres: [('Update on ab_a1 (actual rows=0 loops=1)',), ('  Update on ab_a1_b1 ab_a1_1',), ('  Update on ab_a1_b2 ab_a1_2',), ('  Update on ab_a1_b3 ab_a1_3',), ('  ->  Nested Loop (actual rows=1 loops=1)',), ('        ->  Append (actual rows=1 loops=1)',), ('              ->  Bitmap Heap Scan on ab_a1_b1 ab_a1_1 (actual rows=0 loops=1)',), ('                    Recheck Cond: (a = 1)',), ('                    ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)',), ('                          Index Cond: (a = 1)',), ('              ->  Bitmap Heap Scan on ab_a1_b2 ab_a1_2 (actual rows=1 loops=1)',), ('                    Recheck Cond: (a = 1)',), ('                    Heap Blocks: exact=1',), ('                    ->  Bitmap Index Scan on ab_a1_b2_a_idx (actual rows=1 loops=1)',), ('                          Index Cond: (a = 1)',), ('              ->  Bitmap Heap Scan on ab_a1_b3 ab_a1_3 (actual rows=0 loops=1)',), ('                    Recheck Cond: (a = 1)',), ('                    Heap Blocks: exact=1',), ('                    ->  Bitmap Index Scan on ab_a1_b3_a_idx (actual rows=1 loops=1)',), ('                          Index Cond: (a = 1)',), ('        ->  Materialize (actual rows=1 loops=1)',), ('              ->  Append (actual rows=1 loops=1)',), ('                    ->  Bitmap Heap Scan on ab_a1_b1 ab_1 (actual rows=0 loops=1)',), ('                          Recheck Cond: (a = 1)',), ('                          ->  Bitmap Index Scan on ab_a1_b1_a_idx (actual rows=0 loops=1)',), ('                                Index Cond: (a = 1)',), ('                    ->  Bitmap Heap Scan on ab_a1_b2 ab_2 (actual rows=1 loops=1)',), ('                          Recheck Cond: (a = 1)',), ('                          Heap Blocks: exact=1',), ('                          ->  Bitmap Index Scan on ab_a1_b2_a_idx (actual rows=1 loops=1)',), ('                                Index Cond: (a = 1)',), ('                    ->  Bitmap Heap Scan on ab_a1_b3 ab_3 (actual rows=0 loops=1)',), ('                          Recheck Cond: (a = 1)',), ('                          Heap Blocks: exact=1',), ('                          ->  Bitmap Index Scan on ab_a1_b3_a_idx (actual rows=1 loops=1)',), ('                                Index Cond: (a = 1)',)]

-----------
QUERY:

table ab;
RESULT:
	postgres: [(1, 3)]

-----------
QUERY:


-- Test UPDATE where source relation has run-time pruning enabled
truncate ab;
RESULT:
	postgres: None

-----------
QUERY:

insert into ab values (1, 1), (1, 2), (1, 3), (2, 1);
RESULT:
	postgres: None

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
update ab_a1 set b = 3 from ab_a2 where ab_a2.b = (select 1);
RESULT:
	postgres: [('Update on ab_a1 (actual rows=0 loops=1)',), ('  Update on ab_a1_b1 ab_a1_1',), ('  Update on ab_a1_b2 ab_a1_2',), ('  Update on ab_a1_b3 ab_a1_3',), ('  InitPlan 1',), ('    ->  Result (actual rows=1 loops=1)',), ('  ->  Nested Loop (actual rows=3 loops=1)',), ('        ->  Append (actual rows=3 loops=1)',), ('              ->  Seq Scan on ab_a1_b1 ab_a1_1 (actual rows=1 loops=1)',), ('              ->  Seq Scan on ab_a1_b2 ab_a1_2 (actual rows=1 loops=1)',), ('              ->  Seq Scan on ab_a1_b3 ab_a1_3 (actual rows=1 loops=1)',), ('        ->  Materialize (actual rows=1 loops=3)',), ('              ->  Append (actual rows=1 loops=1)',), ('                    ->  Seq Scan on ab_a2_b1 ab_a2_1 (actual rows=1 loops=1)',), ('                          Filter: (b = (InitPlan 1).col1)',), ('                    ->  Seq Scan on ab_a2_b2 ab_a2_2 (never executed)',), ('                          Filter: (b = (InitPlan 1).col1)',), ('                    ->  Seq Scan on ab_a2_b3 ab_a2_3 (never executed)',), ('                          Filter: (b = (InitPlan 1).col1)',)]

-----------
QUERY:

select tableoid::regclass, * from ab;
RESULT:
	postgres: [('ab_a1_b3', 1, 3), ('ab_a1_b3', 1, 3), ('ab_a1_b3', 1, 3), ('ab_a2_b1', 2, 1)]

-----------
QUERY:


drop table ab, lprt_a;
RESULT:
	postgres: None

-----------
QUERY:


-- Join
create table tbl1(col1 int);
RESULT:
	postgres: None

-----------
QUERY:

insert into tbl1 values (501), (505);
RESULT:
	postgres: None

-----------
QUERY:


-- Basic table
create table tprt (col1 int) partition by range (col1);
RESULT:
	postgres: None

-----------
QUERY:

create table tprt_1 partition of tprt for values from (1) to (501);
RESULT:
	postgres: None

-----------
QUERY:

create table tprt_2 partition of tprt for values from (501) to (1001);
RESULT:
	postgres: None

-----------
QUERY:

create table tprt_3 partition of tprt for values from (1001) to (2001);
RESULT:
	postgres: None

-----------
QUERY:

create table tprt_4 partition of tprt for values from (2001) to (3001);
RESULT:
	postgres: None

-----------
QUERY:

create table tprt_5 partition of tprt for values from (3001) to (4001);
RESULT:
	postgres: None

-----------
QUERY:

create table tprt_6 partition of tprt for values from (4001) to (5001);
RESULT:
	postgres: None

-----------
QUERY:


create index tprt1_idx on tprt_1 (col1);
RESULT:
	postgres: None

-----------
QUERY:

create index tprt2_idx on tprt_2 (col1);
RESULT:
	postgres: None

-----------
QUERY:

create index tprt3_idx on tprt_3 (col1);
RESULT:
	postgres: None

-----------
QUERY:

create index tprt4_idx on tprt_4 (col1);
RESULT:
	postgres: None

-----------
QUERY:

create index tprt5_idx on tprt_5 (col1);
RESULT:
	postgres: None

-----------
QUERY:

create index tprt6_idx on tprt_6 (col1);
RESULT:
	postgres: None

-----------
QUERY:


insert into tprt values (10), (20), (501), (502), (505), (1001), (4500);
RESULT:
	postgres: None

-----------
QUERY:


set enable_hashjoin = off;
RESULT:
	postgres: None

-----------
QUERY:

set enable_mergejoin = off;
RESULT:
	postgres: None

-----------
QUERY:


explain (analyze, costs off, summary off, timing off)
select * from tbl1 join tprt on tbl1.col1 > tprt.col1;
RESULT:
	postgres: [('Nested Loop (actual rows=6 loops=1)',), ('  ->  Seq Scan on tbl1 (actual rows=2 loops=1)',), ('  ->  Append (actual rows=3 loops=2)',), ('        ->  Index Scan using tprt1_idx on tprt_1 (actual rows=2 loops=2)',), ('              Index Cond: (col1 < tbl1.col1)',), ('        ->  Index Scan using tprt2_idx on tprt_2 (actual rows=2 loops=1)',), ('              Index Cond: (col1 < tbl1.col1)',), ('        ->  Index Scan using tprt3_idx on tprt_3 (never executed)',), ('              Index Cond: (col1 < tbl1.col1)',), ('        ->  Index Scan using tprt4_idx on tprt_4 (never executed)',), ('              Index Cond: (col1 < tbl1.col1)',), ('        ->  Index Scan using tprt5_idx on tprt_5 (never executed)',), ('              Index Cond: (col1 < tbl1.col1)',), ('        ->  Index Scan using tprt6_idx on tprt_6 (never executed)',), ('              Index Cond: (col1 < tbl1.col1)',)]

-----------
QUERY:


explain (analyze, costs off, summary off, timing off)
select * from tbl1 join tprt on tbl1.col1 = tprt.col1;
RESULT:
	postgres: [('Nested Loop (actual rows=2 loops=1)',), ('  ->  Seq Scan on tbl1 (actual rows=2 loops=1)',), ('  ->  Append (actual rows=1 loops=2)',), ('        ->  Index Scan using tprt1_idx on tprt_1 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt2_idx on tprt_2 (actual rows=1 loops=2)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt3_idx on tprt_3 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt4_idx on tprt_4 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt5_idx on tprt_5 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt6_idx on tprt_6 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',)]

-----------
QUERY:


select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 > tprt.col1
order by tbl1.col1, tprt.col1;
RESULT:
	postgres: [(501, 10), (501, 20), (505, 10), (505, 20), (505, 501), (505, 502)]

-----------
QUERY:


select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 = tprt.col1
order by tbl1.col1, tprt.col1;
RESULT:
	postgres: [(501, 501), (505, 505)]

-----------
QUERY:


-- Multiple partitions
insert into tbl1 values (1001), (1010), (1011);
RESULT:
	postgres: None

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
select * from tbl1 inner join tprt on tbl1.col1 > tprt.col1;
RESULT:
	postgres: [('Nested Loop (actual rows=23 loops=1)',), ('  ->  Seq Scan on tbl1 (actual rows=5 loops=1)',), ('  ->  Append (actual rows=5 loops=5)',), ('        ->  Index Scan using tprt1_idx on tprt_1 (actual rows=2 loops=5)',), ('              Index Cond: (col1 < tbl1.col1)',), ('        ->  Index Scan using tprt2_idx on tprt_2 (actual rows=3 loops=4)',), ('              Index Cond: (col1 < tbl1.col1)',), ('        ->  Index Scan using tprt3_idx on tprt_3 (actual rows=1 loops=2)',), ('              Index Cond: (col1 < tbl1.col1)',), ('        ->  Index Scan using tprt4_idx on tprt_4 (never executed)',), ('              Index Cond: (col1 < tbl1.col1)',), ('        ->  Index Scan using tprt5_idx on tprt_5 (never executed)',), ('              Index Cond: (col1 < tbl1.col1)',), ('        ->  Index Scan using tprt6_idx on tprt_6 (never executed)',), ('              Index Cond: (col1 < tbl1.col1)',)]

-----------
QUERY:


explain (analyze, costs off, summary off, timing off)
select * from tbl1 inner join tprt on tbl1.col1 = tprt.col1;
RESULT:
	postgres: [('Nested Loop (actual rows=3 loops=1)',), ('  ->  Seq Scan on tbl1 (actual rows=5 loops=1)',), ('  ->  Append (actual rows=1 loops=5)',), ('        ->  Index Scan using tprt1_idx on tprt_1 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt2_idx on tprt_2 (actual rows=1 loops=2)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt3_idx on tprt_3 (actual rows=0 loops=3)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt4_idx on tprt_4 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt5_idx on tprt_5 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt6_idx on tprt_6 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',)]

-----------
QUERY:


select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 > tprt.col1
order by tbl1.col1, tprt.col1;
RESULT:
	postgres: [(501, 10), (501, 20), (505, 10), (505, 20), (505, 501), (505, 502), (1001, 10), (1001, 20), (1001, 501), (1001, 502), (1001, 505), (1010, 10), (1010, 20), (1010, 501), (1010, 502), (1010, 505), (1010, 1001), (1011, 10), (1011, 20), (1011, 501), (1011, 502), (1011, 505), (1011, 1001)]

-----------
QUERY:


select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 = tprt.col1
order by tbl1.col1, tprt.col1;
RESULT:
	postgres: [(501, 501), (505, 505), (1001, 1001)]

-----------
QUERY:


-- Last partition
delete from tbl1;
RESULT:
	postgres: None

-----------
QUERY:

insert into tbl1 values (4400);
RESULT:
	postgres: None

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
select * from tbl1 join tprt on tbl1.col1 < tprt.col1;
RESULT:
	postgres: [('Nested Loop (actual rows=1 loops=1)',), ('  ->  Seq Scan on tbl1 (actual rows=1 loops=1)',), ('  ->  Append (actual rows=1 loops=1)',), ('        ->  Index Scan using tprt1_idx on tprt_1 (never executed)',), ('              Index Cond: (col1 > tbl1.col1)',), ('        ->  Index Scan using tprt2_idx on tprt_2 (never executed)',), ('              Index Cond: (col1 > tbl1.col1)',), ('        ->  Index Scan using tprt3_idx on tprt_3 (never executed)',), ('              Index Cond: (col1 > tbl1.col1)',), ('        ->  Index Scan using tprt4_idx on tprt_4 (never executed)',), ('              Index Cond: (col1 > tbl1.col1)',), ('        ->  Index Scan using tprt5_idx on tprt_5 (never executed)',), ('              Index Cond: (col1 > tbl1.col1)',), ('        ->  Index Scan using tprt6_idx on tprt_6 (actual rows=1 loops=1)',), ('              Index Cond: (col1 > tbl1.col1)',)]

-----------
QUERY:


select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 < tprt.col1
order by tbl1.col1, tprt.col1;
RESULT:
	postgres: [(4400, 4500)]

-----------
QUERY:


-- No matching partition
delete from tbl1;
RESULT:
	postgres: None

-----------
QUERY:

insert into tbl1 values (10000);
RESULT:
	postgres: None

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
select * from tbl1 join tprt on tbl1.col1 = tprt.col1;
RESULT:
	postgres: [('Nested Loop (actual rows=0 loops=1)',), ('  ->  Seq Scan on tbl1 (actual rows=1 loops=1)',), ('  ->  Append (actual rows=0 loops=1)',), ('        ->  Index Scan using tprt1_idx on tprt_1 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt2_idx on tprt_2 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt3_idx on tprt_3 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt4_idx on tprt_4 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt5_idx on tprt_5 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',), ('        ->  Index Scan using tprt6_idx on tprt_6 (never executed)',), ('              Index Cond: (col1 = tbl1.col1)',)]

-----------
QUERY:


select tbl1.col1, tprt.col1 from tbl1
inner join tprt on tbl1.col1 = tprt.col1
order by tbl1.col1, tprt.col1;
RESULT:
	postgres: []

-----------
QUERY:


drop table tbl1, tprt;
RESULT:
	postgres: None

-----------
QUERY:


-- Test with columns defined in varying orders between each level
create table part_abc (a int not null, b int not null, c int not null) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table part_bac (b int not null, a int not null, c int not null) partition by list (b);
RESULT:
	postgres: None

-----------
QUERY:

create table part_cab (c int not null, a int not null, b int not null) partition by list (c);
RESULT:
	postgres: None

-----------
QUERY:

create table part_abc_p1 (a int not null, b int not null, c int not null);
RESULT:
	postgres: None

-----------
QUERY:


alter table part_abc attach partition part_bac for values in(1);
RESULT:
	postgres: None

-----------
QUERY:

alter table part_bac attach partition part_cab for values in(2);
RESULT:
	postgres: None

-----------
QUERY:

alter table part_cab attach partition part_abc_p1 for values in(3);
RESULT:
	postgres: None

-----------
QUERY:


prepare part_abc_q1 (int, int, int) as
select * from part_abc where a = $1 and b = $2 and c = $3;
RESULT:
	postgres: None

-----------
QUERY:


-- Single partition should be scanned.
explain (analyze, costs off, summary off, timing off) execute part_abc_q1 (1, 2, 3);
RESULT:
	postgres: [('Seq Scan on part_abc_p1 part_abc (actual rows=0 loops=1)',), ('  Filter: ((a = $1) AND (b = $2) AND (c = $3))',)]

-----------
QUERY:


deallocate part_abc_q1;
RESULT:
	postgres: None

-----------
QUERY:


drop table part_abc;
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure that an Append node properly handles a sub-partitioned table
-- matching without any of its leaf partitions matching the clause.
create table listp (a int, b int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table listp_1 partition of listp for values in(1) partition by list (b);
RESULT:
	postgres: None

-----------
QUERY:

create table listp_1_1 partition of listp_1 for values in(1);
RESULT:
	postgres: None

-----------
QUERY:

create table listp_2 partition of listp for values in(2) partition by list (b);
RESULT:
	postgres: None

-----------
QUERY:

create table listp_2_1 partition of listp_2 for values in(2);
RESULT:
	postgres: None

-----------
QUERY:

select * from listp where b = 1;
RESULT:
	postgres: []

-----------
QUERY:


-- Ensure that an Append node properly can handle selection of all first level
-- partitions before finally detecting the correct set of 2nd level partitions
-- which match the given parameter.
prepare q1 (int,int) as select * from listp where b in ($1,$2);
RESULT:
	postgres: None

-----------
QUERY:


explain (analyze, costs off, summary off, timing off)  execute q1 (1,1);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 1',), ('  ->  Seq Scan on listp_1_1 listp_1 (actual rows=0 loops=1)',), ('        Filter: (b = ANY (ARRAY[$1, $2]))',)]

-----------
QUERY:


explain (analyze, costs off, summary off, timing off)  execute q1 (2,2);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 1',), ('  ->  Seq Scan on listp_2_1 listp_1 (actual rows=0 loops=1)',), ('        Filter: (b = ANY (ARRAY[$1, $2]))',)]

-----------
QUERY:


-- Try with no matching partitions.
explain (analyze, costs off, summary off, timing off)  execute q1 (0,0);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 2',)]

-----------
QUERY:


deallocate q1;
RESULT:
	postgres: None

-----------
QUERY:


-- Test more complex cases where a not-equal condition further eliminates partitions.
prepare q1 (int,int,int,int) as select * from listp where b in($1,$2) and $3 <> b and $4 <> b;
RESULT:
	postgres: None

-----------
QUERY:


-- Both partitions allowed by IN clause, but one disallowed by <> clause
explain (analyze, costs off, summary off, timing off)  execute q1 (1,2,2,0);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 1',), ('  ->  Seq Scan on listp_1_1 listp_1 (actual rows=0 loops=1)',), ('        Filter: ((b = ANY (ARRAY[$1, $2])) AND ($3 <> b) AND ($4 <> b))',)]

-----------
QUERY:


-- Both partitions allowed by IN clause, then both excluded again by <> clauses.
explain (analyze, costs off, summary off, timing off)  execute q1 (1,2,2,1);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 2',)]

-----------
QUERY:


-- Ensure Params that evaluate to NULL properly prune away all partitions
explain (analyze, costs off, summary off, timing off)
select * from listp where a = (select null::int);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  InitPlan 1',), ('    ->  Result (actual rows=1 loops=1)',), ('  ->  Seq Scan on listp_1_1 listp_1 (never executed)',), ('        Filter: (a = (InitPlan 1).col1)',), ('  ->  Seq Scan on listp_2_1 listp_2 (never executed)',), ('        Filter: (a = (InitPlan 1).col1)',)]

-----------
QUERY:


drop table listp;
RESULT:
	postgres: None

-----------
QUERY:


--
-- check that stable query clauses are only used in run-time pruning
--
create table stable_qual_pruning (a timestamp) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table stable_qual_pruning1 partition of stable_qual_pruning
  for values from ('2000-01-01') to ('2000-02-01');
RESULT:
	postgres: None

-----------
QUERY:

create table stable_qual_pruning2 partition of stable_qual_pruning
  for values from ('2000-02-01') to ('2000-03-01');
RESULT:
	postgres: None

-----------
QUERY:

create table stable_qual_pruning3 partition of stable_qual_pruning
  for values from ('3000-02-01') to ('3000-03-01');
RESULT:
	postgres: None

-----------
QUERY:


-- comparison against a stable value requires run-time pruning
explain (analyze, costs off, summary off, timing off)
select * from stable_qual_pruning where a < localtimestamp;
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 1',), ('  ->  Seq Scan on stable_qual_pruning1 stable_qual_pruning_1 (actual rows=0 loops=1)',), ('        Filter: (a < LOCALTIMESTAMP)',), ('  ->  Seq Scan on stable_qual_pruning2 stable_qual_pruning_2 (actual rows=0 loops=1)',), ('        Filter: (a < LOCALTIMESTAMP)',)]

-----------
QUERY:


-- timestamp < timestamptz comparison is only stable, not immutable
explain (analyze, costs off, summary off, timing off)
select * from stable_qual_pruning where a < '2000-02-01'::timestamptz;
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 2',), ('  ->  Seq Scan on stable_qual_pruning1 stable_qual_pruning_1 (actual rows=0 loops=1)',), ("        Filter: (a < '2000-02-01 00:00:00+01'::timestamp with time zone)",)]

-----------
QUERY:


-- check ScalarArrayOp cases
explain (analyze, costs off, summary off, timing off)
select * from stable_qual_pruning
  where a = any(array['2010-02-01', '2020-01-01']::timestamp[]);
RESULT:
	postgres: [('Result (actual rows=0 loops=1)',), ('  One-Time Filter: false',)]

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
select * from stable_qual_pruning
  where a = any(array['2000-02-01', '2010-01-01']::timestamp[]);
RESULT:
	postgres: [('Seq Scan on stable_qual_pruning2 stable_qual_pruning (actual rows=0 loops=1)',), ('  Filter: (a = ANY (\'{"2000-02-01 00:00:00","2010-01-01 00:00:00"}\'::timestamp without time zone[]))',)]

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
select * from stable_qual_pruning
  where a = any(array['2000-02-01', localtimestamp]::timestamp[]);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 2',), ('  ->  Seq Scan on stable_qual_pruning2 stable_qual_pruning_1 (actual rows=0 loops=1)',), ("        Filter: (a = ANY (ARRAY['2000-02-01 00:00:00'::timestamp without time zone, LOCALTIMESTAMP]))",)]

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
select * from stable_qual_pruning
  where a = any(array['2010-02-01', '2020-01-01']::timestamptz[]);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 3',)]

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
select * from stable_qual_pruning
  where a = any(array['2000-02-01', '2010-01-01']::timestamptz[]);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  Subplans Removed: 2',), ('  ->  Seq Scan on stable_qual_pruning2 stable_qual_pruning_1 (actual rows=0 loops=1)',), ('        Filter: (a = ANY (\'{"2000-02-01 00:00:00+01","2010-01-01 00:00:00+01"}\'::timestamp with time zone[]))',)]

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
select * from stable_qual_pruning
  where a = any(null::timestamptz[]);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  ->  Seq Scan on stable_qual_pruning1 stable_qual_pruning_1 (actual rows=0 loops=1)',), ('        Filter: (a = ANY (NULL::timestamp with time zone[]))',), ('  ->  Seq Scan on stable_qual_pruning2 stable_qual_pruning_2 (actual rows=0 loops=1)',), ('        Filter: (a = ANY (NULL::timestamp with time zone[]))',), ('  ->  Seq Scan on stable_qual_pruning3 stable_qual_pruning_3 (actual rows=0 loops=1)',), ('        Filter: (a = ANY (NULL::timestamp with time zone[]))',)]

-----------
QUERY:


drop table stable_qual_pruning;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Check that pruning with composite range partitioning works correctly when
-- it must ignore clauses for trailing keys once it has seen a clause with
-- non-inclusive operator for an earlier key
--
create table mc3p (a int, b int, c int) partition by range (a, abs(b), c);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p0 partition of mc3p
  for values from (0, 0, 0) to (0, maxvalue, maxvalue);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p1 partition of mc3p
  for values from (1, 1, 1) to (2, minvalue, minvalue);
RESULT:
	postgres: None

-----------
QUERY:

create table mc3p2 partition of mc3p
  for values from (2, minvalue, minvalue) to (3, maxvalue, maxvalue);
RESULT:
	postgres: None

-----------
QUERY:

insert into mc3p values (0, 1, 1), (1, 1, 1), (2, 1, 1);
RESULT:
	postgres: None

-----------
QUERY:


explain (analyze, costs off, summary off, timing off)
select * from mc3p where a < 3 and abs(b) = 1;
RESULT:
	postgres: [('Append (actual rows=3 loops=1)',), ('  ->  Seq Scan on mc3p0 mc3p_1 (actual rows=1 loops=1)',), ('        Filter: ((a < 3) AND (abs(b) = 1))',), ('  ->  Seq Scan on mc3p1 mc3p_2 (actual rows=1 loops=1)',), ('        Filter: ((a < 3) AND (abs(b) = 1))',), ('  ->  Seq Scan on mc3p2 mc3p_3 (actual rows=1 loops=1)',), ('        Filter: ((a < 3) AND (abs(b) = 1))',)]

-----------
QUERY:


--
-- Check that pruning with composite range partitioning works correctly when
-- a combination of runtime parameters is specified, not all of whose values
-- are available at the same time
--
prepare ps1 as
  select * from mc3p where a = $1 and abs(b) < (select 3);
RESULT:
	postgres: None

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
execute ps1(1);
RESULT:
	postgres: [('Append (actual rows=1 loops=1)',), ('  Subplans Removed: 2',), ('  InitPlan 1',), ('    ->  Result (actual rows=1 loops=1)',), ('  ->  Seq Scan on mc3p1 mc3p_1 (actual rows=1 loops=1)',), ('        Filter: ((a = $1) AND (abs(b) < (InitPlan 1).col1))',)]

-----------
QUERY:

deallocate ps1;
RESULT:
	postgres: None

-----------
QUERY:

prepare ps2 as
  select * from mc3p where a <= $1 and abs(b) < (select 3);
RESULT:
	postgres: None

-----------
QUERY:

explain (analyze, costs off, summary off, timing off)
execute ps2(1);
RESULT:
	postgres: [('Append (actual rows=2 loops=1)',), ('  Subplans Removed: 1',), ('  InitPlan 1',), ('    ->  Result (actual rows=1 loops=1)',), ('  ->  Seq Scan on mc3p0 mc3p_1 (actual rows=1 loops=1)',), ('        Filter: ((a <= $1) AND (abs(b) < (InitPlan 1).col1))',), ('  ->  Seq Scan on mc3p1 mc3p_2 (actual rows=1 loops=1)',), ('        Filter: ((a <= $1) AND (abs(b) < (InitPlan 1).col1))',)]

-----------
QUERY:

deallocate ps2;
RESULT:
	postgres: None

-----------
QUERY:


drop table mc3p;
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure runtime pruning works with initplans params with boolean types
create table boolvalues (value bool not null);
RESULT:
	postgres: None

-----------
QUERY:

insert into boolvalues values('t'),('f');
RESULT:
	postgres: None

-----------
QUERY:


create table boolp (a bool) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table boolp_t partition of boolp for values in('t');
RESULT:
	postgres: None

-----------
QUERY:

create table boolp_f partition of boolp for values in('f');
RESULT:
	postgres: None

-----------
QUERY:


explain (analyze, costs off, summary off, timing off)
select * from boolp where a = (select value from boolvalues where value);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  InitPlan 1',), ('    ->  Seq Scan on boolvalues (actual rows=1 loops=1)',), ('          Filter: value',), ('          Rows Removed by Filter: 1',), ('  ->  Seq Scan on boolp_f boolp_1 (never executed)',), ('        Filter: (a = (InitPlan 1).col1)',), ('  ->  Seq Scan on boolp_t boolp_2 (actual rows=0 loops=1)',), ('        Filter: (a = (InitPlan 1).col1)',)]

-----------
QUERY:


explain (analyze, costs off, summary off, timing off)
select * from boolp where a = (select value from boolvalues where not value);
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  InitPlan 1',), ('    ->  Seq Scan on boolvalues (actual rows=1 loops=1)',), ('          Filter: (NOT value)',), ('          Rows Removed by Filter: 1',), ('  ->  Seq Scan on boolp_f boolp_1 (actual rows=0 loops=1)',), ('        Filter: (a = (InitPlan 1).col1)',), ('  ->  Seq Scan on boolp_t boolp_2 (never executed)',), ('        Filter: (a = (InitPlan 1).col1)',)]

-----------
QUERY:


drop table boolp;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test run-time pruning of MergeAppend subnodes
--
set enable_seqscan = off;
RESULT:
	postgres: None

-----------
QUERY:

set enable_sort = off;
RESULT:
	postgres: None

-----------
QUERY:

create table ma_test (a int, b int) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table ma_test_p1 partition of ma_test for values from (0) to (10);
RESULT:
	postgres: None

-----------
QUERY:

create table ma_test_p2 partition of ma_test for values from (10) to (20);
RESULT:
	postgres: None

-----------
QUERY:

create table ma_test_p3 partition of ma_test for values from (20) to (30);
RESULT:
	postgres: None

-----------
QUERY:

insert into ma_test select x,x from generate_series(0,29) t(x);
RESULT:
	postgres: None

-----------
QUERY:

create index on ma_test (b);
RESULT:
	postgres: None

-----------
QUERY:


analyze ma_test;
RESULT:
	postgres: None

-----------
QUERY:

prepare mt_q1 (int) as select a from ma_test where a >= $1 and a % 10 = 5 order by b;
RESULT:
	postgres: None

-----------
QUERY:


explain (analyze, costs off, summary off, timing off) execute mt_q1(15);
RESULT:
	postgres: [('Merge Append (actual rows=2 loops=1)',), ('  Sort Key: ma_test.b',), ('  Subplans Removed: 1',), ('  ->  Index Scan using ma_test_p2_b_idx on ma_test_p2 ma_test_1 (actual rows=1 loops=1)',), ('        Filter: ((a >= $1) AND ((a % 10) = 5))',), ('        Rows Removed by Filter: 9',), ('  ->  Index Scan using ma_test_p3_b_idx on ma_test_p3 ma_test_2 (actual rows=1 loops=1)',), ('        Filter: ((a >= $1) AND ((a % 10) = 5))',), ('        Rows Removed by Filter: 9',)]

-----------
QUERY:

execute mt_q1(15);
RESULT:
	postgres: [(15,), (25,)]

-----------
QUERY:

explain (analyze, costs off, summary off, timing off) execute mt_q1(25);
RESULT:
	postgres: [('Merge Append (actual rows=1 loops=1)',), ('  Sort Key: ma_test.b',), ('  Subplans Removed: 2',), ('  ->  Index Scan using ma_test_p3_b_idx on ma_test_p3 ma_test_1 (actual rows=1 loops=1)',), ('        Filter: ((a >= $1) AND ((a % 10) = 5))',), ('        Rows Removed by Filter: 9',)]

-----------
QUERY:

execute mt_q1(25);
RESULT:
	postgres: [(25,)]

-----------
QUERY:

-- Ensure MergeAppend behaves correctly when no subplans match
explain (analyze, costs off, summary off, timing off) execute mt_q1(35);
RESULT:
	postgres: [('Merge Append (actual rows=0 loops=1)',), ('  Sort Key: ma_test.b',), ('  Subplans Removed: 3',)]

-----------
QUERY:

execute mt_q1(35);
RESULT:
	postgres: []

-----------
QUERY:


deallocate mt_q1;
RESULT:
	postgres: None

-----------
QUERY:


prepare mt_q2 (int) as select * from ma_test where a >= $1 order by b limit 1;
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure output list looks sane when the MergeAppend has no subplans.
explain (analyze, verbose, costs off, summary off, timing off) execute mt_q2 (35);
RESULT:
	postgres: [('Limit (actual rows=0 loops=1)',), ('  Output: ma_test.a, ma_test.b',), ('  ->  Merge Append (actual rows=0 loops=1)',), ('        Sort Key: ma_test.b',), ('        Subplans Removed: 3',)]

-----------
QUERY:


deallocate mt_q2;
RESULT:
	postgres: None

-----------
QUERY:


-- ensure initplan params properly prune partitions
explain (analyze, costs off, summary off, timing off) select * from ma_test where a >= (select min(b) from ma_test_p2) order by b;
RESULT:
	postgres: [('Merge Append (actual rows=20 loops=1)',), ('  Sort Key: ma_test.b',), ('  InitPlan 2',), ('    ->  Result (actual rows=1 loops=1)',), ('          InitPlan 1',), ('            ->  Limit (actual rows=1 loops=1)',), ('                  ->  Index Scan using ma_test_p2_b_idx on ma_test_p2 (actual rows=1 loops=1)',), ('                        Index Cond: (b IS NOT NULL)',), ('  ->  Index Scan using ma_test_p1_b_idx on ma_test_p1 ma_test_1 (never executed)',), ('        Filter: (a >= (InitPlan 2).col1)',), ('  ->  Index Scan using ma_test_p2_b_idx on ma_test_p2 ma_test_2 (actual rows=10 loops=1)',), ('        Filter: (a >= (InitPlan 2).col1)',), ('  ->  Index Scan using ma_test_p3_b_idx on ma_test_p3 ma_test_3 (actual rows=10 loops=1)',), ('        Filter: (a >= (InitPlan 2).col1)',)]

-----------
QUERY:


reset enable_seqscan;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_sort;
RESULT:
	postgres: None

-----------
QUERY:


drop table ma_test;
RESULT:
	postgres: None

-----------
QUERY:


reset enable_indexonlyscan;
RESULT:
	postgres: None

-----------
QUERY:


--
-- check that pruning works properly when the partition key is of a
-- pseudotype
--

-- array type list partition key
create table pp_arrpart (a int[]) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table pp_arrpart1 partition of pp_arrpart for values in ('{1}');
RESULT:
	postgres: None

-----------
QUERY:

create table pp_arrpart2 partition of pp_arrpart for values in ('{2, 3}', '{4, 5}');
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from pp_arrpart where a = '{1}';
RESULT:
	postgres: [('Seq Scan on pp_arrpart1 pp_arrpart',), ("  Filter: (a = '{1}'::integer[])",)]

-----------
QUERY:

explain (costs off) select * from pp_arrpart where a = '{1, 2}';
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

explain (costs off) select * from pp_arrpart where a in ('{4, 5}', '{1}');
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on pp_arrpart1 pp_arrpart_1',), ("        Filter: ((a = '{4,5}'::integer[]) OR (a = '{1}'::integer[]))",), ('  ->  Seq Scan on pp_arrpart2 pp_arrpart_2',), ("        Filter: ((a = '{4,5}'::integer[]) OR (a = '{1}'::integer[]))",)]

-----------
QUERY:

explain (costs off) update pp_arrpart set a = a where a = '{1}';
RESULT:
	postgres: [('Update on pp_arrpart',), ('  Update on pp_arrpart1 pp_arrpart_1',), ('  ->  Seq Scan on pp_arrpart1 pp_arrpart_1',), ("        Filter: (a = '{1}'::integer[])",)]

-----------
QUERY:

explain (costs off) delete from pp_arrpart where a = '{1}';
RESULT:
	postgres: [('Delete on pp_arrpart',), ('  Delete on pp_arrpart1 pp_arrpart_1',), ('  ->  Seq Scan on pp_arrpart1 pp_arrpart_1',), ("        Filter: (a = '{1}'::integer[])",)]

-----------
QUERY:

drop table pp_arrpart;
RESULT:
	postgres: None

-----------
QUERY:


-- array type hash partition key
create table pph_arrpart (a int[]) partition by hash (a);
RESULT:
	postgres: None

-----------
QUERY:

create table pph_arrpart1 partition of pph_arrpart for values with (modulus 2, remainder 0);
RESULT:
	postgres: None

-----------
QUERY:

create table pph_arrpart2 partition of pph_arrpart for values with (modulus 2, remainder 1);
RESULT:
	postgres: None

-----------
QUERY:

insert into pph_arrpart values ('{1}'), ('{1, 2}'), ('{4, 5}');
RESULT:
	postgres: None

-----------
QUERY:

select tableoid::regclass, * from pph_arrpart order by 1;
RESULT:
	postgres: [('pph_arrpart1', [1, 2]), ('pph_arrpart1', [4, 5]), ('pph_arrpart2', [1])]

-----------
QUERY:

explain (costs off) select * from pph_arrpart where a = '{1}';
RESULT:
	postgres: [('Seq Scan on pph_arrpart2 pph_arrpart',), ("  Filter: (a = '{1}'::integer[])",)]

-----------
QUERY:

explain (costs off) select * from pph_arrpart where a = '{1, 2}';
RESULT:
	postgres: [('Seq Scan on pph_arrpart1 pph_arrpart',), ("  Filter: (a = '{1,2}'::integer[])",)]

-----------
QUERY:

explain (costs off) select * from pph_arrpart where a in ('{4, 5}', '{1}');
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on pph_arrpart1 pph_arrpart_1',), ("        Filter: ((a = '{4,5}'::integer[]) OR (a = '{1}'::integer[]))",), ('  ->  Seq Scan on pph_arrpart2 pph_arrpart_2',), ("        Filter: ((a = '{4,5}'::integer[]) OR (a = '{1}'::integer[]))",)]

-----------
QUERY:

drop table pph_arrpart;
RESULT:
	postgres: None

-----------
QUERY:


-- enum type list partition key
create type pp_colors as enum ('green', 'blue', 'black');
RESULT:
	postgres: None

-----------
QUERY:

create table pp_enumpart (a pp_colors) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table pp_enumpart_green partition of pp_enumpart for values in ('green');
RESULT:
	postgres: None

-----------
QUERY:

create table pp_enumpart_blue partition of pp_enumpart for values in ('blue');
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from pp_enumpart where a = 'blue';
RESULT:
	postgres: [('Seq Scan on pp_enumpart_blue pp_enumpart',), ("  Filter: (a = 'blue'::pp_colors)",)]

-----------
QUERY:

explain (costs off) select * from pp_enumpart where a = 'black';
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

drop table pp_enumpart;
RESULT:
	postgres: None

-----------
QUERY:

drop type pp_colors;
RESULT:
	postgres: None

-----------
QUERY:


-- record type as partition key
create type pp_rectype as (a int, b int);
RESULT:
	postgres: None

-----------
QUERY:

create table pp_recpart (a pp_rectype) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table pp_recpart_11 partition of pp_recpart for values in ('(1,1)');
RESULT:
	postgres: None

-----------
QUERY:

create table pp_recpart_23 partition of pp_recpart for values in ('(2,3)');
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from pp_recpart where a = '(1,1)'::pp_rectype;
RESULT:
	postgres: [('Seq Scan on pp_recpart_11 pp_recpart',), ("  Filter: (a = '(1,1)'::pp_rectype)",)]

-----------
QUERY:

explain (costs off) select * from pp_recpart where a = '(1,2)'::pp_rectype;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

drop table pp_recpart;
RESULT:
	postgres: None

-----------
QUERY:

drop type pp_rectype;
RESULT:
	postgres: None

-----------
QUERY:


-- range type partition key
create table pp_intrangepart (a int4range) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table pp_intrangepart12 partition of pp_intrangepart for values in ('[1,2]');
RESULT:
	postgres: None

-----------
QUERY:

create table pp_intrangepart2inf partition of pp_intrangepart for values in ('[2,)');
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from pp_intrangepart where a = '[1,2]'::int4range;
RESULT:
	postgres: [('Seq Scan on pp_intrangepart12 pp_intrangepart',), ("  Filter: (a = '[1,3)'::int4range)",)]

-----------
QUERY:

explain (costs off) select * from pp_intrangepart where a = '(1,2)'::int4range;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

drop table pp_intrangepart;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Ensure the enable_partition_prune GUC properly disables partition pruning.
--

create table pp_lp (a int, value int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table pp_lp1 partition of pp_lp for values in(1);
RESULT:
	postgres: None

-----------
QUERY:

create table pp_lp2 partition of pp_lp for values in(2);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from pp_lp where a = 1;
RESULT:
	postgres: [('Seq Scan on pp_lp1 pp_lp',), ('  Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) update pp_lp set value = 10 where a = 1;
RESULT:
	postgres: [('Update on pp_lp',), ('  Update on pp_lp1 pp_lp_1',), ('  ->  Seq Scan on pp_lp1 pp_lp_1',), ('        Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) delete from pp_lp where a = 1;
RESULT:
	postgres: [('Delete on pp_lp',), ('  Delete on pp_lp1 pp_lp_1',), ('  ->  Seq Scan on pp_lp1 pp_lp_1',), ('        Filter: (a = 1)',)]

-----------
QUERY:


set enable_partition_pruning = off;
RESULT:
	postgres: None

-----------
QUERY:


set constraint_exclusion = 'partition';
RESULT:
	postgres: None

-----------
QUERY:
 -- this should not affect the result.

explain (costs off) select * from pp_lp where a = 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on pp_lp1 pp_lp_1',), ('        Filter: (a = 1)',), ('  ->  Seq Scan on pp_lp2 pp_lp_2',), ('        Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) update pp_lp set value = 10 where a = 1;
RESULT:
	postgres: [('Update on pp_lp',), ('  Update on pp_lp1 pp_lp_1',), ('  Update on pp_lp2 pp_lp_2',), ('  ->  Append',), ('        ->  Seq Scan on pp_lp1 pp_lp_1',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on pp_lp2 pp_lp_2',), ('              Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) delete from pp_lp where a = 1;
RESULT:
	postgres: [('Delete on pp_lp',), ('  Delete on pp_lp1 pp_lp_1',), ('  Delete on pp_lp2 pp_lp_2',), ('  ->  Append',), ('        ->  Seq Scan on pp_lp1 pp_lp_1',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on pp_lp2 pp_lp_2',), ('              Filter: (a = 1)',)]

-----------
QUERY:


set constraint_exclusion = 'off';
RESULT:
	postgres: None

-----------
QUERY:
 -- this should not affect the result.

explain (costs off) select * from pp_lp where a = 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on pp_lp1 pp_lp_1',), ('        Filter: (a = 1)',), ('  ->  Seq Scan on pp_lp2 pp_lp_2',), ('        Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) update pp_lp set value = 10 where a = 1;
RESULT:
	postgres: [('Update on pp_lp',), ('  Update on pp_lp1 pp_lp_1',), ('  Update on pp_lp2 pp_lp_2',), ('  ->  Append',), ('        ->  Seq Scan on pp_lp1 pp_lp_1',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on pp_lp2 pp_lp_2',), ('              Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) delete from pp_lp where a = 1;
RESULT:
	postgres: [('Delete on pp_lp',), ('  Delete on pp_lp1 pp_lp_1',), ('  Delete on pp_lp2 pp_lp_2',), ('  ->  Append',), ('        ->  Seq Scan on pp_lp1 pp_lp_1',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on pp_lp2 pp_lp_2',), ('              Filter: (a = 1)',)]

-----------
QUERY:


drop table pp_lp;
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure enable_partition_prune does not affect non-partitioned tables.

create table inh_lp (a int, value int);
RESULT:
	postgres: None

-----------
QUERY:

create table inh_lp1 (a int, value int, check(a = 1)) inherits (inh_lp);
RESULT:
	postgres: None

-----------
QUERY:

create table inh_lp2 (a int, value int, check(a = 2)) inherits (inh_lp);
RESULT:
	postgres: None

-----------
QUERY:


set constraint_exclusion = 'partition';
RESULT:
	postgres: None

-----------
QUERY:


-- inh_lp2 should be removed in the following 3 cases.
explain (costs off) select * from inh_lp where a = 1;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on inh_lp inh_lp_1',), ('        Filter: (a = 1)',), ('  ->  Seq Scan on inh_lp1 inh_lp_2',), ('        Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) update inh_lp set value = 10 where a = 1;
RESULT:
	postgres: [('Update on inh_lp',), ('  Update on inh_lp inh_lp_1',), ('  Update on inh_lp1 inh_lp_2',), ('  ->  Result',), ('        ->  Append',), ('              ->  Seq Scan on inh_lp inh_lp_1',), ('                    Filter: (a = 1)',), ('              ->  Seq Scan on inh_lp1 inh_lp_2',), ('                    Filter: (a = 1)',)]

-----------
QUERY:

explain (costs off) delete from inh_lp where a = 1;
RESULT:
	postgres: [('Delete on inh_lp',), ('  Delete on inh_lp inh_lp_1',), ('  Delete on inh_lp1 inh_lp_2',), ('  ->  Append',), ('        ->  Seq Scan on inh_lp inh_lp_1',), ('              Filter: (a = 1)',), ('        ->  Seq Scan on inh_lp1 inh_lp_2',), ('              Filter: (a = 1)',)]

-----------
QUERY:


-- Ensure we don/* REPLACED */''t exclude normal relations when we only expect to exclude
-- inheritance children
explain (costs off) update inh_lp1 set value = 10 where a = 2;
RESULT:
	postgres: [('Update on inh_lp1',), ('  ->  Seq Scan on inh_lp1',), ('        Filter: (a = 2)',)]

-----------
QUERY:


drop table inh_lp cascade;
RESULT:
	postgres: None

-----------
QUERY:


reset enable_partition_pruning;
RESULT:
	postgres: None

-----------
QUERY:

reset constraint_exclusion;
RESULT:
	postgres: None

-----------
QUERY:


-- Check pruning for a partition tree containing only temporary relations
create temp table pp_temp_parent (a int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create temp table pp_temp_part_1 partition of pp_temp_parent for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create temp table pp_temp_part_def partition of pp_temp_parent default;
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from pp_temp_parent where true;
RESULT:
	postgres: [('Append',), ('  ->  Seq Scan on pp_temp_part_1 pp_temp_parent_1',), ('  ->  Seq Scan on pp_temp_part_def pp_temp_parent_2',)]

-----------
QUERY:

explain (costs off) select * from pp_temp_parent where a = 2;
RESULT:
	postgres: [('Seq Scan on pp_temp_part_def pp_temp_parent',), ('  Filter: (a = 2)',)]

-----------
QUERY:

drop table pp_temp_parent;
RESULT:
	postgres: None

-----------
QUERY:


-- Stress run-time partition pruning a bit more, per bug reports
create temp table p (a int, b int, c int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create temp table p1 partition of p for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create temp table p2 partition of p for values in (2);
RESULT:
	postgres: None

-----------
QUERY:

create temp table q (a int, b int, c int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create temp table q1 partition of q for values in (1) partition by list (b);
RESULT:
	postgres: None

-----------
QUERY:

create temp table q11 partition of q1 for values in (1) partition by list (c);
RESULT:
	postgres: None

-----------
QUERY:

create temp table q111 partition of q11 for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create temp table q2 partition of q for values in (2) partition by list (b);
RESULT:
	postgres: None

-----------
QUERY:

create temp table q21 partition of q2 for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create temp table q22 partition of q2 for values in (2);
RESULT:
	postgres: None

-----------
QUERY:


insert into q22 values (2, 2, 3);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off)
select *
from (
      select * from p
      union all
      select * from q1
      union all
      select 1, 1, 1
     ) s(a, b, c)
where s.a = 1 and s.b = 1 and s.c = (select 1);
RESULT:
	postgres: [('Append',), ('  InitPlan 1',), ('    ->  Result',), ('  ->  Seq Scan on p1 p',), ('        Filter: ((a = 1) AND (b = 1) AND (c = (InitPlan 1).col1))',), ('  ->  Seq Scan on q111 q1',), ('        Filter: ((a = 1) AND (b = 1) AND (c = (InitPlan 1).col1))',), ('  ->  Result',), ('        One-Time Filter: (1 = (InitPlan 1).col1)',)]

-----------
QUERY:


select *
from (
      select * from p
      union all
      select * from q1
      union all
      select 1, 1, 1
     ) s(a, b, c)
where s.a = 1 and s.b = 1 and s.c = (select 1);
RESULT:
	postgres: [(1, 1, 1)]

-----------
QUERY:


prepare q (int, int) as
select *
from (
      select * from p
      union all
      select * from q1
      union all
      select 1, 1, 1
     ) s(a, b, c)
where s.a = $1 and s.b = $2 and s.c = (select 1);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) execute q (1, 1);
RESULT:
	postgres: [('Append',), ('  Subplans Removed: 1',), ('  InitPlan 1',), ('    ->  Result',), ('  ->  Seq Scan on p1 p',), ('        Filter: ((a = $1) AND (b = $2) AND (c = (InitPlan 1).col1))',), ('  ->  Seq Scan on q111 q1',), ('        Filter: ((a = $1) AND (b = $2) AND (c = (InitPlan 1).col1))',), ('  ->  Result',), ('        One-Time Filter: ((1 = $1) AND (1 = $2) AND (1 = (InitPlan 1).col1))',)]

-----------
QUERY:

execute q (1, 1);
RESULT:
	postgres: [(1, 1, 1)]

-----------
QUERY:


drop table p, q;
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure run-time pruning works correctly when we match a partitioned table
-- on the first level but find no matching partitions on the second level.
create table listp (a int, b int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table listp1 partition of listp for values in(1);
RESULT:
	postgres: None

-----------
QUERY:

create table listp2 partition of listp for values in(2) partition by list(b);
RESULT:
	postgres: None

-----------
QUERY:

create table listp2_10 partition of listp2 for values in (10);
RESULT:
	postgres: None

-----------
QUERY:


explain (analyze, costs off, summary off, timing off)
select * from listp where a = (select 2) and b <> 10;
RESULT:
	postgres: [('Seq Scan on listp1 listp (actual rows=0 loops=1)',), ('  Filter: ((b <> 10) AND (a = (InitPlan 1).col1))',), ('  InitPlan 1',), ('    ->  Result (never executed)',)]

-----------
QUERY:


--
-- check that a partition directly accessed in a query is excluded with
-- constraint_exclusion = on
--

-- turn off partition pruning, so that it doesn/* REPLACED */''t interfere
set enable_partition_pruning to off;
RESULT:
	postgres: None

-----------
QUERY:


-- setting constraint_exclusion to /* REPLACED */''partition/* REPLACED */'' disables exclusion
set constraint_exclusion to 'partition';
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from listp1 where a = 2;
RESULT:
	postgres: [('Seq Scan on listp1',), ('  Filter: (a = 2)',)]

-----------
QUERY:

explain (costs off) update listp1 set a = 1 where a = 2;
RESULT:
	postgres: [('Update on listp1',), ('  ->  Seq Scan on listp1',), ('        Filter: (a = 2)',)]

-----------
QUERY:

-- constraint exclusion enabled
set constraint_exclusion to 'on';
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off) select * from listp1 where a = 2;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

explain (costs off) update listp1 set a = 1 where a = 2;
RESULT:
	postgres: [('Update on listp1',), ('  ->  Result',), ('        One-Time Filter: false',)]

-----------
QUERY:


reset constraint_exclusion;
RESULT:
	postgres: None

-----------
QUERY:

reset enable_partition_pruning;
RESULT:
	postgres: None

-----------
QUERY:


drop table listp;
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure run-time pruning works correctly for nested Append nodes
set parallel_setup_cost to 0;
RESULT:
	postgres: None

-----------
QUERY:

set parallel_tuple_cost to 0;
RESULT:
	postgres: None

-----------
QUERY:


create table listp (a int) partition by list(a);
RESULT:
	postgres: None

-----------
QUERY:

create table listp_12 partition of listp for values in(1,2) partition by list(a);
RESULT:
	postgres: None

-----------
QUERY:

create table listp_12_1 partition of listp_12 for values in(1);
RESULT:
	postgres: None

-----------
QUERY:

create table listp_12_2 partition of listp_12 for values in(2);
RESULT:
	postgres: None

-----------
QUERY:


-- Force the 2nd subnode of the Append to be non-parallel.  This results in
-- a nested Append node because the mixed parallel / non-parallel paths cannot
-- be pulled into the top-level Append.
alter table listp_12_1 set (parallel_workers = 0);
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure that listp_12_2 is not scanned.  (The nested Append is not seen in
-- the plan as it/* REPLACED */''s pulled in setref.c due to having just a single subnode).
select explain_parallel_append('select * from listp where a = (select 1);
RESULT:
	postgres: unterminated quoted string at or near "'select * from listp where a = (select 1);"
LINE 5: select explain_parallel_append('select * from listp where a ...
                                       ^


-----------
QUERY:
');
RESULT:
	postgres: unterminated quoted string at or near "');"
LINE 1: ');
        ^


-----------
QUERY:


-- Like the above but throw some more complexity at the planner by adding
-- a UNION ALL.  We expect both sides of the union not to scan the
-- non-required partitions.
select explain_parallel_append(
'select * from listp where a = (select 1)
  union all
select * from listp where a = (select 2);
RESULT:
	postgres: unterminated quoted string at or near "'select * from listp where a = (select 1)
  union all
select * from listp where a = (select 2);"
LINE 7: 'select * from listp where a = (select 1)
        ^


-----------
QUERY:
');
RESULT:
	postgres: unterminated quoted string at or near "');"
LINE 1: ');
        ^


-----------
QUERY:


drop table listp;
RESULT:
	postgres: None

-----------
QUERY:

reset parallel_tuple_cost;
RESULT:
	postgres: None

-----------
QUERY:

reset parallel_setup_cost;
RESULT:
	postgres: None

-----------
QUERY:


-- Test case for run-time pruning with a nested Merge Append
set enable_sort to 0;
RESULT:
	postgres: None

-----------
QUERY:

create table rangep (a int, b int) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table rangep_0_to_100 partition of rangep for values from (0) to (100) partition by list (b);
RESULT:
	postgres: None

-----------
QUERY:

-- We need 3 sub-partitions. 1 to validate pruning worked and another two
-- because a single remaining partition would be pulled up to the main Append.
create table rangep_0_to_100_1 partition of rangep_0_to_100 for values in(1);
RESULT:
	postgres: None

-----------
QUERY:

create table rangep_0_to_100_2 partition of rangep_0_to_100 for values in(2);
RESULT:
	postgres: None

-----------
QUERY:

create table rangep_0_to_100_3 partition of rangep_0_to_100 for values in(3);
RESULT:
	postgres: None

-----------
QUERY:

create table rangep_100_to_200 partition of rangep for values from (100) to (200);
RESULT:
	postgres: None

-----------
QUERY:

create index on rangep (a);
RESULT:
	postgres: None

-----------
QUERY:


-- Ensure run-time pruning works on the nested Merge Append
explain (analyze on, costs off, timing off, summary off)
select * from rangep where b IN((select 1),(select 2)) order by a;
RESULT:
	postgres: [('Append (actual rows=0 loops=1)',), ('  InitPlan 1',), ('    ->  Result (actual rows=1 loops=1)',), ('  InitPlan 2',), ('    ->  Result (actual rows=1 loops=1)',), ('  ->  Merge Append (actual rows=0 loops=1)',), ('        Sort Key: rangep_2.a',), ('        ->  Index Scan using rangep_0_to_100_1_a_idx on rangep_0_to_100_1 rangep_2 (actual rows=0 loops=1)',), ('              Filter: (b = ANY (ARRAY[(InitPlan 1).col1, (InitPlan 2).col1]))',), ('        ->  Index Scan using rangep_0_to_100_2_a_idx on rangep_0_to_100_2 rangep_3 (actual rows=0 loops=1)',), ('              Filter: (b = ANY (ARRAY[(InitPlan 1).col1, (InitPlan 2).col1]))',), ('        ->  Index Scan using rangep_0_to_100_3_a_idx on rangep_0_to_100_3 rangep_4 (never executed)',), ('              Filter: (b = ANY (ARRAY[(InitPlan 1).col1, (InitPlan 2).col1]))',), ('  ->  Index Scan using rangep_100_to_200_a_idx on rangep_100_to_200 rangep_5 (actual rows=0 loops=1)',), ('        Filter: (b = ANY (ARRAY[(InitPlan 1).col1, (InitPlan 2).col1]))',)]

-----------
QUERY:

reset enable_sort;
RESULT:
	postgres: None

-----------
QUERY:

drop table rangep;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Check that gen_prune_steps_from_opexps() works well for various cases of
-- clauses for different partition keys
--

create table rp_prefix_test1 (a int, b varchar) partition by range(a, b);
RESULT:
	postgres: None

-----------
QUERY:

create table rp_prefix_test1_p1 partition of rp_prefix_test1 for values from (1, 'a') to (1, 'b');
RESULT:
	postgres: None

-----------
QUERY:

create table rp_prefix_test1_p2 partition of rp_prefix_test1 for values from (2, 'a') to (2, 'b');
RESULT:
	postgres: None

-----------
QUERY:


-- Don/* REPLACED */''t call get_steps_using_prefix() with the last partition key b plus
-- an empty prefix
explain (costs off) select * from rp_prefix_test1 where a <= 1 and b = 'a';
RESULT:
	postgres: [('Seq Scan on rp_prefix_test1_p1 rp_prefix_test1',), ("  Filter: ((a <= 1) AND ((b)::text = 'a'::text))",)]

-----------
QUERY:


create table rp_prefix_test2 (a int, b int, c int) partition by range(a, b, c);
RESULT:
	postgres: None

-----------
QUERY:

create table rp_prefix_test2_p1 partition of rp_prefix_test2 for values from (1, 1, 0) to (1, 1, 10);
RESULT:
	postgres: None

-----------
QUERY:

create table rp_prefix_test2_p2 partition of rp_prefix_test2 for values from (2, 2, 0) to (2, 2, 10);
RESULT:
	postgres: None

-----------
QUERY:


-- Don/* REPLACED */''t call get_steps_using_prefix() with the last partition key c plus
-- an invalid prefix (ie, b = 1)
explain (costs off) select * from rp_prefix_test2 where a <= 1 and b = 1 and c >= 0;
RESULT:
	postgres: [('Seq Scan on rp_prefix_test2_p1 rp_prefix_test2',), ('  Filter: ((a <= 1) AND (c >= 0) AND (b = 1))',)]

-----------
QUERY:


create table rp_prefix_test3 (a int, b int, c int, d int) partition by range(a, b, c, d);
RESULT:
	postgres: None

-----------
QUERY:

create table rp_prefix_test3_p1 partition of rp_prefix_test3 for values from (1, 1, 1, 0) to (1, 1, 1, 10);
RESULT:
	postgres: None

-----------
QUERY:

create table rp_prefix_test3_p2 partition of rp_prefix_test3 for values from (2, 2, 2, 0) to (2, 2, 2, 10);
RESULT:
	postgres: None

-----------
QUERY:


-- Test that get_steps_using_prefix() handles a prefix that contains multiple
-- clauses for the partition key b (ie, b >= 1 and b >= 2)
explain (costs off) select * from rp_prefix_test3 where a >= 1 and b >= 1 and b >= 2 and c >= 2 and d >= 0;
RESULT:
	postgres: [('Seq Scan on rp_prefix_test3_p2 rp_prefix_test3',), ('  Filter: ((a >= 1) AND (b >= 1) AND (b >= 2) AND (c >= 2) AND (d >= 0))',)]

-----------
QUERY:


-- Test that get_steps_using_prefix() handles a prefix that contains multiple
-- clauses for the partition key b (ie, b >= 1 and b = 2)  (This also tests
-- that the caller arranges clauses in that prefix in the required order)
explain (costs off) select * from rp_prefix_test3 where a >= 1 and b >= 1 and b = 2 and c = 2 and d >= 0;
RESULT:
	postgres: [('Seq Scan on rp_prefix_test3_p2 rp_prefix_test3',), ('  Filter: ((a >= 1) AND (b >= 1) AND (d >= 0) AND (b = 2) AND (c = 2))',)]

-----------
QUERY:


drop table rp_prefix_test1;
RESULT:
	postgres: None

-----------
QUERY:

drop table rp_prefix_test2;
RESULT:
	postgres: None

-----------
QUERY:

drop table rp_prefix_test3;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test that get_steps_using_prefix() handles IS NULL clauses correctly
--
create table hp_prefix_test (a int, b int, c int, d int)
  partition by hash (a part_test_int4_ops, b part_test_int4_ops, c part_test_int4_ops, d part_test_int4_ops);
RESULT:
	postgres: None

-----------
QUERY:


-- create 8 partitions
select 'create table hp_prefix_test_p' || x::text || ' partition of hp_prefix_test for values with (modulus 8, remainder ' || x::text || ');
RESULT:
	postgres: unterminated quoted string at or near "');"
LINE 4: ...st for values with (modulus 8, remainder ' || x::text || ');
                                                                    ^


-----------
QUERY:
'
from generate_Series(0,7) x;
RESULT:
	postgres: unterminated quoted string at or near "'
from generate_Series(0,7) x;"
LINE 1: '
        ^


-----------
QUERY:

\gexec

-- insert 16 rows, one row for each test to perform.
insert into hp_prefix_test
select
  case a when 0 then null else 1 end,
  case b when 0 then null else 2 end,
  case c when 0 then null else 3 end,
  case d when 0 then null else 4 end
from
  generate_series(0,1) a,
  generate_series(0,1) b,
  generate_Series(0,1) c,
  generate_Series(0,1) d;
RESULT:
	postgres: syntax error at or near "\"
LINE 2: \gexec
        ^


-----------
QUERY:


-- Ensure partition pruning works correctly for each combination of IS NULL
-- and equality quals.  This may seem a little excessive, but there have been
-- a number of bugs in this area over the years.  We make use of row only
-- output to reduce the size of the expected results.
\t on
select
  'explain (costs off) select tableoid::regclass,* from hp_prefix_test where ' ||
  string_agg(c.colname || case when g.s & (1 << c.colpos) = 0 then ' is null' else ' = ' || (colpos+1)::text end, ' and ' order by c.colpos)
from (values('a',0),('b',1),('c',2),('d',3)) c(colname, colpos), generate_Series(0,15) g(s)
group by g.s
order by g.s;
RESULT:
	postgres: syntax error at or near "\"
LINE 7: \t on
        ^


-----------
QUERY:

\gexec

-- And ensure we get exactly 1 row from each. Again, all 16 possible combinations.
select
  'select tableoid::regclass,* from hp_prefix_test where ' ||
  string_agg(c.colname || case when g.s & (1 << c.colpos) = 0 then ' is null' else ' = ' || (colpos+1)::text end, ' and ' order by c.colpos)
from (values('a',0),('b',1),('c',2),('d',3)) c(colname, colpos), generate_Series(0,15) g(s)
group by g.s
order by g.s;
RESULT:
	postgres: syntax error at or near "\"
LINE 2: \gexec
        ^


-----------
QUERY:

\gexec
\t off

drop table hp_prefix_test;
RESULT:
	postgres: syntax error at or near "\"
LINE 2: \gexec
        ^


-----------
QUERY:


--
-- Check that gen_partprune_steps() detects self-contradiction from clauses
-- regardless of the order of the clauses (Here we use a custom operator to
-- prevent the equivclass.c machinery from reordering the clauses)
--

create operator === (
   leftarg = int4,
   rightarg = int4,
   procedure = int4eq,
   commutator = ===,
   hashes
);
RESULT:
	postgres: None

-----------
QUERY:

create operator class part_test_int4_ops2
for type int4
using hash as
operator 1 ===,
function 2 part_hashint4_noop(int4, int8);
RESULT:
	postgres: None

-----------
QUERY:


create table hp_contradict_test (a int, b int) partition by hash (a part_test_int4_ops2, b part_test_int4_ops2);
RESULT:
	postgres: None

-----------
QUERY:

create table hp_contradict_test_p1 partition of hp_contradict_test for values with (modulus 2, remainder 0);
RESULT:
	postgres: None

-----------
QUERY:

create table hp_contradict_test_p2 partition of hp_contradict_test for values with (modulus 2, remainder 1);
RESULT:
	postgres: None

-----------
QUERY:


explain (costs off) select * from hp_contradict_test where a is null and a === 1 and b === 1;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:

explain (costs off) select * from hp_contradict_test where a === 1 and b === 1 and a is null;
RESULT:
	postgres: [('Result',), ('  One-Time Filter: false',)]

-----------
QUERY:


drop table hp_contradict_test;
RESULT:
	postgres: None

-----------
QUERY:

drop operator class part_test_int4_ops2 using hash;
RESULT:
	postgres: None

-----------
QUERY:

drop operator ===(int4, int4);
RESULT:
	postgres: None
