Guest DBMS identified: postgres
-----------
QUERY:
--
-- RULES
-- From Jan/* REPLACED */''s original setup_ruletest.sql and run_ruletest.sql
-- - thomas 1998-09-13
--

--
-- Tables and rules for the view test
--
create table rtest_t1 (a int4, b int4)
RESULT: []

-----------
QUERY:
create table rtest_t2 (a int4, b int4)
RESULT: []

-----------
QUERY:
create table rtest_t3 (a int4, b int4)
RESULT: []

-----------
QUERY:
create view rtest_v1 as select * from rtest_t1
RESULT: []

-----------
QUERY:
create rule rtest_v1_ins as on insert to rtest_v1 do instead
	insert into rtest_t1 values (new.a, new.b)
RESULT: []

-----------
QUERY:
create rule rtest_v1_upd as on update to rtest_v1 do instead
	update rtest_t1 set a = new.a, b = new.b
	where a = old.a
RESULT: []

-----------
QUERY:
create rule rtest_v1_del as on delete to rtest_v1 do instead
	delete from rtest_t1 where a = old.a
RESULT: []

-----------
QUERY:
-- Test comments
COMMENT ON RULE rtest_v1_bad ON rtest_v1 IS 'bad rule'
RESULT: []

-----------
QUERY:
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS 'delete rule'
RESULT: []

-----------
QUERY:
COMMENT ON RULE rtest_v1_del ON rtest_v1 IS NULL
RESULT: []

-----------
QUERY:
--
-- Tables and rules for the constraint update/delete test
--
-- Note:
-- 	Now that we have multiple action rule support, we check
-- 	both possible syntaxes to define them (The last action
--  can but must not have a semicolon at the end).
--
create table rtest_system (sysname text, sysdesc text)
RESULT: []

-----------
QUERY:
create table rtest_interface (sysname text, ifname text)
RESULT: []

-----------
QUERY:
create table rtest_person (pname text, pdesc text)
RESULT: []

-----------
QUERY:
create table rtest_admin (pname text, sysname text)
RESULT: []

-----------
QUERY:
create rule rtest_sys_upd as on update to rtest_system do also (
	update rtest_interface set sysname = new.sysname
		where sysname = old.sysname
RESULT: []

-----------
QUERY:
update rtest_admin set sysname = new.sysname
		where sysname = old.sysname
	)
RESULT: []

-----------
QUERY:
create rule rtest_sys_del as on delete to rtest_system do also (
	delete from rtest_interface where sysname = old.sysname
RESULT: []

-----------
QUERY:
delete from rtest_admin where sysname = old.sysname
RESULT: []

-----------
QUERY:
)
RESULT: []

-----------
QUERY:
create rule rtest_pers_upd as on update to rtest_person do also
	update rtest_admin set pname = new.pname where pname = old.pname
RESULT: []

-----------
QUERY:
create rule rtest_pers_del as on delete to rtest_person do also
	delete from rtest_admin where pname = old.pname
RESULT: []

-----------
QUERY:
--
-- Tables and rules for the logging test
--
create table rtest_emp (ename char(20), salary numeric)
RESULT: []

-----------
QUERY:
create table rtest_emplog (ename char(20), who name, action char(10), newsal numeric, oldsal numeric)
RESULT: []

-----------
QUERY:
create table rtest_empmass (ename char(20), salary numeric)
RESULT: []

-----------
QUERY:
create rule rtest_emp_ins as on insert to rtest_emp do
	insert into rtest_emplog values (new.ename, current_user,
			'hired', new.salary, '0.00')
RESULT: []

-----------
QUERY:
create rule rtest_emp_upd as on update to rtest_emp where new.salary != old.salary do
	insert into rtest_emplog values (new.ename, current_user,
			'honored', new.salary, old.salary)
RESULT: []

-----------
QUERY:
create rule rtest_emp_del as on delete to rtest_emp do
	insert into rtest_emplog values (old.ename, current_user,
			'fired', '0.00', old.salary)
RESULT: []

-----------
QUERY:
--
-- Tables and rules for the multiple cascaded qualified instead
-- rule test
--
create table rtest_t4 (a int4, b text)
RESULT: []

-----------
QUERY:
create table rtest_t5 (a int4, b text)
RESULT: []

-----------
QUERY:
create table rtest_t6 (a int4, b text)
RESULT: []

-----------
QUERY:
create table rtest_t7 (a int4, b text)
RESULT: []

-----------
QUERY:
create table rtest_t8 (a int4, b text)
RESULT: []

-----------
QUERY:
create table rtest_t9 (a int4, b text)
RESULT: []

-----------
QUERY:
create rule rtest_t4_ins1 as on insert to rtest_t4
		where new.a >= 10 and new.a < 20 do instead
	insert into rtest_t5 values (new.a, new.b)
RESULT: []

-----------
QUERY:
create rule rtest_t4_ins2 as on insert to rtest_t4
		where new.a >= 20 and new.a < 30 do
	insert into rtest_t6 values (new.a, new.b)
RESULT: []

-----------
QUERY:
create rule rtest_t5_ins as on insert to rtest_t5
		where new.a > 15 do
	insert into rtest_t7 values (new.a, new.b)
RESULT: []

-----------
QUERY:
create rule rtest_t6_ins as on insert to rtest_t6
		where new.a > 25 do instead
	insert into rtest_t8 values (new.a, new.b)
RESULT: []

-----------
QUERY:
--
-- Tables and rules for the rule fire order test
--
-- As of PG 7.3, the rules should fire in order by name, regardless
-- of INSTEAD attributes or creation order.
--
create table rtest_order1 (a int4)
RESULT: []

-----------
QUERY:
create table rtest_order2 (a int4, b int4, c text)
RESULT: []

-----------
QUERY:
create sequence rtest_seq
RESULT: []

-----------
QUERY:
create rule rtest_order_r3 as on insert to rtest_order1 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 3 - this should run 3rd')
RESULT: []

-----------
QUERY:
create rule rtest_order_r4 as on insert to rtest_order1
		where a < 100 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 4 - this should run 4th')
RESULT: []

-----------
QUERY:
create rule rtest_order_r2 as on insert to rtest_order1 do
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 2 - this should run 2nd')
RESULT: []

-----------
QUERY:
create rule rtest_order_r1 as on insert to rtest_order1 do instead
	insert into rtest_order2 values (new.a, nextval('rtest_seq'),
		'rule 1 - this should run 1st')
RESULT: []

-----------
QUERY:
--
-- Tables and rules for the instead nothing test
--
create table rtest_nothn1 (a int4, b text)
RESULT: []

-----------
QUERY:
create table rtest_nothn2 (a int4, b text)
RESULT: []

-----------
QUERY:
create table rtest_nothn3 (a int4, b text)
RESULT: []

-----------
QUERY:
create table rtest_nothn4 (a int4, b text)
RESULT: []

-----------
QUERY:
create rule rtest_nothn_r1 as on insert to rtest_nothn1
	where new.a >= 10 and new.a < 20 do instead nothing
RESULT: []

-----------
QUERY:
create rule rtest_nothn_r2 as on insert to rtest_nothn1
	where new.a >= 30 and new.a < 40 do instead nothing
RESULT: []

-----------
QUERY:
create rule rtest_nothn_r3 as on insert to rtest_nothn2
	where new.a >= 100 do instead
	insert into rtest_nothn3 values (new.a, new.b)
RESULT: []

-----------
QUERY:
create rule rtest_nothn_r4 as on insert to rtest_nothn2
	do instead nothing
RESULT: []

-----------
QUERY:
--
-- Tests on a view that is select * of a table
-- and has insert/update/delete instead rules to
-- behave close like the real table.
--

--
-- We need test date later
--
insert into rtest_t2 values (1, 21)
RESULT: []

-----------
QUERY:
insert into rtest_t2 values (2, 22)
RESULT: []

-----------
QUERY:
insert into rtest_t2 values (3, 23)
RESULT: []

-----------
QUERY:
insert into rtest_t3 values (1, 31)
RESULT: []

-----------
QUERY:
insert into rtest_t3 values (2, 32)
RESULT: []

-----------
QUERY:
insert into rtest_t3 values (3, 33)
RESULT: []

-----------
QUERY:
insert into rtest_t3 values (4, 34)
RESULT: []

-----------
QUERY:
insert into rtest_t3 values (5, 35)
RESULT: []

-----------
QUERY:
-- insert values
insert into rtest_v1 values (1, 11)
RESULT: []

-----------
QUERY:
insert into rtest_v1 values (2, 12)
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
-- delete with constant expression
delete from rtest_v1 where a = 1
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
insert into rtest_v1 values (1, 11)
RESULT: []

-----------
QUERY:
delete from rtest_v1 where b = 12
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
insert into rtest_v1 values (2, 12)
RESULT: []

-----------
QUERY:
insert into rtest_v1 values (2, 13)
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
** Remember the delete rule on rtest_v1: It says
** DO INSTEAD DELETE FROM rtest_t1 WHERE a = old.a
** So this time both rows with a = 2 must get deleted
\p
\r
delete from rtest_v1 where b = 12
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
delete from rtest_v1
RESULT: []

-----------
QUERY:
-- insert select
insert into rtest_v1 select * from rtest_t2
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
delete from rtest_v1
RESULT: []

-----------
QUERY:
-- same with swapped targetlist
insert into rtest_v1 (b, a) select b, a from rtest_t2
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
-- now with only one target attribute
insert into rtest_v1 (a) select a from rtest_t3
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
select * from rtest_v1 where b isnull
RESULT: []

-----------
QUERY:
-- let attribute a differ (must be done on rtest_t1 - see above)
update rtest_t1 set a = a + 10 where b isnull
RESULT: []

-----------
QUERY:
delete from rtest_v1 where b isnull
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
-- now updates with constant expression
update rtest_v1 set b = 42 where a = 2
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
update rtest_v1 set b = 99 where b = 42
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
update rtest_v1 set b = 88 where b < 50
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
delete from rtest_v1
RESULT: []

-----------
QUERY:
insert into rtest_v1 select rtest_t2.a, rtest_t3.b
    from rtest_t2, rtest_t3
    where rtest_t2.a = rtest_t3.a
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
-- updates in a mergejoin
update rtest_v1 set b = rtest_t2.b from rtest_t2 where rtest_v1.a = rtest_t2.a
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
insert into rtest_v1 select * from rtest_t3
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
update rtest_t1 set a = a + 10 where b > 30
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
update rtest_v1 set a = rtest_t3.a + 20 from rtest_t3 where rtest_v1.b = rtest_t3.b
RESULT: []

-----------
QUERY:
select * from rtest_v1
RESULT: []

-----------
QUERY:
--
-- Test for constraint updates/deletes
--
insert into rtest_system values ('orion', 'Linux Jan Wieck')
RESULT: []

-----------
QUERY:
insert into rtest_system values ('notjw', 'WinNT Jan Wieck (notebook)')
RESULT: []

-----------
QUERY:
insert into rtest_system values ('neptun', 'Fileserver')
RESULT: []

-----------
QUERY:
insert into rtest_interface values ('orion', 'eth0')
RESULT: []

-----------
QUERY:
insert into rtest_interface values ('orion', 'eth1')
RESULT: []

-----------
QUERY:
insert into rtest_interface values ('notjw', 'eth0')
RESULT: []

-----------
QUERY:
insert into rtest_interface values ('neptun', 'eth0')
RESULT: []

-----------
QUERY:
insert into rtest_person values ('jw', 'Jan Wieck')
RESULT: []

-----------
QUERY:
insert into rtest_person values ('bm', 'Bruce Momjian')
RESULT: []

-----------
QUERY:
insert into rtest_admin values ('jw', 'orion')
RESULT: []

-----------
QUERY:
insert into rtest_admin values ('jw', 'notjw')
RESULT: []

-----------
QUERY:
insert into rtest_admin values ('bm', 'neptun')
RESULT: []

-----------
QUERY:
update rtest_system set sysname = 'pluto' where sysname = 'neptun'
RESULT: []

-----------
QUERY:
select * from rtest_interface
RESULT: []

-----------
QUERY:
select * from rtest_admin
RESULT: []

-----------
QUERY:
update rtest_person set pname = 'jwieck' where pdesc = 'Jan Wieck'
RESULT: []

-----------
QUERY:
-- Note: use ORDER BY here to ensure consistent output across all systems.
-- The above UPDATE affects two rows with equal keys, so they could be
-- updated in either order depending on the whim of the local qsort().

select * from rtest_admin order by pname, sysname
RESULT: []

-----------
QUERY:
delete from rtest_system where sysname = 'orion'
RESULT: []

-----------
QUERY:
select * from rtest_interface
RESULT: []

-----------
QUERY:
select * from rtest_admin
RESULT: []

-----------
QUERY:
--
-- Rule qualification test
--
insert into rtest_emp values ('wiecc', '5000.00')
RESULT: []

-----------
QUERY:
insert into rtest_emp values ('gates', '80000.00')
RESULT: []

-----------
QUERY:
update rtest_emp set ename = 'wiecx' where ename = 'wiecc'
RESULT: []

-----------
QUERY:
update rtest_emp set ename = 'wieck', salary = '6000.00' where ename = 'wiecx'
RESULT: []

-----------
QUERY:
update rtest_emp set salary = '7000.00' where ename = 'wieck'
RESULT: []

-----------
QUERY:
delete from rtest_emp where ename = 'gates'
RESULT: []

-----------
QUERY:
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal
RESULT: []

-----------
QUERY:
insert into rtest_empmass values ('meyer', '4000.00')
RESULT: []

-----------
QUERY:
insert into rtest_empmass values ('maier', '5000.00')
RESULT: []

-----------
QUERY:
insert into rtest_empmass values ('mayr', '6000.00')
RESULT: []

-----------
QUERY:
insert into rtest_emp select * from rtest_empmass
RESULT: []

-----------
QUERY:
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal
RESULT: []

-----------
QUERY:
update rtest_empmass set salary = salary + '1000.00'
RESULT: []

-----------
QUERY:
update rtest_emp set salary = rtest_empmass.salary from rtest_empmass where rtest_emp.ename = rtest_empmass.ename
RESULT: []

-----------
QUERY:
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal
RESULT: []

-----------
QUERY:
delete from rtest_emp using rtest_empmass where rtest_emp.ename = rtest_empmass.ename
RESULT: []

-----------
QUERY:
select ename, who = current_user as "matches user", action, newsal, oldsal from rtest_emplog order by ename, action, newsal
RESULT: []

-----------
QUERY:
--
-- Multiple cascaded qualified instead rule test
--
insert into rtest_t4 values (1, 'Record should go to rtest_t4')
RESULT: []

-----------
QUERY:
insert into rtest_t4 values (2, 'Record should go to rtest_t4')
RESULT: []

-----------
QUERY:
insert into rtest_t4 values (10, 'Record should go to rtest_t5')
RESULT: []

-----------
QUERY:
insert into rtest_t4 values (15, 'Record should go to rtest_t5')
RESULT: []

-----------
QUERY:
insert into rtest_t4 values (19, 'Record should go to rtest_t5 and t7')
RESULT: []

-----------
QUERY:
insert into rtest_t4 values (20, 'Record should go to rtest_t4 and t6')
RESULT: []

-----------
QUERY:
insert into rtest_t4 values (26, 'Record should go to rtest_t4 and t8')
RESULT: []

-----------
QUERY:
insert into rtest_t4 values (28, 'Record should go to rtest_t4 and t8')
RESULT: []

-----------
QUERY:
insert into rtest_t4 values (30, 'Record should go to rtest_t4')
RESULT: []

-----------
QUERY:
insert into rtest_t4 values (40, 'Record should go to rtest_t4')
RESULT: []

-----------
QUERY:
select * from rtest_t4
RESULT: []

-----------
QUERY:
select * from rtest_t5
RESULT: []

-----------
QUERY:
select * from rtest_t6
RESULT: []

-----------
QUERY:
select * from rtest_t7
RESULT: []

-----------
QUERY:
select * from rtest_t8
RESULT: []

-----------
QUERY:
delete from rtest_t4
RESULT: []

-----------
QUERY:
delete from rtest_t5
RESULT: []

-----------
QUERY:
delete from rtest_t6
RESULT: []

-----------
QUERY:
delete from rtest_t7
RESULT: []

-----------
QUERY:
delete from rtest_t8
RESULT: []

-----------
QUERY:
insert into rtest_t9 values (1, 'Record should go to rtest_t4')
RESULT: []

-----------
QUERY:
insert into rtest_t9 values (2, 'Record should go to rtest_t4')
RESULT: []

-----------
QUERY:
insert into rtest_t9 values (10, 'Record should go to rtest_t5')
RESULT: []

-----------
QUERY:
insert into rtest_t9 values (15, 'Record should go to rtest_t5')
RESULT: []

-----------
QUERY:
insert into rtest_t9 values (19, 'Record should go to rtest_t5 and t7')
RESULT: []

-----------
QUERY:
insert into rtest_t9 values (20, 'Record should go to rtest_t4 and t6')
RESULT: []

-----------
QUERY:
insert into rtest_t9 values (26, 'Record should go to rtest_t4 and t8')
RESULT: []

-----------
QUERY:
insert into rtest_t9 values (28, 'Record should go to rtest_t4 and t8')
RESULT: []

-----------
QUERY:
insert into rtest_t9 values (30, 'Record should go to rtest_t4')
RESULT: []

-----------
QUERY:
insert into rtest_t9 values (40, 'Record should go to rtest_t4')
RESULT: []

-----------
QUERY:
insert into rtest_t4 select * from rtest_t9 where a < 20
RESULT: []

-----------
QUERY:
select * from rtest_t4
RESULT: []

-----------
QUERY:
select * from rtest_t5
RESULT: []

-----------
QUERY:
select * from rtest_t6
RESULT: []

-----------
QUERY:
select * from rtest_t7
RESULT: []

-----------
QUERY:
select * from rtest_t8
RESULT: []

-----------
QUERY:
insert into rtest_t4 select * from rtest_t9 where b ~ 'and t8'
RESULT: []

-----------
QUERY:
select * from rtest_t4
RESULT: []

-----------
QUERY:
select * from rtest_t5
RESULT: []

-----------
QUERY:
select * from rtest_t6
RESULT: []

-----------
QUERY:
select * from rtest_t7
RESULT: []

-----------
QUERY:
select * from rtest_t8
RESULT: []

-----------
QUERY:
insert into rtest_t4 select a + 1, b from rtest_t9 where a in (20, 30, 40)
RESULT: []

-----------
QUERY:
select * from rtest_t4
RESULT: []

-----------
QUERY:
select * from rtest_t5
RESULT: []

-----------
QUERY:
select * from rtest_t6
RESULT: []

-----------
QUERY:
select * from rtest_t7
RESULT: []

-----------
QUERY:
select * from rtest_t8
RESULT: []

-----------
QUERY:
--
-- Check that the ordering of rules fired is correct
--
insert into rtest_order1 values (1)
RESULT: []

-----------
QUERY:
select * from rtest_order2
RESULT: []

-----------
QUERY:
--
-- Check if instead nothing w/without qualification works
--
insert into rtest_nothn1 values (1, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 values (2, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 values (10, 'don''t want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 values (19, 'don''t want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 values (20, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 values (29, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 values (30, 'don''t want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 values (39, 'don''t want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 values (40, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 values (50, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 values (60, 'want this')
RESULT: []

-----------
QUERY:
select * from rtest_nothn1
RESULT: []

-----------
QUERY:
insert into rtest_nothn2 values (10, 'too small')
RESULT: []

-----------
QUERY:
insert into rtest_nothn2 values (50, 'too small')
RESULT: []

-----------
QUERY:
insert into rtest_nothn2 values (100, 'OK')
RESULT: []

-----------
QUERY:
insert into rtest_nothn2 values (200, 'OK')
RESULT: []

-----------
QUERY:
select * from rtest_nothn2
RESULT: []

-----------
QUERY:
select * from rtest_nothn3
RESULT: []

-----------
QUERY:
delete from rtest_nothn1
RESULT: []

-----------
QUERY:
delete from rtest_nothn2
RESULT: []

-----------
QUERY:
delete from rtest_nothn3
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (1, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (2, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (10, 'don''t want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (19, 'don''t want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (20, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (29, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (30, 'don''t want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (39, 'don''t want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (40, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (50, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (60, 'want this')
RESULT: []

-----------
QUERY:
insert into rtest_nothn1 select * from rtest_nothn4
RESULT: []

-----------
QUERY:
select * from rtest_nothn1
RESULT: []

-----------
QUERY:
delete from rtest_nothn4
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (10, 'too small')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (50, 'too small')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (100, 'OK')
RESULT: []

-----------
QUERY:
insert into rtest_nothn4 values (200, 'OK')
RESULT: []

-----------
QUERY:
insert into rtest_nothn2 select * from rtest_nothn4
RESULT: []

-----------
QUERY:
select * from rtest_nothn2
RESULT: []

-----------
QUERY:
select * from rtest_nothn3
RESULT: []

-----------
QUERY:
create table rtest_view1 (a int4, b text, v bool)
RESULT: []

-----------
QUERY:
create table rtest_view2 (a int4)
RESULT: []

-----------
QUERY:
create table rtest_view3 (a int4, b text)
RESULT: []

-----------
QUERY:
create table rtest_view4 (a int4, b text, c int4)
RESULT: []

-----------
QUERY:
create view rtest_vview1 as select a, b from rtest_view1 X
	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a)
RESULT: []

-----------
QUERY:
create view rtest_vview2 as select a, b from rtest_view1 where v
RESULT: []

-----------
QUERY:
create view rtest_vview3 as select a, b from rtest_vview2 X
	where 0 < (select count(*) from rtest_view2 Y where Y.a = X.a)
RESULT: []

-----------
QUERY:
create view rtest_vview4 as select X.a, X.b, count(Y.a) as refcount
	from rtest_view1 X, rtest_view2 Y
	where X.a = Y.a
	group by X.a, X.b
RESULT: []

-----------
QUERY:
create function rtest_viewfunc1(int4) returns int4 as
	'select count(*)::int4 from rtest_view2 where a = $1'
	language sql
RESULT: []

-----------
QUERY:
create view rtest_vview5 as select a, b, rtest_viewfunc1(a) as refcount
	from rtest_view1
RESULT: []

-----------
QUERY:
insert into rtest_view1 values (1, 'item 1', 't')
RESULT: []

-----------
QUERY:
insert into rtest_view1 values (2, 'item 2', 't')
RESULT: []

-----------
QUERY:
insert into rtest_view1 values (3, 'item 3', 't')
RESULT: []

-----------
QUERY:
insert into rtest_view1 values (4, 'item 4', 'f')
RESULT: []

-----------
QUERY:
insert into rtest_view1 values (5, 'item 5', 't')
RESULT: []

-----------
QUERY:
insert into rtest_view1 values (6, 'item 6', 'f')
RESULT: []

-----------
QUERY:
insert into rtest_view1 values (7, 'item 7', 't')
RESULT: []

-----------
QUERY:
insert into rtest_view1 values (8, 'item 8', 't')
RESULT: []

-----------
QUERY:
insert into rtest_view2 values (2)
RESULT: []

-----------
QUERY:
insert into rtest_view2 values (2)
RESULT: []

-----------
QUERY:
insert into rtest_view2 values (4)
RESULT: []

-----------
QUERY:
insert into rtest_view2 values (5)
RESULT: []

-----------
QUERY:
insert into rtest_view2 values (7)
RESULT: []

-----------
QUERY:
insert into rtest_view2 values (7)
RESULT: []

-----------
QUERY:
insert into rtest_view2 values (7)
RESULT: []

-----------
QUERY:
insert into rtest_view2 values (7)
RESULT: []

-----------
QUERY:
select * from rtest_vview1
RESULT: []

-----------
QUERY:
select * from rtest_vview2
RESULT: []

-----------
QUERY:
select * from rtest_vview3
RESULT: []

-----------
QUERY:
select * from rtest_vview4 order by a, b
RESULT: []

-----------
QUERY:
select * from rtest_vview5
RESULT: []

-----------
QUERY:
insert into rtest_view3 select * from rtest_vview1 where a < 7
RESULT: []

-----------
QUERY:
select * from rtest_view3
RESULT: []

-----------
QUERY:
delete from rtest_view3
RESULT: []

-----------
QUERY:
insert into rtest_view3 select * from rtest_vview2 where a != 5 and b !~ '2'
RESULT: []

-----------
QUERY:
select * from rtest_view3
RESULT: []

-----------
QUERY:
delete from rtest_view3
RESULT: []

-----------
QUERY:
insert into rtest_view3 select * from rtest_vview3
RESULT: []

-----------
QUERY:
select * from rtest_view3
RESULT: []

-----------
QUERY:
delete from rtest_view3
RESULT: []

-----------
QUERY:
insert into rtest_view4 select * from rtest_vview4 where 3 > refcount
RESULT: []

-----------
QUERY:
select * from rtest_view4 order by a, b
RESULT: []

-----------
QUERY:
delete from rtest_view4
RESULT: []

-----------
QUERY:
insert into rtest_view4 select * from rtest_vview5 where a > 2 and refcount = 0
RESULT: []

-----------
QUERY:
select * from rtest_view4
RESULT: []

-----------
QUERY:
delete from rtest_view4
RESULT: []

-----------
QUERY:
--
-- Test for computations in views
--
create table rtest_comp (
	part	text,
	unit	char(4),
	size	float
)
RESULT: []

-----------
QUERY:
create table rtest_unitfact (
	unit	char(4),
	factor	float
)
RESULT: []

-----------
QUERY:
create view rtest_vcomp as
	select X.part, (X.size * Y.factor) as size_in_cm
			from rtest_comp X, rtest_unitfact Y
			where X.unit = Y.unit
RESULT: []

-----------
QUERY:
insert into rtest_unitfact values ('m', 100.0)
RESULT: []

-----------
QUERY:
insert into rtest_unitfact values ('cm', 1.0)
RESULT: []

-----------
QUERY:
insert into rtest_unitfact values ('inch', 2.54)
RESULT: []

-----------
QUERY:
insert into rtest_comp values ('p1', 'm', 5.0)
RESULT: []

-----------
QUERY:
insert into rtest_comp values ('p2', 'm', 3.0)
RESULT: []

-----------
QUERY:
insert into rtest_comp values ('p3', 'cm', 5.0)
RESULT: []

-----------
QUERY:
insert into rtest_comp values ('p4', 'cm', 15.0)
RESULT: []

-----------
QUERY:
insert into rtest_comp values ('p5', 'inch', 7.0)
RESULT: []

-----------
QUERY:
insert into rtest_comp values ('p6', 'inch', 4.4)
RESULT: []

-----------
QUERY:
select * from rtest_vcomp order by part
RESULT: []

-----------
QUERY:
select * from rtest_vcomp where size_in_cm > 10.0 order by size_in_cm using >
RESULT: []

-----------
QUERY:
--
-- In addition run the (slightly modified) queries from the
-- programmers manual section on the rule system.
--
CREATE TABLE shoe_data (
	shoename   char(10),      -- primary key
	sh_avail   integer,       -- available # of pairs
	slcolor    char(10),      -- preferred shoelace color
	slminlen   float,         -- minimum shoelace length
	slmaxlen   float,         -- maximum shoelace length
	slunit     char(8)        -- length unit
)
RESULT: []

-----------
QUERY:
CREATE TABLE shoelace_data (
	sl_name    char(10),      -- primary key
	sl_avail   integer,       -- available # of pairs
	sl_color   char(10),      -- shoelace color
	sl_len     float,         -- shoelace length
	sl_unit    char(8)        -- length unit
)
RESULT: []

-----------
QUERY:
CREATE TABLE unit (
	un_name    char(8),       -- the primary key
	un_fact    float          -- factor to transform to cm
)
RESULT: []

-----------
QUERY:
CREATE VIEW shoe AS
	SELECT sh.shoename,
		   sh.sh_avail,
		   sh.slcolor,
		   sh.slminlen,
		   sh.slminlen * un.un_fact AS slminlen_cm,
		   sh.slmaxlen,
		   sh.slmaxlen * un.un_fact AS slmaxlen_cm,
		   sh.slunit
	  FROM shoe_data sh, unit un
	 WHERE sh.slunit = un.un_name
RESULT: []

-----------
QUERY:
CREATE VIEW shoelace AS
	SELECT s.sl_name,
		   s.sl_avail,
		   s.sl_color,
		   s.sl_len,
		   s.sl_unit,
		   s.sl_len * u.un_fact AS sl_len_cm
	  FROM shoelace_data s, unit u
	 WHERE s.sl_unit = u.un_name
RESULT: []

-----------
QUERY:
CREATE VIEW shoe_ready AS
	SELECT rsh.shoename,
		   rsh.sh_avail,
		   rsl.sl_name,
		   rsl.sl_avail,
		   int4smaller(rsh.sh_avail, rsl.sl_avail) AS total_avail
	  FROM shoe rsh, shoelace rsl
	 WHERE rsl.sl_color = rsh.slcolor
	   AND rsl.sl_len_cm >= rsh.slminlen_cm
	   AND rsl.sl_len_cm <= rsh.slmaxlen_cm
RESULT: []

-----------
QUERY:
INSERT INTO unit VALUES ('cm', 1.0)
RESULT: []

-----------
QUERY:
INSERT INTO unit VALUES ('m', 100.0)
RESULT: []

-----------
QUERY:
INSERT INTO unit VALUES ('inch', 2.54)
RESULT: []

-----------
QUERY:
INSERT INTO shoe_data VALUES ('sh1', 2, 'black', 70.0, 90.0, 'cm')
RESULT: []

-----------
QUERY:
INSERT INTO shoe_data VALUES ('sh2', 0, 'black', 30.0, 40.0, 'inch')
RESULT: []

-----------
QUERY:
INSERT INTO shoe_data VALUES ('sh3', 4, 'brown', 50.0, 65.0, 'cm')
RESULT: []

-----------
QUERY:
INSERT INTO shoe_data VALUES ('sh4', 3, 'brown', 40.0, 50.0, 'inch')
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_data VALUES ('sl1', 5, 'black', 80.0, 'cm')
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_data VALUES ('sl2', 6, 'black', 100.0, 'cm')
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_data VALUES ('sl3', 0, 'black', 35.0 , 'inch')
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_data VALUES ('sl4', 8, 'black', 40.0 , 'inch')
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_data VALUES ('sl5', 4, 'brown', 1.0 , 'm')
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_data VALUES ('sl6', 0, 'brown', 0.9 , 'm')
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_data VALUES ('sl7', 7, 'brown', 60 , 'cm')
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_data VALUES ('sl8', 1, 'brown', 40 , 'inch')
RESULT: []

-----------
QUERY:
-- SELECTs in doc
SELECT * FROM shoelace ORDER BY sl_name
RESULT: []

-----------
QUERY:
SELECT * FROM shoe_ready WHERE total_avail >= 2 ORDER BY 1
RESULT: []

-----------
QUERY:
CREATE TABLE shoelace_log (
        sl_name    char(10),      -- shoelace changed
        sl_avail   integer,       -- new available value
        log_who    name,          -- who did it
        log_when   timestamp      -- when
    )
RESULT: []

-----------
QUERY:
-- Want /* REPLACED */''log_who/* REPLACED */'' to be CURRENT_USER,
-- but that is non-portable for the regression test
-- - thomas 1999-02-21

    CREATE RULE log_shoelace AS ON UPDATE TO shoelace_data
        WHERE NEW.sl_avail != OLD.sl_avail
        DO INSERT INTO shoelace_log VALUES (
                                        NEW.sl_name,
                                        NEW.sl_avail,
                                        'Al Bundy',
                                        'epoch'
                                    )
RESULT: []

-----------
QUERY:
UPDATE shoelace_data SET sl_avail = 6 WHERE  sl_name = 'sl7'
RESULT: []

-----------
QUERY:
SELECT * FROM shoelace_log
RESULT: []

-----------
QUERY:
CREATE RULE shoelace_ins AS ON INSERT TO shoelace
        DO INSTEAD
        INSERT INTO shoelace_data VALUES (
               NEW.sl_name,
               NEW.sl_avail,
               NEW.sl_color,
               NEW.sl_len,
               NEW.sl_unit)
RESULT: []

-----------
QUERY:
CREATE RULE shoelace_upd AS ON UPDATE TO shoelace
        DO INSTEAD
        UPDATE shoelace_data SET
               sl_name = NEW.sl_name,
               sl_avail = NEW.sl_avail,
               sl_color = NEW.sl_color,
               sl_len = NEW.sl_len,
               sl_unit = NEW.sl_unit
         WHERE sl_name = OLD.sl_name
RESULT: []

-----------
QUERY:
CREATE RULE shoelace_del AS ON DELETE TO shoelace
        DO INSTEAD
        DELETE FROM shoelace_data
         WHERE sl_name = OLD.sl_name
RESULT: []

-----------
QUERY:
CREATE TABLE shoelace_arrive (
        arr_name    char(10),
        arr_quant   integer
    )
RESULT: []

-----------
QUERY:
CREATE TABLE shoelace_ok (
        ok_name     char(10),
        ok_quant    integer
    )
RESULT: []

-----------
QUERY:
CREATE RULE shoelace_ok_ins AS ON INSERT TO shoelace_ok
        DO INSTEAD
        UPDATE shoelace SET
               sl_avail = sl_avail + NEW.ok_quant
         WHERE sl_name = NEW.ok_name
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_arrive VALUES ('sl3', 10)
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_arrive VALUES ('sl6', 20)
RESULT: []

-----------
QUERY:
INSERT INTO shoelace_arrive VALUES ('sl8', 20)
RESULT: []

-----------
QUERY:
SELECT * FROM shoelace ORDER BY sl_name
RESULT: []

-----------
QUERY:
insert into shoelace_ok select * from shoelace_arrive
RESULT: []

-----------
QUERY:
SELECT * FROM shoelace ORDER BY sl_name
RESULT: []

-----------
QUERY:
SELECT * FROM shoelace_log ORDER BY sl_name
RESULT: []

-----------
QUERY:
CREATE VIEW shoelace_obsolete AS
	SELECT * FROM shoelace WHERE NOT EXISTS
	    (SELECT shoename FROM shoe WHERE slcolor = sl_color)
RESULT: []

-----------
QUERY:
CREATE VIEW shoelace_candelete AS
	SELECT * FROM shoelace_obsolete WHERE sl_avail = 0
RESULT: []

-----------
QUERY:
insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0)
RESULT: []

-----------
QUERY:
insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0)
RESULT: []

-----------
QUERY:
-- Unsupported (even though a similar updatable view construct is)
insert into shoelace values ('sl10', 1000, 'magenta', 40.0, 'inch', 0.0)
  on conflict do nothing
RESULT: []

-----------
QUERY:
SELECT * FROM shoelace_obsolete ORDER BY sl_len_cm
RESULT: []

-----------
QUERY:
SELECT * FROM shoelace_candelete
RESULT: []

-----------
QUERY:
DELETE FROM shoelace WHERE EXISTS
    (SELECT * FROM shoelace_candelete
             WHERE sl_name = shoelace.sl_name)
RESULT: []

-----------
QUERY:
SELECT * FROM shoelace ORDER BY sl_name
RESULT: []

-----------
QUERY:
SELECT * FROM shoe ORDER BY shoename
RESULT: []

-----------
QUERY:
SELECT count(*) FROM shoe
RESULT: []

-----------
QUERY:
--
-- Simple test of qualified ON INSERT ... this did not work in 7.0 ...
--
create table rules_foo (f1 int)
RESULT: []

-----------
QUERY:
create table rules_foo2 (f1 int)
RESULT: []

-----------
QUERY:
create rule rules_foorule as on insert to rules_foo where f1 < 100
do instead nothing
RESULT: []

-----------
QUERY:
insert into rules_foo values(1)
RESULT: []

-----------
QUERY:
insert into rules_foo values(1001)
RESULT: []

-----------
QUERY:
select * from rules_foo
RESULT: []

-----------
QUERY:
drop rule rules_foorule on rules_foo
RESULT: []

-----------
QUERY:
-- this should fail because f1 is not exposed for unqualified reference:
create rule rules_foorule as on insert to rules_foo where f1 < 100
do instead insert into rules_foo2 values (f1)
RESULT: []

-----------
QUERY:
-- this is the correct way:
create rule rules_foorule as on insert to rules_foo where f1 < 100
do instead insert into rules_foo2 values (new.f1)
RESULT: []

-----------
QUERY:
insert into rules_foo values(2)
RESULT: []

-----------
QUERY:
insert into rules_foo values(100)
RESULT: []

-----------
QUERY:
select * from rules_foo
RESULT: []

-----------
QUERY:
select * from rules_foo2
RESULT: []

-----------
QUERY:
drop rule rules_foorule on rules_foo
RESULT: []

-----------
QUERY:
drop table rules_foo
RESULT: []

-----------
QUERY:
drop table rules_foo2
RESULT: []

-----------
QUERY:
--
-- Test rules containing INSERT ... SELECT, which is a very ugly special
-- case as of 7.1.  Example is based on bug report from Joel Burton.
--
create table pparent (pid int, txt text)
RESULT: []

-----------
QUERY:
insert into pparent values (1,'parent1')
RESULT: []

-----------
QUERY:
insert into pparent values (2,'parent2')
RESULT: []

-----------
QUERY:
create table cchild (pid int, descrip text)
RESULT: []

-----------
QUERY:
insert into cchild values (1,'descrip1')
RESULT: []

-----------
QUERY:
create view vview as
  select pparent.pid, txt, descrip from
    pparent left join cchild using (pid)
RESULT: []

-----------
QUERY:
create rule rrule as
  on update to vview do instead
(
  insert into cchild (pid, descrip)
    select old.pid, new.descrip where old.descrip isnull
RESULT: []

-----------
QUERY:
update cchild set descrip = new.descrip where cchild.pid = old.pid
RESULT: []

-----------
QUERY:
)
RESULT: []

-----------
QUERY:
select * from vview
RESULT: []

-----------
QUERY:
update vview set descrip='test1' where pid=1
RESULT: []

-----------
QUERY:
select * from vview
RESULT: []

-----------
QUERY:
update vview set descrip='test2' where pid=2
RESULT: []

-----------
QUERY:
select * from vview
RESULT: []

-----------
QUERY:
update vview set descrip='test3' where pid=3
RESULT: []

-----------
QUERY:
select * from vview
RESULT: []

-----------
QUERY:
select * from cchild
RESULT: []

-----------
QUERY:
drop rule rrule on vview
RESULT: []

-----------
QUERY:
drop view vview
RESULT: []

-----------
QUERY:
drop table pparent
RESULT: []

-----------
QUERY:
drop table cchild
RESULT: []

-----------
QUERY:
--
-- Check that ruleutils are working
--

-- temporarily disable fancy output, so view changes create less diff noise
\a\t

SELECT viewname, definition FROM pg_views
WHERE schemaname = 'pg_catalog'
ORDER BY viewname
RESULT: []

-----------
QUERY:
SELECT tablename, rulename, definition FROM pg_rules
WHERE schemaname = 'pg_catalog'
ORDER BY tablename, rulename
RESULT: []

-----------
QUERY:
-- restore normal output mode
\a\t

--
-- CREATE OR REPLACE RULE
--

CREATE TABLE ruletest_tbl (a int, b int)
RESULT: []

-----------
QUERY:
CREATE TABLE ruletest_tbl2 (a int, b int)
RESULT: []

-----------
QUERY:
CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (10, 10)
RESULT: []

-----------
QUERY:
INSERT INTO ruletest_tbl VALUES (99, 99)
RESULT: []

-----------
QUERY:
CREATE OR REPLACE RULE myrule AS ON INSERT TO ruletest_tbl
	DO INSTEAD INSERT INTO ruletest_tbl2 VALUES (1000, 1000)
RESULT: []

-----------
QUERY:
INSERT INTO ruletest_tbl VALUES (99, 99)
RESULT: []

-----------
QUERY:
SELECT * FROM ruletest_tbl2
RESULT: []

-----------
QUERY:
-- Check that rewrite rules splitting one INSERT into multiple
-- conditional statements does not disable FK checking.
create table rule_and_refint_t1 (
	id1a integer,
	id1b integer,

	primary key (id1a, id1b)
)
RESULT: []

-----------
QUERY:
create table rule_and_refint_t2 (
	id2a integer,
	id2c integer,

	primary key (id2a, id2c)
)
RESULT: []

-----------
QUERY:
create table rule_and_refint_t3 (
	id3a integer,
	id3b integer,
	id3c integer,
	data text,

	primary key (id3a, id3b, id3c),

	foreign key (id3a, id3b) references rule_and_refint_t1 (id1a, id1b),
	foreign key (id3a, id3c) references rule_and_refint_t2 (id2a, id2c)
)
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t1 values (1, 11)
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t1 values (1, 12)
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t1 values (2, 21)
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t1 values (2, 22)
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t2 values (1, 11)
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t2 values (1, 12)
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t2 values (2, 21)
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t2 values (2, 22)
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t3 values (1, 11, 11, 'row1')
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t3 values (1, 11, 12, 'row2')
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t3 values (1, 12, 11, 'row3')
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t3 values (1, 12, 12, 'row4')
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t3 values (1, 11, 13, 'row5')
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
RESULT: []

-----------
QUERY:
-- Ordinary table
insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
  on conflict do nothing
RESULT: []

-----------
QUERY:
-- rule not fired, so fk violation
insert into rule_and_refint_t3 values (1, 13, 11, 'row6')
  on conflict (id3a, id3b, id3c) do update
  set id3b = excluded.id3b
RESULT: []

-----------
QUERY:
-- rule fired, so unsupported
insert into shoelace values ('sl9', 0, 'pink', 35.0, 'inch', 0.0)
  on conflict (sl_name) do update
  set sl_avail = excluded.sl_avail
RESULT: []

-----------
QUERY:
create rule rule_and_refint_t3_ins as on insert to rule_and_refint_t3
	where (exists (select 1 from rule_and_refint_t3
			where (((rule_and_refint_t3.id3a = new.id3a)
			and (rule_and_refint_t3.id3b = new.id3b))
			and (rule_and_refint_t3.id3c = new.id3c))))
	do instead update rule_and_refint_t3 set data = new.data
	where (((rule_and_refint_t3.id3a = new.id3a)
	and (rule_and_refint_t3.id3b = new.id3b))
	and (rule_and_refint_t3.id3c = new.id3c))
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t3 values (1, 11, 13, 'row7')
RESULT: []

-----------
QUERY:
insert into rule_and_refint_t3 values (1, 13, 11, 'row8')
RESULT: []

-----------
QUERY:
--
-- disallow dropping a view/* REPLACED */''s rule (bug #5072)
--

create view rules_fooview as select 'rules_foo'::text
RESULT: []

-----------
QUERY:
drop rule "_RETURN" on rules_fooview
RESULT: []

-----------
QUERY:
drop view rules_fooview
RESULT: []

-----------
QUERY:
--
-- We used to allow converting a table to a view by creating a /* REPLACED */''_RETURN/* REPLACED */''
-- rule for it, but no more.
--

create table rules_fooview (x int, y text)
RESULT: []

-----------
QUERY:
create rule "_RETURN" as on select to rules_fooview do instead
  select 1 as x, 'aaa'::text as y
RESULT: []

-----------
QUERY:
drop table rules_fooview
RESULT: []

-----------
QUERY:
-- likewise, converting a partitioned table or partition to view is not allowed
create table rules_fooview (x int, y text) partition by list (x)
RESULT: []

-----------
QUERY:
create rule "_RETURN" as on select to rules_fooview do instead
  select 1 as x, 'aaa'::text as y
RESULT: []

-----------
QUERY:
create table rules_fooview_part partition of rules_fooview for values in (1)
RESULT: []

-----------
QUERY:
create rule "_RETURN" as on select to rules_fooview_part do instead
  select 1 as x, 'aaa'::text as y
RESULT: []

-----------
QUERY:
drop table rules_fooview
RESULT: []

-----------
QUERY:
--
-- check for planner problems with complex inherited UPDATES
--

create table id (id serial primary key, name text)
RESULT: []

-----------
QUERY:
-- currently, must respecify PKEY for each inherited subtable
create table test_1 (id integer primary key) inherits (id)
RESULT: []

-----------
QUERY:
create table test_2 (id integer primary key) inherits (id)
RESULT: []

-----------
QUERY:
create table test_3 (id integer primary key) inherits (id)
RESULT: []

-----------
QUERY:
insert into test_1 (name) values ('Test 1')
RESULT: []

-----------
QUERY:
insert into test_1 (name) values ('Test 2')
RESULT: []

-----------
QUERY:
insert into test_2 (name) values ('Test 3')
RESULT: []

-----------
QUERY:
insert into test_2 (name) values ('Test 4')
RESULT: []

-----------
QUERY:
insert into test_3 (name) values ('Test 5')
RESULT: []

-----------
QUERY:
insert into test_3 (name) values ('Test 6')
RESULT: []

-----------
QUERY:
create view id_ordered as select * from id order by id
RESULT: []

-----------
QUERY:
create rule update_id_ordered as on update to id_ordered
	do instead update id set name = new.name where id = old.id
RESULT: []

-----------
QUERY:
select * from id_ordered
RESULT: []

-----------
QUERY:
update id_ordered set name = 'update 2' where id = 2
RESULT: []

-----------
QUERY:
update id_ordered set name = 'update 4' where id = 4
RESULT: []

-----------
QUERY:
update id_ordered set name = 'update 5' where id = 5
RESULT: []

-----------
QUERY:
select * from id_ordered
RESULT: []

-----------
QUERY:
drop table id cascade
RESULT: []

-----------
QUERY:
--
-- check corner case where an entirely-dummy subplan is created by
-- constraint exclusion
--

create temp table t1 (a integer primary key)
RESULT: []

-----------
QUERY:
create temp table t1_1 (check (a >= 0 and a < 10)) inherits (t1)
RESULT: []

-----------
QUERY:
create temp table t1_2 (check (a >= 10 and a < 20)) inherits (t1)
RESULT: []

-----------
QUERY:
create rule t1_ins_1 as on insert to t1
	where new.a >= 0 and new.a < 10
	do instead
	insert into t1_1 values (new.a)
RESULT: []

-----------
QUERY:
create rule t1_ins_2 as on insert to t1
	where new.a >= 10 and new.a < 20
	do instead
	insert into t1_2 values (new.a)
RESULT: []

-----------
QUERY:
create rule t1_upd_1 as on update to t1
	where old.a >= 0 and old.a < 10
	do instead
	update t1_1 set a = new.a where a = old.a
RESULT: []

-----------
QUERY:
create rule t1_upd_2 as on update to t1
	where old.a >= 10 and old.a < 20
	do instead
	update t1_2 set a = new.a where a = old.a
RESULT: []

-----------
QUERY:
set constraint_exclusion = on
RESULT: []

-----------
QUERY:
insert into t1 select * from generate_series(5,19,1) g
RESULT: []

-----------
QUERY:
update t1 set a = 4 where a = 5
RESULT: []

-----------
QUERY:
select * from only t1
RESULT: []

-----------
QUERY:
select * from only t1_1
RESULT: []

-----------
QUERY:
select * from only t1_2
RESULT: []

-----------
QUERY:
reset constraint_exclusion
RESULT: []

-----------
QUERY:
-- test FOR UPDATE in rules

create table rules_base(f1 int, f2 int)
RESULT: []

-----------
QUERY:
insert into rules_base values(1,2), (11,12)
RESULT: []

-----------
QUERY:
create rule r1 as on update to rules_base do instead
  select * from rules_base where f1 = 1 for update
RESULT: []

-----------
QUERY:
update rules_base set f2 = f2 + 1
RESULT: []

-----------
QUERY:
create or replace rule r1 as on update to rules_base do instead
  select * from rules_base where f1 = 11 for update of rules_base
RESULT: []

-----------
QUERY:
update rules_base set f2 = f2 + 1
RESULT: []

-----------
QUERY:
create or replace rule r1 as on update to rules_base do instead
  select * from rules_base where f1 = 11 for update of old
RESULT: []

-----------
QUERY:
-- error
drop table rules_base
RESULT: []

-----------
QUERY:
-- test various flavors of pg_get_viewdef()

select pg_get_viewdef('shoe'::regclass) as unpretty
RESULT: []

-----------
QUERY:
select pg_get_viewdef('shoe'::regclass,true) as pretty
RESULT: []

-----------
QUERY:
select pg_get_viewdef('shoe'::regclass,0) as prettier
RESULT: []

-----------
QUERY:
--
-- check multi-row VALUES in rules
--

create table rules_src(f1 int, f2 int default 0)
RESULT: []

-----------
QUERY:
create table rules_log(f1 int, f2 int, tag text, id serial)
RESULT: []

-----------
QUERY:
insert into rules_src values(1,2), (11,12)
RESULT: []

-----------
QUERY:
create rule r1 as on update to rules_src do also
  insert into rules_log values(old.*, 'old', default), (new.*, 'new', default)
RESULT: []

-----------
QUERY:
update rules_src set f2 = f2 + 1
RESULT: []

-----------
QUERY:
update rules_src set f2 = f2 * 10
RESULT: []

-----------
QUERY:
select * from rules_src
RESULT: []

-----------
QUERY:
select * from rules_log
RESULT: []

-----------
QUERY:
create rule r2 as on update to rules_src do also
  values(old.*, 'old'), (new.*, 'new')
RESULT: []

-----------
QUERY:
update rules_src set f2 = f2 / 10
RESULT: []

-----------
QUERY:
create rule r3 as on insert to rules_src do also
  insert into rules_log values(null, null, '-', default), (new.*, 'new', default)
RESULT: []

-----------
QUERY:
insert into rules_src values(22,23), (33,default)
RESULT: []

-----------
QUERY:
select * from rules_src
RESULT: []

-----------
QUERY:
select * from rules_log
RESULT: []

-----------
QUERY:
create rule r4 as on delete to rules_src do notify rules_src_deletion
RESULT: []

-----------
QUERY:
--
-- Ensure an aliased target relation for insert is correctly deparsed.
--
create rule r5 as on insert to rules_src do instead insert into rules_log AS trgt SELECT NEW.* RETURNING trgt.f1, trgt.f2
RESULT: []

-----------
QUERY:
create rule r6 as on update to rules_src do instead UPDATE rules_log AS trgt SET tag = 'updated' WHERE trgt.f1 = new.f1
RESULT: []

-----------
QUERY:
--
-- Check deparse disambiguation of INSERT/UPDATE/DELETE targets.
--
create rule r7 as on delete to rules_src do instead
  with wins as (insert into int4_tbl as trgt values (0) returning *),
       wupd as (update int4_tbl trgt set f1 = f1+1 returning *),
       wdel as (delete from int4_tbl trgt where f1 = 0 returning *)
  insert into rules_log AS trgt select old.* from wins, wupd, wdel
  returning trgt.f1, trgt.f2
RESULT: []

-----------
QUERY:
-- check display of all rules added above
-- \d+ rules_src

--
-- Also check multiassignment deparsing.
--
create table rule_t1(f1 int, f2 int)
RESULT: []

-----------
QUERY:
create table rule_dest(f1 int, f2 int[], tag text)
RESULT: []

-----------
QUERY:
create rule rr as on update to rule_t1 do instead UPDATE rule_dest trgt
  SET (f2[1], f1, tag) = (SELECT new.f2, new.f1, 'updated'::varchar)
  WHERE trgt.f1 = new.f1 RETURNING new.*
RESULT: []

-----------
QUERY:
-- \d+ rule_t1
drop table rule_t1, rule_dest
RESULT: []

-----------
QUERY:
--
-- Test implicit LATERAL references to old/new in rules
--
CREATE TABLE rule_t1(a int, b text DEFAULT 'xxx', c int)
RESULT: []

-----------
QUERY:
CREATE VIEW rule_v1 AS SELECT * FROM rule_t1
RESULT: []

-----------
QUERY:
CREATE RULE v1_ins AS ON INSERT TO rule_v1
  DO ALSO INSERT INTO rule_t1
  SELECT * FROM (SELECT a + 10 FROM rule_t1 WHERE a = NEW.a) tt
RESULT: []

-----------
QUERY:
CREATE RULE v1_upd AS ON UPDATE TO rule_v1
  DO ALSO UPDATE rule_t1 t
  SET c = tt.a * 10
  FROM (SELECT a FROM rule_t1 WHERE a = OLD.a) tt WHERE t.a = tt.a
RESULT: []

-----------
QUERY:
INSERT INTO rule_v1 VALUES (1, 'a'), (2, 'b')
RESULT: []

-----------
QUERY:
UPDATE rule_v1 SET b = upper(b)
RESULT: []

-----------
QUERY:
SELECT * FROM rule_t1
RESULT: []

-----------
QUERY:
DROP TABLE rule_t1 CASCADE
RESULT: []

-----------
QUERY:
--
-- check alter rename rule
--
CREATE TABLE rule_t1 (a INT)
RESULT: []

-----------
QUERY:
CREATE VIEW rule_v1 AS SELECT * FROM rule_t1
RESULT: []

-----------
QUERY:
CREATE RULE InsertRule AS
    ON INSERT TO rule_v1
    DO INSTEAD
        INSERT INTO rule_t1 VALUES(new.a)
RESULT: []

-----------
QUERY:
ALTER RULE InsertRule ON rule_v1 RENAME to NewInsertRule
RESULT: []

-----------
QUERY:
INSERT INTO rule_v1 VALUES(1)
RESULT: []

-----------
QUERY:
SELECT * FROM rule_v1
RESULT: []

-----------
QUERY:
-- \d+ rule_v1

--
-- error conditions for alter rename rule
--
ALTER RULE InsertRule ON rule_v1 RENAME TO NewInsertRule
RESULT: []

-----------
QUERY:
-- doesn/* REPLACED */''t exist
ALTER RULE NewInsertRule ON rule_v1 RENAME TO "_RETURN"
RESULT: []

-----------
QUERY:
-- already exists
ALTER RULE "_RETURN" ON rule_v1 RENAME TO abc
RESULT: []

-----------
QUERY:
-- ON SELECT rule cannot be renamed

DROP VIEW rule_v1
RESULT: []

-----------
QUERY:
DROP TABLE rule_t1
RESULT: []

-----------
QUERY:
--
-- check display of VALUES in view definitions
--
create view rule_v1 as values(1,2)
RESULT: []

-----------
QUERY:
-- \d+ rule_v1
alter table rule_v1 rename column column2 to q2
RESULT: []

-----------
QUERY:
-- \d+ rule_v1
drop view rule_v1
RESULT: []

-----------
QUERY:
create view rule_v1(x) as values(1,2)
RESULT: []

-----------
QUERY:
-- \d+ rule_v1
drop view rule_v1
RESULT: []

-----------
QUERY:
create view rule_v1(x) as select * from (values(1,2)) v
RESULT: []

-----------
QUERY:
-- \d+ rule_v1
drop view rule_v1
RESULT: []

-----------
QUERY:
create view rule_v1(x) as select * from (values(1,2)) v(q,w)
RESULT: []

-----------
QUERY:
-- \d+ rule_v1
drop view rule_v1
RESULT: []

-----------
QUERY:
--
-- Check DO INSTEAD rules with ON CONFLICT
--
CREATE TABLE hats (
	hat_name    char(10) primary key,
	hat_color   char(10)      -- hat color
)
RESULT: []

-----------
QUERY:
CREATE TABLE hat_data (
	hat_name    char(10),
	hat_color   char(10)      -- hat color
)
RESULT: []

-----------
QUERY:
create unique index hat_data_unique_idx
  on hat_data (hat_name COLLATE "C" bpchar_pattern_ops)
RESULT: []

-----------
QUERY:
-- DO NOTHING with ON CONFLICT
CREATE RULE hat_nosert AS ON INSERT TO hats
    DO INSTEAD
    INSERT INTO hat_data VALUES (
           NEW.hat_name,
           NEW.hat_color)
        ON CONFLICT (hat_name COLLATE "C" bpchar_pattern_ops) WHERE hat_color = 'green'
        DO NOTHING
        RETURNING *
RESULT: []

-----------
QUERY:
SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename
RESULT: []

-----------
QUERY:
-- Works (projects row)
INSERT INTO hats VALUES ('h7', 'black') RETURNING *
RESULT: []

-----------
QUERY:
-- Works (does nothing)
INSERT INTO hats VALUES ('h7', 'black') RETURNING *
RESULT: []

-----------
QUERY:
SELECT tablename, rulename, definition FROM pg_rules
	WHERE tablename = 'hats'
RESULT: []

-----------
QUERY:
DROP RULE hat_nosert ON hats
RESULT: []

-----------
QUERY:
-- DO NOTHING without ON CONFLICT
CREATE RULE hat_nosert_all AS ON INSERT TO hats
    DO INSTEAD
    INSERT INTO hat_data VALUES (
           NEW.hat_name,
           NEW.hat_color)
        ON CONFLICT
        DO NOTHING
        RETURNING *
RESULT: []

-----------
QUERY:
SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename
RESULT: []

-----------
QUERY:
DROP RULE hat_nosert_all ON hats
RESULT: []

-----------
QUERY:
-- Works (does nothing)
INSERT INTO hats VALUES ('h7', 'black') RETURNING *
RESULT: []

-----------
QUERY:
-- DO UPDATE with a WHERE clause
CREATE RULE hat_upsert AS ON INSERT TO hats
    DO INSTEAD
    INSERT INTO hat_data VALUES (
           NEW.hat_name,
           NEW.hat_color)
        ON CONFLICT (hat_name)
        DO UPDATE
           SET hat_name = hat_data.hat_name, hat_color = excluded.hat_color
           WHERE excluded.hat_color <>  'forbidden' AND hat_data.* != excluded.*
        RETURNING *
RESULT: []

-----------
QUERY:
SELECT definition FROM pg_rules WHERE tablename = 'hats' ORDER BY rulename
RESULT: []

-----------
QUERY:
-- Works (does upsert)
INSERT INTO hats VALUES ('h8', 'black') RETURNING *
RESULT: []

-----------
QUERY:
SELECT * FROM hat_data WHERE hat_name = 'h8'
RESULT: []

-----------
QUERY:
INSERT INTO hats VALUES ('h8', 'white') RETURNING *
RESULT: []

-----------
QUERY:
SELECT * FROM hat_data WHERE hat_name = 'h8'
RESULT: []

-----------
QUERY:
INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *
RESULT: []

-----------
QUERY:
SELECT * FROM hat_data WHERE hat_name = 'h8'
RESULT: []

-----------
QUERY:
SELECT tablename, rulename, definition FROM pg_rules
	WHERE tablename = 'hats'
RESULT: []

-----------
QUERY:
-- ensure explain works for on insert conflict rules
explain (costs off) INSERT INTO hats VALUES ('h8', 'forbidden') RETURNING *
RESULT: []

-----------
QUERY:
-- ensure upserting into a rule, with a CTE (different offsets!) works
WITH data(hat_name, hat_color) AS MATERIALIZED (
    VALUES ('h8', 'green'),
        ('h9', 'blue'),
        ('h7', 'forbidden')
)
INSERT INTO hats
    SELECT * FROM data
RETURNING *
RESULT: []

-----------
QUERY:
EXPLAIN (costs off)
WITH data(hat_name, hat_color) AS MATERIALIZED (
    VALUES ('h8', 'green'),
        ('h9', 'blue'),
        ('h7', 'forbidden')
)
INSERT INTO hats
    SELECT * FROM data
RETURNING *
RESULT: []

-----------
QUERY:
SELECT * FROM hat_data WHERE hat_name IN ('h8', 'h9', 'h7') ORDER BY hat_name
RESULT: []

-----------
QUERY:
DROP RULE hat_upsert ON hats
RESULT: []

-----------
QUERY:
drop table hats
RESULT: []

-----------
QUERY:
drop table hat_data
RESULT: []

-----------
QUERY:
-- test for pg_get_functiondef properly regurgitating SET parameters
-- Note that the function is kept around to stress pg_dump.
CREATE FUNCTION func_with_set_params() RETURNS integer
    AS 'select 1
RESULT: []

-----------
QUERY:
'
    LANGUAGE SQL
    SET search_path TO PG_CATALOG
    SET extra_float_digits TO 2
    SET work_mem TO '4MB'
    SET datestyle to iso, mdy
    SET local_preload_libraries TO "Mixed/Case", 'c:/''a"/path', '', '0123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789'
    IMMUTABLE STRICT
RESULT: []

-----------
QUERY:
SELECT pg_get_functiondef('func_with_set_params()'::regprocedure)
RESULT: []

-----------
QUERY:
-- tests for pg_get_*def with invalid objects
SELECT pg_get_constraintdef(0)
RESULT: []

-----------
QUERY:
SELECT pg_get_functiondef(0)
RESULT: []

-----------
QUERY:
SELECT pg_get_indexdef(0)
RESULT: []

-----------
QUERY:
SELECT pg_get_ruledef(0)
RESULT: []

-----------
QUERY:
SELECT pg_get_statisticsobjdef(0)
RESULT: []

-----------
QUERY:
SELECT pg_get_triggerdef(0)
RESULT: []

-----------
QUERY:
SELECT pg_get_viewdef(0)
RESULT: []

-----------
QUERY:
SELECT pg_get_function_arguments(0)
RESULT: []

-----------
QUERY:
SELECT pg_get_function_identity_arguments(0)
RESULT: []

-----------
QUERY:
SELECT pg_get_function_result(0)
RESULT: []

-----------
QUERY:
SELECT pg_get_function_arg_default(0, 0)
RESULT: []

-----------
QUERY:
SELECT pg_get_function_arg_default('pg_class'::regclass, 0)
RESULT: []

-----------
QUERY:
SELECT pg_get_partkeydef(0)
RESULT: []

-----------
QUERY:
-- test rename for a rule defined on a partitioned table
CREATE TABLE rules_parted_table (a int) PARTITION BY LIST (a)
RESULT: []

-----------
QUERY:
CREATE TABLE rules_parted_table_1 PARTITION OF rules_parted_table FOR VALUES IN (1)
RESULT: []

-----------
QUERY:
CREATE RULE rules_parted_table_insert AS ON INSERT to rules_parted_table
    DO INSTEAD INSERT INTO rules_parted_table_1 VALUES (NEW.*)
RESULT: []

-----------
QUERY:
ALTER RULE rules_parted_table_insert ON rules_parted_table RENAME TO rules_parted_table_insert_redirect
RESULT: []

-----------
QUERY:
DROP TABLE rules_parted_table
RESULT: []

-----------
QUERY:
--
-- test MERGE
--
CREATE TABLE rule_merge1 (a int, b text)
RESULT: []

-----------
QUERY:
CREATE TABLE rule_merge2 (a int, b text)
RESULT: []

-----------
QUERY:
CREATE RULE rule1 AS ON INSERT TO rule_merge1
	DO INSTEAD INSERT INTO rule_merge2 VALUES (NEW.*)
RESULT: []

-----------
QUERY:
CREATE RULE rule2 AS ON UPDATE TO rule_merge1
	DO INSTEAD UPDATE rule_merge2 SET a = NEW.a, b = NEW.b
	WHERE a = OLD.a
RESULT: []

-----------
QUERY:
CREATE RULE rule3 AS ON DELETE TO rule_merge1
	DO INSTEAD DELETE FROM rule_merge2 WHERE a = OLD.a
RESULT: []

-----------
QUERY:
-- MERGE not supported for table with rules
MERGE INTO rule_merge1 t USING (SELECT 1 AS a) s
	ON t.a = s.a
	WHEN MATCHED AND t.a < 2 THEN
		UPDATE SET b = b || ' updated by merge'
	WHEN MATCHED AND t.a > 2 THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT VALUES (s.a, '')
RESULT: []

-----------
QUERY:
-- should be ok with the other table though
MERGE INTO rule_merge2 t USING (SELECT 1 AS a) s
	ON t.a = s.a
	WHEN MATCHED AND t.a < 2 THEN
		UPDATE SET b = b || ' updated by merge'
	WHEN MATCHED AND t.a > 2 THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT VALUES (s.a, '')
RESULT: []

-----------
QUERY:
-- also ok if the rules are disabled
ALTER TABLE rule_merge1 DISABLE RULE rule1
RESULT: []

-----------
QUERY:
ALTER TABLE rule_merge1 DISABLE RULE rule2
RESULT: []

-----------
QUERY:
ALTER TABLE rule_merge1 DISABLE RULE rule3
RESULT: []

-----------
QUERY:
MERGE INTO rule_merge1 t USING (SELECT 1 AS a) s
	ON t.a = s.a
	WHEN MATCHED AND t.a < 2 THEN
		UPDATE SET b = b || ' updated by merge'
	WHEN MATCHED AND t.a > 2 THEN
		DELETE
	WHEN NOT MATCHED THEN
		INSERT VALUES (s.a, '')
RESULT: []

-----------
QUERY:
-- test deparsing
CREATE TABLE sf_target(id int, data text, filling int[])
RESULT: []

-----------
QUERY:
CREATE FUNCTION merge_sf_test()
 RETURNS TABLE(action text, a int, b text, id int, data text, filling int[])
 LANGUAGE sql
BEGIN ATOMIC
 MERGE INTO sf_target t
   USING rule_merge1 s
   ON (s.a = t.id)
WHEN MATCHED
   AND (s.a + t.id) = 42
   THEN UPDATE SET data = repeat(t.data, s.a) || s.b, id = length(s.b)
WHEN NOT MATCHED
   AND (s.b IS NOT NULL)
   THEN INSERT (data, id)
   VALUES (s.b, s.a)
WHEN MATCHED
   AND length(s.b || t.data) > 10
   THEN UPDATE SET data = s.b
WHEN MATCHED
   AND s.a > 200
   THEN UPDATE SET filling[s.a] = t.id
WHEN MATCHED
   AND s.a > 100
   THEN DELETE
WHEN MATCHED
   THEN DO NOTHING
WHEN NOT MATCHED
   AND s.a > 200
   THEN INSERT DEFAULT VALUES
WHEN NOT MATCHED
   AND s.a > 100
   THEN INSERT (id, data) OVERRIDING USER VALUE
   VALUES (s.a, DEFAULT)
WHEN NOT MATCHED
   AND s.a > 0
   THEN INSERT
   VALUES (s.a, s.b, DEFAULT)
WHEN NOT MATCHED
   THEN INSERT (filling[1], id)
   VALUES (s.a, s.a)
RETURNING
   merge_action() AS action, *
RESULT: []

-----------
QUERY:
END
RESULT: []

-----------
QUERY:
\sf merge_sf_test

DROP FUNCTION merge_sf_test
RESULT: []

-----------
QUERY:
DROP TABLE sf_target
RESULT: []

-----------
QUERY:
--
-- Test enabling/disabling
--
CREATE TABLE ruletest1 (a int)
RESULT: []

-----------
QUERY:
CREATE TABLE ruletest2 (b int)
RESULT: []

-----------
QUERY:
CREATE RULE rule1 AS ON INSERT TO ruletest1
    DO INSTEAD INSERT INTO ruletest2 VALUES (NEW.*)
RESULT: []

-----------
QUERY:
INSERT INTO ruletest1 VALUES (1)
RESULT: []

-----------
QUERY:
ALTER TABLE ruletest1 DISABLE RULE rule1
RESULT: []

-----------
QUERY:
INSERT INTO ruletest1 VALUES (2)
RESULT: []

-----------
QUERY:
ALTER TABLE ruletest1 ENABLE RULE rule1
RESULT: []

-----------
QUERY:
SET session_replication_role = replica
RESULT: []

-----------
QUERY:
INSERT INTO ruletest1 VALUES (3)
RESULT: []

-----------
QUERY:
ALTER TABLE ruletest1 ENABLE REPLICA RULE rule1
RESULT: []

-----------
QUERY:
INSERT INTO ruletest1 VALUES (4)
RESULT: []

-----------
QUERY:
RESET session_replication_role
RESULT: []

-----------
QUERY:
INSERT INTO ruletest1 VALUES (5)
RESULT: []

-----------
QUERY:
SELECT * FROM ruletest1
RESULT: []

-----------
QUERY:
SELECT * FROM ruletest2
RESULT: []

-----------
QUERY:
DROP TABLE ruletest1
RESULT: []

-----------
QUERY:
DROP TABLE ruletest2
RESULT: []

-----------
QUERY:
--
-- Test non-SELECT rule on security invoker view.
-- Should use view owner/* REPLACED */''s permissions.
--
CREATE USER regress_rule_user1
RESULT: []

-----------
QUERY:
CREATE TABLE ruletest_t1 (x int)
RESULT: []

-----------
QUERY:
CREATE TABLE ruletest_t2 (x int)
RESULT: []

-----------
QUERY:
CREATE VIEW ruletest_v1 WITH (security_invoker=true) AS
    SELECT * FROM ruletest_t1
RESULT: []

-----------
QUERY:
GRANT INSERT ON ruletest_v1 TO regress_rule_user1
RESULT: []

-----------
QUERY:
CREATE RULE rule1 AS ON INSERT TO ruletest_v1
    DO INSTEAD INSERT INTO ruletest_t2 VALUES (NEW.*)
RESULT: []

-----------
QUERY:
SET SESSION AUTHORIZATION regress_rule_user1
RESULT: []

-----------
QUERY:
INSERT INTO ruletest_v1 VALUES (1)
RESULT: []

-----------
QUERY:
RESET SESSION AUTHORIZATION
RESULT: []

-----------
QUERY:
-- Test that main query/* REPLACED */''s relation/* REPLACED */''s permissions are checked before
-- the rule action/* REPLACED */''s relation/* REPLACED */''s.
CREATE TABLE ruletest_t3 (x int)
RESULT: []

-----------
QUERY:
CREATE RULE rule2 AS ON UPDATE TO ruletest_t1
    DO INSTEAD INSERT INTO ruletest_t2 VALUES (OLD.*)
RESULT: []

-----------
QUERY:
REVOKE ALL ON ruletest_t2 FROM regress_rule_user1
RESULT: []

-----------
QUERY:
REVOKE ALL ON ruletest_t3 FROM regress_rule_user1
RESULT: []

-----------
QUERY:
ALTER TABLE ruletest_t1 OWNER TO regress_rule_user1
RESULT: []

-----------
QUERY:
SET SESSION AUTHORIZATION regress_rule_user1
RESULT: []

-----------
QUERY:
UPDATE ruletest_t1 t1 SET x = 0 FROM ruletest_t3 t3 WHERE t1.x = t3.x
RESULT: []

-----------
QUERY:
RESET SESSION AUTHORIZATION
RESULT: []

-----------
QUERY:
SELECT * FROM ruletest_t1
RESULT: []

-----------
QUERY:
SELECT * FROM ruletest_t2
RESULT: []

-----------
QUERY:
DROP VIEW ruletest_v1
RESULT: []

-----------
QUERY:
DROP RULE rule2 ON ruletest_t1
RESULT: []

-----------
QUERY:
DROP TABLE ruletest_t3
RESULT: []

-----------
QUERY:
DROP TABLE ruletest_t2
RESULT: []

-----------
QUERY:
DROP TABLE ruletest_t1
RESULT: []

-----------
QUERY:
DROP USER regress_rule_user1
RESULT: []
=========================================
Summary for test case rules/test.sql of postgres
=========================================
