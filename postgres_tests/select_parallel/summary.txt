Guest DBMS identified: postgres
-----------
QUERY:
--
-- PARALLEL
--

create function sp_parallel_restricted(int) returns int as
  $$begin return $1; end$$ language plpgsql parallel restricted
RESULT: []

-----------
QUERY:
begin
RESULT: []

-----------
QUERY:
-- encourage use of parallel plans
set parallel_setup_cost=0
RESULT: []

-----------
QUERY:
set parallel_tuple_cost=0
RESULT: []

-----------
QUERY:
set min_parallel_table_scan_size=0
RESULT: []

-----------
QUERY:
set max_parallel_workers_per_gather=4
RESULT: []

-----------
QUERY:
-- Parallel Append with partial-subplans
explain (costs off)
  select round(avg(aa)), sum(aa) from a_star
RESULT: []

-----------
QUERY:
select round(avg(aa)), sum(aa) from a_star a1
RESULT: []

-----------
QUERY:
-- Parallel Append with both partial and non-partial subplans
alter table c_star set (parallel_workers = 0)
RESULT: []

-----------
QUERY:
alter table d_star set (parallel_workers = 0)
RESULT: []

-----------
QUERY:
explain (costs off)
  select round(avg(aa)), sum(aa) from a_star
RESULT: []

-----------
QUERY:
select round(avg(aa)), sum(aa) from a_star a2
RESULT: []

-----------
QUERY:
-- Parallel Append with only non-partial subplans
alter table a_star set (parallel_workers = 0)
RESULT: []

-----------
QUERY:
alter table b_star set (parallel_workers = 0)
RESULT: []

-----------
QUERY:
alter table e_star set (parallel_workers = 0)
RESULT: []

-----------
QUERY:
alter table f_star set (parallel_workers = 0)
RESULT: []

-----------
QUERY:
explain (costs off)
  select round(avg(aa)), sum(aa) from a_star
RESULT: []

-----------
QUERY:
select round(avg(aa)), sum(aa) from a_star a3
RESULT: []

-----------
QUERY:
-- Disable Parallel Append
alter table a_star reset (parallel_workers)
RESULT: []

-----------
QUERY:
alter table b_star reset (parallel_workers)
RESULT: []

-----------
QUERY:
alter table c_star reset (parallel_workers)
RESULT: []

-----------
QUERY:
alter table d_star reset (parallel_workers)
RESULT: []

-----------
QUERY:
alter table e_star reset (parallel_workers)
RESULT: []

-----------
QUERY:
alter table f_star reset (parallel_workers)
RESULT: []

-----------
QUERY:
set enable_parallel_append to off
RESULT: []

-----------
QUERY:
explain (costs off)
  select round(avg(aa)), sum(aa) from a_star
RESULT: []

-----------
QUERY:
select round(avg(aa)), sum(aa) from a_star a4
RESULT: []

-----------
QUERY:
reset enable_parallel_append
RESULT: []

-----------
QUERY:
-- Parallel Append that runs serially
create function sp_test_func() returns setof text as
$$ select 'foo'::varchar union all select 'bar'::varchar $$
language sql stable
RESULT: []

-----------
QUERY:
select sp_test_func() order by 1
RESULT: []

-----------
QUERY:
-- Parallel Append is not to be used when the subpath depends on the outer param
create table part_pa_test(a int, b int) partition by range(a)
RESULT: []

-----------
QUERY:
create table part_pa_test_p1 partition of part_pa_test for values from (minvalue) to (0)
RESULT: []

-----------
QUERY:
create table part_pa_test_p2 partition of part_pa_test for values from (0) to (maxvalue)
RESULT: []

-----------
QUERY:
explain (costs off)
	select (select max((select pa1.b from part_pa_test pa1 where pa1.a = pa2.a)))
	from part_pa_test pa2
RESULT: []

-----------
QUERY:
drop table part_pa_test
RESULT: []

-----------
QUERY:
-- test with leader participation disabled
set parallel_leader_participation = off
RESULT: []

-----------
QUERY:
explain (costs off)
  select count(*) from tenk1 where stringu1 = 'GRAAAA'
RESULT: []

-----------
QUERY:
select count(*) from tenk1 where stringu1 = 'GRAAAA'
RESULT: []

-----------
QUERY:
-- test with leader participation disabled, but no workers available (so
-- the leader will have to run the plan despite the setting)
set max_parallel_workers = 0
RESULT: []

-----------
QUERY:
explain (costs off)
  select count(*) from tenk1 where stringu1 = 'GRAAAA'
RESULT: []

-----------
QUERY:
select count(*) from tenk1 where stringu1 = 'GRAAAA'
RESULT: []

-----------
QUERY:
reset max_parallel_workers
RESULT: []

-----------
QUERY:
reset parallel_leader_participation
RESULT: []

-----------
QUERY:
-- test that parallel_restricted function doesn/* REPLACED */''t run in worker
alter table tenk1 set (parallel_workers = 4)
RESULT: []

-----------
QUERY:
explain (verbose, costs off)
select sp_parallel_restricted(unique1) from tenk1
  where stringu1 = 'GRAAAA' order by 1
RESULT: []

-----------
QUERY:
-- test parallel plan when group by expression is in target list.
explain (costs off)
	select length(stringu1) from tenk1 group by length(stringu1)
RESULT: []

-----------
QUERY:
select length(stringu1) from tenk1 group by length(stringu1)
RESULT: []

-----------
QUERY:
explain (costs off)
	select stringu1, count(*) from tenk1 group by stringu1 order by stringu1
RESULT: []

-----------
QUERY:
-- test that parallel plan for aggregates is not selected when
-- target list contains parallel restricted clause.
explain (costs off)
	select  sum(sp_parallel_restricted(unique1)) from tenk1
	group by(sp_parallel_restricted(unique1))
RESULT: []

-----------
QUERY:
-- test prepared statement
prepare tenk1_count(integer) As select  count((unique1)) from tenk1 where hundred > $1
RESULT: []

-----------
QUERY:
explain (costs off) execute tenk1_count(1)
RESULT: []

-----------
QUERY:
execute tenk1_count(1)
RESULT: []

-----------
QUERY:
deallocate tenk1_count
RESULT: []

-----------
QUERY:
-- test parallel plans for queries containing un-correlated subplans.
alter table tenk2 set (parallel_workers = 0)
RESULT: []

-----------
QUERY:
explain (costs off)
	select count(*) from tenk1 where (two, four) not in
	(select hundred, thousand from tenk2 where thousand > 100)
RESULT: []

-----------
QUERY:
select count(*) from tenk1 where (two, four) not in
	(select hundred, thousand from tenk2 where thousand > 100)
RESULT: []

-----------
QUERY:
-- this is not parallel-safe due to use of random() within SubLink/* REPLACED */''s testexpr:
explain (costs off)
	select * from tenk1 where (unique1 + random())::integer not in
	(select ten from tenk2)
RESULT: []

-----------
QUERY:
alter table tenk2 reset (parallel_workers)
RESULT: []

-----------
QUERY:
-- test parallel plan for a query containing initplan.
set enable_indexscan = off
RESULT: []

-----------
QUERY:
set enable_indexonlyscan = off
RESULT: []

-----------
QUERY:
set enable_bitmapscan = off
RESULT: []

-----------
QUERY:
alter table tenk2 set (parallel_workers = 2)
RESULT: []

-----------
QUERY:
explain (costs off)
	select count(*) from tenk1
        where tenk1.unique1 = (Select max(tenk2.unique1) from tenk2)
RESULT: []

-----------
QUERY:
select count(*) from tenk1
    where tenk1.unique1 = (Select max(tenk2.unique1) from tenk2)
RESULT: []

-----------
QUERY:
reset enable_indexscan
RESULT: []

-----------
QUERY:
reset enable_indexonlyscan
RESULT: []

-----------
QUERY:
reset enable_bitmapscan
RESULT: []

-----------
QUERY:
alter table tenk2 reset (parallel_workers)
RESULT: []

-----------
QUERY:
-- test parallel index scans.
set enable_seqscan to off
RESULT: []

-----------
QUERY:
set enable_bitmapscan to off
RESULT: []

-----------
QUERY:
explain (costs off)
	select  count((unique1)) from tenk1 where hundred > 1
RESULT: []

-----------
QUERY:
select  count((unique1)) from tenk1 where hundred > 1
RESULT: []

-----------
QUERY:
-- test parallel index-only scans.
explain (costs off)
	select  count(*) from tenk1 where thousand > 95
RESULT: []

-----------
QUERY:
select  count(*) from tenk1 where thousand > 95
RESULT: []

-----------
QUERY:
-- test rescan cases too
set enable_material = false
RESULT: []

-----------
QUERY:
explain (costs off)
select * from
  (select count(unique1) from tenk1 where hundred > 10) ss
  right join (values (1),(2),(3)) v(x) on true
RESULT: []

-----------
QUERY:
select * from
  (select count(unique1) from tenk1 where hundred > 10) ss
  right join (values (1),(2),(3)) v(x) on true
RESULT: []

-----------
QUERY:
explain (costs off)
select * from
  (select count(*) from tenk1 where thousand > 99) ss
  right join (values (1),(2),(3)) v(x) on true
RESULT: []

-----------
QUERY:
select * from
  (select count(*) from tenk1 where thousand > 99) ss
  right join (values (1),(2),(3)) v(x) on true
RESULT: []

-----------
QUERY:
-- test rescans for a Limit node with a parallel node beneath it.
reset enable_seqscan
RESULT: []

-----------
QUERY:
set enable_indexonlyscan to off
RESULT: []

-----------
QUERY:
set enable_indexscan to off
RESULT: []

-----------
QUERY:
alter table tenk1 set (parallel_workers = 0)
RESULT: []

-----------
QUERY:
alter table tenk2 set (parallel_workers = 1)
RESULT: []

-----------
QUERY:
explain (costs off)
select count(*) from tenk1
  left join (select tenk2.unique1 from tenk2 order by 1 limit 1000) ss
  on tenk1.unique1 < ss.unique1 + 1
  where tenk1.unique1 < 2
RESULT: []

-----------
QUERY:
select count(*) from tenk1
  left join (select tenk2.unique1 from tenk2 order by 1 limit 1000) ss
  on tenk1.unique1 < ss.unique1 + 1
  where tenk1.unique1 < 2
RESULT: []

-----------
QUERY:
--reset the value of workers for each table as it was before this test.
alter table tenk1 set (parallel_workers = 4)
RESULT: []

-----------
QUERY:
alter table tenk2 reset (parallel_workers)
RESULT: []

-----------
QUERY:
reset enable_material
RESULT: []

-----------
QUERY:
reset enable_bitmapscan
RESULT: []

-----------
QUERY:
reset enable_indexonlyscan
RESULT: []

-----------
QUERY:
reset enable_indexscan
RESULT: []

-----------
QUERY:
-- test parallel bitmap heap scan.
set enable_seqscan to off
RESULT: []

-----------
QUERY:
set enable_indexscan to off
RESULT: []

-----------
QUERY:
set enable_hashjoin to off
RESULT: []

-----------
QUERY:
set enable_mergejoin to off
RESULT: []

-----------
QUERY:
set enable_material to off
RESULT: []

-----------
QUERY:
-- test prefetching, if the platform allows it
DO $$
BEGIN
 SET effective_io_concurrency = 50;
EXCEPTION WHEN invalid_parameter_value THEN
END $$
RESULT: []

-----------
QUERY:
set work_mem='64kB'
RESULT: []

-----------
QUERY:
--set small work mem to force lossy pages
explain (costs off)
	select count(*) from tenk1, tenk2 where tenk1.hundred > 1 and tenk2.thousand=0
RESULT: []

-----------
QUERY:
select count(*) from tenk1, tenk2 where tenk1.hundred > 1 and tenk2.thousand=0
RESULT: []

-----------
QUERY:
create table bmscantest (a int, t text)
RESULT: []

-----------
QUERY:
insert into bmscantest select r, 'fooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo' FROM generate_series(1,100000) r
RESULT: []

-----------
QUERY:
create index i_bmtest ON bmscantest(a)
RESULT: []

-----------
QUERY:
select count(*) from bmscantest where a>1
RESULT: []

-----------
QUERY:
-- test accumulation of stats for parallel nodes
reset enable_seqscan
RESULT: []

-----------
QUERY:
alter table tenk2 set (parallel_workers = 0)
RESULT: []

-----------
QUERY:
explain (analyze, timing off, summary off, costs off)
   select count(*) from tenk1, tenk2 where tenk1.hundred > 1
        and tenk2.thousand=0
RESULT: []

-----------
QUERY:
alter table tenk2 reset (parallel_workers)
RESULT: []

-----------
QUERY:
reset work_mem
RESULT: []

-----------
QUERY:
create function explain_parallel_sort_stats() returns setof text
language plpgsql as
$$
declare ln text;
begin
    for ln in
        explain (analyze, timing off, summary off, costs off)
          select * from
          (select ten from tenk1 where ten < 100 order by ten) ss
          right join (values (1),(2),(3)) v(x) on true
    loop
        ln := regexp_replace(ln, 'Memory: \S*',  'Memory: xxx');
        return next ln;
    end loop;
end;
$$
RESULT: []

-----------
QUERY:
select * from explain_parallel_sort_stats()
RESULT: []

-----------
QUERY:
reset enable_indexscan
RESULT: []

-----------
QUERY:
reset enable_hashjoin
RESULT: []

-----------
QUERY:
reset enable_mergejoin
RESULT: []

-----------
QUERY:
reset enable_material
RESULT: []

-----------
QUERY:
reset effective_io_concurrency
RESULT: []

-----------
QUERY:
drop table bmscantest
RESULT: []

-----------
QUERY:
drop function explain_parallel_sort_stats()
RESULT: []

-----------
QUERY:
-- test parallel merge join path.
set enable_hashjoin to off
RESULT: []

-----------
QUERY:
set enable_nestloop to off
RESULT: []

-----------
QUERY:
explain (costs off)
	select  count(*) from tenk1, tenk2 where tenk1.unique1 = tenk2.unique1
RESULT: []

-----------
QUERY:
select  count(*) from tenk1, tenk2 where tenk1.unique1 = tenk2.unique1
RESULT: []

-----------
QUERY:
reset enable_hashjoin
RESULT: []

-----------
QUERY:
reset enable_nestloop
RESULT: []

-----------
QUERY:
-- test gather merge
set enable_hashagg = false
RESULT: []

-----------
QUERY:
explain (costs off)
   select count(*) from tenk1 group by twenty
RESULT: []

-----------
QUERY:
select count(*) from tenk1 group by twenty
RESULT: []

-----------
QUERY:
--test expressions in targetlist are pushed down for gather merge
create function sp_simple_func(var1 integer) returns integer
as $$
begin
        return var1 + 10;
end;
$$ language plpgsql PARALLEL SAFE
RESULT: []

-----------
QUERY:
explain (costs off, verbose)
    select ten, sp_simple_func(ten) from tenk1 where ten < 100 order by ten
RESULT: []

-----------
QUERY:
drop function sp_simple_func(integer)
RESULT: []

-----------
QUERY:
-- test handling of SRFs in targetlist (bug in 10.0)

explain (costs off)
   select count(*), generate_series(1,2) from tenk1 group by twenty
RESULT: []

-----------
QUERY:
select count(*), generate_series(1,2) from tenk1 group by twenty
RESULT: []

-----------
QUERY:
-- test gather merge with parallel leader participation disabled
set parallel_leader_participation = off
RESULT: []

-----------
QUERY:
explain (costs off)
   select count(*) from tenk1 group by twenty
RESULT: []

-----------
QUERY:
select count(*) from tenk1 group by twenty
RESULT: []

-----------
QUERY:
reset parallel_leader_participation
RESULT: []

-----------
QUERY:
--test rescan behavior of gather merge
set enable_material = false
RESULT: []

-----------
QUERY:
explain (costs off)
select * from
  (select string4, count(unique2)
   from tenk1 group by string4 order by string4) ss
  right join (values (1),(2),(3)) v(x) on true
RESULT: []

-----------
QUERY:
select * from
  (select string4, count(unique2)
   from tenk1 group by string4 order by string4) ss
  right join (values (1),(2),(3)) v(x) on true
RESULT: []

-----------
QUERY:
reset enable_material
RESULT: []

-----------
QUERY:
reset enable_hashagg
RESULT: []

-----------
QUERY:
-- check parallelized int8 aggregate (bug #14897)
explain (costs off)
select avg(unique1::int8) from tenk1
RESULT: []

-----------
QUERY:
select avg(unique1::int8) from tenk1
RESULT: []

-----------
QUERY:
-- gather merge test with a LIMIT
explain (costs off)
  select fivethous from tenk1 order by fivethous limit 4
RESULT: []

-----------
QUERY:
select fivethous from tenk1 order by fivethous limit 4
RESULT: []

-----------
QUERY:
-- gather merge test with 0 worker
set max_parallel_workers = 0
RESULT: []

-----------
QUERY:
explain (costs off)
   select string4 from tenk1 order by string4 limit 5
RESULT: []

-----------
QUERY:
select string4 from tenk1 order by string4 limit 5
RESULT: []

-----------
QUERY:
-- gather merge test with 0 workers, with parallel leader
-- participation disabled (the leader will have to run the plan
-- despite the setting)
set parallel_leader_participation = off
RESULT: []

-----------
QUERY:
explain (costs off)
   select string4 from tenk1 order by string4 limit 5
RESULT: []

-----------
QUERY:
select string4 from tenk1 order by string4 limit 5
RESULT: []

-----------
QUERY:
reset parallel_leader_participation
RESULT: []

-----------
QUERY:
reset max_parallel_workers
RESULT: []

-----------
QUERY:
create function parallel_safe_volatile(a int) returns int as
  $$ begin return a; end; $$ parallel safe volatile language plpgsql
RESULT: []

-----------
QUERY:
-- Test gather merge atop of a sort of a partial path
explain (costs off)
select * from tenk1 where four = 2
order by four, hundred, parallel_safe_volatile(thousand)
RESULT: []

-----------
QUERY:
-- Test gather merge atop of an incremental sort a of partial path
set min_parallel_index_scan_size = 0
RESULT: []

-----------
QUERY:
set enable_seqscan = off
RESULT: []

-----------
QUERY:
explain (costs off)
select * from tenk1 where four = 2
order by four, hundred, parallel_safe_volatile(thousand)
RESULT: []

-----------
QUERY:
reset min_parallel_index_scan_size
RESULT: []

-----------
QUERY:
reset enable_seqscan
RESULT: []

-----------
QUERY:
-- Test GROUP BY with a gather merge path atop of a sort of a partial path
explain (costs off)
select count(*) from tenk1
group by twenty, parallel_safe_volatile(two)
RESULT: []

-----------
QUERY:
drop function parallel_safe_volatile(int)
RESULT: []

-----------
QUERY:
SAVEPOINT settings
RESULT: []

-----------
QUERY:
SET LOCAL debug_parallel_query = 1
RESULT: []

-----------
QUERY:
explain (costs off)
  select stringu1::int2 from tenk1 where unique1 = 1
RESULT: []

-----------
QUERY:
ROLLBACK TO SAVEPOINT settings
RESULT: []

-----------
QUERY:
-- exercise record typmod remapping between backends
CREATE FUNCTION make_record(n int)
  RETURNS RECORD LANGUAGE plpgsql PARALLEL SAFE AS
$$
BEGIN
  RETURN CASE n
           WHEN 1 THEN ROW(1)
           WHEN 2 THEN ROW(1, 2)
           WHEN 3 THEN ROW(1, 2, 3)
           WHEN 4 THEN ROW(1, 2, 3, 4)
           ELSE ROW(1, 2, 3, 4, 5)
         END;
END;
$$
RESULT: []

-----------
QUERY:
SAVEPOINT settings
RESULT: []

-----------
QUERY:
SET LOCAL debug_parallel_query = 1
RESULT: []

-----------
QUERY:
SELECT make_record(x) FROM (SELECT generate_series(1, 5) x) ss ORDER BY x
RESULT: []

-----------
QUERY:
ROLLBACK TO SAVEPOINT settings
RESULT: []

-----------
QUERY:
DROP function make_record(n int)
RESULT: []

-----------
QUERY:
-- test the sanity of parallel query after the active role is dropped.
drop role if exists regress_parallel_worker
RESULT: []

-----------
QUERY:
create role regress_parallel_worker
RESULT: []

-----------
QUERY:
set role regress_parallel_worker
RESULT: []

-----------
QUERY:
reset session authorization
RESULT: []

-----------
QUERY:
drop role regress_parallel_worker
RESULT: []

-----------
QUERY:
set debug_parallel_query = 1
RESULT: []

-----------
QUERY:
select count(*) from tenk1
RESULT: []

-----------
QUERY:
reset debug_parallel_query
RESULT: []

-----------
QUERY:
reset role
RESULT: []

-----------
QUERY:
-- Window function calculation can/* REPLACED */''t be pushed to workers.
explain (costs off, verbose)
  select count(*) from tenk1 a where (unique1, two) in
    (select unique1, row_number() over() from tenk1 b)
RESULT: []

-----------
QUERY:
-- LIMIT/OFFSET within sub-selects can/* REPLACED */''t be pushed to workers.
explain (costs off)
  select * from tenk1 a where two in
    (select two from tenk1 b where stringu1 like '%AAAA' limit 3)
RESULT: []

-----------
QUERY:
-- to increase the parallel query test coverage
SAVEPOINT settings
RESULT: []

-----------
QUERY:
SET LOCAL debug_parallel_query = 1
RESULT: []

-----------
QUERY:
EXPLAIN (analyze, timing off, summary off, costs off) SELECT * FROM tenk1
RESULT: []

-----------
QUERY:
ROLLBACK TO SAVEPOINT settings
RESULT: []

-----------
QUERY:
-- provoke error in worker
-- (make the error message long enough to require multiple bufferloads)
SAVEPOINT settings
RESULT: []

-----------
QUERY:
SET LOCAL debug_parallel_query = 1
RESULT: []

-----------
QUERY:
select (stringu1 || repeat('abcd', 5000))::int2 from tenk1 where unique1 = 1
RESULT: []

-----------
QUERY:
ROLLBACK TO SAVEPOINT settings
RESULT: []

-----------
QUERY:
-- test interaction with set-returning functions
SAVEPOINT settings
RESULT: []

-----------
QUERY:
-- multiple subqueries under a single Gather node
-- must set parallel_setup_cost > 0 to discourage multiple Gather nodes
SET LOCAL parallel_setup_cost = 10
RESULT: []

-----------
QUERY:
EXPLAIN (COSTS OFF)
SELECT unique1 FROM tenk1 WHERE fivethous = tenthous + 1
UNION ALL
SELECT unique1 FROM tenk1 WHERE fivethous = tenthous + 1
RESULT: []

-----------
QUERY:
ROLLBACK TO SAVEPOINT settings
RESULT: []

-----------
QUERY:
-- can/* REPLACED */''t use multiple subqueries under a single Gather node due to initPlans
EXPLAIN (COSTS OFF)
SELECT unique1 FROM tenk1 WHERE fivethous =
	(SELECT unique1 FROM tenk1 WHERE fivethous = 1 LIMIT 1)
UNION ALL
SELECT unique1 FROM tenk1 WHERE fivethous =
	(SELECT unique2 FROM tenk1 WHERE fivethous = 1 LIMIT 1)
ORDER BY 1
RESULT: []

-----------
QUERY:
-- test interaction with SRFs
SELECT * FROM information_schema.foreign_data_wrapper_options
ORDER BY 1, 2, 3
RESULT: []

-----------
QUERY:
EXPLAIN (VERBOSE, COSTS OFF)
SELECT generate_series(1, two), array(select generate_series(1, two))
  FROM tenk1 ORDER BY tenthous
RESULT: []

-----------
QUERY:
-- must disallow pushing sort below gather when pathkey contains an SRF
EXPLAIN (VERBOSE, COSTS OFF)
SELECT unnest(ARRAY[]::integer[]) + 1 AS pathkey
  FROM tenk1 t1 JOIN tenk1 t2 ON TRUE
  ORDER BY pathkey
RESULT: []

-----------
QUERY:
-- test passing expanded-value representations to workers
CREATE FUNCTION make_some_array(int,int) returns int[] as
$$declare x int[];
  begin
    x[1] := $1;
    x[2] := $2;
    return x;
  end$$ language plpgsql parallel safe
RESULT: []

-----------
QUERY:
CREATE TABLE fooarr(f1 text, f2 int[], f3 text)
RESULT: []

-----------
QUERY:
INSERT INTO fooarr VALUES('1', ARRAY[1,2], 'one')
RESULT: []

-----------
QUERY:
PREPARE pstmt(text, int[]) AS SELECT * FROM fooarr WHERE f1 = $1 AND f2 = $2
RESULT: []

-----------
QUERY:
EXPLAIN (COSTS OFF) EXECUTE pstmt('1', make_some_array(1,2))
RESULT: []

-----------
QUERY:
EXECUTE pstmt('1', make_some_array(1,2))
RESULT: []

-----------
QUERY:
DEALLOCATE pstmt
RESULT: []

-----------
QUERY:
-- test interaction between subquery and partial_paths
CREATE VIEW tenk1_vw_sec WITH (security_barrier) AS SELECT * FROM tenk1
RESULT: []

-----------
QUERY:
EXPLAIN (COSTS OFF)
SELECT 1 FROM tenk1_vw_sec
  WHERE (SELECT sum(f1) FROM int4_tbl WHERE f1 < unique1) < 100
RESULT: []

-----------
QUERY:
rollback
RESULT: []
=========================================
Summary for test case select_parallel/test.sql of postgres
=========================================
