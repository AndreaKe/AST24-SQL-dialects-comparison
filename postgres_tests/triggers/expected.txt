
-----------
QUERY:
--
-- TRIGGERS
--

-- directory paths and dlsuffix are passed to us in environment variables
-- \getenv libdir '/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress'
-- \getenv dlsuffix '.so'

-- \set autoinclib /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress' '/autoinc' /* REPLACED */'.so'
-- \set refintlib /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress' '/refint' /* REPLACED */'.so'
-- \set regresslib /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress' '/regress' /* REPLACED */'.so'

CREATE FUNCTION autoinc ()
	RETURNS trigger
	AS /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/autoinc.so'
	LANGUAGE C;
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION check_primary_key ()
	RETURNS trigger
	AS /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/refint.so'
	LANGUAGE C;
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION check_foreign_key ()
	RETURNS trigger
	AS /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/refint.so'
	LANGUAGE C;
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION trigger_return_old ()
        RETURNS trigger
        AS /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/regress.so'
        LANGUAGE C;
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION set_ttdummy (int4)
        RETURNS int4
        AS /* REPLACED */'/home/keuscha/Documents/FS2024/AST/project/postgresql/src/test/regress/regress.so'
        LANGUAGE C STRICT;
RESULT:
	postgres: None

-----------
QUERY:


create table pkeys (pkey1 int4 not null, pkey2 text not null);
RESULT:
	postgres: None

-----------
QUERY:

create table fkeys (fkey1 int4, fkey2 text, fkey3 int);
RESULT:
	postgres: None

-----------
QUERY:

create table fkeys2 (fkey21 int4, fkey22 text, pkey23 int not null);
RESULT:
	postgres: None

-----------
QUERY:


create index fkeys_i on fkeys (fkey1, fkey2);
RESULT:
	postgres: None

-----------
QUERY:

create index fkeys2_i on fkeys2 (fkey21, fkey22);
RESULT:
	postgres: None

-----------
QUERY:

create index fkeys2p_i on fkeys2 (pkey23);
RESULT:
	postgres: None

-----------
QUERY:


insert into pkeys values (10, '1');
RESULT:
	postgres: None

-----------
QUERY:

insert into pkeys values (20, '2');
RESULT:
	postgres: None

-----------
QUERY:

insert into pkeys values (30, '3');
RESULT:
	postgres: None

-----------
QUERY:

insert into pkeys values (40, '4');
RESULT:
	postgres: None

-----------
QUERY:

insert into pkeys values (50, '5');
RESULT:
	postgres: None

-----------
QUERY:

insert into pkeys values (60, '6');
RESULT:
	postgres: None

-----------
QUERY:

create unique index pkeys_i on pkeys (pkey1, pkey2);
RESULT:
	postgres: None

-----------
QUERY:


--
-- For fkeys:
-- 	(fkey1, fkey2)	--> pkeys (pkey1, pkey2)
-- 	(fkey3)		--> fkeys2 (pkey23)
--
create trigger check_fkeys_pkey_exist
	before insert or update on fkeys
	for each row
	execute function
	check_primary_key ('fkey1', 'fkey2', 'pkeys', 'pkey1', 'pkey2');
RESULT:
	postgres: None

-----------
QUERY:


create trigger check_fkeys_pkey2_exist
	before insert or update on fkeys
	for each row
	execute function check_primary_key ('fkey3', 'fkeys2', 'pkey23');
RESULT:
	postgres: None

-----------
QUERY:


--
-- For fkeys2:
-- 	(fkey21, fkey22)	--> pkeys (pkey1, pkey2)
--
create trigger check_fkeys2_pkey_exist
	before insert or update on fkeys2
	for each row
	execute procedure
	check_primary_key ('fkey21', 'fkey22', 'pkeys', 'pkey1', 'pkey2');
RESULT:
	postgres: None

-----------
QUERY:


-- Test comments
COMMENT ON TRIGGER check_fkeys2_pkey_bad ON fkeys2 IS 'wrong';
RESULT:
	postgres: trigger "check_fkeys2_pkey_bad" for table "fkeys2" does not exist


-----------
QUERY:

COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS 'right';
RESULT:
	postgres: None

-----------
QUERY:

COMMENT ON TRIGGER check_fkeys2_pkey_exist ON fkeys2 IS NULL;
RESULT:
	postgres: None

-----------
QUERY:


--
-- For pkeys:
-- 	ON DELETE/UPDATE (pkey1, pkey2) CASCADE:
-- 		fkeys (fkey1, fkey2) and fkeys2 (fkey21, fkey22)
--
create trigger check_pkeys_fkey_cascade
	before delete or update on pkeys
	for each row
	execute procedure
	check_foreign_key (2, 'cascade', 'pkey1', 'pkey2',
	'fkeys', 'fkey1', 'fkey2', 'fkeys2', 'fkey21', 'fkey22');
RESULT:
	postgres: None

-----------
QUERY:


--
-- For fkeys2:
-- 	ON DELETE/UPDATE (pkey23) RESTRICT:
-- 		fkeys (fkey3)
--
create trigger check_fkeys2_fkey_restrict
	before delete or update on fkeys2
	for each row
	execute procedure check_foreign_key (1, 'restrict', 'pkey23', 'fkeys', 'fkey3');
RESULT:
	postgres: None

-----------
QUERY:


insert into fkeys2 values (10, '1', 1);
RESULT:
	postgres: None

-----------
QUERY:

insert into fkeys2 values (30, '3', 2);
RESULT:
	postgres: None

-----------
QUERY:

insert into fkeys2 values (40, '4', 5);
RESULT:
	postgres: None

-----------
QUERY:

insert into fkeys2 values (50, '5', 3);
RESULT:
	postgres: None

-----------
QUERY:

-- no key in pkeys
insert into fkeys2 values (70, '5', 3);
RESULT:
	postgres: tuple references non-existent key
DETAIL:  Trigger "check_fkeys2_pkey_exist" found tuple referencing non-existent key in "pkeys".


-----------
QUERY:


insert into fkeys values (10, '1', 2);
RESULT:
	postgres: None

-----------
QUERY:

insert into fkeys values (30, '3', 3);
RESULT:
	postgres: None

-----------
QUERY:

insert into fkeys values (40, '4', 2);
RESULT:
	postgres: None

-----------
QUERY:

insert into fkeys values (50, '5', 2);
RESULT:
	postgres: None

-----------
QUERY:

-- no key in pkeys
insert into fkeys values (70, '5', 1);
RESULT:
	postgres: tuple references non-existent key
DETAIL:  Trigger "check_fkeys_pkey_exist" found tuple referencing non-existent key in "pkeys".


-----------
QUERY:

-- no key in fkeys2
insert into fkeys values (60, '6', 4);
RESULT:
	postgres: tuple references non-existent key
DETAIL:  Trigger "check_fkeys_pkey2_exist" found tuple referencing non-existent key in "fkeys2".


-----------
QUERY:


delete from pkeys where pkey1 = 30 and pkey2 = '3';
RESULT:
	postgres: "check_fkeys2_fkey_restrict": tuple is referenced in "fkeys"
CONTEXT:  SQL statement "delete from fkeys2 where fkey21 = $1 and fkey22 = $2 "


-----------
QUERY:

delete from pkeys where pkey1 = 40 and pkey2 = '4';
RESULT:
	postgres: None

-----------
QUERY:

update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 50 and pkey2 = '5';
RESULT:
	postgres: "check_fkeys2_fkey_restrict": tuple is referenced in "fkeys"
CONTEXT:  SQL statement "delete from fkeys2 where fkey21 = $1 and fkey22 = $2 "


-----------
QUERY:

update pkeys set pkey1 = 7, pkey2 = '70' where pkey1 = 10 and pkey2 = '1';
RESULT:
	postgres: None

-----------
QUERY:


SELECT trigger_name, event_manipulation, event_object_schema, event_object_table,
       action_order, action_condition, action_orientation, action_timing,
       action_reference_old_table, action_reference_new_table
  FROM information_schema.triggers
  WHERE event_object_table in ('pkeys', 'fkeys', 'fkeys2')
  ORDER BY trigger_name COLLATE "C", 2;
RESULT:
	postgres: [('check_fkeys2_fkey_restrict', 'DELETE', 'public', 'fkeys2', 1, None, 'ROW', 'BEFORE', None, None), ('check_fkeys2_fkey_restrict', 'UPDATE', 'public', 'fkeys2', 1, None, 'ROW', 'BEFORE', None, None), ('check_fkeys2_pkey_exist', 'INSERT', 'public', 'fkeys2', 1, None, 'ROW', 'BEFORE', None, None), ('check_fkeys2_pkey_exist', 'UPDATE', 'public', 'fkeys2', 2, None, 'ROW', 'BEFORE', None, None), ('check_fkeys_pkey2_exist', 'INSERT', 'public', 'fkeys', 1, None, 'ROW', 'BEFORE', None, None), ('check_fkeys_pkey2_exist', 'UPDATE', 'public', 'fkeys', 1, None, 'ROW', 'BEFORE', None, None), ('check_fkeys_pkey_exist', 'INSERT', 'public', 'fkeys', 2, None, 'ROW', 'BEFORE', None, None), ('check_fkeys_pkey_exist', 'UPDATE', 'public', 'fkeys', 2, None, 'ROW', 'BEFORE', None, None), ('check_pkeys_fkey_cascade', 'DELETE', 'public', 'pkeys', 1, None, 'ROW', 'BEFORE', None, None), ('check_pkeys_fkey_cascade', 'UPDATE', 'public', 'pkeys', 1, None, 'ROW', 'BEFORE', None, None)]

-----------
QUERY:


DROP TABLE pkeys;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE fkeys;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE fkeys2;
RESULT:
	postgres: None

-----------
QUERY:


-- Check behavior when trigger returns unmodified trigtuple
create table trigtest (f1 int, f2 text);
RESULT:
	postgres: None

-----------
QUERY:


create trigger trigger_return_old
	before insert or delete or update on trigtest
	for each row execute procedure trigger_return_old();
RESULT:
	postgres: None

-----------
QUERY:


insert into trigtest values(1, 'foo');
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(1, 'foo')]

-----------
QUERY:

update trigtest set f2 = f2 || 'bar';
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(1, 'foo')]

-----------
QUERY:

delete from trigtest;
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: []

-----------
QUERY:


-- Also check what happens when such a trigger runs before or after others
create function f1_times_10() returns trigger as
$$ begin new.f1 := new.f1 * 10; return new; end $$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


create trigger trigger_alpha
	before insert or update on trigtest
	for each row execute procedure f1_times_10();
RESULT:
	postgres: None

-----------
QUERY:


insert into trigtest values(1, 'foo');
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(10, 'foo')]

-----------
QUERY:

update trigtest set f2 = f2 || 'bar';
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(10, 'foo')]

-----------
QUERY:

delete from trigtest;
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: []

-----------
QUERY:


create trigger trigger_zed
	before insert or update on trigtest
	for each row execute procedure f1_times_10();
RESULT:
	postgres: None

-----------
QUERY:


insert into trigtest values(1, 'foo');
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(100, 'foo')]

-----------
QUERY:

update trigtest set f2 = f2 || 'bar';
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(1000, 'foo')]

-----------
QUERY:

delete from trigtest;
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: []

-----------
QUERY:


drop trigger trigger_alpha on trigtest;
RESULT:
	postgres: None

-----------
QUERY:


insert into trigtest values(1, 'foo');
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(10, 'foo')]

-----------
QUERY:

update trigtest set f2 = f2 || 'bar';
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(100, 'foo')]

-----------
QUERY:

delete from trigtest;
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: []

-----------
QUERY:


drop table trigtest;
RESULT:
	postgres: None

-----------
QUERY:


-- Check behavior with an implicit column default, too (bug #16644)
create table trigtest (
  a integer,
  b bool default true not null,
  c text default 'xyzzy' not null);
RESULT:
	postgres: None

-----------
QUERY:


create trigger trigger_return_old
	before insert or delete or update on trigtest
	for each row execute procedure trigger_return_old();
RESULT:
	postgres: None

-----------
QUERY:


insert into trigtest values(1);
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(1, True, 'xyzzy')]

-----------
QUERY:


alter table trigtest add column d integer default 42 not null;
RESULT:
	postgres: None

-----------
QUERY:


select * from trigtest;
RESULT:
	postgres: [(1, True, 'xyzzy', 42)]

-----------
QUERY:

update trigtest set a = 2 where a = 1 returning *;
RESULT:
	postgres: [(1, True, 'xyzzy', 42)]

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(1, True, 'xyzzy', 42)]

-----------
QUERY:


alter table trigtest drop column b;
RESULT:
	postgres: None

-----------
QUERY:


select * from trigtest;
RESULT:
	postgres: [(1, 'xyzzy', 42)]

-----------
QUERY:

update trigtest set a = 2 where a = 1 returning *;
RESULT:
	postgres: [(1, 'xyzzy', 42)]

-----------
QUERY:

select * from trigtest;
RESULT:
	postgres: [(1, 'xyzzy', 42)]

-----------
QUERY:


drop table trigtest;
RESULT:
	postgres: None

-----------
QUERY:


create sequence ttdummy_seq increment 10 start 0 minvalue 0;
RESULT:
	postgres: None

-----------
QUERY:


create table tttest (
	price_id	int4,
	price_val	int4,
	price_on	int4,
	price_off	int4 default 999999
);
RESULT:
	postgres: None

-----------
QUERY:


create trigger ttdummy
	before delete or update on tttest
	for each row
	execute procedure
	ttdummy (price_on, price_off);
RESULT:
	postgres: None

-----------
QUERY:


create trigger ttserial
	before insert or update on tttest
	for each row
	execute procedure
	autoinc (price_on, ttdummy_seq);
RESULT:
	postgres: None

-----------
QUERY:


insert into tttest values (1, 1, null);
RESULT:
	postgres: None

-----------
QUERY:

insert into tttest values (2, 2, null);
RESULT:
	postgres: None

-----------
QUERY:

insert into tttest values (3, 3, 0);
RESULT:
	postgres: None

-----------
QUERY:


select * from tttest;
RESULT:
	postgres: [(1, 1, 10, 999999), (2, 2, 20, 999999), (3, 3, 30, 999999)]

-----------
QUERY:

delete from tttest where price_id = 2;
RESULT:
	postgres: None

-----------
QUERY:

select * from tttest;
RESULT:
	postgres: [(1, 1, 10, 999999), (3, 3, 30, 999999), (2, 2, 20, 40)]

-----------
QUERY:

-- what do we see ?

-- get current prices
select * from tttest where price_off = 999999;
RESULT:
	postgres: [(1, 1, 10, 999999), (3, 3, 30, 999999)]

-----------
QUERY:


-- change price for price_id == 3
update tttest set price_val = 30 where price_id = 3;
RESULT:
	postgres: None

-----------
QUERY:

select * from tttest;
RESULT:
	postgres: [(1, 1, 10, 999999), (2, 2, 20, 40), (3, 30, 50, 999999), (3, 3, 30, 50)]

-----------
QUERY:


-- now we want to change pric_id in ALL tuples
-- this gets us not what we need
update tttest set price_id = 5 where price_id = 3;
RESULT:
	postgres: None

-----------
QUERY:

select * from tttest;
RESULT:
	postgres: [(1, 1, 10, 999999), (2, 2, 20, 40), (3, 3, 30, 50), (5, 30, 60, 999999), (3, 30, 50, 60)]

-----------
QUERY:


-- restore data as before last update:
select set_ttdummy(0);
RESULT:
	postgres: [(1,)]

-----------
QUERY:

delete from tttest where price_id = 5;
RESULT:
	postgres: None

-----------
QUERY:

update tttest set price_off = 999999 where price_val = 30;
RESULT:
	postgres: None

-----------
QUERY:

select * from tttest;
RESULT:
	postgres: [(1, 1, 10, 999999), (2, 2, 20, 40), (3, 3, 30, 50), (3, 30, 50, 999999)]

-----------
QUERY:


-- and try change price_id now!
update tttest set price_id = 5 where price_id = 3;
RESULT:
	postgres: None

-----------
QUERY:

select * from tttest;
RESULT:
	postgres: [(1, 1, 10, 999999), (2, 2, 20, 40), (5, 3, 30, 50), (5, 30, 50, 999999)]

-----------
QUERY:

-- isn/* REPLACED */''t it what we need ?

select set_ttdummy(1);
RESULT:
	postgres: [(0,)]

-----------
QUERY:


-- we want to correct some /* REPLACED */''date/* REPLACED */''
update tttest set price_on = -1 where price_id = 1;
RESULT:
	postgres: ttdummy (tttest): you cannot change price_on and/or price_off columns (use set_ttdummy)


-----------
QUERY:

-- but this doesn/* REPLACED */''t work

-- try in this way
select set_ttdummy(0);
RESULT:
	postgres: [(1,)]

-----------
QUERY:

update tttest set price_on = -1 where price_id = 1;
RESULT:
	postgres: None

-----------
QUERY:

select * from tttest;
RESULT:
	postgres: [(2, 2, 20, 40), (5, 3, 30, 50), (5, 30, 50, 999999), (1, 1, -1, 999999)]

-----------
QUERY:

-- isn/* REPLACED */''t it what we need ?

-- get price for price_id == 5 as it was @ /* REPLACED */''date/* REPLACED */'' 35
select * from tttest where price_on <= 35 and price_off > 35 and price_id = 5;
RESULT:
	postgres: [(5, 3, 30, 50)]

-----------
QUERY:


drop table tttest;
RESULT:
	postgres: None

-----------
QUERY:

drop sequence ttdummy_seq;
RESULT:
	postgres: None

-----------
QUERY:


--
-- tests for per-statement triggers
--

CREATE TABLE log_table (tstamp timestamp default timeofday()::timestamp);
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE main_table (a int unique, b int);
RESULT:
	postgres: None

-----------
QUERY:


COPY main_table (a,b) FROM stdin;
RESULT:
	postgres: can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

5	10
20	20
30	10
50	35
80	15
\.

CREATE FUNCTION trigger_func() RETURNS trigger LANGUAGE plpgsql AS '
BEGIN
	RAISE NOTICE ''trigger_func(%) called: action = %, when = %, level = %'', TG_ARGV[0], TG_OP, TG_WHEN, TG_LEVEL;
RESULT:
	postgres: syntax error at or near "5"
LINE 2: 5 10
        ^


-----------
QUERY:

	RETURN NULL;
RESULT:
	postgres: syntax error at or near "RETURN"
LINE 2:  RETURN NULL;
         ^


-----------
QUERY:

END;
RESULT:
	postgres: None

-----------
QUERY:
';
RESULT:
	postgres: unterminated quoted string at or near "';"
LINE 1: ';
        ^


-----------
QUERY:


CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_table
FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_ins_stmt');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:


CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_table
FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_ins_stmt');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:


--
-- if neither /* REPLACED */''FOR EACH ROW/* REPLACED */'' nor /* REPLACED */''FOR EACH STATEMENT/* REPLACED */'' was specified,
-- CREATE TRIGGER should default to /* REPLACED */''FOR EACH STATEMENT/* REPLACED */''
--
CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_table
EXECUTE PROCEDURE trigger_func('after_upd_stmt');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:


-- Both insert and update statement level triggers (before and after) should
-- fire.  Doesn/* REPLACED */''t fire UPDATE before trigger, but only because one isn/* REPLACED */''t
-- defined.
INSERT INTO main_table (a, b) VALUES (5, 10) ON CONFLICT (a)
  DO UPDATE SET b = EXCLUDED.b;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER after_upd_row_trig AFTER UPDATE ON main_table
FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_row');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:


INSERT INTO main_table DEFAULT VALUES;
RESULT:
	postgres: None

-----------
QUERY:


UPDATE main_table SET a = a + 1 WHERE b < 30;
RESULT:
	postgres: None

-----------
QUERY:

-- UPDATE that effects zero rows should still call per-statement trigger
UPDATE main_table SET a = a + 2 WHERE b > 100;
RESULT:
	postgres: None

-----------
QUERY:


-- constraint now unneeded
ALTER TABLE main_table DROP CONSTRAINT main_table_a_key;
RESULT:
	postgres: None

-----------
QUERY:


-- COPY should fire per-row and per-statement INSERT triggers
COPY main_table (a, b) FROM stdin;
RESULT:
	postgres: can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

30	40
50	60
\.

SELECT * FROM main_table ORDER BY a, b;
RESULT:
	postgres: syntax error at or near "30"
LINE 2: 30 40
        ^


-----------
QUERY:


--
-- test triggers with WHEN clause
--

CREATE TRIGGER modified_a BEFORE UPDATE OF a ON main_table
FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE trigger_func('modified_a');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

CREATE TRIGGER modified_any BEFORE UPDATE OF a ON main_table
FOR EACH ROW WHEN (OLD.* IS DISTINCT FROM NEW.*) EXECUTE PROCEDURE trigger_func('modified_any');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

CREATE TRIGGER insert_a AFTER INSERT ON main_table
FOR EACH ROW WHEN (NEW.a = 123) EXECUTE PROCEDURE trigger_func('insert_a');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

CREATE TRIGGER delete_a AFTER DELETE ON main_table
FOR EACH ROW WHEN (OLD.a = 123) EXECUTE PROCEDURE trigger_func('delete_a');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

CREATE TRIGGER insert_when BEFORE INSERT ON main_table
FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('insert_when');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

CREATE TRIGGER delete_when AFTER DELETE ON main_table
FOR EACH STATEMENT WHEN (true) EXECUTE PROCEDURE trigger_func('delete_when');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

SELECT trigger_name, event_manipulation, event_object_schema, event_object_table,
       action_order, action_condition, action_orientation, action_timing,
       action_reference_old_table, action_reference_new_table
  FROM information_schema.triggers
  WHERE event_object_table IN ('main_table')
  ORDER BY trigger_name COLLATE "C", 2;
RESULT:
	postgres: []

-----------
QUERY:

INSERT INTO main_table (a) VALUES (123), (456);
RESULT:
	postgres: None

-----------
QUERY:

COPY main_table FROM stdin;
RESULT:
	postgres: can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

123	999
456	999
\.
DELETE FROM main_table WHERE a IN (123, 456);
RESULT:
	postgres: syntax error at or near "123"
LINE 2: 123 999
        ^


-----------
QUERY:

UPDATE main_table SET a = 50, b = 60;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM main_table ORDER BY a, b;
RESULT:
	postgres: [(50, 60), (50, 60), (50, 60), (50, 60)]

-----------
QUERY:

SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
RESULT:
	postgres: []

-----------
QUERY:

SELECT pg_get_triggerdef(oid, false) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
RESULT:
	postgres: []

-----------
QUERY:

SELECT pg_get_triggerdef(oid, true) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_any';
RESULT:
	postgres: []

-----------
QUERY:


-- Test RENAME TRIGGER
ALTER TRIGGER modified_a ON main_table RENAME TO modified_modified_a;
RESULT:
	postgres: trigger "modified_a" for table "main_table" does not exist


-----------
QUERY:

SELECT count(*) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_a';
RESULT:
	postgres: [(0,)]

-----------
QUERY:

SELECT count(*) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'modified_modified_a';
RESULT:
	postgres: [(0,)]

-----------
QUERY:


DROP TRIGGER modified_modified_a ON main_table;
RESULT:
	postgres: trigger "modified_modified_a" for table "main_table" does not exist


-----------
QUERY:

DROP TRIGGER modified_any ON main_table;
RESULT:
	postgres: trigger "modified_any" for table "main_table" does not exist


-----------
QUERY:

DROP TRIGGER insert_a ON main_table;
RESULT:
	postgres: trigger "insert_a" for table "main_table" does not exist


-----------
QUERY:

DROP TRIGGER delete_a ON main_table;
RESULT:
	postgres: trigger "delete_a" for table "main_table" does not exist


-----------
QUERY:

DROP TRIGGER insert_when ON main_table;
RESULT:
	postgres: trigger "insert_when" for table "main_table" does not exist


-----------
QUERY:

DROP TRIGGER delete_when ON main_table;
RESULT:
	postgres: trigger "delete_when" for table "main_table" does not exist


-----------
QUERY:


-- Test WHEN condition accessing system columns.
create table table_with_oids(a int);
RESULT:
	postgres: None

-----------
QUERY:

insert into table_with_oids values (1);
RESULT:
	postgres: None

-----------
QUERY:

create trigger oid_unchanged_trig after update on table_with_oids
	for each row
	when (new.tableoid = old.tableoid AND new.tableoid <> 0)
	execute procedure trigger_func('after_upd_oid_unchanged');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

update table_with_oids set a = a + 1;
RESULT:
	postgres: None

-----------
QUERY:

drop table table_with_oids;
RESULT:
	postgres: None

-----------
QUERY:


-- Test column-level triggers
DROP TRIGGER after_upd_row_trig ON main_table;
RESULT:
	postgres: trigger "after_upd_row_trig" for table "main_table" does not exist


-----------
QUERY:


CREATE TRIGGER before_upd_a_row_trig BEFORE UPDATE OF a ON main_table
FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_a_row');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

CREATE TRIGGER after_upd_b_row_trig AFTER UPDATE OF b ON main_table
FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_b_row');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

CREATE TRIGGER after_upd_a_b_row_trig AFTER UPDATE OF a, b ON main_table
FOR EACH ROW EXECUTE PROCEDURE trigger_func('after_upd_a_b_row');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:


CREATE TRIGGER before_upd_a_stmt_trig BEFORE UPDATE OF a ON main_table
FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('before_upd_a_stmt');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

CREATE TRIGGER after_upd_b_stmt_trig AFTER UPDATE OF b ON main_table
FOR EACH STATEMENT EXECUTE PROCEDURE trigger_func('after_upd_b_stmt');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:


SELECT pg_get_triggerdef(oid) FROM pg_trigger WHERE tgrelid = 'main_table'::regclass AND tgname = 'after_upd_a_b_row_trig';
RESULT:
	postgres: []

-----------
QUERY:


UPDATE main_table SET a = 50;
RESULT:
	postgres: None

-----------
QUERY:

UPDATE main_table SET b = 10;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test case for bug with BEFORE trigger followed by AFTER trigger with WHEN
--

CREATE TABLE some_t (some_col boolean NOT NULL);
RESULT:
	postgres: None

-----------
QUERY:

CREATE FUNCTION dummy_update_func() RETURNS trigger AS $$
BEGIN
  RAISE NOTICE 'dummy_update_func(%) called: action = %, old = %, new = %',
    TG_ARGV[0], TG_OP, OLD, NEW;
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TRIGGER some_trig_before BEFORE UPDATE ON some_t FOR EACH ROW
  EXECUTE PROCEDURE dummy_update_func('before');
RESULT:
	postgres: None

-----------
QUERY:

CREATE TRIGGER some_trig_aftera AFTER UPDATE ON some_t FOR EACH ROW
  WHEN (NOT OLD.some_col AND NEW.some_col)
  EXECUTE PROCEDURE dummy_update_func('aftera');
RESULT:
	postgres: None

-----------
QUERY:

CREATE TRIGGER some_trig_afterb AFTER UPDATE ON some_t FOR EACH ROW
  WHEN (NOT NEW.some_col)
  EXECUTE PROCEDURE dummy_update_func('afterb');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO some_t VALUES (TRUE);
RESULT:
	postgres: None

-----------
QUERY:

UPDATE some_t SET some_col = TRUE;
RESULT:
	postgres: None

-----------
QUERY:

UPDATE some_t SET some_col = FALSE;
RESULT:
	postgres: None

-----------
QUERY:

UPDATE some_t SET some_col = TRUE;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE some_t;
RESULT:
	postgres: None

-----------
QUERY:


-- bogus cases
CREATE TRIGGER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_table
FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_and_col');
RESULT:
	postgres: duplicate trigger events specified at or near "ON"
LINE 4: ...ER error_upd_and_col BEFORE UPDATE OR UPDATE OF a ON main_ta...
                                                             ^


-----------
QUERY:

CREATE TRIGGER error_upd_a_a BEFORE UPDATE OF a, a ON main_table
FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_upd_a_a');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
FOR EACH ROW EXECUTE PROCEDURE trigger_func('error_ins_a');
RESULT:
	postgres: syntax error at or near "OF"
LINE 2: CREATE TRIGGER error_ins_a BEFORE INSERT OF a ON main_table
                                                 ^


-----------
QUERY:

CREATE TRIGGER error_ins_when BEFORE INSERT OR UPDATE ON main_table
FOR EACH ROW WHEN (OLD.a <> NEW.a)
EXECUTE PROCEDURE trigger_func('error_ins_old');
RESULT:
	postgres: INSERT trigger's WHEN condition cannot reference OLD values
LINE 3: FOR EACH ROW WHEN (OLD.a <> NEW.a)
                           ^


-----------
QUERY:

CREATE TRIGGER error_del_when BEFORE DELETE OR UPDATE ON main_table
FOR EACH ROW WHEN (OLD.a <> NEW.a)
EXECUTE PROCEDURE trigger_func('error_del_new');
RESULT:
	postgres: DELETE trigger's WHEN condition cannot reference NEW values
LINE 3: FOR EACH ROW WHEN (OLD.a <> NEW.a)
                                    ^


-----------
QUERY:

CREATE TRIGGER error_del_when BEFORE INSERT OR UPDATE ON main_table
FOR EACH ROW WHEN (NEW.tableoid <> 0)
EXECUTE PROCEDURE trigger_func('error_when_sys_column');
RESULT:
	postgres: BEFORE trigger's WHEN condition cannot reference NEW system columns
LINE 3: FOR EACH ROW WHEN (NEW.tableoid <> 0)
                           ^


-----------
QUERY:

CREATE TRIGGER error_stmt_when BEFORE UPDATE OF a ON main_table
FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)
EXECUTE PROCEDURE trigger_func('error_stmt_when');
RESULT:
	postgres: statement trigger's WHEN condition cannot reference column values
LINE 3: FOR EACH STATEMENT WHEN (OLD.* IS DISTINCT FROM NEW.*)
                                 ^


-----------
QUERY:


-- check dependency restrictions
ALTER TABLE main_table DROP COLUMN b;
RESULT:
	postgres: None

-----------
QUERY:

-- this should succeed, but we/* REPLACED */''ll roll it back to keep the triggers around
begin;
RESULT:
	postgres: None

-----------
QUERY:

DROP TRIGGER after_upd_a_b_row_trig ON main_table;
RESULT:
	postgres: trigger "after_upd_a_b_row_trig" for table "main_table" does not exist


-----------
QUERY:

DROP TRIGGER after_upd_b_row_trig ON main_table;
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

DROP TRIGGER after_upd_b_stmt_trig ON main_table;
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

ALTER TABLE main_table DROP COLUMN b;
RESULT:
	postgres: current transaction is aborted, commands ignored until end of transaction block


-----------
QUERY:

rollback;
RESULT:
	postgres: None

-----------
QUERY:


-- Test enable/disable triggers

create table trigtest (i serial primary key);
RESULT:
	postgres: None

-----------
QUERY:

-- test that disabling RI triggers works
create table trigtest2 (i int references trigtest(i) on delete cascade);
RESULT:
	postgres: None

-----------
QUERY:


create function trigtest() returns trigger as $$
begin
	raise notice '% % % %', TG_TABLE_NAME, TG_OP, TG_WHEN, TG_LEVEL;
	return new;
end;$$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


create trigger trigtest_b_row_tg before insert or update or delete on trigtest
for each row execute procedure trigtest();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trigtest_a_row_tg after insert or update or delete on trigtest
for each row execute procedure trigtest();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trigtest_b_stmt_tg before insert or update or delete on trigtest
for each statement execute procedure trigtest();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trigtest_a_stmt_tg after insert or update or delete on trigtest
for each statement execute procedure trigtest();
RESULT:
	postgres: None

-----------
QUERY:


insert into trigtest default values;
RESULT:
	postgres: None

-----------
QUERY:

alter table trigtest disable trigger trigtest_b_row_tg;
RESULT:
	postgres: None

-----------
QUERY:

insert into trigtest default values;
RESULT:
	postgres: None

-----------
QUERY:

alter table trigtest disable trigger user;
RESULT:
	postgres: None

-----------
QUERY:

insert into trigtest default values;
RESULT:
	postgres: None

-----------
QUERY:

alter table trigtest enable trigger trigtest_a_stmt_tg;
RESULT:
	postgres: None

-----------
QUERY:

insert into trigtest default values;
RESULT:
	postgres: None

-----------
QUERY:

set session_replication_role = replica;
RESULT:
	postgres: None

-----------
QUERY:

insert into trigtest default values;
RESULT:
	postgres: None

-----------
QUERY:
  -- does not trigger
alter table trigtest enable always trigger trigtest_a_stmt_tg;
RESULT:
	postgres: None

-----------
QUERY:

insert into trigtest default values;
RESULT:
	postgres: None

-----------
QUERY:
  -- now it does
reset session_replication_role;
RESULT:
	postgres: None

-----------
QUERY:

insert into trigtest2 values(1);
RESULT:
	postgres: None

-----------
QUERY:

insert into trigtest2 values(2);
RESULT:
	postgres: None

-----------
QUERY:

delete from trigtest where i=2;
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest2;
RESULT:
	postgres: [(1,)]

-----------
QUERY:

alter table trigtest disable trigger all;
RESULT:
	postgres: None

-----------
QUERY:

delete from trigtest where i=1;
RESULT:
	postgres: None

-----------
QUERY:

select * from trigtest2;
RESULT:
	postgres: [(1,)]

-----------
QUERY:

-- ensure we still insert, even when all triggers are disabled
insert into trigtest default values;
RESULT:
	postgres: None

-----------
QUERY:

select *  from trigtest;
RESULT:
	postgres: [(3,), (4,), (5,), (6,), (7,)]

-----------
QUERY:

drop table trigtest2;
RESULT:
	postgres: None

-----------
QUERY:

drop table trigtest;
RESULT:
	postgres: None

-----------
QUERY:



-- dump trigger data
CREATE TABLE trigger_test (
        i int,
        v varchar
);
RESULT:
	postgres: None

-----------
QUERY:


CREATE OR REPLACE FUNCTION trigger_data()  RETURNS trigger
LANGUAGE plpgsql AS $$

declare

	argstr text;
	relid text;

begin

	relid := TG_relid::regclass;

	-- plpgsql can/* REPLACED */''t discover its trigger data in a hash like perl and python
	-- can, or by a sort of reflection like tcl can,
	-- so we have to hard code the names.
	raise NOTICE 'TG_NAME: %', TG_name;
	raise NOTICE 'TG_WHEN: %', TG_when;
	raise NOTICE 'TG_LEVEL: %', TG_level;
	raise NOTICE 'TG_OP: %', TG_op;
	raise NOTICE 'TG_RELID::regclass: %', relid;
	raise NOTICE 'TG_RELNAME: %', TG_relname;
	raise NOTICE 'TG_TABLE_NAME: %', TG_table_name;
	raise NOTICE 'TG_TABLE_SCHEMA: %', TG_table_schema;
	raise NOTICE 'TG_NARGS: %', TG_nargs;

	argstr := '[';
	for i in 0 .. TG_nargs - 1 loop
		if i > 0 then
			argstr := argstr || ', ';
		end if;
		argstr := argstr || TG_argv[i];
	end loop;
	argstr := argstr || ']';
	raise NOTICE 'TG_ARGV: %', argstr;

	if TG_OP != 'INSERT' then
		raise NOTICE 'OLD: %', OLD;
	end if;

	if TG_OP != 'DELETE' then
		raise NOTICE 'NEW: %', NEW;
	end if;

	if TG_OP = 'DELETE' then
		return OLD;
	else
		return NEW;
	end if;

end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER show_trigger_data_trig
BEFORE INSERT OR UPDATE OR DELETE ON trigger_test
FOR EACH ROW EXECUTE PROCEDURE trigger_data(23,'skidoo');
RESULT:
	postgres: None

-----------
QUERY:


insert into trigger_test values(1,'insert');
RESULT:
	postgres: None

-----------
QUERY:

update trigger_test set v = 'update' where i = 1;
RESULT:
	postgres: None

-----------
QUERY:

delete from trigger_test;
RESULT:
	postgres: None

-----------
QUERY:


DROP TRIGGER show_trigger_data_trig on trigger_test;
RESULT:
	postgres: None

-----------
QUERY:


DROP FUNCTION trigger_data();
RESULT:
	postgres: None

-----------
QUERY:


DROP TABLE trigger_test;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test use of row comparisons on OLD/NEW
--

CREATE TABLE trigger_test (f1 int, f2 text, f3 text);
RESULT:
	postgres: None

-----------
QUERY:


-- this is the obvious (and wrong...) way to compare rows
CREATE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$
begin
	if row(old.*) = row(new.*) then
		raise notice 'row % not changed', new.f1;
	else
		raise notice 'row % changed', new.f1;
	end if;
	return new;
end$$;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER t
BEFORE UPDATE ON trigger_test
FOR EACH ROW EXECUTE PROCEDURE mytrigger();
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO trigger_test VALUES(1, 'foo', 'bar');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trigger_test VALUES(2, 'baz', 'quux');
RESULT:
	postgres: None

-----------
QUERY:


UPDATE trigger_test SET f3 = 'bar';
RESULT:
	postgres: None

-----------
QUERY:

UPDATE trigger_test SET f3 = NULL;
RESULT:
	postgres: None

-----------
QUERY:

-- this demonstrates that the above isn/* REPLACED */''t really working as desired:
UPDATE trigger_test SET f3 = NULL;
RESULT:
	postgres: None

-----------
QUERY:


-- the right way when considering nulls is
CREATE OR REPLACE FUNCTION mytrigger() RETURNS trigger LANGUAGE plpgsql as $$
begin
	if row(old.*) is distinct from row(new.*) then
		raise notice 'row % changed', new.f1;
	else
		raise notice 'row % not changed', new.f1;
	end if;
	return new;
end$$;
RESULT:
	postgres: None

-----------
QUERY:


UPDATE trigger_test SET f3 = 'bar';
RESULT:
	postgres: None

-----------
QUERY:

UPDATE trigger_test SET f3 = NULL;
RESULT:
	postgres: None

-----------
QUERY:

UPDATE trigger_test SET f3 = NULL;
RESULT:
	postgres: None

-----------
QUERY:


DROP TABLE trigger_test;
RESULT:
	postgres: None

-----------
QUERY:


DROP FUNCTION mytrigger();
RESULT:
	postgres: None

-----------
QUERY:


-- Test snapshot management in serializable transactions involving triggers
-- per bug report in 6bc73d4c0910042358k3d1adff3qa36f8df75198ecea@mail.gmail.com
CREATE FUNCTION serializable_update_trig() RETURNS trigger LANGUAGE plpgsql AS
$$
declare
	rec record;
begin
	new.description = 'updated in trigger';
	return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE serializable_update_tab (
	id int,
	filler  text,
	description text
);
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER serializable_update_trig BEFORE UPDATE ON serializable_update_tab
	FOR EACH ROW EXECUTE PROCEDURE serializable_update_trig();
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO serializable_update_tab SELECT a, repeat('xyzxz', 100), 'new'
	FROM generate_series(1, 50) a;
RESULT:
	postgres: None

-----------
QUERY:


BEGIN;
RESULT:
	postgres: None

-----------
QUERY:

SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
RESULT:
	postgres: None

-----------
QUERY:

UPDATE serializable_update_tab SET description = 'no no', id = 1 WHERE id = 1;
RESULT:
	postgres: None

-----------
QUERY:

COMMIT;
RESULT:
	postgres: None

-----------
QUERY:

SELECT description FROM serializable_update_tab WHERE id = 1;
RESULT:
	postgres: [('updated in trigger',)]

-----------
QUERY:

DROP TABLE serializable_update_tab;
RESULT:
	postgres: None

-----------
QUERY:


-- minimal update trigger

CREATE TABLE min_updates_test (
	f1	text,
	f2 int,
	f3 int);
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO min_updates_test VALUES ('a',1,2),('b','2',null);
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER z_min_update
BEFORE UPDATE ON min_updates_test
FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();
RESULT:
	postgres: None

-----------
QUERY:


-- \set QUIET false

UPDATE min_updates_test SET f1 = f1;
RESULT:
	postgres: None

-----------
QUERY:


UPDATE min_updates_test SET f2 = f2 + 1;
RESULT:
	postgres: None

-----------
QUERY:


UPDATE min_updates_test SET f3 = 2 WHERE f3 is null;
RESULT:
	postgres: None

-----------
QUERY:


-- \set QUIET true

SELECT * FROM min_updates_test;
RESULT:
	postgres: [('a', 2, 2), ('b', 3, 2)]

-----------
QUERY:


DROP TABLE min_updates_test;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test triggers on views
--

CREATE VIEW main_view AS SELECT a, b FROM main_table;
RESULT:
	postgres: column "b" does not exist
LINE 7: CREATE VIEW main_view AS SELECT a, b FROM main_table;
                                           ^


-----------
QUERY:


-- VIEW trigger function
CREATE OR REPLACE FUNCTION view_trigger() RETURNS trigger
LANGUAGE plpgsql AS $$
declare
    argstr text := '';
begin
    for i in 0 .. TG_nargs - 1 loop
        if i > 0 then
            argstr := argstr || ', ';
        end if;
        argstr := argstr || TG_argv[i];
    end loop;

    raise notice '% % % % (%)', TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, argstr;

    if TG_LEVEL = 'ROW' then
        if TG_OP = 'INSERT' then
            raise NOTICE 'NEW: %', NEW;
            INSERT INTO main_table VALUES (NEW.a, NEW.b);
            RETURN NEW;
        end if;

        if TG_OP = 'UPDATE' then
            raise NOTICE 'OLD: %, NEW: %', OLD, NEW;
            UPDATE main_table SET a = NEW.a, b = NEW.b WHERE a = OLD.a AND b = OLD.b;
            if NOT FOUND then RETURN NULL; end if;
            RETURN NEW;
        end if;

        if TG_OP = 'DELETE' then
            raise NOTICE 'OLD: %', OLD;
            DELETE FROM main_table WHERE a = OLD.a AND b = OLD.b;
            if NOT FOUND then RETURN NULL; end if;
            RETURN OLD;
        end if;
    end if;

    RETURN NULL;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


-- Before row triggers aren/* REPLACED */''t allowed on views
CREATE TRIGGER invalid_trig BEFORE INSERT ON main_view
FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER invalid_trig BEFORE UPDATE ON main_view
FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER invalid_trig BEFORE DELETE ON main_view
FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


-- After row triggers aren/* REPLACED */''t allowed on views
CREATE TRIGGER invalid_trig AFTER INSERT ON main_view
FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_ins_row');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER invalid_trig AFTER UPDATE ON main_view
FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_upd_row');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER invalid_trig AFTER DELETE ON main_view
FOR EACH ROW EXECUTE PROCEDURE trigger_func('before_del_row');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


-- Truncate triggers aren/* REPLACED */''t allowed on views
CREATE TRIGGER invalid_trig BEFORE TRUNCATE ON main_view
EXECUTE PROCEDURE trigger_func('before_tru_row');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER invalid_trig AFTER TRUNCATE ON main_view
EXECUTE PROCEDURE trigger_func('before_tru_row');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


-- INSTEAD OF triggers aren/* REPLACED */''t allowed on tables
CREATE TRIGGER invalid_trig INSTEAD OF INSERT ON main_table
FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
RESULT:
	postgres: "main_table" is a table
DETAIL:  Tables cannot have INSTEAD OF triggers.


-----------
QUERY:


CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_table
FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
RESULT:
	postgres: "main_table" is a table
DETAIL:  Tables cannot have INSTEAD OF triggers.


-----------
QUERY:


CREATE TRIGGER invalid_trig INSTEAD OF DELETE ON main_table
FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
RESULT:
	postgres: "main_table" is a table
DETAIL:  Tables cannot have INSTEAD OF triggers.


-----------
QUERY:


-- Don/* REPLACED */''t support WHEN clauses with INSTEAD OF triggers
CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
FOR EACH ROW WHEN (OLD.a <> NEW.a) EXECUTE PROCEDURE view_trigger('instead_of_upd');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


-- Don/* REPLACED */''t support column-level INSTEAD OF triggers
CREATE TRIGGER invalid_trig INSTEAD OF UPDATE OF a ON main_view
FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


-- Don/* REPLACED */''t support statement-level INSTEAD OF triggers
CREATE TRIGGER invalid_trig INSTEAD OF UPDATE ON main_view
EXECUTE PROCEDURE view_trigger('instead_of_upd');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


-- Valid INSTEAD OF triggers
CREATE TRIGGER instead_of_insert_trig INSTEAD OF INSERT ON main_view
FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_ins');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER instead_of_update_trig INSTEAD OF UPDATE ON main_view
FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_upd');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER instead_of_delete_trig INSTEAD OF DELETE ON main_view
FOR EACH ROW EXECUTE PROCEDURE view_trigger('instead_of_del');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


-- Valid BEFORE statement VIEW triggers
CREATE TRIGGER before_ins_stmt_trig BEFORE INSERT ON main_view
FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_ins_stmt');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER before_upd_stmt_trig BEFORE UPDATE ON main_view
FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_upd_stmt');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER before_del_stmt_trig BEFORE DELETE ON main_view
FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('before_view_del_stmt');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


-- Valid AFTER statement VIEW triggers
CREATE TRIGGER after_ins_stmt_trig AFTER INSERT ON main_view
FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_ins_stmt');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER after_upd_stmt_trig AFTER UPDATE ON main_view
FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_upd_stmt');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


CREATE TRIGGER after_del_stmt_trig AFTER DELETE ON main_view
FOR EACH STATEMENT EXECUTE PROCEDURE view_trigger('after_view_del_stmt');
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:


-- \set QUIET false

-- Insert into view using trigger
INSERT INTO main_view VALUES (20, 30);
RESULT:
	postgres: relation "main_view" does not exist
LINE 6: INSERT INTO main_view VALUES (20, 30);
                    ^


-----------
QUERY:

INSERT INTO main_view VALUES (21, 31) RETURNING a, b;
RESULT:
	postgres: relation "main_view" does not exist
LINE 2: INSERT INTO main_view VALUES (21, 31) RETURNING a, b;
                    ^


-----------
QUERY:


-- Table trigger will prevent updates
UPDATE main_view SET b = 31 WHERE a = 20;
RESULT:
	postgres: relation "main_view" does not exist
LINE 4: UPDATE main_view SET b = 31 WHERE a = 20;
               ^


-----------
QUERY:

UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
RESULT:
	postgres: relation "main_view" does not exist
LINE 2: UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNIN...
               ^


-----------
QUERY:


-- Remove table trigger to allow updates
DROP TRIGGER before_upd_a_row_trig ON main_table;
RESULT:
	postgres: trigger "before_upd_a_row_trig" for table "main_table" does not exist


-----------
QUERY:

UPDATE main_view SET b = 31 WHERE a = 20;
RESULT:
	postgres: relation "main_view" does not exist
LINE 2: UPDATE main_view SET b = 31 WHERE a = 20;
               ^


-----------
QUERY:

UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNING a, b;
RESULT:
	postgres: relation "main_view" does not exist
LINE 2: UPDATE main_view SET b = 32 WHERE a = 21 AND b = 31 RETURNIN...
               ^


-----------
QUERY:


-- Before and after stmt triggers should fire even when no rows are affected
UPDATE main_view SET b = 0 WHERE false;
RESULT:
	postgres: relation "main_view" does not exist
LINE 4: UPDATE main_view SET b = 0 WHERE false;
               ^


-----------
QUERY:


-- Delete from view using trigger
DELETE FROM main_view WHERE a IN (20,21);
RESULT:
	postgres: relation "main_view" does not exist
LINE 4: DELETE FROM main_view WHERE a IN (20,21);
                    ^


-----------
QUERY:

DELETE FROM main_view WHERE a = 31 RETURNING a, b;
RESULT:
	postgres: relation "main_view" does not exist
LINE 2: DELETE FROM main_view WHERE a = 31 RETURNING a, b;
                    ^


-----------
QUERY:


-- \set QUIET true

-- Describe view should list triggers
-- \d main_view

-- Test dropping view triggers
DROP TRIGGER instead_of_insert_trig ON main_view;
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:

DROP TRIGGER instead_of_delete_trig ON main_view;
RESULT:
	postgres: relation "main_view" does not exist


-----------
QUERY:

-- \d+ main_view
DROP VIEW main_view;
RESULT:
	postgres: view "main_view" does not exist


-----------
QUERY:


--
-- Test triggers on a join view
--
CREATE TABLE country_table (
    country_id        serial primary key,
    country_name    text unique not null,
    continent        text not null
);
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO country_table (country_name, continent)
    VALUES ('Japan', 'Asia'),
           ('UK', 'Europe'),
           ('USA', 'North America')
    RETURNING *;
RESULT:
	postgres: [(1, 'Japan', 'Asia'), (2, 'UK', 'Europe'), (3, 'USA', 'North America')]

-----------
QUERY:


CREATE TABLE city_table (
    city_id        serial primary key,
    city_name    text not null,
    population    bigint,
    country_id    int references country_table
);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW city_view AS
    SELECT city_id, city_name, population, country_name, continent
    FROM city_table ci
    LEFT JOIN country_table co ON co.country_id = ci.country_id;
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION city_insert() RETURNS trigger LANGUAGE plpgsql AS $$
declare
    ctry_id int;
begin
    if NEW.country_name IS NOT NULL then
        SELECT country_id, continent INTO ctry_id, NEW.continent
            FROM country_table WHERE country_name = NEW.country_name;
        if NOT FOUND then
            raise exception 'No such country: "%"', NEW.country_name;
        end if;
    else
        NEW.continent := NULL;
    end if;

    if NEW.city_id IS NOT NULL then
        INSERT INTO city_table
            VALUES(NEW.city_id, NEW.city_name, NEW.population, ctry_id);
    else
        INSERT INTO city_table(city_name, population, country_id)
            VALUES(NEW.city_name, NEW.population, ctry_id)
            RETURNING city_id INTO NEW.city_id;
    end if;

    RETURN NEW;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER city_insert_trig INSTEAD OF INSERT ON city_view
FOR EACH ROW EXECUTE PROCEDURE city_insert();
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION city_delete() RETURNS trigger LANGUAGE plpgsql AS $$
begin
    DELETE FROM city_table WHERE city_id = OLD.city_id;
    if NOT FOUND then RETURN NULL; end if;
    RETURN OLD;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER city_delete_trig INSTEAD OF DELETE ON city_view
FOR EACH ROW EXECUTE PROCEDURE city_delete();
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION city_update() RETURNS trigger LANGUAGE plpgsql AS $$
declare
    ctry_id int;
begin
    if NEW.country_name IS DISTINCT FROM OLD.country_name then
        SELECT country_id, continent INTO ctry_id, NEW.continent
            FROM country_table WHERE country_name = NEW.country_name;
        if NOT FOUND then
            raise exception 'No such country: "%"', NEW.country_name;
        end if;

        UPDATE city_table SET city_name = NEW.city_name,
                              population = NEW.population,
                              country_id = ctry_id
            WHERE city_id = OLD.city_id;
    else
        UPDATE city_table SET city_name = NEW.city_name,
                              population = NEW.population
            WHERE city_id = OLD.city_id;
        NEW.continent := OLD.continent;
    end if;

    if NOT FOUND then RETURN NULL; end if;
    RETURN NEW;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER city_update_trig INSTEAD OF UPDATE ON city_view
FOR EACH ROW EXECUTE PROCEDURE city_update();
RESULT:
	postgres: None

-----------
QUERY:


-- \set QUIET false

-- INSERT .. RETURNING
INSERT INTO city_view(city_name) VALUES('Tokyo') RETURNING *;
RESULT:
	postgres: [(1, 'Tokyo', None, None, None)]

-----------
QUERY:

INSERT INTO city_view(city_name, population) VALUES('London', 7556900) RETURNING *;
RESULT:
	postgres: [(2, 'London', 7556900, None, None)]

-----------
QUERY:

INSERT INTO city_view(city_name, country_name) VALUES('Washington DC', 'USA') RETURNING *;
RESULT:
	postgres: [(3, 'Washington DC', None, 'USA', 'North America')]

-----------
QUERY:

INSERT INTO city_view(city_id, city_name) VALUES(123456, 'New York') RETURNING *;
RESULT:
	postgres: [(123456, 'New York', None, None, None)]

-----------
QUERY:

INSERT INTO city_view VALUES(234567, 'Birmingham', 1016800, 'UK', 'EU') RETURNING *;
RESULT:
	postgres: [(234567, 'Birmingham', 1016800, 'UK', 'Europe')]

-----------
QUERY:


-- UPDATE .. RETURNING
UPDATE city_view SET country_name = 'Japon' WHERE city_name = 'Tokyo';
RESULT:
	postgres: No such country: "Japon"
CONTEXT:  PL/pgSQL function city_update() line 9 at RAISE


-----------
QUERY:
 -- error
UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Takyo';
RESULT:
	postgres: None

-----------
QUERY:
 -- no match
UPDATE city_view SET country_name = 'Japan' WHERE city_name = 'Tokyo' RETURNING *;
RESULT:
	postgres: [(1, 'Tokyo', None, 'Japan', 'Asia')]

-----------
QUERY:
 -- OK

UPDATE city_view SET population = 13010279 WHERE city_name = 'Tokyo' RETURNING *;
RESULT:
	postgres: [(1, 'Tokyo', 13010279, 'Japan', 'Asia')]

-----------
QUERY:

UPDATE city_view SET country_name = 'UK' WHERE city_name = 'New York' RETURNING *;
RESULT:
	postgres: [(123456, 'New York', None, 'UK', 'Europe')]

-----------
QUERY:

UPDATE city_view SET country_name = 'USA', population = 8391881 WHERE city_name = 'New York' RETURNING *;
RESULT:
	postgres: [(123456, 'New York', 8391881, 'USA', 'North America')]

-----------
QUERY:

UPDATE city_view SET continent = 'EU' WHERE continent = 'Europe' RETURNING *;
RESULT:
	postgres: [(234567, 'Birmingham', 1016800, 'UK', 'Europe')]

-----------
QUERY:

UPDATE city_view v1 SET country_name = v2.country_name FROM city_view v2
    WHERE v2.city_name = 'Birmingham' AND v1.city_name = 'London' RETURNING *;
RESULT:
	postgres: [(2, 'London', 7556900, 'UK', 'Europe', 234567, 'Birmingham', 1016800, 'UK', 'Europe')]

-----------
QUERY:


-- DELETE .. RETURNING
DELETE FROM city_view WHERE city_name = 'Birmingham' RETURNING *;
RESULT:
	postgres: [(234567, 'Birmingham', 1016800, 'UK', 'Europe')]

-----------
QUERY:


-- \set QUIET true

-- read-only view with WHERE clause
CREATE VIEW european_city_view AS
    SELECT * FROM city_view WHERE continent = 'Europe';
RESULT:
	postgres: None

-----------
QUERY:

SELECT count(*) FROM european_city_view;
RESULT:
	postgres: [(1,)]

-----------
QUERY:


CREATE FUNCTION no_op_trig_fn() RETURNS trigger LANGUAGE plpgsql
AS 'begin RETURN NULL;
RESULT:
	postgres: unterminated quoted string at or near "'begin RETURN NULL;"
LINE 4: AS 'begin RETURN NULL;
           ^


-----------
QUERY:
 end';
RESULT:
	postgres: unterminated quoted string at or near "';"
LINE 1:  end';
            ^


-----------
QUERY:


CREATE TRIGGER no_op_trig INSTEAD OF INSERT OR UPDATE OR DELETE
ON european_city_view FOR EACH ROW EXECUTE PROCEDURE no_op_trig_fn();
RESULT:
	postgres: function no_op_trig_fn() does not exist


-----------
QUERY:


-- \set QUIET false

INSERT INTO european_city_view VALUES (0, 'x', 10000, 'y', 'z');
RESULT:
	postgres: No such country: "y"
CONTEXT:  PL/pgSQL function city_insert() line 9 at RAISE


-----------
QUERY:

UPDATE european_city_view SET population = 10000;
RESULT:
	postgres: None

-----------
QUERY:

DELETE FROM european_city_view;
RESULT:
	postgres: None

-----------
QUERY:


-- \set QUIET true

-- rules bypassing no-op triggers
CREATE RULE european_city_insert_rule AS ON INSERT TO european_city_view
DO INSTEAD INSERT INTO city_view
VALUES (NEW.city_id, NEW.city_name, NEW.population, NEW.country_name, NEW.continent)
RETURNING *;
RESULT:
	postgres: None

-----------
QUERY:


CREATE RULE european_city_update_rule AS ON UPDATE TO european_city_view
DO INSTEAD UPDATE city_view SET
    city_name = NEW.city_name,
    population = NEW.population,
    country_name = NEW.country_name
WHERE city_id = OLD.city_id
RETURNING NEW.*;
RESULT:
	postgres: None

-----------
QUERY:


CREATE RULE european_city_delete_rule AS ON DELETE TO european_city_view
DO INSTEAD DELETE FROM city_view WHERE city_id = OLD.city_id RETURNING *;
RESULT:
	postgres: None

-----------
QUERY:


-- \set QUIET false

-- INSERT not limited by view/* REPLACED */''s WHERE clause, but UPDATE AND DELETE are
INSERT INTO european_city_view(city_name, country_name)
    VALUES ('Cambridge', 'USA') RETURNING *;
RESULT:
	postgres: [(4, 'Cambridge', None, 'USA', 'North America')]

-----------
QUERY:

UPDATE european_city_view SET country_name = 'UK'
    WHERE city_name = 'Cambridge';
RESULT:
	postgres: None

-----------
QUERY:

DELETE FROM european_city_view WHERE city_name = 'Cambridge';
RESULT:
	postgres: None

-----------
QUERY:


-- UPDATE and DELETE via rule and trigger
UPDATE city_view SET country_name = 'UK'
    WHERE city_name = 'Cambridge' RETURNING *;
RESULT:
	postgres: [(4, 'Cambridge', None, 'UK', 'Europe')]

-----------
QUERY:

UPDATE european_city_view SET population = 122800
    WHERE city_name = 'Cambridge' RETURNING *;
RESULT:
	postgres: [(4, 'Cambridge', 122800, 'UK', 'Europe')]

-----------
QUERY:

DELETE FROM european_city_view WHERE city_name = 'Cambridge' RETURNING *;
RESULT:
	postgres: [(4, 'Cambridge', 122800, 'UK', 'Europe')]

-----------
QUERY:


-- join UPDATE test
UPDATE city_view v SET population = 599657
    FROM city_table ci, country_table co
    WHERE ci.city_name = 'Washington DC' and co.country_name = 'USA'
    AND v.city_id = ci.city_id AND v.country_name = co.country_name
    RETURNING co.country_id, v.country_name,
              v.city_id, v.city_name, v.population;
RESULT:
	postgres: [(3, 'USA', 3, 'Washington DC', 599657)]

-----------
QUERY:


-- \set QUIET true

SELECT * FROM city_view;
RESULT:
	postgres: [(1, 'Tokyo', 13010279, 'Japan', 'Asia'), (123456, 'New York', 8391881, 'USA', 'North America'), (3, 'Washington DC', 599657, 'USA', 'North America')]

-----------
QUERY:


DROP TABLE city_table CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE country_table;
RESULT:
	postgres: None

-----------
QUERY:



-- Test pg_trigger_depth()

create table depth_a (id int not null primary key);
RESULT:
	postgres: None

-----------
QUERY:

create table depth_b (id int not null primary key);
RESULT:
	postgres: None

-----------
QUERY:

create table depth_c (id int not null primary key);
RESULT:
	postgres: None

-----------
QUERY:


create function depth_a_tf() returns trigger
  language plpgsql as $$
begin
  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  insert into depth_b values (new.id);
  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger depth_a_tr before insert on depth_a
  for each row execute procedure depth_a_tf();
RESULT:
	postgres: None

-----------
QUERY:


create function depth_b_tf() returns trigger
  language plpgsql as $$
begin
  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  begin
    execute 'insert into depth_c values (' || new.id::text || ')';
  exception
    when sqlstate 'U9999' then
      raise notice 'SQLSTATE = U9999: depth = %', pg_trigger_depth();
  end;
  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  if new.id = 1 then
    execute 'insert into depth_c values (' || new.id::text || ')';
  end if;
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger depth_b_tr before insert on depth_b
  for each row execute procedure depth_b_tf();
RESULT:
	postgres: None

-----------
QUERY:


create function depth_c_tf() returns trigger
  language plpgsql as $$
begin
  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  if new.id = 1 then
    raise exception sqlstate 'U9999';
  end if;
  raise notice '%: depth = %', tg_name, pg_trigger_depth();
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger depth_c_tr before insert on depth_c
  for each row execute procedure depth_c_tf();
RESULT:
	postgres: None

-----------
QUERY:


select pg_trigger_depth();
RESULT:
	postgres: [(0,)]

-----------
QUERY:

insert into depth_a values (1);
RESULT:
	postgres: U9999
CONTEXT:  PL/pgSQL function depth_c_tf() line 5 at RAISE
SQL statement "insert into depth_c values (1)"
PL/pgSQL function depth_b_tf() line 12 at EXECUTE
SQL statement "insert into depth_b values (new.id)"
PL/pgSQL function depth_a_tf() line 4 at SQL statement


-----------
QUERY:

select pg_trigger_depth();
RESULT:
	postgres: [(0,)]

-----------
QUERY:

insert into depth_a values (2);
RESULT:
	postgres: None

-----------
QUERY:

select pg_trigger_depth();
RESULT:
	postgres: [(0,)]

-----------
QUERY:


drop table depth_a, depth_b, depth_c;
RESULT:
	postgres: None

-----------
QUERY:

drop function depth_a_tf();
RESULT:
	postgres: None

-----------
QUERY:

drop function depth_b_tf();
RESULT:
	postgres: None

-----------
QUERY:

drop function depth_c_tf();
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test updates to rows during firing of BEFORE ROW triggers.
-- As of 9.2, such cases should be rejected (see bug #6123).
--

create temp table parent (
    aid int not null primary key,
    val1 text,
    val2 text,
    val3 text,
    val4 text,
    bcnt int not null default 0);
RESULT:
	postgres: None

-----------
QUERY:

create temp table child (
    bid int not null primary key,
    aid int not null,
    val1 text);
RESULT:
	postgres: None

-----------
QUERY:


create function parent_upd_func()
  returns trigger language plpgsql as
$$
begin
  if old.val1 <> new.val1 then
    new.val2 = new.val1;
    delete from child where child.aid = new.aid and child.val1 = new.val1;
  end if;
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger parent_upd_trig before update on parent
  for each row execute procedure parent_upd_func();
RESULT:
	postgres: None

-----------
QUERY:


create function parent_del_func()
  returns trigger language plpgsql as
$$
begin
  delete from child where aid = old.aid;
  return old;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger parent_del_trig before delete on parent
  for each row execute procedure parent_del_func();
RESULT:
	postgres: None

-----------
QUERY:


create function child_ins_func()
  returns trigger language plpgsql as
$$
begin
  update parent set bcnt = bcnt + 1 where aid = new.aid;
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger child_ins_trig after insert on child
  for each row execute procedure child_ins_func();
RESULT:
	postgres: None

-----------
QUERY:


create function child_del_func()
  returns trigger language plpgsql as
$$
begin
  update parent set bcnt = bcnt - 1 where aid = old.aid;
  return old;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger child_del_trig after delete on child
  for each row execute procedure child_del_func();
RESULT:
	postgres: None

-----------
QUERY:


insert into parent values (1, 'a', 'a', 'a', 'a', 0);
RESULT:
	postgres: None

-----------
QUERY:

insert into child values (10, 1, 'b');
RESULT:
	postgres: None

-----------
QUERY:

select * from parent;
RESULT:
	postgres: [(1, 'a', 'a', 'a', 'a', 1)]

-----------
QUERY:
 select * from child;
RESULT:
	postgres: [(10, 1, 'b')]

-----------
QUERY:


update parent set val1 = 'b' where aid = 1;
RESULT:
	postgres: tuple to be updated was already modified by an operation triggered by the current command
HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.


-----------
QUERY:
 -- should fail
merge into parent p using (values (1)) as v(id) on p.aid = v.id
  when matched then update set val1 = 'b';
RESULT:
	postgres: tuple to be updated or deleted was already modified by an operation triggered by the current command
HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.


-----------
QUERY:
 -- should fail
select * from parent;
RESULT:
	postgres: [(1, 'a', 'a', 'a', 'a', 1)]

-----------
QUERY:
 select * from child;
RESULT:
	postgres: [(10, 1, 'b')]

-----------
QUERY:


delete from parent where aid = 1;
RESULT:
	postgres: tuple to be deleted was already modified by an operation triggered by the current command
HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.


-----------
QUERY:
 -- should fail
merge into parent p using (values (1)) as v(id) on p.aid = v.id
  when matched then delete;
RESULT:
	postgres: tuple to be updated or deleted was already modified by an operation triggered by the current command
HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.


-----------
QUERY:
 -- should fail
select * from parent;
RESULT:
	postgres: [(1, 'a', 'a', 'a', 'a', 1)]

-----------
QUERY:
 select * from child;
RESULT:
	postgres: [(10, 1, 'b')]

-----------
QUERY:


-- replace the trigger function with one that restarts the deletion after
-- having modified a child
create or replace function parent_del_func()
  returns trigger language plpgsql as
$$
begin
  delete from child where aid = old.aid;
  if found then
    delete from parent where aid = old.aid;
    return null; -- cancel outer deletion
  end if;
  return old;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


delete from parent where aid = 1;
RESULT:
	postgres: None

-----------
QUERY:

select * from parent;
RESULT:
	postgres: []

-----------
QUERY:
 select * from child;
RESULT:
	postgres: []

-----------
QUERY:


drop table parent, child;
RESULT:
	postgres: None

-----------
QUERY:


drop function parent_upd_func();
RESULT:
	postgres: None

-----------
QUERY:

drop function parent_del_func();
RESULT:
	postgres: None

-----------
QUERY:

drop function child_ins_func();
RESULT:
	postgres: None

-----------
QUERY:

drop function child_del_func();
RESULT:
	postgres: None

-----------
QUERY:


-- similar case, but with a self-referencing FK so that parent and child
-- rows can be affected by a single operation

create temp table self_ref_trigger (
    id int primary key,
    parent int references self_ref_trigger,
    data text,
    nchildren int not null default 0
);
RESULT:
	postgres: None

-----------
QUERY:


create function self_ref_trigger_ins_func()
  returns trigger language plpgsql as
$$
begin
  if new.parent is not null then
    update self_ref_trigger set nchildren = nchildren + 1
      where id = new.parent;
  end if;
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger self_ref_trigger_ins_trig before insert on self_ref_trigger
  for each row execute procedure self_ref_trigger_ins_func();
RESULT:
	postgres: None

-----------
QUERY:


create function self_ref_trigger_del_func()
  returns trigger language plpgsql as
$$
begin
  if old.parent is not null then
    update self_ref_trigger set nchildren = nchildren - 1
      where id = old.parent;
  end if;
  return old;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger self_ref_trigger_del_trig before delete on self_ref_trigger
  for each row execute procedure self_ref_trigger_del_func();
RESULT:
	postgres: None

-----------
QUERY:


insert into self_ref_trigger values (1, null, 'root');
RESULT:
	postgres: None

-----------
QUERY:

insert into self_ref_trigger values (2, 1, 'root child A');
RESULT:
	postgres: None

-----------
QUERY:

insert into self_ref_trigger values (3, 1, 'root child B');
RESULT:
	postgres: None

-----------
QUERY:

insert into self_ref_trigger values (4, 2, 'grandchild 1');
RESULT:
	postgres: None

-----------
QUERY:

insert into self_ref_trigger values (5, 3, 'grandchild 2');
RESULT:
	postgres: None

-----------
QUERY:


update self_ref_trigger set data = 'root!' where id = 1;
RESULT:
	postgres: None

-----------
QUERY:


select * from self_ref_trigger;
RESULT:
	postgres: [(2, 1, 'root child A', 1), (4, 2, 'grandchild 1', 0), (3, 1, 'root child B', 1), (5, 3, 'grandchild 2', 0), (1, None, 'root!', 2)]

-----------
QUERY:


delete from self_ref_trigger;
RESULT:
	postgres: tuple to be updated was already modified by an operation triggered by the current command
HINT:  Consider using an AFTER trigger instead of a BEFORE trigger to propagate changes to other rows.


-----------
QUERY:


select * from self_ref_trigger;
RESULT:
	postgres: [(2, 1, 'root child A', 1), (4, 2, 'grandchild 1', 0), (3, 1, 'root child B', 1), (5, 3, 'grandchild 2', 0), (1, None, 'root!', 2)]

-----------
QUERY:


drop table self_ref_trigger;
RESULT:
	postgres: None

-----------
QUERY:

drop function self_ref_trigger_ins_func();
RESULT:
	postgres: None

-----------
QUERY:

drop function self_ref_trigger_del_func();
RESULT:
	postgres: None

-----------
QUERY:


--
-- Check that statement triggers work correctly even with all children excluded
--

create table stmt_trig_on_empty_upd (a int);
RESULT:
	postgres: None

-----------
QUERY:

create table stmt_trig_on_empty_upd1 () inherits (stmt_trig_on_empty_upd);
RESULT:
	postgres: None

-----------
QUERY:

create function update_stmt_notice() returns trigger as $$
begin
	raise notice 'updating %', TG_TABLE_NAME;
	return null;
end;
$$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:

create trigger before_stmt_trigger
	before update on stmt_trig_on_empty_upd
	execute procedure update_stmt_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger before_stmt_trigger
	before update on stmt_trig_on_empty_upd1
	execute procedure update_stmt_notice();
RESULT:
	postgres: None

-----------
QUERY:


-- inherited no-op update
update stmt_trig_on_empty_upd set a = a where false returning a+1 as aa;
RESULT:
	postgres: []

-----------
QUERY:

-- simple no-op update
update stmt_trig_on_empty_upd1 set a = a where false returning a+1 as aa;
RESULT:
	postgres: []

-----------
QUERY:


drop table stmt_trig_on_empty_upd cascade;
RESULT:
	postgres: None

-----------
QUERY:

drop function update_stmt_notice();
RESULT:
	postgres: None

-----------
QUERY:


--
-- Check that index creation (or DDL in general) is prohibited in a trigger
--

create table trigger_ddl_table (
   col1 integer,
   col2 integer
);
RESULT:
	postgres: None

-----------
QUERY:


create function trigger_ddl_func() returns trigger as $$
begin
  alter table trigger_ddl_table add primary key (col1);
  return new;
end$$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


create trigger trigger_ddl_func before insert on trigger_ddl_table for each row
  execute procedure trigger_ddl_func();
RESULT:
	postgres: None

-----------
QUERY:


insert into trigger_ddl_table values (1, 42);
RESULT:
	postgres: cannot ALTER TABLE "trigger_ddl_table" because it is being used by active queries in this session
CONTEXT:  SQL statement "alter table trigger_ddl_table add primary key (col1)"
PL/pgSQL function trigger_ddl_func() line 3 at SQL statement


-----------
QUERY:
  -- fail

create or replace function trigger_ddl_func() returns trigger as $$
begin
  create index on trigger_ddl_table (col2);
  return new;
end$$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


insert into trigger_ddl_table values (1, 42);
RESULT:
	postgres: cannot CREATE INDEX "trigger_ddl_table" because it is being used by active queries in this session
CONTEXT:  SQL statement "create index on trigger_ddl_table (col2)"
PL/pgSQL function trigger_ddl_func() line 3 at SQL statement


-----------
QUERY:
  -- fail

drop table trigger_ddl_table;
RESULT:
	postgres: None

-----------
QUERY:

drop function trigger_ddl_func();
RESULT:
	postgres: None

-----------
QUERY:


--
-- Verify behavior of before and after triggers with INSERT...ON CONFLICT
-- DO UPDATE
--
create table upsert (key int4 primary key, color text);
RESULT:
	postgres: None

-----------
QUERY:


create function upsert_before_func()
  returns trigger language plpgsql as
$$
begin
  if (TG_OP = 'UPDATE') then
    raise warning 'before update (old): %', old.*::text;
    raise warning 'before update (new): %', new.*::text;
  elsif (TG_OP = 'INSERT') then
    raise warning 'before insert (new): %', new.*::text;
    if new.key % 2 = 0 then
      new.key := new.key + 1;
      new.color := new.color || ' trig modified';
      raise warning 'before insert (new, modified): %', new.*::text;
    end if;
  end if;
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger upsert_before_trig before insert or update on upsert
  for each row execute procedure upsert_before_func();
RESULT:
	postgres: None

-----------
QUERY:


create function upsert_after_func()
  returns trigger language plpgsql as
$$
begin
  if (TG_OP = 'UPDATE') then
    raise warning 'after update (old): %', old.*::text;
    raise warning 'after update (new): %', new.*::text;
  elsif (TG_OP = 'INSERT') then
    raise warning 'after insert (new): %', new.*::text;
  end if;
  return null;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger upsert_after_trig after insert or update on upsert
  for each row execute procedure upsert_after_func();
RESULT:
	postgres: None

-----------
QUERY:


insert into upsert values(1, 'black') on conflict (key) do update set color = 'updated ' || upsert.color;
RESULT:
	postgres: None

-----------
QUERY:

insert into upsert values(2, 'red') on conflict (key) do update set color = 'updated ' || upsert.color;
RESULT:
	postgres: None

-----------
QUERY:

insert into upsert values(3, 'orange') on conflict (key) do update set color = 'updated ' || upsert.color;
RESULT:
	postgres: None

-----------
QUERY:

insert into upsert values(4, 'green') on conflict (key) do update set color = 'updated ' || upsert.color;
RESULT:
	postgres: None

-----------
QUERY:

insert into upsert values(5, 'purple') on conflict (key) do update set color = 'updated ' || upsert.color;
RESULT:
	postgres: None

-----------
QUERY:

insert into upsert values(6, 'white') on conflict (key) do update set color = 'updated ' || upsert.color;
RESULT:
	postgres: None

-----------
QUERY:

insert into upsert values(7, 'pink') on conflict (key) do update set color = 'updated ' || upsert.color;
RESULT:
	postgres: None

-----------
QUERY:

insert into upsert values(8, 'yellow') on conflict (key) do update set color = 'updated ' || upsert.color;
RESULT:
	postgres: None

-----------
QUERY:


select * from upsert;
RESULT:
	postgres: [(1, 'black'), (3, 'updated red trig modified'), (5, 'updated green trig modified'), (7, 'updated white trig modified'), (9, 'yellow trig modified')]

-----------
QUERY:


drop table upsert;
RESULT:
	postgres: None

-----------
QUERY:

drop function upsert_before_func();
RESULT:
	postgres: None

-----------
QUERY:

drop function upsert_after_func();
RESULT:
	postgres: None

-----------
QUERY:


--
-- Verify that triggers with transition tables are not allowed on
-- views
--

create table my_table (i int);
RESULT:
	postgres: None

-----------
QUERY:

create view my_view as select * from my_table;
RESULT:
	postgres: None

-----------
QUERY:

create function my_trigger_function() returns trigger as $$ begin end; $$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:

create trigger my_trigger after update on my_view referencing old table as old_table
   for each statement execute procedure my_trigger_function();
RESULT:
	postgres: "my_view" is a view
DETAIL:  Triggers on views cannot have transition tables.


-----------
QUERY:

drop function my_trigger_function();
RESULT:
	postgres: None

-----------
QUERY:

drop view my_view;
RESULT:
	postgres: None

-----------
QUERY:

drop table my_table;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Verify cases that are unsupported with partitioned tables
--
create table parted_trig (a int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create function trigger_nothing() returns trigger
  language plpgsql as $$ begin end; $$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger failed instead of update on parted_trig
  for each row execute procedure trigger_nothing();
RESULT:
	postgres: "parted_trig" is a table
DETAIL:  Tables cannot have INSTEAD OF triggers.


-----------
QUERY:

create trigger failed after update on parted_trig
  referencing old table as old_table
  for each row execute procedure trigger_nothing();
RESULT:
	postgres: "parted_trig" is a partitioned table
DETAIL:  ROW triggers with transition tables are not supported on partitioned tables.


-----------
QUERY:

drop table parted_trig;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Verify trigger creation for partitioned tables, and drop behavior
--
create table trigpart (a int, b int) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table trigpart1 partition of trigpart for values from (0) to (1000);
RESULT:
	postgres: None

-----------
QUERY:

create trigger trg1 after insert on trigpart for each row execute procedure trigger_nothing();
RESULT:
	postgres: None

-----------
QUERY:

create table trigpart2 partition of trigpart for values from (1000) to (2000);
RESULT:
	postgres: None

-----------
QUERY:

create table trigpart3 (like trigpart);
RESULT:
	postgres: None

-----------
QUERY:

alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
RESULT:
	postgres: None

-----------
QUERY:

create table trigpart4 partition of trigpart for values from (3000) to (4000) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table trigpart41 partition of trigpart4 for values from (3000) to (3500);
RESULT:
	postgres: None

-----------
QUERY:

create table trigpart42 (like trigpart);
RESULT:
	postgres: None

-----------
QUERY:

alter table trigpart4 attach partition trigpart42 for values from (3500) to (4000);
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger
  where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
RESULT:
	postgres: [('trigpart', 'trg1', 'trigger_nothing'), ('trigpart1', 'trg1', 'trigger_nothing'), ('trigpart2', 'trg1', 'trigger_nothing'), ('trigpart3', 'trg1', 'trigger_nothing'), ('trigpart4', 'trg1', 'trigger_nothing'), ('trigpart41', 'trg1', 'trigger_nothing'), ('trigpart42', 'trg1', 'trigger_nothing')]

-----------
QUERY:

drop trigger trg1 on trigpart1;
RESULT:
	postgres: cannot drop trigger trg1 on table trigpart1 because trigger trg1 on table trigpart requires it
HINT:  You can drop trigger trg1 on table trigpart instead.


-----------
QUERY:
	-- fail
drop trigger trg1 on trigpart2;
RESULT:
	postgres: cannot drop trigger trg1 on table trigpart2 because trigger trg1 on table trigpart requires it
HINT:  You can drop trigger trg1 on table trigpart instead.


-----------
QUERY:
	-- fail
drop trigger trg1 on trigpart3;
RESULT:
	postgres: cannot drop trigger trg1 on table trigpart3 because trigger trg1 on table trigpart requires it
HINT:  You can drop trigger trg1 on table trigpart instead.


-----------
QUERY:
	-- fail
drop table trigpart2;
RESULT:
	postgres: None

-----------
QUERY:
			-- ok, trigger should be gone in that partition
select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger
  where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
RESULT:
	postgres: [('trigpart', 'trg1', 'trigger_nothing'), ('trigpart1', 'trg1', 'trigger_nothing'), ('trigpart3', 'trg1', 'trigger_nothing'), ('trigpart4', 'trg1', 'trigger_nothing'), ('trigpart41', 'trg1', 'trigger_nothing'), ('trigpart42', 'trg1', 'trigger_nothing')]

-----------
QUERY:

drop trigger trg1 on trigpart;
RESULT:
	postgres: None

-----------
QUERY:
		-- ok, all gone
select tgrelid::regclass, tgname, tgfoid::regproc from pg_trigger
  where tgrelid::regclass::text like 'trigpart%' order by tgrelid::regclass::text;
RESULT:
	postgres: []

-----------
QUERY:


-- check detach behavior
create trigger trg1 after insert on trigpart for each row execute procedure trigger_nothing();
RESULT:
	postgres: None

-----------
QUERY:

-- \d trigpart3
alter table trigpart detach partition trigpart3;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger trg1 on trigpart3;
RESULT:
	postgres: trigger "trg1" for table "trigpart3" does not exist


-----------
QUERY:
 -- fail due to /* REPLACED */''does not exist/* REPLACED */''
alter table trigpart detach partition trigpart4;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger trg1 on trigpart41;
RESULT:
	postgres: trigger "trg1" for table "trigpart41" does not exist


-----------
QUERY:
 -- fail due to /* REPLACED */''does not exist/* REPLACED */''
drop table trigpart4;
RESULT:
	postgres: None

-----------
QUERY:

alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
RESULT:
	postgres: None

-----------
QUERY:

alter table trigpart detach partition trigpart3;
RESULT:
	postgres: None

-----------
QUERY:

alter table trigpart attach partition trigpart3 for values from (2000) to (3000);
RESULT:
	postgres: None

-----------
QUERY:

drop table trigpart3;
RESULT:
	postgres: None

-----------
QUERY:


select tgrelid::regclass::text, tgname, tgfoid::regproc, tgenabled, tgisinternal from pg_trigger
  where tgname ~ '^trg1' order by 1;
RESULT:
	postgres: [('trigpart', 'trg1', 'trigger_nothing', 'O', False), ('trigpart1', 'trg1', 'trigger_nothing', 'O', False)]

-----------
QUERY:

create table trigpart3 (like trigpart);
RESULT:
	postgres: None

-----------
QUERY:

create trigger trg1 after insert on trigpart3 for each row execute procedure trigger_nothing();
RESULT:
	postgres: None

-----------
QUERY:

-- \d trigpart3
alter table trigpart attach partition trigpart3 FOR VALUES FROM (2000) to (3000);
RESULT:
	postgres: trigger "trg1" for relation "trigpart3" already exists


-----------
QUERY:
 -- fail
drop table trigpart3;
RESULT:
	postgres: None

-----------
QUERY:


-- check display of unrelated triggers
create trigger samename after delete on trigpart execute function trigger_nothing();
RESULT:
	postgres: None

-----------
QUERY:

create trigger samename after delete on trigpart1 execute function trigger_nothing();
RESULT:
	postgres: None

-----------
QUERY:

-- \d trigpart1

drop table trigpart;
RESULT:
	postgres: None

-----------
QUERY:

drop function trigger_nothing();
RESULT:
	postgres: None

-----------
QUERY:


--
-- Verify that triggers are fired for partitioned tables
--
create table parted_stmt_trig (a int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_stmt_trig1 partition of parted_stmt_trig for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_stmt_trig2 partition of parted_stmt_trig for values in (2);
RESULT:
	postgres: None

-----------
QUERY:


create table parted2_stmt_trig (a int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted2_stmt_trig1 partition of parted2_stmt_trig for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create table parted2_stmt_trig2 partition of parted2_stmt_trig for values in (2);
RESULT:
	postgres: None

-----------
QUERY:


create or replace function trigger_notice() returns trigger as $$
  begin
    raise notice 'trigger % on % % % for %', TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL;
    if TG_LEVEL = 'ROW' then
       return NEW;
    end if;
    return null;
  end;
  $$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


-- insert/update/delete statement-level triggers on the parent
create trigger trig_ins_before before insert on parted_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_ins_after after insert on parted_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_upd_before before update on parted_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_upd_after after update on parted_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_del_before before delete on parted_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_del_after after delete on parted_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:


-- insert/update/delete row-level triggers on the parent
create trigger trig_ins_after_parent after insert on parted_stmt_trig
  for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_upd_after_parent after update on parted_stmt_trig
  for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_del_after_parent after delete on parted_stmt_trig
  for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:


-- insert/update/delete row-level triggers on the first partition
create trigger trig_ins_before_child before insert on parted_stmt_trig1
  for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_ins_after_child after insert on parted_stmt_trig1
  for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_upd_before_child before update on parted_stmt_trig1
  for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_upd_after_child after update on parted_stmt_trig1
  for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_del_before_child before delete on parted_stmt_trig1
  for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_del_after_child after delete on parted_stmt_trig1
  for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:


-- insert/update/delete statement-level triggers on the parent
create trigger trig_ins_before_3 before insert on parted2_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_ins_after_3 after insert on parted2_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_upd_before_3 before update on parted2_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_upd_after_3 after update on parted2_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_del_before_3 before delete on parted2_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_del_after_3 after delete on parted2_stmt_trig
  for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:


with ins (a) as (
  insert into parted2_stmt_trig values (1), (2) returning a
) insert into parted_stmt_trig select a from ins returning tableoid::regclass, a;
RESULT:
	postgres: [('parted_stmt_trig1', 1), ('parted_stmt_trig2', 2)]

-----------
QUERY:


with upd as (
  update parted2_stmt_trig set a = a
) update parted_stmt_trig  set a = a;
RESULT:
	postgres: None

-----------
QUERY:


delete from parted_stmt_trig;
RESULT:
	postgres: None

-----------
QUERY:


-- insert via copy on the parent
copy parted_stmt_trig(a) from stdin;
RESULT:
	postgres: can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

1
2
\.

-- insert via copy on the first partition
copy parted_stmt_trig1(a) from stdin;
RESULT:
	postgres: syntax error at or near "1"
LINE 2: 1
        ^


-----------
QUERY:

1
\.

-- Disabling a trigger in the parent table should disable children triggers too
alter table parted_stmt_trig disable trigger trig_ins_after_parent;
RESULT:
	postgres: syntax error at or near "1"
LINE 2: 1
        ^


-----------
QUERY:

insert into parted_stmt_trig values (1);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_stmt_trig enable trigger trig_ins_after_parent;
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_stmt_trig values (1);
RESULT:
	postgres: None

-----------
QUERY:


drop table parted_stmt_trig, parted2_stmt_trig;
RESULT:
	postgres: None

-----------
QUERY:


-- Verify that triggers fire in alphabetical order
create table parted_trig (a int) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trig_1 partition of parted_trig for values from (0) to (1000)
   partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trig_2 partition of parted_trig for values from (1000) to (2000);
RESULT:
	postgres: None

-----------
QUERY:

create trigger zzz after insert on parted_trig for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger mmm after insert on parted_trig_1_1 for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger aaa after insert on parted_trig_1 for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger bbb after insert on parted_trig for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger qqq after insert on parted_trig_1_1 for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trig values (50), (1500);
RESULT:
	postgres: None

-----------
QUERY:

drop table parted_trig;
RESULT:
	postgres: None

-----------
QUERY:


-- Verify that the correct triggers fire for cross-partition updates
create table parted_trig (a int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trig1 partition of parted_trig for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trig2 partition of parted_trig for values in (2);
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trig values (1);
RESULT:
	postgres: None

-----------
QUERY:


create or replace function trigger_notice() returns trigger as $$
  begin
    raise notice 'trigger % on % % % for %', TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL;
    if TG_LEVEL = 'ROW' then
      if TG_OP = 'DELETE' then
        return OLD;
      else
        return NEW;
      end if;
    end if;
    return null;
  end;
  $$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:

create trigger parted_trig_before_stmt before insert or update or delete on parted_trig
   for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger parted_trig_before_row before insert or update or delete on parted_trig
   for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger parted_trig_after_row after insert or update or delete on parted_trig
   for each row execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:

create trigger parted_trig_after_stmt after insert or update or delete on parted_trig
   for each statement execute procedure trigger_notice();
RESULT:
	postgres: None

-----------
QUERY:


update parted_trig set a = 2 where a = 1;
RESULT:
	postgres: None

-----------
QUERY:


-- update action in merge should behave the same
merge into parted_trig using (select 1) as ss on true
  when matched and a = 2 then update set a = 1;
RESULT:
	postgres: None

-----------
QUERY:


drop table parted_trig;
RESULT:
	postgres: None

-----------
QUERY:


-- Verify propagation of trigger arguments to partitions
create table parted_trig (a int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trig1 partition of parted_trig for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create or replace function trigger_notice() returns trigger as $$
  declare
    arg1 text = TG_ARGV[0];
    arg2 integer = TG_ARGV[1];
  begin
    raise notice 'trigger % on % % % for % args % %',
		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL, arg1, arg2;
    return null;
  end;
  $$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:

create trigger aaa after insert on parted_trig
   for each row execute procedure trigger_notice('quirky', 1);
RESULT:
	postgres: None

-----------
QUERY:


-- Verify propagation of trigger arguments to partitions attached after creating trigger
create table parted_trig2 partition of parted_trig for values in (2);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trig3 (like parted_trig);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_trig attach partition parted_trig3 for values in (3);
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trig values (1), (2), (3);
RESULT:
	postgres: None

-----------
QUERY:

drop table parted_trig;
RESULT:
	postgres: None

-----------
QUERY:


-- test irregular partitions (i.e., different column definitions),
-- including that the WHEN clause works
create function bark(text) returns bool language plpgsql immutable
  as $$ begin raise notice '% <- woof!', $1; return true; end; $$;
RESULT:
	postgres: None

-----------
QUERY:

create or replace function trigger_notice_ab() returns trigger as $$
  begin
    raise notice 'trigger % on % % % for %: (a,b)=(%,%)',
		TG_NAME, TG_TABLE_NAME, TG_WHEN, TG_OP, TG_LEVEL,
		NEW.a, NEW.b;
    if TG_LEVEL = 'ROW' then
       return NEW;
    end if;
    return null;
  end;
  $$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:

create table parted_irreg_ancestor (fd text, b text, fd2 int, fd3 int, a int)
  partition by range (b);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_irreg_ancestor drop column fd,
  drop column fd2, drop column fd3;
RESULT:
	postgres: None

-----------
QUERY:

create table parted_irreg (fd int, a int, fd2 int, b text)
  partition by range (b);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_irreg drop column fd, drop column fd2;
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_irreg_ancestor attach partition parted_irreg
  for values from ('aaaa') to ('zzzz');
RESULT:
	postgres: None

-----------
QUERY:

create table parted1_irreg (b text, fd int, a int);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted1_irreg drop column fd;
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_irreg attach partition parted1_irreg
  for values from ('aaaa') to ('bbbb');
RESULT:
	postgres: None

-----------
QUERY:

create trigger parted_trig after insert on parted_irreg
  for each row execute procedure trigger_notice_ab();
RESULT:
	postgres: None

-----------
QUERY:

create trigger parted_trig_odd after insert on parted_irreg for each row
  when (bark(new.b) AND new.a % 2 = 1) execute procedure trigger_notice_ab();
RESULT:
	postgres: None

-----------
QUERY:

-- we should hear barking for every insert, but parted_trig_odd only emits
-- noise for odd values of a. parted_trig does it for all inserts.
insert into parted_irreg values (1, 'aardvark'), (2, 'aanimals');
RESULT:
	postgres: None

-----------
QUERY:

insert into parted1_irreg values ('aardwolf', 2);
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_irreg_ancestor values ('aasvogel', 3);
RESULT:
	postgres: None

-----------
QUERY:

drop table parted_irreg_ancestor;
RESULT:
	postgres: None

-----------
QUERY:


-- Before triggers and partitions
create table parted (a int, b int, c text) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_1 partition of parted for values in (1)
  partition by list (b);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_1_1 partition of parted_1 for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create function parted_trigfunc() returns trigger language plpgsql as $$
begin
  new.a = new.a + 1;
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

insert into parted values (1, 1, 'uno uno v1');
RESULT:
	postgres: None

-----------
QUERY:
    -- works
create trigger t before insert or update or delete on parted
  for each row execute function parted_trigfunc();
RESULT:
	postgres: None

-----------
QUERY:

insert into parted values (1, 1, 'uno uno v2');
RESULT:
	postgres: moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1_1".


-----------
QUERY:
    -- fail
update parted set c = c || 'v3';
RESULT:
	postgres: no partition of relation "parted" found for row
DETAIL:  Partition key of the failing row contains (a) = (2).


-----------
QUERY:
                   -- fail
create or replace function parted_trigfunc() returns trigger language plpgsql as $$
begin
  new.b = new.b + 1;
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

insert into parted values (1, 1, 'uno uno v4');
RESULT:
	postgres: moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1_1".


-----------
QUERY:
    -- fail
update parted set c = c || 'v5';
RESULT:
	postgres: no partition of relation "parted_1" found for row
DETAIL:  Partition key of the failing row contains (b) = (2).


-----------
QUERY:
                   -- fail
create or replace function parted_trigfunc() returns trigger language plpgsql as $$
begin
  new.c = new.c || ' did '|| TG_OP;
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

insert into parted values (1, 1, 'uno uno');
RESULT:
	postgres: None

-----------
QUERY:
       -- works
update parted set c = c || ' v6';
RESULT:
	postgres: None

-----------
QUERY:
                   -- works
select tableoid::regclass, * from parted;
RESULT:
	postgres: [('parted_1_1', 1, 1, 'uno uno v1 v6 did UPDATE'), ('parted_1_1', 1, 1, 'uno uno did INSERT v6 did UPDATE')]

-----------
QUERY:


-- update itself moves tuple to new partition /* REPLACED */, trigger still works
truncate table parted;
RESULT:
	postgres: None

-----------
QUERY:

create table parted_2 partition of parted for values in (2);
RESULT:
	postgres: None

-----------
QUERY:

insert into parted values (1, 1, 'uno uno v5');
RESULT:
	postgres: None

-----------
QUERY:

update parted set a = 2;
RESULT:
	postgres: None

-----------
QUERY:

select tableoid::regclass, * from parted;
RESULT:
	postgres: [('parted_2', 2, 1, 'uno uno v5 did INSERT did UPDATE did INSERT')]

-----------
QUERY:


-- both trigger and update change the partition
create or replace function parted_trigfunc2() returns trigger language plpgsql as $$
begin
  new.a = new.a + 1;
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger t2 before update on parted
  for each row execute function parted_trigfunc2();
RESULT:
	postgres: None

-----------
QUERY:

truncate table parted;
RESULT:
	postgres: None

-----------
QUERY:

insert into parted values (1, 1, 'uno uno v6');
RESULT:
	postgres: None

-----------
QUERY:

create table parted_3 partition of parted for values in (3);
RESULT:
	postgres: None

-----------
QUERY:

update parted set a = a + 1;
RESULT:
	postgres: None

-----------
QUERY:

select tableoid::regclass, * from parted;
RESULT:
	postgres: [('parted_3', 3, 1, 'uno uno v6 did INSERT did UPDATE did INSERT')]

-----------
QUERY:

-- there/* REPLACED */''s no partition for a=0, but this update works anyway because
-- the trigger causes the tuple to be routed to another partition
update parted set a = 0;
RESULT:
	postgres: None

-----------
QUERY:

select tableoid::regclass, * from parted;
RESULT:
	postgres: [('parted_1_1', 1, 1, 'uno uno v6 did INSERT did UPDATE did INSERT did UPDATE did INSERT')]

-----------
QUERY:


drop table parted;
RESULT:
	postgres: None

-----------
QUERY:

create table parted (a int, b int, c text) partition by list ((a + b));
RESULT:
	postgres: None

-----------
QUERY:

create or replace function parted_trigfunc() returns trigger language plpgsql as $$
begin
  new.a = new.a + new.b;
  return new;
end;
$$;
RESULT:
	postgres: None

-----------
QUERY:

create table parted_1 partition of parted for values in (1, 2);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_2 partition of parted for values in (3, 4);
RESULT:
	postgres: None

-----------
QUERY:

create trigger t before insert or update on parted
  for each row execute function parted_trigfunc();
RESULT:
	postgres: None

-----------
QUERY:

insert into parted values (0, 1, 'zero win');
RESULT:
	postgres: None

-----------
QUERY:

insert into parted values (1, 1, 'one fail');
RESULT:
	postgres: moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_1".


-----------
QUERY:

insert into parted values (1, 2, 'two fail');
RESULT:
	postgres: moving row to another partition during a BEFORE FOR EACH ROW trigger is not supported
DETAIL:  Before executing trigger "t", the row was to be in partition "public.parted_2".


-----------
QUERY:

select * from parted;
RESULT:
	postgres: [(1, 1, 'zero win')]

-----------
QUERY:

drop table parted;
RESULT:
	postgres: None

-----------
QUERY:

drop function parted_trigfunc();
RESULT:
	postgres: None

-----------
QUERY:


--
-- Constraint triggers and partitioned tables
create table parted_constr_ancestor (a int, b text)
  partition by range (b);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_constr (a int, b text)
  partition by range (b);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_constr_ancestor attach partition parted_constr
  for values from ('aaaa') to ('zzzz');
RESULT:
	postgres: None

-----------
QUERY:

create table parted1_constr (a int, b text);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_constr attach partition parted1_constr
  for values from ('aaaa') to ('bbbb');
RESULT:
	postgres: None

-----------
QUERY:

create constraint trigger parted_trig after insert on parted_constr_ancestor
  deferrable
  for each row execute procedure trigger_notice_ab();
RESULT:
	postgres: None

-----------
QUERY:

create constraint trigger parted_trig_two after insert on parted_constr
  deferrable initially deferred
  for each row when (bark(new.b) AND new.a % 2 = 1)
  execute procedure trigger_notice_ab();
RESULT:
	postgres: None

-----------
QUERY:


-- The immediate constraint is fired immediately /* REPLACED */, the WHEN clause of the
-- deferred constraint is also called immediately.  The deferred constraint
-- is fired at commit time.
begin;
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_constr values (1, 'aardvark');
RESULT:
	postgres: None

-----------
QUERY:

insert into parted1_constr values (2, 'aardwolf');
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_constr_ancestor values (3, 'aasvogel');
RESULT:
	postgres: None

-----------
QUERY:

commit;
RESULT:
	postgres: None

-----------
QUERY:


-- The WHEN clause is immediate, and both constraint triggers are fired at
-- commit time.
begin;
RESULT:
	postgres: None

-----------
QUERY:

set constraints parted_trig deferred;
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_constr values (1, 'aardvark');
RESULT:
	postgres: None

-----------
QUERY:

insert into parted1_constr values (2, 'aardwolf'), (3, 'aasvogel');
RESULT:
	postgres: None

-----------
QUERY:

commit;
RESULT:
	postgres: None

-----------
QUERY:

drop table parted_constr_ancestor;
RESULT:
	postgres: None

-----------
QUERY:

drop function bark(text);
RESULT:
	postgres: None

-----------
QUERY:


-- Test that the WHEN clause is set properly to partitions
create table parted_trigger (a int, b text) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_2 (drp int, a int, b text);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_trigger_2 drop column drp;
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
RESULT:
	postgres: None

-----------
QUERY:

create trigger parted_trigger after update on parted_trigger
  for each row when (new.a % 2 = 1 and length(old.b) >= 2) execute procedure trigger_notice_ab();
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_3 (b text, a int) partition by range (length(b));
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trigger values
    (0, 'a'), (1, 'bbb'), (2, 'bcd'), (3, 'c'),
	(1000, 'c'), (1001, 'ddd'), (1002, 'efg'), (1003, 'f'),
	(2000, 'e'), (2001, 'fff'), (2002, 'ghi'), (2003, 'h');
RESULT:
	postgres: None

-----------
QUERY:

update parted_trigger set a = a + 2;
RESULT:
	postgres: None

-----------
QUERY:
 -- notice for odd /* REPLACED */''a/* REPLACED */'' values, long /* REPLACED */''b/* REPLACED */'' values
drop table parted_trigger;
RESULT:
	postgres: None

-----------
QUERY:


-- try a constraint trigger, also
create table parted_referenced (a int);
RESULT:
	postgres: None

-----------
QUERY:

create table unparted_trigger (a int, b text);
RESULT:
	postgres: None

-----------
QUERY:
	-- for comparison purposes
create table parted_trigger (a int, b text) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_2 (drp int, a int, b text);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_trigger_2 drop column drp;
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
RESULT:
	postgres: None

-----------
QUERY:

create constraint trigger parted_trigger after update on parted_trigger
  from parted_referenced
  for each row execute procedure trigger_notice_ab();
RESULT:
	postgres: None

-----------
QUERY:

create constraint trigger parted_trigger after update on unparted_trigger
  from parted_referenced
  for each row execute procedure trigger_notice_ab();
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_3 (b text, a int) partition by range (length(b));
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (3);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_3_2 partition of parted_trigger_3 for values from (3) to (5);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
RESULT:
	postgres: None

-----------
QUERY:

select tgname, conname, t.tgrelid::regclass, t.tgconstrrelid::regclass,
  c.conrelid::regclass, c.confrelid::regclass
  from pg_trigger t join pg_constraint c on (t.tgconstraint = c.oid)
  where tgname = 'parted_trigger'
  order by t.tgrelid::regclass::text;
RESULT:
	postgres: [('parted_trigger', 'parted_trigger', 'parted_trigger', 'parted_referenced', 'parted_trigger', '-'), ('parted_trigger', 'parted_trigger', 'parted_trigger_1', 'parted_referenced', 'parted_trigger_1', '-'), ('parted_trigger', 'parted_trigger', 'parted_trigger_2', 'parted_referenced', 'parted_trigger_2', '-'), ('parted_trigger', 'parted_trigger', 'parted_trigger_3', 'parted_referenced', 'parted_trigger_3', '-'), ('parted_trigger', 'parted_trigger', 'parted_trigger_3_1', 'parted_referenced', 'parted_trigger_3_1', '-'), ('parted_trigger', 'parted_trigger', 'parted_trigger_3_2', 'parted_referenced', 'parted_trigger_3_2', '-'), ('parted_trigger', 'parted_trigger', 'unparted_trigger', 'parted_referenced', 'unparted_trigger', '-')]

-----------
QUERY:

drop table parted_referenced, parted_trigger, unparted_trigger;
RESULT:
	postgres: None

-----------
QUERY:


-- verify that the /* REPLACED */''AFTER UPDATE OF columns/* REPLACED */'' event is propagated correctly
create table parted_trigger (a int, b text) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_1 partition of parted_trigger for values from (0) to (1000);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_2 (drp int, a int, b text);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_trigger_2 drop column drp;
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_trigger attach partition parted_trigger_2 for values from (1000) to (2000);
RESULT:
	postgres: None

-----------
QUERY:

create trigger parted_trigger after update of b on parted_trigger
  for each row execute procedure trigger_notice_ab();
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_3 (b text, a int) partition by range (length(b));
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_3_1 partition of parted_trigger_3 for values from (1) to (4);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trigger_3_2 partition of parted_trigger_3 for values from (4) to (8);
RESULT:
	postgres: None

-----------
QUERY:

alter table parted_trigger attach partition parted_trigger_3 for values from (2000) to (3000);
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trigger values (0, 'a'), (1000, 'c'), (2000, 'e'), (2001, 'eeee');
RESULT:
	postgres: None

-----------
QUERY:

update parted_trigger set a = a + 2;
RESULT:
	postgres: None

-----------
QUERY:
	-- no notices here
update parted_trigger set b = b || 'b';
RESULT:
	postgres: None

-----------
QUERY:
	-- all triggers should fire
drop table parted_trigger;
RESULT:
	postgres: None

-----------
QUERY:


drop function trigger_notice_ab();
RESULT:
	postgres: None

-----------
QUERY:


-- Make sure we don/* REPLACED */''t end up with unnecessary copies of triggers, when
-- cloning them.
create table trg_clone (a int) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table trg_clone1 partition of trg_clone for values from (0) to (1000);
RESULT:
	postgres: None

-----------
QUERY:

alter table trg_clone add constraint uniq unique (a) deferrable;
RESULT:
	postgres: None

-----------
QUERY:

create table trg_clone2 partition of trg_clone for values from (1000) to (2000);
RESULT:
	postgres: None

-----------
QUERY:

create table trg_clone3 partition of trg_clone for values from (2000) to (3000)
  partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table trg_clone_3_3 partition of trg_clone3 for values from (2000) to (2100);
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, count(*) from pg_trigger
  where tgrelid::regclass in ('trg_clone', 'trg_clone1', 'trg_clone2',
	'trg_clone3', 'trg_clone_3_3')
  group by tgrelid::regclass order by tgrelid::regclass;
RESULT:
	postgres: [('trg_clone', 1), ('trg_clone1', 1), ('trg_clone2', 1), ('trg_clone3', 1), ('trg_clone_3_3', 1)]

-----------
QUERY:

drop table trg_clone;
RESULT:
	postgres: None

-----------
QUERY:


-- Test the interaction between ALTER TABLE .. DISABLE TRIGGER and
-- both kinds of inheritance.  Historically, legacy inheritance has
-- not recursed to children, so that behavior is preserved.
create table parent (a int);
RESULT:
	postgres: None

-----------
QUERY:

create table child1 () inherits (parent);
RESULT:
	postgres: None

-----------
QUERY:

create function trig_nothing() returns trigger language plpgsql
  as $$ begin return null; end $$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger tg after insert on parent
  for each row execute function trig_nothing();
RESULT:
	postgres: None

-----------
QUERY:

create trigger tg after insert on child1
  for each row execute function trig_nothing();
RESULT:
	postgres: None

-----------
QUERY:

alter table parent disable trigger tg;
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, tgname, tgenabled from pg_trigger
  where tgrelid in ('parent'::regclass, 'child1'::regclass)
  order by tgrelid::regclass::text;
RESULT:
	postgres: [('child1', 'tg', 'O'), ('parent', 'tg', 'D')]

-----------
QUERY:

alter table only parent enable always trigger tg;
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, tgname, tgenabled from pg_trigger
  where tgrelid in ('parent'::regclass, 'child1'::regclass)
  order by tgrelid::regclass::text;
RESULT:
	postgres: [('child1', 'tg', 'O'), ('parent', 'tg', 'A')]

-----------
QUERY:

drop table parent, child1;
RESULT:
	postgres: None

-----------
QUERY:


create table parent (a int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table child1 partition of parent for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create trigger tg after insert on parent
  for each row execute procedure trig_nothing();
RESULT:
	postgres: None

-----------
QUERY:

create trigger tg_stmt after insert on parent
  for statement execute procedure trig_nothing();
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, tgname, tgenabled from pg_trigger
  where tgrelid in ('parent'::regclass, 'child1'::regclass)
  order by tgrelid::regclass::text, tgname;
RESULT:
	postgres: [('child1', 'tg', 'O'), ('parent', 'tg', 'O'), ('parent', 'tg_stmt', 'O')]

-----------
QUERY:

alter table only parent enable always trigger tg;
RESULT:
	postgres: None

-----------
QUERY:
	-- no recursion because ONLY
alter table parent enable always trigger tg_stmt;
RESULT:
	postgres: None

-----------
QUERY:
	-- no recursion because statement trigger
select tgrelid::regclass, tgname, tgenabled from pg_trigger
  where tgrelid in ('parent'::regclass, 'child1'::regclass)
  order by tgrelid::regclass::text, tgname;
RESULT:
	postgres: [('child1', 'tg', 'O'), ('parent', 'tg', 'A'), ('parent', 'tg_stmt', 'A')]

-----------
QUERY:

-- The following is a no-op for the parent trigger but not so
-- for the child trigger, so recursion should be applied.
alter table parent enable always trigger tg;
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, tgname, tgenabled from pg_trigger
  where tgrelid in ('parent'::regclass, 'child1'::regclass)
  order by tgrelid::regclass::text, tgname;
RESULT:
	postgres: [('child1', 'tg', 'A'), ('parent', 'tg', 'A'), ('parent', 'tg_stmt', 'A')]

-----------
QUERY:

-- This variant malfunctioned in some releases.
alter table parent disable trigger user;
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, tgname, tgenabled from pg_trigger
  where tgrelid in ('parent'::regclass, 'child1'::regclass)
  order by tgrelid::regclass::text, tgname;
RESULT:
	postgres: [('child1', 'tg', 'D'), ('parent', 'tg', 'D'), ('parent', 'tg_stmt', 'D')]

-----------
QUERY:

drop table parent, child1;
RESULT:
	postgres: None

-----------
QUERY:


-- Check processing of foreign key triggers
create table parent (a int primary key, f int references parent)
  partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table child1 partition of parent for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, rtrim(tgname, '0123456789') as tgname,
  tgfoid::regproc, tgenabled
  from pg_trigger where tgrelid in ('parent'::regclass, 'child1'::regclass)
  order by tgrelid::regclass::text, tgfoid;
RESULT:
	postgres: [('child1', 'RI_ConstraintTrigger_c_', '"RI_FKey_check_ins"', 'O'), ('child1', 'RI_ConstraintTrigger_c_', '"RI_FKey_check_upd"', 'O'), ('parent', 'RI_ConstraintTrigger_c_', '"RI_FKey_check_ins"', 'O'), ('parent', 'RI_ConstraintTrigger_c_', '"RI_FKey_check_upd"', 'O'), ('parent', 'RI_ConstraintTrigger_a_', '"RI_FKey_noaction_del"', 'O'), ('parent', 'RI_ConstraintTrigger_a_', '"RI_FKey_noaction_upd"', 'O')]

-----------
QUERY:

alter table parent disable trigger all;
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, rtrim(tgname, '0123456789') as tgname,
  tgfoid::regproc, tgenabled
  from pg_trigger where tgrelid in ('parent'::regclass, 'child1'::regclass)
  order by tgrelid::regclass::text, tgfoid;
RESULT:
	postgres: [('child1', 'RI_ConstraintTrigger_c_', '"RI_FKey_check_ins"', 'D'), ('child1', 'RI_ConstraintTrigger_c_', '"RI_FKey_check_upd"', 'D'), ('parent', 'RI_ConstraintTrigger_c_', '"RI_FKey_check_ins"', 'D'), ('parent', 'RI_ConstraintTrigger_c_', '"RI_FKey_check_upd"', 'D'), ('parent', 'RI_ConstraintTrigger_a_', '"RI_FKey_noaction_del"', 'D'), ('parent', 'RI_ConstraintTrigger_a_', '"RI_FKey_noaction_upd"', 'D')]

-----------
QUERY:

drop table parent, child1;
RESULT:
	postgres: None

-----------
QUERY:


-- Verify that firing state propagates correctly on creation, too
CREATE TABLE trgfire (i int) PARTITION BY RANGE (i);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trgfire1 PARTITION OF trgfire FOR VALUES FROM (1) TO (10);
RESULT:
	postgres: None

-----------
QUERY:

CREATE OR REPLACE FUNCTION tgf() RETURNS trigger LANGUAGE plpgsql
  AS $$ begin raise exception 'except'; end $$;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TRIGGER tg AFTER INSERT ON trgfire FOR EACH ROW EXECUTE FUNCTION tgf();
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trgfire VALUES (1);
RESULT:
	postgres: except
CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE


-----------
QUERY:

ALTER TABLE trgfire DISABLE TRIGGER tg;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trgfire VALUES (1);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trgfire2 PARTITION OF trgfire FOR VALUES FROM (10) TO (20);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trgfire VALUES (11);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trgfire3 (LIKE trgfire);
RESULT:
	postgres: None

-----------
QUERY:

ALTER TABLE trgfire ATTACH PARTITION trgfire3 FOR VALUES FROM (20) TO (30);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trgfire VALUES (21);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trgfire4 PARTITION OF trgfire FOR VALUES FROM (30) TO (40) PARTITION BY LIST (i);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trgfire4_30 PARTITION OF trgfire4 FOR VALUES IN (30);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trgfire VALUES (30);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trgfire5 (LIKE trgfire) PARTITION BY LIST (i);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE trgfire5_40 PARTITION OF trgfire5 FOR VALUES IN (40);
RESULT:
	postgres: None

-----------
QUERY:

ALTER TABLE trgfire ATTACH PARTITION trgfire5 FOR VALUES FROM (40) TO (50);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trgfire VALUES (40);
RESULT:
	postgres: None

-----------
QUERY:

SELECT tgrelid::regclass, tgenabled FROM pg_trigger
  WHERE tgrelid::regclass IN (SELECT oid from pg_class where relname LIKE 'trgfire%')
  ORDER BY tgrelid::regclass::text;
RESULT:
	postgres: [('trgfire', 'D'), ('trgfire1', 'D'), ('trgfire2', 'D'), ('trgfire3', 'D'), ('trgfire4', 'D'), ('trgfire4_30', 'D'), ('trgfire5', 'D'), ('trgfire5_40', 'D')]

-----------
QUERY:

ALTER TABLE trgfire ENABLE TRIGGER tg;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO trgfire VALUES (1);
RESULT:
	postgres: except
CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE


-----------
QUERY:

INSERT INTO trgfire VALUES (11);
RESULT:
	postgres: except
CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE


-----------
QUERY:

INSERT INTO trgfire VALUES (21);
RESULT:
	postgres: except
CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE


-----------
QUERY:

INSERT INTO trgfire VALUES (30);
RESULT:
	postgres: except
CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE


-----------
QUERY:

INSERT INTO trgfire VALUES (40);
RESULT:
	postgres: except
CONTEXT:  PL/pgSQL function tgf() line 1 at RAISE


-----------
QUERY:

DROP TABLE trgfire;
RESULT:
	postgres: None

-----------
QUERY:

DROP FUNCTION tgf();
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test the interaction between transition tables and both kinds of
-- inheritance.  We/* REPLACED */''ll dump the contents of the transition tables in a
-- format that shows the attribute order, so that we can distinguish
-- tuple formats (though not dropped attributes).
--

create or replace function dump_insert() returns trigger language plpgsql as
$$
  begin
    raise notice 'trigger = %, new table = %',
                 TG_NAME,
                 (select string_agg(new_table::text, ', ' order by a) from new_table);
    return null;
  end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


create or replace function dump_update() returns trigger language plpgsql as
$$
  begin
    raise notice 'trigger = %, old table = %, new table = %',
                 TG_NAME,
                 (select string_agg(old_table::text, ', ' order by a) from old_table),
                 (select string_agg(new_table::text, ', ' order by a) from new_table);
    return null;
  end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


create or replace function dump_delete() returns trigger language plpgsql as
$$
  begin
    raise notice 'trigger = %, old table = %',
                 TG_NAME,
                 (select string_agg(old_table::text, ', ' order by a) from old_table);
    return null;
  end;
$$;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Verify behavior of statement triggers on partition hierarchy with
-- transition tables.  Tuples should appear to each trigger in the
-- format of the relation the trigger is attached to.
--

-- set up a partition hierarchy with some different TupleDescriptors
create table parent (a text, b int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:


-- a child matching parent
create table child1 partition of parent for values in ('AAA');
RESULT:
	postgres: None

-----------
QUERY:


-- a child with a dropped column
create table child2 (x int, a text, b int);
RESULT:
	postgres: None

-----------
QUERY:

alter table child2 drop column x;
RESULT:
	postgres: None

-----------
QUERY:

alter table parent attach partition child2 for values in ('BBB');
RESULT:
	postgres: None

-----------
QUERY:


-- a child with a different column order
create table child3 (b int, a text);
RESULT:
	postgres: None

-----------
QUERY:

alter table parent attach partition child3 for values in ('CCC');
RESULT:
	postgres: None

-----------
QUERY:


create trigger parent_insert_trig
  after insert on parent referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger parent_update_trig
  after update on parent referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:

create trigger parent_delete_trig
  after delete on parent referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


create trigger child1_insert_trig
  after insert on child1 referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child1_update_trig
  after update on child1 referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child1_delete_trig
  after delete on child1 referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


create trigger child2_insert_trig
  after insert on child2 referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child2_update_trig
  after update on child2 referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child2_delete_trig
  after delete on child2 referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


create trigger child3_insert_trig
  after insert on child3 referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child3_update_trig
  after update on child3 referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child3_delete_trig
  after delete on child3 referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


SELECT trigger_name, event_manipulation, event_object_schema, event_object_table,
       action_order, action_condition, action_orientation, action_timing,
       action_reference_old_table, action_reference_new_table
  FROM information_schema.triggers
  WHERE event_object_table IN ('parent', 'child1', 'child2', 'child3')
  ORDER BY trigger_name COLLATE "C", 2;
RESULT:
	postgres: [('child1_delete_trig', 'DELETE', 'public', 'child1', 1, None, 'STATEMENT', 'AFTER', 'old_table', None), ('child1_insert_trig', 'INSERT', 'public', 'child1', 1, None, 'STATEMENT', 'AFTER', None, 'new_table'), ('child1_update_trig', 'UPDATE', 'public', 'child1', 1, None, 'STATEMENT', 'AFTER', 'old_table', 'new_table'), ('child2_delete_trig', 'DELETE', 'public', 'child2', 1, None, 'STATEMENT', 'AFTER', 'old_table', None), ('child2_insert_trig', 'INSERT', 'public', 'child2', 1, None, 'STATEMENT', 'AFTER', None, 'new_table'), ('child2_update_trig', 'UPDATE', 'public', 'child2', 1, None, 'STATEMENT', 'AFTER', 'old_table', 'new_table'), ('child3_delete_trig', 'DELETE', 'public', 'child3', 1, None, 'STATEMENT', 'AFTER', 'old_table', None), ('child3_insert_trig', 'INSERT', 'public', 'child3', 1, None, 'STATEMENT', 'AFTER', None, 'new_table'), ('child3_update_trig', 'UPDATE', 'public', 'child3', 1, None, 'STATEMENT', 'AFTER', 'old_table', 'new_table'), ('parent_delete_trig', 'DELETE', 'public', 'parent', 1, None, 'STATEMENT', 'AFTER', 'old_table', None), ('parent_insert_trig', 'INSERT', 'public', 'parent', 1, None, 'STATEMENT', 'AFTER', None, 'new_table'), ('parent_update_trig', 'UPDATE', 'public', 'parent', 1, None, 'STATEMENT', 'AFTER', 'old_table', 'new_table')]

-----------
QUERY:


-- insert directly into children sees respective child-format tuples
insert into child1 values ('AAA', 42);
RESULT:
	postgres: None

-----------
QUERY:

insert into child2 values ('BBB', 42);
RESULT:
	postgres: None

-----------
QUERY:

insert into child3 values (42, 'CCC');
RESULT:
	postgres: None

-----------
QUERY:


-- update via parent sees parent-format tuples
update parent set b = b + 1;
RESULT:
	postgres: None

-----------
QUERY:


-- delete via parent sees parent-format tuples
delete from parent;
RESULT:
	postgres: None

-----------
QUERY:


-- insert into parent sees parent-format tuples
insert into parent values ('AAA', 42);
RESULT:
	postgres: None

-----------
QUERY:

insert into parent values ('BBB', 42);
RESULT:
	postgres: None

-----------
QUERY:

insert into parent values ('CCC', 42);
RESULT:
	postgres: None

-----------
QUERY:


-- delete from children sees respective child-format tuples
delete from child1;
RESULT:
	postgres: None

-----------
QUERY:

delete from child2;
RESULT:
	postgres: None

-----------
QUERY:

delete from child3;
RESULT:
	postgres: None

-----------
QUERY:


-- copy into parent sees parent-format tuples
copy parent (a, b) from stdin;
RESULT:
	postgres: can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

AAA	42
BBB	42
CCC	42
\.

-- DML affecting parent sees tuples collected from children even if
-- there is no transition table trigger on the children
drop trigger child1_insert_trig on child1;
RESULT:
	postgres: syntax error at or near "AAA"
LINE 2: AAA 42
        ^


-----------
QUERY:

drop trigger child1_update_trig on child1;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child1_delete_trig on child1;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child2_insert_trig on child2;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child2_update_trig on child2;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child2_delete_trig on child2;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child3_insert_trig on child3;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child3_update_trig on child3;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child3_delete_trig on child3;
RESULT:
	postgres: None

-----------
QUERY:

delete from parent;
RESULT:
	postgres: None

-----------
QUERY:


-- copy into parent sees tuples collected from children even if there
-- is no transition-table trigger on the children
copy parent (a, b) from stdin;
RESULT:
	postgres: can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

AAA	42
BBB	42
CCC	42
\.

-- insert into parent with a before trigger on a child tuple before
-- insertion, and we capture the newly modified row in parent format
create or replace function intercept_insert() returns trigger language plpgsql as
$$
  begin
    new.b = new.b + 1000;
    return new;
  end;
$$;
RESULT:
	postgres: syntax error at or near "AAA"
LINE 2: AAA 42
        ^


-----------
QUERY:


create trigger intercept_insert_child3
  before insert on child3
  for each row execute procedure intercept_insert();
RESULT:
	postgres: function intercept_insert() does not exist


-----------
QUERY:



-- insert, parent trigger sees post-modification parent-format tuple
insert into parent values ('AAA', 42), ('BBB', 42), ('CCC', 66);
RESULT:
	postgres: None

-----------
QUERY:


-- copy, parent trigger sees post-modification parent-format tuple
copy parent (a, b) from stdin;
RESULT:
	postgres: can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

AAA	42
BBB	42
CCC	234
\.

drop table child1, child2, child3, parent;
RESULT:
	postgres: syntax error at or near "AAA"
LINE 2: AAA 42
        ^


-----------
QUERY:

drop function intercept_insert();
RESULT:
	postgres: function intercept_insert() does not exist


-----------
QUERY:


--
-- Verify prohibition of row triggers with transition triggers on
-- partitions
--
create table parent (a text, b int) partition by list (a);
RESULT:
	postgres: relation "parent" already exists


-----------
QUERY:

create table child partition of parent for values in ('AAA');
RESULT:
	postgres: partition "child" would overlap partition "child1"
LINE 2: ...reate table child partition of parent for values in ('AAA');
                                                                ^


-----------
QUERY:


-- adding row trigger with transition table fails
create trigger child_row_trig
  after insert on child referencing new table as new_table
  for each row execute procedure dump_insert();
RESULT:
	postgres: relation "child" does not exist


-----------
QUERY:


-- detaching it first works
alter table parent detach partition child;
RESULT:
	postgres: relation "child" does not exist


-----------
QUERY:


create trigger child_row_trig
  after insert on child referencing new table as new_table
  for each row execute procedure dump_insert();
RESULT:
	postgres: relation "child" does not exist


-----------
QUERY:


-- but now we/* REPLACED */''re not allowed to reattach it
alter table parent attach partition child for values in ('AAA');
RESULT:
	postgres: relation "child" does not exist


-----------
QUERY:


-- drop the trigger, and now we/* REPLACED */''re allowed to attach it again
drop trigger child_row_trig on child;
RESULT:
	postgres: relation "child" does not exist


-----------
QUERY:

alter table parent attach partition child for values in ('AAA');
RESULT:
	postgres: relation "child" does not exist


-----------
QUERY:


drop table child, parent;
RESULT:
	postgres: table "child" does not exist


-----------
QUERY:


--
-- Verify behavior of statement triggers on (non-partition)
-- inheritance hierarchy with transition tables /* REPLACED */, similar to the
-- partition case, except there is no rerouting on insertion and child
-- tables can have extra columns
--

-- set up inheritance hierarchy with different TupleDescriptors
create table parent (a text, b int);
RESULT:
	postgres: relation "parent" already exists


-----------
QUERY:


-- a child matching parent
create table child1 () inherits (parent);
RESULT:
	postgres: cannot inherit from partitioned table "parent"


-----------
QUERY:


-- a child with a different column order
create table child2 (b int, a text);
RESULT:
	postgres: relation "child2" already exists


-----------
QUERY:

alter table child2 inherit parent;
RESULT:
	postgres: cannot change inheritance of a partition


-----------
QUERY:


-- a child with an extra column
create table child3 (c text) inherits (parent);
RESULT:
	postgres: cannot inherit from partitioned table "parent"


-----------
QUERY:


create trigger parent_insert_trig
  after insert on parent referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: trigger "parent_insert_trig" for relation "parent" already exists


-----------
QUERY:

create trigger parent_update_trig
  after update on parent referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: trigger "parent_update_trig" for relation "parent" already exists


-----------
QUERY:

create trigger parent_delete_trig
  after delete on parent referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: trigger "parent_delete_trig" for relation "parent" already exists


-----------
QUERY:


create trigger child1_insert_trig
  after insert on child1 referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: trigger "child1_insert_trig" for relation "child1" already exists


-----------
QUERY:

create trigger child1_update_trig
  after update on child1 referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child1_delete_trig
  after delete on child1 referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


create trigger child2_insert_trig
  after insert on child2 referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child2_update_trig
  after update on child2 referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child2_delete_trig
  after delete on child2 referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


create trigger child3_insert_trig
  after insert on child3 referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child3_update_trig
  after update on child3 referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:

create trigger child3_delete_trig
  after delete on child3 referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


-- insert directly into children sees respective child-format tuples
insert into child1 values ('AAA', 42);
RESULT:
	postgres: None

-----------
QUERY:

insert into child2 values (42, 'BBB');
RESULT:
	postgres: invalid input syntax for type integer: "BBB"
LINE 2: insert into child2 values (42, 'BBB');
                                       ^


-----------
QUERY:

insert into child3 values ('CCC', 42, 'foo');
RESULT:
	postgres: INSERT has more expressions than target columns
LINE 2: insert into child3 values ('CCC', 42, 'foo');
                                              ^


-----------
QUERY:


-- update via parent sees parent-format tuples
update parent set b = b + 1;
RESULT:
	postgres: None

-----------
QUERY:


-- delete via parent sees parent-format tuples
delete from parent;
RESULT:
	postgres: None

-----------
QUERY:


-- reinsert values into children for next test...
insert into child1 values ('AAA', 42);
RESULT:
	postgres: None

-----------
QUERY:

insert into child2 values (42, 'BBB');
RESULT:
	postgres: invalid input syntax for type integer: "BBB"
LINE 2: insert into child2 values (42, 'BBB');
                                       ^


-----------
QUERY:

insert into child3 values ('CCC', 42, 'foo');
RESULT:
	postgres: INSERT has more expressions than target columns
LINE 2: insert into child3 values ('CCC', 42, 'foo');
                                              ^


-----------
QUERY:


-- delete from children sees respective child-format tuples
delete from child1;
RESULT:
	postgres: None

-----------
QUERY:

delete from child2;
RESULT:
	postgres: None

-----------
QUERY:

delete from child3;
RESULT:
	postgres: None

-----------
QUERY:


-- copy into parent sees parent-format tuples (no rerouting, so these
-- are really inserted into the parent)
copy parent (a, b) from stdin;
RESULT:
	postgres: can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

AAA	42
BBB	42
CCC	42
\.

-- same behavior for copy if there is an index (interesting because rows are
-- captured by a different code path in copyfrom.c if there are indexes)
create index on parent(b);
RESULT:
	postgres: syntax error at or near "AAA"
LINE 2: AAA 42
        ^


-----------
QUERY:

copy parent (a, b) from stdin;
RESULT:
	postgres: can't execute COPY FROM: use the copy_from() method instead

-----------
QUERY:

DDD	42
\.

-- DML affecting parent sees tuples collected from children even if
-- there is no transition table trigger on the children
drop trigger child1_insert_trig on child1;
RESULT:
	postgres: syntax error at or near "DDD"
LINE 2: DDD 42
        ^


-----------
QUERY:

drop trigger child1_update_trig on child1;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child1_delete_trig on child1;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child2_insert_trig on child2;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child2_update_trig on child2;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child2_delete_trig on child2;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child3_insert_trig on child3;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child3_update_trig on child3;
RESULT:
	postgres: None

-----------
QUERY:

drop trigger child3_delete_trig on child3;
RESULT:
	postgres: None

-----------
QUERY:

delete from parent;
RESULT:
	postgres: None

-----------
QUERY:


drop table child1, child2, child3, parent;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Verify prohibition of row triggers with transition triggers on
-- inheritance children
--
create table parent (a text, b int);
RESULT:
	postgres: None

-----------
QUERY:

create table child () inherits (parent);
RESULT:
	postgres: None

-----------
QUERY:


-- adding row trigger with transition table fails
create trigger child_row_trig
  after insert on child referencing new table as new_table
  for each row execute procedure dump_insert();
RESULT:
	postgres: ROW triggers with transition tables are not supported on inheritance children


-----------
QUERY:


-- disinheriting it first works
alter table child no inherit parent;
RESULT:
	postgres: None

-----------
QUERY:


create trigger child_row_trig
  after insert on child referencing new table as new_table
  for each row execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:


-- but now we/* REPLACED */''re not allowed to make it inherit anymore
alter table child inherit parent;
RESULT:
	postgres: trigger "child_row_trig" prevents table "child" from becoming an inheritance child
DETAIL:  ROW triggers with transition tables are not supported in inheritance hierarchies.


-----------
QUERY:


-- drop the trigger, and now we/* REPLACED */''re allowed to make it inherit again
drop trigger child_row_trig on child;
RESULT:
	postgres: None

-----------
QUERY:

alter table child inherit parent;
RESULT:
	postgres: None

-----------
QUERY:


drop table child, parent;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Verify behavior of queries with wCTEs, where multiple transition
-- tuplestores can be active at the same time because there are
-- multiple DML statements that might fire triggers with transition
-- tables
--
create table table1 (a int);
RESULT:
	postgres: None

-----------
QUERY:

create table table2 (a text);
RESULT:
	postgres: None

-----------
QUERY:

create trigger table1_trig
  after insert on table1 referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger table2_trig
  after insert on table2 referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:


with wcte as (insert into table1 values (42))
  insert into table2 values ('hello world');
RESULT:
	postgres: None

-----------
QUERY:


with wcte as (insert into table1 values (43))
  insert into table1 values (44);
RESULT:
	postgres: None

-----------
QUERY:


select * from table1;
RESULT:
	postgres: [(42,), (44,), (43,)]

-----------
QUERY:

select * from table2;
RESULT:
	postgres: [('hello world',)]

-----------
QUERY:


drop table table1;
RESULT:
	postgres: None

-----------
QUERY:

drop table table2;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Verify behavior of INSERT ... ON CONFLICT DO UPDATE ... with
-- transition tables.
--

create table my_table (a int primary key, b text);
RESULT:
	postgres: None

-----------
QUERY:

create trigger my_table_insert_trig
  after insert on my_table referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger my_table_update_trig
  after update on my_table referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:


-- inserts only
insert into my_table values (1, 'AAA'), (2, 'BBB')
  on conflict (a) do
  update set b = my_table.b || ':' || excluded.b;
RESULT:
	postgres: None

-----------
QUERY:


-- mixture of inserts and updates
insert into my_table values (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD')
  on conflict (a) do
  update set b = my_table.b || ':' || excluded.b;
RESULT:
	postgres: None

-----------
QUERY:


-- updates only
insert into my_table values (3, 'CCC'), (4, 'DDD')
  on conflict (a) do
  update set b = my_table.b || ':' || excluded.b;
RESULT:
	postgres: None

-----------
QUERY:


--
-- now using a partitioned table
--

create table iocdu_tt_parted (a int primary key, b text) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table iocdu_tt_parted1 partition of iocdu_tt_parted for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create table iocdu_tt_parted2 partition of iocdu_tt_parted for values in (2);
RESULT:
	postgres: None

-----------
QUERY:

create table iocdu_tt_parted3 partition of iocdu_tt_parted for values in (3);
RESULT:
	postgres: None

-----------
QUERY:

create table iocdu_tt_parted4 partition of iocdu_tt_parted for values in (4);
RESULT:
	postgres: None

-----------
QUERY:

create trigger iocdu_tt_parted_insert_trig
  after insert on iocdu_tt_parted referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger iocdu_tt_parted_update_trig
  after update on iocdu_tt_parted referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:


-- inserts only
insert into iocdu_tt_parted values (1, 'AAA'), (2, 'BBB')
  on conflict (a) do
  update set b = iocdu_tt_parted.b || ':' || excluded.b;
RESULT:
	postgres: None

-----------
QUERY:


-- mixture of inserts and updates
insert into iocdu_tt_parted values (1, 'AAA'), (2, 'BBB'), (3, 'CCC'), (4, 'DDD')
  on conflict (a) do
  update set b = iocdu_tt_parted.b || ':' || excluded.b;
RESULT:
	postgres: None

-----------
QUERY:


-- updates only
insert into iocdu_tt_parted values (3, 'CCC'), (4, 'DDD')
  on conflict (a) do
  update set b = iocdu_tt_parted.b || ':' || excluded.b;
RESULT:
	postgres: None

-----------
QUERY:


drop table iocdu_tt_parted;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Verify that you can/* REPLACED */''t create a trigger with transition tables for
-- more than one event.
--

create trigger my_table_multievent_trig
  after insert or update on my_table referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: transition tables cannot be specified for triggers with more than one event


-----------
QUERY:


--
-- Verify that you can/* REPLACED */''t create a trigger with transition tables with
-- a column list.
--

create trigger my_table_col_update_trig
  after update of b on my_table referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: transition tables cannot be specified for triggers with column lists


-----------
QUERY:


drop table my_table;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test firing of triggers with transition tables by foreign key cascades
--

create table refd_table (a int primary key, b text);
RESULT:
	postgres: None

-----------
QUERY:

create table trig_table (a int, b text,
  foreign key (a) references refd_table on update cascade on delete cascade
);
RESULT:
	postgres: None

-----------
QUERY:


create trigger trig_table_before_trig
  before insert or update or delete on trig_table
  for each statement execute procedure trigger_func('trig_table');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

create trigger trig_table_insert_trig
  after insert on trig_table referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_table_update_trig
  after update on trig_table referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:

create trigger trig_table_delete_trig
  after delete on trig_table referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


insert into refd_table values
  (1, 'one'),
  (2, 'two'),
  (3, 'three');
RESULT:
	postgres: None

-----------
QUERY:

insert into trig_table values
  (1, 'one a'),
  (1, 'one b'),
  (2, 'two a'),
  (2, 'two b'),
  (3, 'three a'),
  (3, 'three b');
RESULT:
	postgres: None

-----------
QUERY:


update refd_table set a = 11 where b = 'one';
RESULT:
	postgres: None

-----------
QUERY:


select * from trig_table;
RESULT:
	postgres: [(2, 'two a'), (2, 'two b'), (3, 'three a'), (3, 'three b'), (11, 'one a'), (11, 'one b')]

-----------
QUERY:


delete from refd_table where length(b) = 3;
RESULT:
	postgres: None

-----------
QUERY:


select * from trig_table;
RESULT:
	postgres: [(3, 'three a'), (3, 'three b')]

-----------
QUERY:


drop table refd_table, trig_table;
RESULT:
	postgres: None

-----------
QUERY:


--
-- self-referential FKs are even more fun
--

create table self_ref (a int primary key,
                       b int references self_ref(a) on delete cascade);
RESULT:
	postgres: None

-----------
QUERY:


create trigger self_ref_before_trig
  before delete on self_ref
  for each statement execute procedure trigger_func('self_ref');
RESULT:
	postgres: function trigger_func() does not exist


-----------
QUERY:

create trigger self_ref_r_trig
  after delete on self_ref referencing old table as old_table
  for each row execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:

create trigger self_ref_s_trig
  after delete on self_ref referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


insert into self_ref values (1, null), (2, 1), (3, 2);
RESULT:
	postgres: None

-----------
QUERY:


delete from self_ref where a = 1;
RESULT:
	postgres: None

-----------
QUERY:


-- without AR trigger, cascaded deletes all end up in one transition table
drop trigger self_ref_r_trig on self_ref;
RESULT:
	postgres: None

-----------
QUERY:


insert into self_ref values (1, null), (2, 1), (3, 2), (4, 3);
RESULT:
	postgres: None

-----------
QUERY:


delete from self_ref where a = 1;
RESULT:
	postgres: None

-----------
QUERY:


drop table self_ref;
RESULT:
	postgres: None

-----------
QUERY:


--
-- test transition tables with MERGE
--
create table merge_target_table (a int primary key, b text);
RESULT:
	postgres: None

-----------
QUERY:

create trigger merge_target_table_insert_trig
  after insert on merge_target_table referencing new table as new_table
  for each statement execute procedure dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

create trigger merge_target_table_update_trig
  after update on merge_target_table referencing old table as old_table new table as new_table
  for each statement execute procedure dump_update();
RESULT:
	postgres: None

-----------
QUERY:

create trigger merge_target_table_delete_trig
  after delete on merge_target_table referencing old table as old_table
  for each statement execute procedure dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


create table merge_source_table (a int, b text);
RESULT:
	postgres: None

-----------
QUERY:

insert into merge_source_table
  values (1, 'initial1'), (2, 'initial2'),
		 (3, 'initial3'), (4, 'initial4');
RESULT:
	postgres: None

-----------
QUERY:


merge into merge_target_table t
using merge_source_table s
on t.a = s.a
when not matched then
  insert values (a, b);
RESULT:
	postgres: None

-----------
QUERY:


merge into merge_target_table t
using merge_source_table s
on t.a = s.a
when matched and s.a <= 2 then
	update set b = t.b || ' updated by merge'
when matched and s.a > 2 then
	delete
when not matched then
  insert values (a, b);
RESULT:
	postgres: None

-----------
QUERY:


merge into merge_target_table t
using merge_source_table s
on t.a = s.a
when matched and s.a <= 2 then
	update set b = t.b || ' updated again by merge'
when matched and s.a > 2 then
	delete
when not matched then
  insert values (a, b);
RESULT:
	postgres: None

-----------
QUERY:


drop table merge_source_table, merge_target_table;
RESULT:
	postgres: None

-----------
QUERY:


-- cleanup
drop function dump_insert();
RESULT:
	postgres: None

-----------
QUERY:

drop function dump_update();
RESULT:
	postgres: None

-----------
QUERY:

drop function dump_delete();
RESULT:
	postgres: None

-----------
QUERY:


--
-- Tests for CREATE OR REPLACE TRIGGER
--
create table my_table (id integer);
RESULT:
	postgres: None

-----------
QUERY:


create function funcA() returns trigger as $$
begin
  raise notice 'hello from funcA';
  return null;
end; $$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


create function funcB() returns trigger as $$
begin
  raise notice 'hello from funcB';
  return null;
end; $$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


create trigger my_trig
  after insert on my_table
  for each row execute procedure funcA();
RESULT:
	postgres: None

-----------
QUERY:


create trigger my_trig
  before insert on my_table
  for each row execute procedure funcB();
RESULT:
	postgres: trigger "my_trig" for relation "my_table" already exists


-----------
QUERY:
  -- should fail

insert into my_table values (1);
RESULT:
	postgres: None

-----------
QUERY:


create or replace trigger my_trig
  before insert on my_table
  for each row execute procedure funcB();
RESULT:
	postgres: None

-----------
QUERY:
  -- OK

insert into my_table values (2);
RESULT:
	postgres: None

-----------
QUERY:
  -- this insert should become a no-op

table my_table;
RESULT:
	postgres: [(1,)]

-----------
QUERY:


drop table my_table;
RESULT:
	postgres: None

-----------
QUERY:


-- test CREATE OR REPLACE TRIGGER on partition table
create table parted_trig (a int) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trig_1 partition of parted_trig
       for values from (0) to (1000) partition by range (a);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trig_1_1 partition of parted_trig_1 for values from (0) to (100);
RESULT:
	postgres: None

-----------
QUERY:

create table parted_trig_2 partition of parted_trig for values from (1000) to (2000);
RESULT:
	postgres: None

-----------
QUERY:

create table default_parted_trig partition of parted_trig default;
RESULT:
	postgres: None

-----------
QUERY:


-- test that trigger can be replaced by another one
-- at the same level of partition table
create or replace trigger my_trig
  after insert on parted_trig
  for each row execute procedure funcA();
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trig (a) values (50);
RESULT:
	postgres: None

-----------
QUERY:

create or replace trigger my_trig
  after insert on parted_trig
  for each row execute procedure funcB();
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trig (a) values (50);
RESULT:
	postgres: None

-----------
QUERY:


-- test that child trigger cannot be replaced directly
create or replace trigger my_trig
  after insert on parted_trig
  for each row execute procedure funcA();
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trig (a) values (50);
RESULT:
	postgres: None

-----------
QUERY:

create or replace trigger my_trig
  after insert on parted_trig_1
  for each row execute procedure funcB();
RESULT:
	postgres: trigger "my_trig" for relation "parted_trig_1" is an internal or a child trigger


-----------
QUERY:
  -- should fail
insert into parted_trig (a) values (50);
RESULT:
	postgres: None

-----------
QUERY:

drop trigger my_trig on parted_trig;
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trig (a) values (50);
RESULT:
	postgres: None

-----------
QUERY:


-- test that user trigger can be overwritten by one defined at upper level
create trigger my_trig
  after insert on parted_trig_1
  for each row execute procedure funcA();
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trig (a) values (50);
RESULT:
	postgres: None

-----------
QUERY:

create trigger my_trig
  after insert on parted_trig
  for each row execute procedure funcB();
RESULT:
	postgres: trigger "my_trig" for relation "parted_trig_1" already exists


-----------
QUERY:
  -- should fail
insert into parted_trig (a) values (50);
RESULT:
	postgres: None

-----------
QUERY:

create or replace trigger my_trig
  after insert on parted_trig
  for each row execute procedure funcB();
RESULT:
	postgres: None

-----------
QUERY:

insert into parted_trig (a) values (50);
RESULT:
	postgres: None

-----------
QUERY:


-- cleanup
drop table parted_trig;
RESULT:
	postgres: None

-----------
QUERY:

drop function funcA();
RESULT:
	postgres: None

-----------
QUERY:

drop function funcB();
RESULT:
	postgres: None

-----------
QUERY:


-- Leave around some objects for other tests
create table trigger_parted (a int primary key) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create function trigger_parted_trigfunc() returns trigger language plpgsql as
  $$ begin end; $$;
RESULT:
	postgres: None

-----------
QUERY:

create trigger aft_row after insert or update on trigger_parted
  for each row execute function trigger_parted_trigfunc();
RESULT:
	postgres: None

-----------
QUERY:

create table trigger_parted_p1 partition of trigger_parted for values in (1)
  partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table trigger_parted_p1_1 partition of trigger_parted_p1 for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create table trigger_parted_p2 partition of trigger_parted for values in (2)
  partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table trigger_parted_p2_2 partition of trigger_parted_p2 for values in (2);
RESULT:
	postgres: None

-----------
QUERY:

alter table only trigger_parted_p2 disable trigger aft_row;
RESULT:
	postgres: None

-----------
QUERY:

alter table trigger_parted_p2_2 enable always trigger aft_row;
RESULT:
	postgres: None

-----------
QUERY:


-- verify transition table conversion slot/* REPLACED */''s lifetime
-- https://postgr.es/m/39a71864-b120-5a5c-8cc5-c632b6f16761@amazon.com
create table convslot_test_parent (col1 text primary key);
RESULT:
	postgres: None

-----------
QUERY:

create table convslot_test_child (col1 text primary key,
	foreign key (col1) references convslot_test_parent(col1) on delete cascade on update cascade
);
RESULT:
	postgres: None

-----------
QUERY:


alter table convslot_test_child add column col2 text not null default 'tutu';
RESULT:
	postgres: None

-----------
QUERY:

insert into convslot_test_parent(col1) values ('1');
RESULT:
	postgres: None

-----------
QUERY:

insert into convslot_test_child(col1) values ('1');
RESULT:
	postgres: None

-----------
QUERY:

insert into convslot_test_parent(col1) values ('3');
RESULT:
	postgres: None

-----------
QUERY:

insert into convslot_test_child(col1) values ('3');
RESULT:
	postgres: None

-----------
QUERY:


create function convslot_trig1()
returns trigger
language plpgsql
AS $$
begin
raise notice 'trigger = %, old_table = %',
          TG_NAME,
          (select string_agg(old_table::text, ', ' order by col1) from old_table);
return null;
end; $$;
RESULT:
	postgres: None

-----------
QUERY:


create function convslot_trig2()
returns trigger
language plpgsql
AS $$
begin
raise notice 'trigger = %, new table = %',
          TG_NAME,
          (select string_agg(new_table::text, ', ' order by col1) from new_table);
return null;
end; $$;
RESULT:
	postgres: None

-----------
QUERY:


create trigger but_trigger after update on convslot_test_child
referencing new table as new_table
for each statement execute function convslot_trig2();
RESULT:
	postgres: None

-----------
QUERY:


update convslot_test_parent set col1 = col1 || '1';
RESULT:
	postgres: None

-----------
QUERY:


create function convslot_trig3()
returns trigger
language plpgsql
AS $$
begin
raise notice 'trigger = %, old_table = %, new table = %',
          TG_NAME,
          (select string_agg(old_table::text, ', ' order by col1) from old_table),
          (select string_agg(new_table::text, ', ' order by col1) from new_table);
return null;
end; $$;
RESULT:
	postgres: None

-----------
QUERY:


create trigger but_trigger2 after update on convslot_test_child
referencing old table as old_table new table as new_table
for each statement execute function convslot_trig3();
RESULT:
	postgres: None

-----------
QUERY:

update convslot_test_parent set col1 = col1 || '1';
RESULT:
	postgres: None

-----------
QUERY:


create trigger bdt_trigger after delete on convslot_test_child
referencing old table as old_table
for each statement execute function convslot_trig1();
RESULT:
	postgres: None

-----------
QUERY:

delete from convslot_test_parent;
RESULT:
	postgres: None

-----------
QUERY:


drop table convslot_test_child, convslot_test_parent;
RESULT:
	postgres: None

-----------
QUERY:

drop function convslot_trig1();
RESULT:
	postgres: None

-----------
QUERY:

drop function convslot_trig2();
RESULT:
	postgres: None

-----------
QUERY:

drop function convslot_trig3();
RESULT:
	postgres: None

-----------
QUERY:


-- Bug #17607: variant of above in which trigger function raises an error /* REPLACED */,
-- we don/* REPLACED */''t see any ill effects unless trigger tuple requires mapping

create table convslot_test_parent (id int primary key, val int)
partition by range (id);
RESULT:
	postgres: None

-----------
QUERY:


create table convslot_test_part (val int, id int not null);
RESULT:
	postgres: None

-----------
QUERY:


alter table convslot_test_parent
  attach partition convslot_test_part for values from (1) to (1000);
RESULT:
	postgres: None

-----------
QUERY:


create function convslot_trig4() returns trigger as
$$begin raise exception 'BOOM!'; end$$ language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


create trigger convslot_test_parent_update
    after update on convslot_test_parent
    referencing old table as old_rows new table as new_rows
    for each statement execute procedure convslot_trig4();
RESULT:
	postgres: None

-----------
QUERY:


insert into convslot_test_parent (id, val) values (1, 2);
RESULT:
	postgres: None

-----------
QUERY:


begin;
RESULT:
	postgres: None

-----------
QUERY:

savepoint svp;
RESULT:
	postgres: None

-----------
QUERY:

update convslot_test_parent set val = 3;
RESULT:
	postgres: BOOM!
CONTEXT:  PL/pgSQL function convslot_trig4() line 1 at RAISE


-----------
QUERY:
  -- error expected
rollback to savepoint svp;
RESULT:
	postgres: None

-----------
QUERY:

rollback;
RESULT:
	postgres: None

-----------
QUERY:


drop table convslot_test_parent;
RESULT:
	postgres: None

-----------
QUERY:

drop function convslot_trig4();
RESULT:
	postgres: None

-----------
QUERY:


-- Test trigger renaming on partitioned tables
create table grandparent (id int, primary key (id)) partition by range (id);
RESULT:
	postgres: None

-----------
QUERY:

create table middle partition of grandparent for values from (1) to (10)
partition by range (id);
RESULT:
	postgres: None

-----------
QUERY:

create table chi partition of middle for values from (1) to (5);
RESULT:
	postgres: None

-----------
QUERY:

create table cho partition of middle for values from (6) to (10);
RESULT:
	postgres: None

-----------
QUERY:

create function f () returns trigger as
$$ begin return new; end; $$
language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:

create trigger a after insert on grandparent
for each row execute procedure f();
RESULT:
	postgres: None

-----------
QUERY:


alter trigger a on grandparent rename to b;
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, tgname,
(select tgname from pg_trigger tr where tr.oid = pg_trigger.tgparentid) parent_tgname
from pg_trigger where tgrelid in (select relid from pg_partition_tree('grandparent'))
order by tgname, tgrelid::regclass::text COLLATE "C";
RESULT:
	postgres: [('chi', 'b', 'b'), ('cho', 'b', 'b'), ('grandparent', 'b', None), ('middle', 'b', 'b')]

-----------
QUERY:

alter trigger a on only grandparent rename to b;
RESULT:
	postgres: syntax error at or near "only"
LINE 2: alter trigger a on only grandparent rename to b;
                           ^


-----------
QUERY:
	-- ONLY not supported
alter trigger b on middle rename to c;
RESULT:
	postgres: cannot rename trigger "b" on table "middle"
HINT:  Rename the trigger on the partitioned table "grandparent" instead.


-----------
QUERY:
	-- can/* REPLACED */''t rename trigger on partition
create trigger c after insert on middle
for each row execute procedure f();
RESULT:
	postgres: None

-----------
QUERY:

alter trigger b on grandparent rename to c;
RESULT:
	postgres: trigger "c" for relation "middle" already exists


-----------
QUERY:


-- Rename cascading does not affect statement triggers
create trigger p after insert on grandparent for each statement execute function f();
RESULT:
	postgres: None

-----------
QUERY:

create trigger p after insert on middle for each statement execute function f();
RESULT:
	postgres: None

-----------
QUERY:

alter trigger p on grandparent rename to q;
RESULT:
	postgres: None

-----------
QUERY:

select tgrelid::regclass, tgname,
(select tgname from pg_trigger tr where tr.oid = pg_trigger.tgparentid) parent_tgname
from pg_trigger where tgrelid in (select relid from pg_partition_tree('grandparent'))
order by tgname, tgrelid::regclass::text COLLATE "C";
RESULT:
	postgres: [('chi', 'b', 'b'), ('cho', 'b', 'b'), ('grandparent', 'b', None), ('middle', 'b', 'b'), ('chi', 'c', 'c'), ('cho', 'c', 'c'), ('middle', 'c', None), ('middle', 'p', None), ('grandparent', 'q', None)]

-----------
QUERY:


drop table grandparent;
RESULT:
	postgres: None

-----------
QUERY:


-- Trigger renaming does not recurse on legacy inheritance
create table parent (a int);
RESULT:
	postgres: None

-----------
QUERY:

create table child () inherits (parent);
RESULT:
	postgres: None

-----------
QUERY:

create trigger parenttrig after insert on parent
for each row execute procedure f();
RESULT:
	postgres: None

-----------
QUERY:

create trigger parenttrig after insert on child
for each row execute procedure f();
RESULT:
	postgres: None

-----------
QUERY:

alter trigger parenttrig on parent rename to anothertrig;
RESULT:
	postgres: None

-----------
QUERY:

-- \d+ child

drop table parent, child;
RESULT:
	postgres: None

-----------
QUERY:

drop function f();
RESULT:
	postgres: None
