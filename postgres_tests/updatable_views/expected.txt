
-----------
QUERY:
--
-- UPDATABLE VIEWS
--

-- avoid bit-exact output here because operations may not be bit-exact.
SET extra_float_digits = 0;
RESULT:
	postgres: None

-----------
QUERY:


-- check that non-updatable views and columns are rejected with useful error
-- messages

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW ro_view1 AS SELECT DISTINCT a, b FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:
 -- DISTINCT not supported
CREATE VIEW ro_view2 AS SELECT a, b FROM base_tbl GROUP BY a, b;
RESULT:
	postgres: None

-----------
QUERY:
 -- GROUP BY not supported
CREATE VIEW ro_view3 AS SELECT 1 FROM base_tbl HAVING max(a) > 0;
RESULT:
	postgres: None

-----------
QUERY:
 -- HAVING not supported
CREATE VIEW ro_view4 AS SELECT count(*) FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:
 -- Aggregate functions not supported
CREATE VIEW ro_view5 AS SELECT a, rank() OVER() FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:
 -- Window functions not supported
CREATE VIEW ro_view6 AS SELECT a, b FROM base_tbl UNION SELECT -a, b FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:
 -- Set ops not supported
CREATE VIEW ro_view7 AS WITH t AS (SELECT a, b FROM base_tbl) SELECT * FROM t;
RESULT:
	postgres: None

-----------
QUERY:
 -- WITH not supported
CREATE VIEW ro_view8 AS SELECT a, b FROM base_tbl ORDER BY a OFFSET 1;
RESULT:
	postgres: None

-----------
QUERY:
 -- OFFSET not supported
CREATE VIEW ro_view9 AS SELECT a, b FROM base_tbl ORDER BY a LIMIT 1;
RESULT:
	postgres: None

-----------
QUERY:
 -- LIMIT not supported
CREATE VIEW ro_view10 AS SELECT 1 AS a;
RESULT:
	postgres: None

-----------
QUERY:
 -- No base relations
CREATE VIEW ro_view11 AS SELECT b1.a, b2.b FROM base_tbl b1, base_tbl b2;
RESULT:
	postgres: None

-----------
QUERY:
 -- Multiple base relations
CREATE VIEW ro_view12 AS SELECT * FROM generate_series(1, 10) AS g(a);
RESULT:
	postgres: None

-----------
QUERY:
 -- SRF in rangetable
CREATE VIEW ro_view13 AS SELECT a, b FROM (SELECT * FROM base_tbl) AS t;
RESULT:
	postgres: None

-----------
QUERY:
 -- Subselect in rangetable
CREATE VIEW rw_view14 AS SELECT ctid, a, b FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:
 -- System columns may be part of an updatable view
CREATE VIEW rw_view15 AS SELECT a, upper(b) FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:
 -- Expression/function may be part of an updatable view
CREATE VIEW rw_view16 AS SELECT a, b, a AS aa FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:
 -- Repeated column may be part of an updatable view
CREATE VIEW ro_view17 AS SELECT * FROM ro_view1;
RESULT:
	postgres: None

-----------
QUERY:
 -- Base relation not updatable
CREATE VIEW ro_view18 AS SELECT * FROM (VALUES(1)) AS tmp(a);
RESULT:
	postgres: None

-----------
QUERY:
 -- VALUES in rangetable
CREATE SEQUENCE uv_seq;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW ro_view19 AS SELECT * FROM uv_seq;
RESULT:
	postgres: None

-----------
QUERY:
 -- View based on a sequence
CREATE VIEW ro_view20 AS SELECT a, b, generate_series(1, a) g FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:
 -- SRF in targetlist not supported

SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('ro_view1', 'NO'), ('ro_view10', 'NO'), ('ro_view11', 'NO'), ('ro_view12', 'NO'), ('ro_view13', 'NO'), ('ro_view17', 'NO'), ('ro_view18', 'NO'), ('ro_view19', 'NO'), ('ro_view2', 'NO'), ('ro_view20', 'NO'), ('ro_view3', 'NO'), ('ro_view4', 'NO'), ('ro_view5', 'NO'), ('ro_view6', 'NO'), ('ro_view7', 'NO'), ('ro_view8', 'NO'), ('ro_view9', 'NO'), ('rw_view14', 'YES'), ('rw_view15', 'YES'), ('rw_view16', 'YES')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('ro_view1', 'NO', 'NO'), ('ro_view10', 'NO', 'NO'), ('ro_view11', 'NO', 'NO'), ('ro_view12', 'NO', 'NO'), ('ro_view13', 'NO', 'NO'), ('ro_view17', 'NO', 'NO'), ('ro_view18', 'NO', 'NO'), ('ro_view19', 'NO', 'NO'), ('ro_view2', 'NO', 'NO'), ('ro_view20', 'NO', 'NO'), ('ro_view3', 'NO', 'NO'), ('ro_view4', 'NO', 'NO'), ('ro_view5', 'NO', 'NO'), ('ro_view6', 'NO', 'NO'), ('ro_view7', 'NO', 'NO'), ('ro_view8', 'NO', 'NO'), ('ro_view9', 'NO', 'NO'), ('rw_view14', 'YES', 'YES'), ('rw_view15', 'YES', 'YES'), ('rw_view16', 'YES', 'YES')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	postgres: [('ro_view1', 'a', 'NO'), ('ro_view1', 'b', 'NO'), ('ro_view10', 'a', 'NO'), ('ro_view11', 'a', 'NO'), ('ro_view11', 'b', 'NO'), ('ro_view12', 'a', 'NO'), ('ro_view13', 'a', 'NO'), ('ro_view13', 'b', 'NO'), ('ro_view17', 'a', 'NO'), ('ro_view17', 'b', 'NO'), ('ro_view18', 'a', 'NO'), ('ro_view19', 'last_value', 'NO'), ('ro_view19', 'log_cnt', 'NO'), ('ro_view19', 'is_called', 'NO'), ('ro_view2', 'a', 'NO'), ('ro_view2', 'b', 'NO'), ('ro_view20', 'a', 'NO'), ('ro_view20', 'b', 'NO'), ('ro_view20', 'g', 'NO'), ('ro_view3', '?column?', 'NO'), ('ro_view4', 'count', 'NO'), ('ro_view5', 'a', 'NO'), ('ro_view5', 'rank', 'NO'), ('ro_view6', 'a', 'NO'), ('ro_view6', 'b', 'NO'), ('ro_view7', 'a', 'NO'), ('ro_view7', 'b', 'NO'), ('ro_view8', 'a', 'NO'), ('ro_view8', 'b', 'NO'), ('ro_view9', 'a', 'NO'), ('ro_view9', 'b', 'NO'), ('rw_view14', 'ctid', 'NO'), ('rw_view14', 'a', 'YES'), ('rw_view14', 'b', 'YES'), ('rw_view15', 'a', 'YES'), ('rw_view15', 'upper', 'NO'), ('rw_view16', 'a', 'YES'), ('rw_view16', 'b', 'YES'), ('rw_view16', 'aa', 'YES')]

-----------
QUERY:


-- Read-only views
DELETE FROM ro_view1;
RESULT:
	postgres: cannot delete from view "ro_view1"
DETAIL:  Views containing DISTINCT are not automatically updatable.
HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.


-----------
QUERY:

DELETE FROM ro_view2;
RESULT:
	postgres: cannot delete from view "ro_view2"
DETAIL:  Views containing GROUP BY are not automatically updatable.
HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.


-----------
QUERY:

DELETE FROM ro_view3;
RESULT:
	postgres: cannot delete from view "ro_view3"
DETAIL:  Views containing HAVING are not automatically updatable.
HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.


-----------
QUERY:

DELETE FROM ro_view4;
RESULT:
	postgres: cannot delete from view "ro_view4"
DETAIL:  Views that return aggregate functions are not automatically updatable.
HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.


-----------
QUERY:

DELETE FROM ro_view5;
RESULT:
	postgres: cannot delete from view "ro_view5"
DETAIL:  Views that return window functions are not automatically updatable.
HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.


-----------
QUERY:

DELETE FROM ro_view6;
RESULT:
	postgres: cannot delete from view "ro_view6"
DETAIL:  Views containing UNION, INTERSECT, or EXCEPT are not automatically updatable.
HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.


-----------
QUERY:

UPDATE ro_view7 SET a=a+1;
RESULT:
	postgres: cannot update view "ro_view7"
DETAIL:  Views containing WITH are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:

UPDATE ro_view8 SET a=a+1;
RESULT:
	postgres: cannot update view "ro_view8"
DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:

UPDATE ro_view9 SET a=a+1;
RESULT:
	postgres: cannot update view "ro_view9"
DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:

UPDATE ro_view10 SET a=a+1;
RESULT:
	postgres: cannot update view "ro_view10"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:

UPDATE ro_view11 SET a=a+1;
RESULT:
	postgres: cannot update view "ro_view11"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:

UPDATE ro_view12 SET a=a+1;
RESULT:
	postgres: cannot update view "ro_view12"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:

INSERT INTO ro_view13 VALUES (3, 'Row 3');
RESULT:
	postgres: cannot insert into view "ro_view13"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.


-----------
QUERY:

MERGE INTO ro_view13 AS t USING (VALUES (1, 'Row 1')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	postgres: cannot delete from view "ro_view13"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable deleting from the view using MERGE, provide an INSTEAD OF DELETE trigger.


-----------
QUERY:

MERGE INTO ro_view13 AS t USING (VALUES (2, 'Row 2')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = v.b;
RESULT:
	postgres: cannot update view "ro_view13"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable updating the view using MERGE, provide an INSTEAD OF UPDATE trigger.


-----------
QUERY:

MERGE INTO ro_view13 AS t USING (VALUES (3, 'Row 3')) AS v(a,b) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a, v.b);
RESULT:
	postgres: cannot insert into view "ro_view13"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable inserting into the view using MERGE, provide an INSTEAD OF INSERT trigger.


-----------
QUERY:

MERGE INTO ro_view13 AS t USING (VALUES (3, 'Row 3')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN DO NOTHING
  WHEN NOT MATCHED THEN DO NOTHING;
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK to do nothing
-- Partially updatable view
INSERT INTO rw_view14 VALUES (null, 3, 'Row 3');
RESULT:
	postgres: cannot insert into column "ctid" of view "rw_view14"
DETAIL:  View columns that refer to system columns are not updatable.


-----------
QUERY:
 -- should fail
INSERT INTO rw_view14 (a, b) VALUES (3, 'Row 3');
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
UPDATE rw_view14 SET ctid=null WHERE a=3;
RESULT:
	postgres: cannot update column "ctid" of view "rw_view14"
DETAIL:  View columns that refer to system columns are not updatable.


-----------
QUERY:
 -- should fail
UPDATE rw_view14 SET b='ROW 3' WHERE a=3;
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl;
RESULT:
	postgres: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2'), (3, 'ROW 3')]

-----------
QUERY:

DELETE FROM rw_view14 WHERE a=3;
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
MERGE INTO rw_view14  AS t
  USING (VALUES (2, 'Merged row 2'), (3, 'Merged row 3')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = v.b  -- should be OK, except...
  WHEN NOT MATCHED THEN INSERT VALUES (null, v.a, v.b);
RESULT:
	postgres: cannot merge into column "ctid" of view "rw_view14"
DETAIL:  View columns that refer to system columns are not updatable.


-----------
QUERY:
 -- should fail
MERGE INTO rw_view14  AS t
  USING (VALUES (2, 'Merged row 2'), (3, 'Merged row 3')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = v.b  -- should be OK
  WHEN NOT MATCHED THEN INSERT (a,b) VALUES (v.a, v.b);
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl ORDER BY a;
RESULT:
	postgres: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Merged row 2'), (3, 'Merged row 3')]

-----------
QUERY:

MERGE INTO rw_view14  AS t
  USING (VALUES (2, 'Row 2'), (3, 'Row 3')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED AND t.a = 2 THEN UPDATE SET b = v.b  -- should be OK
  WHEN MATCHED AND t.a = 3 THEN DELETE;
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl ORDER BY a;
RESULT:
	postgres: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:

-- Partially updatable view
INSERT INTO rw_view15 VALUES (3, 'ROW 3');
RESULT:
	postgres: cannot insert into column "upper" of view "rw_view15"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
INSERT INTO rw_view15 (a) VALUES (3);
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT DO NOTHING;
RESULT:
	postgres: None

-----------
QUERY:
 -- succeeds
SELECT * FROM rw_view15;
RESULT:
	postgres: [(-2, 'ROW -2'), (-1, 'ROW -1'), (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2'), (3, 'UNSPECIFIED')]

-----------
QUERY:

INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO NOTHING;
RESULT:
	postgres: None

-----------
QUERY:
 -- succeeds
SELECT * FROM rw_view15;
RESULT:
	postgres: [(-2, 'ROW -2'), (-1, 'ROW -1'), (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2'), (3, 'UNSPECIFIED')]

-----------
QUERY:

INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set a = excluded.a;
RESULT:
	postgres: None

-----------
QUERY:
 -- succeeds
SELECT * FROM rw_view15;
RESULT:
	postgres: [(-2, 'ROW -2'), (-1, 'ROW -1'), (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2'), (3, 'UNSPECIFIED')]

-----------
QUERY:

INSERT INTO rw_view15 (a) VALUES (3) ON CONFLICT (a) DO UPDATE set upper = 'blarg';
RESULT:
	postgres: cannot insert into column "upper" of view "rw_view15"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- fails
SELECT * FROM rw_view15;
RESULT:
	postgres: [(-2, 'ROW -2'), (-1, 'ROW -1'), (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2'), (3, 'UNSPECIFIED')]

-----------
QUERY:

SELECT * FROM rw_view15;
RESULT:
	postgres: [(-2, 'ROW -2'), (-1, 'ROW -1'), (0, 'ROW 0'), (1, 'ROW 1'), (2, 'ROW 2'), (3, 'UNSPECIFIED')]

-----------
QUERY:

ALTER VIEW rw_view15 ALTER COLUMN upper SET DEFAULT 'NOT SET';
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view15 (a) VALUES (4);
RESULT:
	postgres: cannot insert into column "upper" of view "rw_view15"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
UPDATE rw_view15 SET upper='ROW 3' WHERE a=3;
RESULT:
	postgres: cannot update column "upper" of view "rw_view15"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
UPDATE rw_view15 SET upper=DEFAULT WHERE a=3;
RESULT:
	postgres: cannot update column "upper" of view "rw_view15"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
UPDATE rw_view15 SET a=4 WHERE a=3;
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl;
RESULT:
	postgres: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2'), (4, 'Unspecified')]

-----------
QUERY:

DELETE FROM rw_view15 WHERE a=4;
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
-- Partially updatable view
INSERT INTO rw_view16 VALUES (3, 'Row 3', 3);
RESULT:
	postgres: multiple assignments to same column "a"


-----------
QUERY:
 -- should fail
INSERT INTO rw_view16 (a, b) VALUES (3, 'Row 3');
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
UPDATE rw_view16 SET a=3, aa=-3 WHERE a=3;
RESULT:
	postgres: multiple assignments to same column "a"


-----------
QUERY:
 -- should fail
UPDATE rw_view16 SET aa=-3 WHERE a=3;
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl;
RESULT:
	postgres: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Row 2'), (-3, 'Row 3')]

-----------
QUERY:

DELETE FROM rw_view16 WHERE a=-3;
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
-- Read-only views
INSERT INTO ro_view17 VALUES (3, 'ROW 3');
RESULT:
	postgres: cannot insert into view "ro_view1"
DETAIL:  Views containing DISTINCT are not automatically updatable.
HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.


-----------
QUERY:

DELETE FROM ro_view18;
RESULT:
	postgres: cannot delete from view "ro_view18"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.


-----------
QUERY:

UPDATE ro_view19 SET last_value=1000;
RESULT:
	postgres: cannot update view "ro_view19"
DETAIL:  Views that do not select from a single table or view are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:

UPDATE ro_view20 SET b=upper(b);
RESULT:
	postgres: cannot update view "ro_view20"
DETAIL:  Views that return set-returning functions are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:


-- A view with a conditional INSTEAD rule but no unconditional INSTEAD rules
-- or INSTEAD OF triggers should be non-updatable and generate useful error
-- messages with appropriate detail
CREATE RULE rw_view16_ins_rule AS ON INSERT TO rw_view16
  WHERE NEW.a > 0 DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b);
RESULT:
	postgres: None

-----------
QUERY:

CREATE RULE rw_view16_upd_rule AS ON UPDATE TO rw_view16
  WHERE OLD.a > 0 DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;
RESULT:
	postgres: None

-----------
QUERY:

CREATE RULE rw_view16_del_rule AS ON DELETE TO rw_view16
  WHERE OLD.a > 0 DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view16 (a, b) VALUES (3, 'Row 3');
RESULT:
	postgres: cannot insert into view "rw_view16"
DETAIL:  Views with conditional DO INSTEAD rules are not automatically updatable.
HINT:  To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule.


-----------
QUERY:
 -- should fail
UPDATE rw_view16 SET b='ROW 2' WHERE a=2;
RESULT:
	postgres: cannot update view "rw_view16"
DETAIL:  Views with conditional DO INSTEAD rules are not automatically updatable.
HINT:  To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule.


-----------
QUERY:
 -- should fail
DELETE FROM rw_view16 WHERE a=2;
RESULT:
	postgres: cannot delete from view "rw_view16"
DETAIL:  Views with conditional DO INSTEAD rules are not automatically updatable.
HINT:  To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule.


-----------
QUERY:
 -- should fail
MERGE INTO rw_view16 AS t USING (VALUES (3, 'Row 3')) AS v(a,b) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a, v.b);
RESULT:
	postgres: cannot execute MERGE on relation "rw_view16"
DETAIL:  MERGE is not supported for relations with rules.


-----------
QUERY:
 -- should fail

DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP VIEW ro_view10, ro_view12, ro_view18;
RESULT:
	postgres: None

-----------
QUERY:

DROP SEQUENCE uv_seq CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- simple updatable view

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0;
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name = 'rw_view1';
RESULT:
	postgres: [('rw_view1', 'YES')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name = 'rw_view1';
RESULT:
	postgres: [('rw_view1', 'YES', 'YES')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name = 'rw_view1'
 ORDER BY ordinal_position;
RESULT:
	postgres: [('rw_view1', 'a', 'YES'), ('rw_view1', 'b', 'YES')]

-----------
QUERY:


INSERT INTO rw_view1 VALUES (3, 'Row 3');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view1 (a) VALUES (4);
RESULT:
	postgres: None

-----------
QUERY:

UPDATE rw_view1 SET a=5 WHERE a=4;
RESULT:
	postgres: None

-----------
QUERY:

DELETE FROM rw_view1 WHERE b='Row 2';
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM base_tbl;
RESULT:
	postgres: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (3, 'Row 3'), (5, 'Unspecified')]

-----------
QUERY:


MERGE INTO rw_view1 t
  USING (VALUES (0, 'ROW 0'), (1, 'ROW 1'),
                (2, 'ROW 2'), (3, 'ROW 3')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED AND t.a <= 1 THEN UPDATE SET b = v.b
  WHEN MATCHED THEN DELETE
  WHEN NOT MATCHED AND a > 0 THEN INSERT (a) VALUES (v.a)
  RETURNING merge_action(), v.*, t.*;
RESULT:
	postgres: [('UPDATE', 1, 'ROW 1', 1, 'ROW 1'), ('DELETE', 3, 'ROW 3', 3, 'Row 3'), ('INSERT', 2, 'ROW 2', 2, 'Unspecified')]

-----------
QUERY:

SELECT * FROM base_tbl ORDER BY a;
RESULT:
	postgres: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'ROW 1'), (2, 'Unspecified'), (5, 'Unspecified')]

-----------
QUERY:


EXPLAIN (costs off) UPDATE rw_view1 SET a=6 WHERE a=5;
RESULT:
	postgres: [('Update on base_tbl',), ('  ->  Index Scan using base_tbl_pkey on base_tbl',), ('        Index Cond: ((a > 0) AND (a = 5))',)]

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view1 WHERE a=5;
RESULT:
	postgres: [('Delete on base_tbl',), ('  ->  Index Scan using base_tbl_pkey on base_tbl',), ('        Index Cond: ((a > 0) AND (a = 5))',)]

-----------
QUERY:


EXPLAIN (costs off)
MERGE INTO rw_view1 t USING (VALUES (5, 'X')) AS v(a,b) ON t.a = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	postgres: [('Merge on base_tbl',), ('  ->  Index Scan using base_tbl_pkey on base_tbl',), ('        Index Cond: ((a > 0) AND (a = 5))',)]

-----------
QUERY:


EXPLAIN (costs off)
MERGE INTO rw_view1 t
  USING (SELECT * FROM generate_series(1,5)) AS s(a) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = 'Updated';
RESULT:
	postgres: [('Merge on base_tbl',), ('  ->  Hash Join',), ('        Hash Cond: (base_tbl.a = generate_series.generate_series)',), ('        ->  Bitmap Heap Scan on base_tbl',), ('              Recheck Cond: (a > 0)',), ('              ->  Bitmap Index Scan on base_tbl_pkey',), ('                    Index Cond: (a > 0)',), ('        ->  Hash',), ('              ->  Function Scan on generate_series',)]

-----------
QUERY:


EXPLAIN (costs off)
MERGE INTO rw_view1 t
  USING (SELECT * FROM generate_series(1,5)) AS s(a) ON t.a = s.a
  WHEN NOT MATCHED THEN INSERT (a) VALUES (s.a);
RESULT:
	postgres: [('Merge on base_tbl',), ('  ->  Hash Right Join',), ('        Hash Cond: (base_tbl.a = generate_series.generate_series)',), ('        ->  Bitmap Heap Scan on base_tbl',), ('              Recheck Cond: (a > 0)',), ('              ->  Bitmap Index Scan on base_tbl_pkey',), ('                    Index Cond: (a > 0)',), ('        ->  Hash',), ('              ->  Function Scan on generate_series',)]

-----------
QUERY:


-- it/* REPLACED */''s still updatable if we add a DO ALSO rule

CREATE TABLE base_tbl_hist(ts timestamptz default now(), a int, b text);
RESULT:
	postgres: None

-----------
QUERY:


CREATE RULE base_tbl_log AS ON INSERT TO rw_view1 DO ALSO
  INSERT INTO base_tbl_hist(a,b) VALUES(new.a, new.b);
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name = 'rw_view1';
RESULT:
	postgres: [('rw_view1', 'YES', 'YES')]

-----------
QUERY:


-- Check behavior with DEFAULTs (bug #17633)

INSERT INTO rw_view1 VALUES (9, DEFAULT), (10, DEFAULT);
RESULT:
	postgres: None

-----------
QUERY:

SELECT a, b FROM base_tbl_hist;
RESULT:
	postgres: [(9, None), (10, None)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE base_tbl_hist;
RESULT:
	postgres: None

-----------
QUERY:


-- view on top of view

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl WHERE a>0;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT aa AS aaa, bb AS bbb FROM rw_view1 WHERE aa<10;
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name = 'rw_view2';
RESULT:
	postgres: [('rw_view2', 'YES')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name = 'rw_view2';
RESULT:
	postgres: [('rw_view2', 'YES', 'YES')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name = 'rw_view2'
 ORDER BY ordinal_position;
RESULT:
	postgres: [('rw_view2', 'aaa', 'YES'), ('rw_view2', 'bbb', 'YES')]

-----------
QUERY:


INSERT INTO rw_view2 VALUES (3, 'Row 3');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view2 (aaa) VALUES (4);
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1, 'Row 1'), (2, 'Row 2'), (3, 'Row 3'), (4, 'Unspecified')]

-----------
QUERY:

UPDATE rw_view2 SET bbb='Row 4' WHERE aaa=4;
RESULT:
	postgres: None

-----------
QUERY:

DELETE FROM rw_view2 WHERE aaa=2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1, 'Row 1'), (3, 'Row 3'), (4, 'Row 4')]

-----------
QUERY:


MERGE INTO rw_view2 t
  USING (VALUES (3, 'R3'), (4, 'R4'), (5, 'R5')) AS v(a,b) ON aaa = v.a
  WHEN MATCHED AND aaa = 3 THEN DELETE
  WHEN MATCHED THEN UPDATE SET bbb = v.b
  WHEN NOT MATCHED THEN INSERT (aaa) VALUES (v.a)
  RETURNING merge_action(), v.*, t.*;
RESULT:
	postgres: [('DELETE', 3, 'R3', 3, 'Row 3'), ('UPDATE', 4, 'R4', 4, 'R4'), ('INSERT', 5, 'R5', 5, 'Unspecified')]

-----------
QUERY:

SELECT * FROM rw_view2 ORDER BY aaa;
RESULT:
	postgres: [(1, 'Row 1'), (4, 'R4'), (5, 'Unspecified')]

-----------
QUERY:


EXPLAIN (costs off) UPDATE rw_view2 SET aaa=5 WHERE aaa=4;
RESULT:
	postgres: [('Update on base_tbl',), ('  ->  Index Scan using base_tbl_pkey on base_tbl',), ('        Index Cond: ((a < 10) AND (a > 0) AND (a = 4))',)]

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view2 WHERE aaa=4;
RESULT:
	postgres: [('Delete on base_tbl',), ('  ->  Index Scan using base_tbl_pkey on base_tbl',), ('        Index Cond: ((a < 10) AND (a > 0) AND (a = 4))',)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- view on top of view with rules

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0;
RESULT:
	postgres: None

-----------
QUERY:
 -- not updatable without rules/triggers
CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO', 'NO'), ('rw_view2', 'NO', 'NO')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	postgres: [('rw_view1', 'a', 'NO'), ('rw_view1', 'b', 'NO'), ('rw_view2', 'a', 'NO'), ('rw_view2', 'b', 'NO')]

-----------
QUERY:


CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, NEW.b) RETURNING *;
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'YES'), ('rw_view2', 'YES')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO', 'YES'), ('rw_view2', 'NO', 'YES')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	postgres: [('rw_view1', 'a', 'NO'), ('rw_view1', 'b', 'NO'), ('rw_view2', 'a', 'NO'), ('rw_view2', 'b', 'NO')]

-----------
QUERY:


CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
  DO INSTEAD UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a RETURNING NEW.*;
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'YES'), ('rw_view2', 'YES')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO', 'YES'), ('rw_view2', 'NO', 'YES')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	postgres: [('rw_view1', 'a', 'NO'), ('rw_view1', 'b', 'NO'), ('rw_view2', 'a', 'NO'), ('rw_view2', 'b', 'NO')]

-----------
QUERY:


CREATE RULE rw_view1_del_rule AS ON DELETE TO rw_view1
  DO INSTEAD DELETE FROM base_tbl WHERE a=OLD.a RETURNING OLD.*;
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'YES'), ('rw_view2', 'YES')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'YES', 'YES'), ('rw_view2', 'YES', 'YES')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	postgres: [('rw_view1', 'a', 'YES'), ('rw_view1', 'b', 'YES'), ('rw_view2', 'a', 'YES'), ('rw_view2', 'b', 'YES')]

-----------
QUERY:


INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
RESULT:
	postgres: [(3, 'Row 3')]

-----------
QUERY:

UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
RESULT:
	postgres: [(3, 'Row three')]

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1, 'Row 1'), (2, 'Row 2'), (3, 'Row three')]

-----------
QUERY:

DELETE FROM rw_view2 WHERE a=3 RETURNING *;
RESULT:
	postgres: [(3, 'Row three')]

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:


MERGE INTO rw_view2 t USING (VALUES (3, 'Row 3')) AS v(a,b) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a, v.b);
RESULT:
	postgres: cannot execute MERGE on relation "rw_view1"
DETAIL:  MERGE is not supported for relations with rules.


-----------
QUERY:
 -- should fail

EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
RESULT:
	postgres: [('Update on base_tbl',), ('  ->  Nested Loop',), ('        ->  Index Scan using base_tbl_pkey on base_tbl',), ('              Index Cond: (a = 2)',), ('        ->  Subquery Scan on rw_view1',), ('              Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))',), ('              ->  Bitmap Heap Scan on base_tbl base_tbl_1',), ('                    Recheck Cond: (a > 0)',), ('                    ->  Bitmap Index Scan on base_tbl_pkey',), ('                          Index Cond: (a > 0)',)]

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
RESULT:
	postgres: [('Delete on base_tbl',), ('  ->  Nested Loop',), ('        ->  Index Scan using base_tbl_pkey on base_tbl',), ('              Index Cond: (a = 2)',), ('        ->  Subquery Scan on rw_view1',), ('              Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))',), ('              ->  Bitmap Heap Scan on base_tbl base_tbl_1',), ('                    Recheck Cond: (a > 0)',), ('                    ->  Bitmap Index Scan on base_tbl_pkey',), ('                          Index Cond: (a > 0)',)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- view on top of view with triggers

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a>0 OFFSET 0;
RESULT:
	postgres: None

-----------
QUERY:
 -- not updatable without rules/triggers
CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a<10;
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into,
       is_trigger_updatable, is_trigger_deletable,
       is_trigger_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO', 'NO', 'NO', 'NO', 'NO'), ('rw_view2', 'NO', 'NO', 'NO', 'NO', 'NO')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	postgres: [('rw_view1', 'a', 'NO'), ('rw_view1', 'b', 'NO'), ('rw_view2', 'a', 'NO'), ('rw_view2', 'b', 'NO')]

-----------
QUERY:


CREATE FUNCTION rw_view1_trig_fn()
RETURNS trigger AS
$$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO base_tbl VALUES (NEW.a, NEW.b);
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    UPDATE base_tbl SET b=NEW.b WHERE a=OLD.a;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    DELETE FROM base_tbl WHERE a=OLD.a;
    RETURN OLD;
  END IF;
END;
$$
LANGUAGE plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER rw_view1_ins_trig INSTEAD OF INSERT ON rw_view1
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into,
       is_trigger_updatable, is_trigger_deletable,
       is_trigger_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO', 'NO', 'NO', 'NO', 'YES'), ('rw_view2', 'NO', 'NO', 'NO', 'NO', 'NO')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	postgres: [('rw_view1', 'a', 'NO'), ('rw_view1', 'b', 'NO'), ('rw_view2', 'a', 'NO'), ('rw_view2', 'b', 'NO')]

-----------
QUERY:


CREATE TRIGGER rw_view1_upd_trig INSTEAD OF UPDATE ON rw_view1
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into,
       is_trigger_updatable, is_trigger_deletable,
       is_trigger_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO', 'NO', 'YES', 'NO', 'YES'), ('rw_view2', 'NO', 'NO', 'NO', 'NO', 'NO')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	postgres: [('rw_view1', 'a', 'NO'), ('rw_view1', 'b', 'NO'), ('rw_view2', 'a', 'NO'), ('rw_view2', 'b', 'NO')]

-----------
QUERY:


CREATE TRIGGER rw_view1_del_trig INSTEAD OF DELETE ON rw_view1
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO'), ('rw_view2', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into,
       is_trigger_updatable, is_trigger_deletable,
       is_trigger_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'NO', 'NO', 'YES', 'YES', 'YES'), ('rw_view2', 'NO', 'NO', 'NO', 'NO', 'NO')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE 'rw_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	postgres: [('rw_view1', 'a', 'NO'), ('rw_view1', 'b', 'NO'), ('rw_view2', 'a', 'NO'), ('rw_view2', 'b', 'NO')]

-----------
QUERY:


INSERT INTO rw_view2 VALUES (3, 'Row 3') RETURNING *;
RESULT:
	postgres: [(3, 'Row 3')]

-----------
QUERY:

UPDATE rw_view2 SET b='Row three' WHERE a=3 RETURNING *;
RESULT:
	postgres: [(3, 'Row three')]

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1, 'Row 1'), (2, 'Row 2'), (3, 'Row three')]

-----------
QUERY:

DELETE FROM rw_view2 WHERE a=3 RETURNING *;
RESULT:
	postgres: [(3, 'Row three')]

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1, 'Row 1'), (2, 'Row 2')]

-----------
QUERY:


MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED AND t.a <= 1 THEN DELETE
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b)
  RETURNING merge_action(), s.*, t.*;
RESULT:
	postgres: [('DELETE', 1, 'R1', 1, 'Row 1'), ('UPDATE', 2, 'R2', 2, 'R2'), ('INSERT', 3, 'R3', 3, 'R3')]

-----------
QUERY:

SELECT * FROM base_tbl ORDER BY a;
RESULT:
	postgres: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (2, 'R2'), (3, 'R3')]

-----------
QUERY:


EXPLAIN (costs off) UPDATE rw_view2 SET a=3 WHERE a=2;
RESULT:
	postgres: [('Update on rw_view1 rw_view1_1',), ('  ->  Subquery Scan on rw_view1',), ('        Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))',), ('        ->  Bitmap Heap Scan on base_tbl',), ('              Recheck Cond: (a > 0)',), ('              ->  Bitmap Index Scan on base_tbl_pkey',), ('                    Index Cond: (a > 0)',)]

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view2 WHERE a=2;
RESULT:
	postgres: [('Delete on rw_view1 rw_view1_1',), ('  ->  Subquery Scan on rw_view1',), ('        Filter: ((rw_view1.a < 10) AND (rw_view1.a = 2))',), ('        ->  Bitmap Heap Scan on base_tbl',), ('              Recheck Cond: (a > 0)',), ('              ->  Bitmap Index Scan on base_tbl_pkey',), ('                    Index Cond: (a > 0)',)]

-----------
QUERY:


EXPLAIN (costs off)
MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED AND t.a <= 1 THEN DELETE
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
RESULT:
	postgres: [('Merge on rw_view1 rw_view1_1',), ('  ->  Hash Right Join',), ('        Hash Cond: (rw_view1.a = x.x)',), ('        ->  Subquery Scan on rw_view1',), ('              Filter: (rw_view1.a < 10)',), ('              ->  Bitmap Heap Scan on base_tbl',), ('                    Recheck Cond: (a > 0)',), ('                    ->  Bitmap Index Scan on base_tbl_pkey',), ('                          Index Cond: (a > 0)',), ('        ->  Hash',), ('              ->  Function Scan on generate_series x',)]

-----------
QUERY:


-- MERGE with incomplete set of INSTEAD OF triggers
DROP TRIGGER rw_view1_del_trig ON rw_view1;
RESULT:
	postgres: None

-----------
QUERY:

MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED AND t.a <= 1 THEN DELETE
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
RESULT:
	postgres: cannot delete from view "rw_view1"
DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
HINT:  To enable deleting from the view using MERGE, provide an INSTEAD OF DELETE trigger.


-----------
QUERY:
 -- should fail
MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok

DROP TRIGGER rw_view1_ins_trig ON rw_view1;
RESULT:
	postgres: None

-----------
QUERY:

MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
RESULT:
	postgres: cannot insert into view "rw_view1"
DETAIL:  Views containing LIMIT or OFFSET are not automatically updatable.
HINT:  To enable inserting into the view using MERGE, provide an INSTEAD OF INSERT trigger.


-----------
QUERY:
 -- should fail
MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = s.b;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok

-- MERGE with INSTEAD OF triggers on auto-updatable view
CREATE TRIGGER rw_view2_upd_trig INSTEAD OF UPDATE ON rw_view2
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:

MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = s.b
  WHEN NOT MATCHED AND s.a > 0 THEN INSERT VALUES (s.a, s.b);
RESULT:
	postgres: cannot merge into view "rw_view2"
DETAIL:  MERGE is not supported for views with INSTEAD OF triggers for some actions, but not others.
HINT:  To enable merging into the view, either provide a full set of INSTEAD OF triggers or drop the existing INSTEAD OF triggers.


-----------
QUERY:
 -- should fail
MERGE INTO rw_view2 t
  USING (SELECT x, 'R'||x FROM generate_series(0,3) x) AS s(a,b) ON t.a = s.a
  WHEN MATCHED THEN UPDATE SET b = s.b;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
SELECT * FROM base_tbl ORDER BY a;
RESULT:
	postgres: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'R1'), (2, 'R2'), (3, 'R3')]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP FUNCTION rw_view1_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:


-- update using whole row from view

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl SELECT i, 'Row ' || i FROM generate_series(-2, 2) g(i);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT b AS bb, a AS aa FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION rw_view1_aa(x rw_view1)
  RETURNS int AS $$ SELECT x.aa $$ LANGUAGE sql;
RESULT:
	postgres: None

-----------
QUERY:


UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2
  RETURNING rw_view1_aa(v), v.bb;
RESULT:
	postgres: [(2, 'Updated row 2')]

-----------
QUERY:

SELECT * FROM base_tbl;
RESULT:
	postgres: [(-2, 'Row -2'), (-1, 'Row -1'), (0, 'Row 0'), (1, 'Row 1'), (2, 'Updated row 2')]

-----------
QUERY:


EXPLAIN (costs off)
UPDATE rw_view1 v SET bb='Updated row 2' WHERE rw_view1_aa(v)=2
  RETURNING rw_view1_aa(v), v.bb;
RESULT:
	postgres: [('Update on base_tbl',), ('  ->  Index Scan using base_tbl_pkey on base_tbl',), ('        Index Cond: (a = 2)',)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- permissions checks

CREATE USER regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE USER regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE USER regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE base_tbl(a int, b text, c float);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
RESULT:
	postgres: None

-----------
QUERY:


GRANT SELECT ON base_tbl TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

GRANT SELECT ON rw_view1 TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

GRANT UPDATE (a,c) ON base_tbl TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

GRANT UPDATE (bb,cc) ON rw_view1 TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM base_tbl;
RESULT:
	postgres: [(1, 'Row 1', 1.0), (2, 'Row 2', 2.0)]

-----------
QUERY:
 -- ok
SELECT * FROM rw_view1;
RESULT:
	postgres: [('Row 1', 1.0, 1), ('Row 2', 2.0, 2)]

-----------
QUERY:
 -- ok
SELECT * FROM rw_view2;
RESULT:
	postgres: [('Row 1', 1.0, 1), ('Row 2', 2.0, 2)]

-----------
QUERY:
 -- ok

INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3);
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
INSERT INTO rw_view2 VALUES ('Row 3', 3.0, 3);
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

MERGE INTO rw_view1 t
  USING (VALUES ('Row 3', 3.0, 3)) AS v(b,c,a) ON t.aa = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.b, v.c, v.a);
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t
  USING (VALUES ('Row 3', 3.0, 3)) AS v(b,c,a) ON t.aa = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.b, v.c, v.a);
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

UPDATE base_tbl SET a=a, c=c;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
UPDATE base_tbl SET b=b;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
UPDATE rw_view1 SET bb=bb, cc=cc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET aa=aa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
UPDATE rw_view2 SET aa=aa, cc=cc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
UPDATE rw_view2 SET bb=bb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET bb = bb, cc = cc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET aa = aa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET aa = aa, cc = cc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET bb = bb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

DELETE FROM base_tbl;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
DELETE FROM rw_view1;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
DELETE FROM rw_view2;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
INSERT INTO rw_view2 VALUES ('Row 4', 4.0, 4);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
DELETE FROM base_tbl WHERE a=1;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
DELETE FROM rw_view1 WHERE aa=2;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
DELETE FROM rw_view2 WHERE aa=2;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED AND bb = 'xxx' THEN DELETE;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED AND bb = 'xxx' THEN DELETE;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
SELECT * FROM base_tbl;
RESULT:
	postgres: [(3, 'Row 3', 3.0), (4, 'Row 4', 4.0)]

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

GRANT INSERT, DELETE ON rw_view1 TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (5, 'Row 5', 5.0);
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
INSERT INTO rw_view1 VALUES ('Row 5', 5.0, 5);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view2 VALUES ('Row 6', 6.0, 6);
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
DELETE FROM base_tbl WHERE a=3;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
DELETE FROM rw_view1 WHERE aa=3;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
DELETE FROM rw_view2 WHERE aa=4;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED AND bb = 'xxx' THEN DELETE;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED AND bb = 'xxx' THEN DELETE;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
SELECT * FROM base_tbl;
RESULT:
	postgres: [(4, 'Row 4', 4.0), (5, 'Row 5', 5.0)]

-----------
QUERY:

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- nested-view permissions

CREATE TABLE base_tbl(a int, b text, c float);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
SELECT * FROM rw_view1 FOR UPDATE;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT * FROM rw_view1;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:

GRANT SELECT ON base_tbl TO regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	postgres: [(1, 'Row 1', 1.0)]

-----------
QUERY:

SELECT * FROM rw_view1 FOR UPDATE;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

GRANT SELECT ON rw_view1 TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1, 'Row 1', 1.0)]

-----------
QUERY:

SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:

GRANT UPDATE ON base_tbl TO regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	postgres: [(1, 'Row 1', 1.0)]

-----------
QUERY:

SELECT * FROM rw_view1 FOR UPDATE;
RESULT:
	postgres: [(1, 'Row 1', 1.0)]

-----------
QUERY:

UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
RESULT:
	postgres: None

-----------
QUERY:

MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1, 'foo', 1.0)]

-----------
QUERY:

SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'bar';
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

GRANT UPDATE ON rw_view1 TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1, 'foo', 1.0)]

-----------
QUERY:

SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	postgres: [(1, 'foo', 1.0)]

-----------
QUERY:

UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	postgres: None

-----------
QUERY:

MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'fud';
RESULT:
	postgres: None

-----------
QUERY:


RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:

REVOKE UPDATE ON base_tbl FROM regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	postgres: [(1, 'fud', 1.0)]

-----------
QUERY:

SELECT * FROM rw_view1 FOR UPDATE;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view1 SET b = 'foo' WHERE a = 1;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1, 'fud', 1.0)]

-----------
QUERY:

SELECT * FROM rw_view2 FOR UPDATE;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET b = 'bar' WHERE a = 1;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET b = 'foo';
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- security invoker view permissions

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE base_tbl(a int, b text, c float);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

ALTER VIEW rw_view1 SET (security_invoker = true);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view1 VALUES ('Row 2', 2.0, 2);
RESULT:
	postgres: None

-----------
QUERY:

GRANT SELECT ON rw_view1 TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

GRANT UPDATE (bb,cc) ON rw_view1 TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM base_tbl;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
SELECT * FROM rw_view1;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
INSERT INTO rw_view1 VALUES ('Row 3', 3.0, 3);
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
UPDATE base_tbl SET a=a;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
UPDATE rw_view1 SET bb=bb, cc=cc;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET bb = bb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
DELETE FROM base_tbl;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
DELETE FROM rw_view1;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

GRANT SELECT ON base_tbl TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

GRANT UPDATE (a,c) ON base_tbl TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM base_tbl;
RESULT:
	postgres: [(1, 'Row 1', 1.0), (2, 'Row 2', 2.0)]

-----------
QUERY:
 -- ok
SELECT * FROM rw_view1;
RESULT:
	postgres: [('Row 1', 1.0, 1), ('Row 2', 2.0, 2)]

-----------
QUERY:
 -- ok
UPDATE base_tbl SET a=a, c=c;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
UPDATE base_tbl SET b=b;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
UPDATE rw_view1 SET cc=cc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET cc = cc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET aa=aa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
UPDATE rw_view1 SET bb=bb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET aa = aa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET bb = bb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (3, 'Row 3', 3.0);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
DELETE FROM base_tbl WHERE a=1;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
DELETE FROM rw_view1 WHERE aa=2;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

REVOKE INSERT, DELETE ON base_tbl FROM regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

GRANT INSERT, DELETE ON rw_view1 TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
DELETE FROM rw_view1 WHERE aa=2;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

GRANT INSERT, DELETE ON base_tbl TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view1 VALUES ('Row 4', 4.0, 4);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
DELETE FROM rw_view1 WHERE aa=2;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (3)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN DELETE;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
SELECT * FROM base_tbl;
RESULT:
	postgres: [(4, 'Row 4', 4.0)]

-----------
QUERY:
 -- ok

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- ordinary view on top of security invoker view permissions

CREATE TABLE base_tbl(a int, b text, c float);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1', 1.0);
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT b AS bb, c AS cc, a AS aa FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

ALTER VIEW rw_view1 SET (security_invoker = true);
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view1 SET aa=aa;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (2, 'Row 2', 2.0)) AS v(a,b,c) ON t.aa = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.b, v.c, v.a);
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT cc AS ccc, aa AS aaa, bb AS bbb FROM rw_view1;
RESULT:
	postgres: None

-----------
QUERY:

GRANT SELECT, UPDATE ON rw_view2 TO regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (2, 'Row 2', 2.0)) AS v(a,b,c) ON t.aaa = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.c, v.a, v.b);
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


GRANT SELECT ON base_tbl TO regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

GRANT UPDATE (a, b) ON base_tbl TO regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	postgres: [('Row 1', 1.0, 1)]

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET aa=aa, bb=bb;
RESULT:
	postgres: None

-----------
QUERY:
  -- ok
UPDATE rw_view1 SET cc=cc;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET aa = aa, bb = bb;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET cc = cc;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

GRANT SELECT ON rw_view1 TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

GRANT UPDATE (bb, cc) ON rw_view1 TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


GRANT SELECT ON base_tbl TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

GRANT UPDATE (a, c) ON base_tbl TO regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1.0, 1, 'Row 1')]

-----------
QUERY:
  -- ok
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	postgres: None

-----------
QUERY:
  -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok

SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


GRANT SELECT ON base_tbl TO regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:

GRANT UPDATE (a, c) ON base_tbl TO regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1.0, 1, 'Row 1')]

-----------
QUERY:
  -- ok
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	postgres: None

-----------
QUERY:
  -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


REVOKE SELECT, UPDATE ON base_tbl FROM regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view1 SET aa=aa;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.aa = v.a
  WHEN MATCHED THEN UPDATE SET aa = aa;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1.0, 1, 'Row 1')]

-----------
QUERY:
  -- ok
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	postgres: None

-----------
QUERY:
  -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok

SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1.0, 1, 'Row 1')]

-----------
QUERY:
  -- ok
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	postgres: None

-----------
QUERY:
  -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


REVOKE SELECT, UPDATE ON base_tbl FROM regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


SET SESSION AUTHORIZATION regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed

SET SESSION AUTHORIZATION regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view2;
RESULT:
	postgres: [(1.0, 1, 'Row 1')]

-----------
QUERY:
  -- ok
UPDATE rw_view2 SET aaa=aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET bbb=bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
  -- not allowed
UPDATE rw_view2 SET ccc=ccc;
RESULT:
	postgres: None

-----------
QUERY:
  -- ok
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET aaa = aaa;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET bbb = bbb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- not allowed
MERGE INTO rw_view2 t USING (VALUES (1)) AS v(a) ON t.aaa = v.a
  WHEN MATCHED THEN UPDATE SET ccc = ccc;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok

RESET SESSION AUTHORIZATION;
RESULT:
	postgres: None

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


DROP USER regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

DROP USER regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

DROP USER regress_view_user3;
RESULT:
	postgres: None

-----------
QUERY:


-- column defaults

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified', c serial);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (2, 'Row 2');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (3);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

ALTER VIEW rw_view1 ALTER COLUMN bb SET DEFAULT 'View default';
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view1 VALUES (4, 'Row 4');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view1 (aa) VALUES (5);
RESULT:
	postgres: None

-----------
QUERY:

MERGE INTO rw_view1 t USING (VALUES (6)) AS v(a) ON t.aa = v.a
  WHEN NOT MATCHED THEN INSERT (aa) VALUES (v.a);
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM base_tbl;
RESULT:
	postgres: [(1, 'Row 1', 1), (2, 'Row 2', 2), (3, 'Unspecified', 3), (4, 'Row 4', 4), (5, 'View default', 5), (6, 'View default', 6)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- Table having triggers

CREATE TABLE base_tbl (a int PRIMARY KEY, b text DEFAULT 'Unspecified');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1');
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (2, 'Row 2');
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION rw_view1_trig_fn()
RETURNS trigger AS
$$
BEGIN
  IF TG_OP = 'INSERT' THEN
    UPDATE base_tbl SET b=NEW.b WHERE a=1;
    RETURN NULL;
  END IF;
  RETURN NULL;
END;
$$
LANGUAGE plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER rw_view1_ins_trig AFTER INSERT ON base_tbl
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT a AS aa, b AS bb FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view1 VALUES (3, 'Row 3');
RESULT:
	postgres: None

-----------
QUERY:

select * from base_tbl;
RESULT:
	postgres: [(2, 'Row 2'), (3, 'Row 3'), (1, 'Row 3')]

-----------
QUERY:


DROP VIEW rw_view1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TRIGGER rw_view1_ins_trig on base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

DROP FUNCTION rw_view1_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE base_tbl;
RESULT:
	postgres: None

-----------
QUERY:


-- view with ORDER BY

CREATE TABLE base_tbl (a int, b int);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (1,2), (4,5), (3,-3);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl ORDER BY a+b;
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM rw_view1;
RESULT:
	postgres: [(3, -3), (1, 2), (4, 5)]

-----------
QUERY:


INSERT INTO rw_view1 VALUES (7,-8);
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	postgres: [(7, -8), (3, -3), (1, 2), (4, 5)]

-----------
QUERY:


EXPLAIN (verbose, costs off) UPDATE rw_view1 SET b = b + 1 RETURNING *;
RESULT:
	postgres: [('Update on public.base_tbl',), ('  Output: base_tbl.a, base_tbl.b',), ('  ->  Seq Scan on public.base_tbl',), ('        Output: (base_tbl.b + 1), base_tbl.ctid',)]

-----------
QUERY:

UPDATE rw_view1 SET b = b + 1 RETURNING *;
RESULT:
	postgres: [(1, 3), (4, 6), (3, -2), (7, -7)]

-----------
QUERY:

SELECT * FROM rw_view1;
RESULT:
	postgres: [(7, -7), (3, -2), (1, 3), (4, 6)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- multiple array-column updates

CREATE TABLE base_tbl (a int, arr int[]);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (1,ARRAY[2]), (3,ARRAY[4]);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:


UPDATE rw_view1 SET arr[1] = 42, arr[2] = 77 WHERE a = 3;
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM rw_view1;
RESULT:
	postgres: [(1, [2]), (3, [42, 77])]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- views with updatable and non-updatable columns

CREATE TABLE base_tbl(a float);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl SELECT i/10.0 FROM generate_series(1,10) g(i);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS
  SELECT ctid, sin(a) s, a, cos(a) c
  FROM base_tbl
  WHERE a != 0
  ORDER BY abs(a);
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view1 VALUES (null, null, 1.1, null);
RESULT:
	postgres: cannot insert into column "ctid" of view "rw_view1"
DETAIL:  View columns that refer to system columns are not updatable.


-----------
QUERY:
 -- should fail
INSERT INTO rw_view1 (s, c, a) VALUES (null, null, 1.1);
RESULT:
	postgres: cannot insert into column "s" of view "rw_view1"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
INSERT INTO rw_view1 (a) VALUES (1.1) RETURNING a, s, c;
RESULT:
	postgres: [(1.1, 0.891207360061435, 0.453596121425577)]

-----------
QUERY:
 -- OK
UPDATE rw_view1 SET s = s WHERE a = 1.1;
RESULT:
	postgres: cannot update column "s" of view "rw_view1"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
UPDATE rw_view1 SET a = 1.05 WHERE a = 1.1 RETURNING s;
RESULT:
	postgres: [(0.867423225594017,)]

-----------
QUERY:
 -- OK
DELETE FROM rw_view1 WHERE a = 1.05;
RESULT:
	postgres: None

-----------
QUERY:
 -- OK

CREATE VIEW rw_view2 AS
  SELECT s, c, s/c t, a base_a, ctid
  FROM rw_view1;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view2 VALUES (null, null, null, 1.1, null);
RESULT:
	postgres: cannot insert into column "t" of view "rw_view2"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
INSERT INTO rw_view2(s, c, base_a) VALUES (null, null, 1.1);
RESULT:
	postgres: cannot insert into column "s" of view "rw_view1"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
INSERT INTO rw_view2(base_a) VALUES (1.1) RETURNING t;
RESULT:
	postgres: [(1.96475965724865,)]

-----------
QUERY:
 -- OK
UPDATE rw_view2 SET s = s WHERE base_a = 1.1;
RESULT:
	postgres: cannot update column "s" of view "rw_view1"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
UPDATE rw_view2 SET t = t WHERE base_a = 1.1;
RESULT:
	postgres: cannot update column "t" of view "rw_view2"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
UPDATE rw_view2 SET base_a = 1.05 WHERE base_a = 1.1;
RESULT:
	postgres: None

-----------
QUERY:
 -- OK
DELETE FROM rw_view2 WHERE base_a = 1.05 RETURNING base_a, s, c, t;
RESULT:
	postgres: [(1.05, 0.867423225594017, 0.497571047891727, 1.74331530998317)]

-----------
QUERY:
 -- OK

CREATE VIEW rw_view3 AS
  SELECT s, c, s/c t, ctid
  FROM rw_view1;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view3 VALUES (null, null, null, null);
RESULT:
	postgres: cannot insert into column "t" of view "rw_view3"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
INSERT INTO rw_view3(s) VALUES (null);
RESULT:
	postgres: cannot insert into column "s" of view "rw_view1"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
UPDATE rw_view3 SET s = s;
RESULT:
	postgres: cannot update column "s" of view "rw_view1"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:
 -- should fail
DELETE FROM rw_view3 WHERE s = sin(0.1);
RESULT:
	postgres: None

-----------
QUERY:
 -- should be OK
SELECT * FROM base_tbl ORDER BY a;
RESULT:
	postgres: [(0.2,), (0.3,), (0.4,), (0.5,), (0.6,), (0.7,), (0.8,), (0.9,), (1.0,)]

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'YES'), ('rw_view2', 'YES'), ('rw_view3', 'NO')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name;
RESULT:
	postgres: [('rw_view1', 'YES', 'YES'), ('rw_view2', 'YES', 'YES'), ('rw_view3', 'NO', 'NO')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name LIKE E'r_\\_view%'
 ORDER BY table_name, ordinal_position;
RESULT:
	postgres: [('rw_view1', 'ctid', 'NO'), ('rw_view1', 's', 'NO'), ('rw_view1', 'a', 'YES'), ('rw_view1', 'c', 'NO'), ('rw_view2', 's', 'NO'), ('rw_view2', 'c', 'NO'), ('rw_view2', 't', 'NO'), ('rw_view2', 'base_a', 'YES'), ('rw_view2', 'ctid', 'NO'), ('rw_view3', 's', 'NO'), ('rw_view3', 'c', 'NO'), ('rw_view3', 't', 'NO'), ('rw_view3', 'ctid', 'NO')]

-----------
QUERY:


SELECT events & 4 != 0 AS upd,
       events & 8 != 0 AS ins,
       events & 16 != 0 AS del
  FROM pg_catalog.pg_relation_is_updatable('rw_view3'::regclass, false) t(events);
RESULT:
	postgres: [(False, False, True)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- view on table with GENERATED columns

CREATE TABLE base_tbl (id int, idplus1 int GENERATED ALWAYS AS (id + 1) STORED);
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT * FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO base_tbl (id) VALUES (1);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view1 (id) VALUES (2);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl (id, idplus1) VALUES (3, DEFAULT);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view1 (id, idplus1) VALUES (4, DEFAULT);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl (id, idplus1) VALUES (5, 6);
RESULT:
	postgres: cannot insert a non-DEFAULT value into column "idplus1"
DETAIL:  Column "idplus1" is a generated column.


-----------
QUERY:
  -- error
INSERT INTO rw_view1 (id, idplus1) VALUES (6, 7);
RESULT:
	postgres: cannot insert a non-DEFAULT value into column "idplus1"
DETAIL:  Column "idplus1" is a generated column.


-----------
QUERY:
  -- error

SELECT * FROM base_tbl;
RESULT:
	postgres: [(1, 2), (2, 3), (3, 4), (4, 5)]

-----------
QUERY:


UPDATE base_tbl SET id = 2000 WHERE id = 2;
RESULT:
	postgres: None

-----------
QUERY:

UPDATE rw_view1 SET id = 3000 WHERE id = 3;
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM base_tbl;
RESULT:
	postgres: [(1, 2), (4, 5), (2000, 2001), (3000, 3001)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- inheritance tests

CREATE TABLE base_tbl_parent (a int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE base_tbl_child (CHECK (a > 0)) INHERITS (base_tbl_parent);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl_parent SELECT * FROM generate_series(-8, -1);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl_child SELECT * FROM generate_series(1, 8);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl_parent;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT * FROM ONLY base_tbl_parent;
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM rw_view1 ORDER BY a;
RESULT:
	postgres: [(-8,), (-7,), (-6,), (-5,), (-4,), (-3,), (-2,), (-1,), (1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,)]

-----------
QUERY:

SELECT * FROM ONLY rw_view1 ORDER BY a;
RESULT:
	postgres: [(-8,), (-7,), (-6,), (-5,), (-4,), (-3,), (-2,), (-1,), (1,), (2,), (3,), (4,), (5,), (6,), (7,), (8,)]

-----------
QUERY:

SELECT * FROM rw_view2 ORDER BY a;
RESULT:
	postgres: [(-8,), (-7,), (-6,), (-5,), (-4,), (-3,), (-2,), (-1,)]

-----------
QUERY:


INSERT INTO rw_view1 VALUES (-100), (100);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view2 VALUES (-200), (200);
RESULT:
	postgres: None

-----------
QUERY:


UPDATE rw_view1 SET a = a*10 WHERE a IN (-1, 1);
RESULT:
	postgres: None

-----------
QUERY:
 -- Should produce -10 and 10
UPDATE ONLY rw_view1 SET a = a*10 WHERE a IN (-2, 2);
RESULT:
	postgres: None

-----------
QUERY:
 -- Should produce -20 and 20
UPDATE rw_view2 SET a = a*10 WHERE a IN (-3, 3);
RESULT:
	postgres: None

-----------
QUERY:
 -- Should produce -30 only
UPDATE ONLY rw_view2 SET a = a*10 WHERE a IN (-4, 4);
RESULT:
	postgres: None

-----------
QUERY:
 -- Should produce -40 only

DELETE FROM rw_view1 WHERE a IN (-5, 5);
RESULT:
	postgres: None

-----------
QUERY:
 -- Should delete -5 and 5
DELETE FROM ONLY rw_view1 WHERE a IN (-6, 6);
RESULT:
	postgres: None

-----------
QUERY:
 -- Should delete -6 and 6
DELETE FROM rw_view2 WHERE a IN (-7, 7);
RESULT:
	postgres: None

-----------
QUERY:
 -- Should delete -7 only
DELETE FROM ONLY rw_view2 WHERE a IN (-8, 8);
RESULT:
	postgres: None

-----------
QUERY:
 -- Should delete -8 only

SELECT * FROM ONLY base_tbl_parent ORDER BY a;
RESULT:
	postgres: [(-200,), (-100,), (-40,), (-30,), (-20,), (-10,), (100,), (200,)]

-----------
QUERY:

SELECT * FROM base_tbl_child ORDER BY a;
RESULT:
	postgres: [(3,), (4,), (7,), (8,), (10,), (20,)]

-----------
QUERY:


MERGE INTO rw_view1 t USING (VALUES (-200), (10)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a+1;
RESULT:
	postgres: None

-----------
QUERY:
 -- Should produce -199 and 11
MERGE INTO ONLY rw_view1 t USING (VALUES (-100), (20)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a+1;
RESULT:
	postgres: None

-----------
QUERY:
 -- Should produce -99 and 21
MERGE INTO rw_view2 t USING (VALUES (-40), (3)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a+1;
RESULT:
	postgres: None

-----------
QUERY:
 -- Should produce -39 only
MERGE INTO ONLY rw_view2 t USING (VALUES (-30), (4)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a+1;
RESULT:
	postgres: None

-----------
QUERY:
 -- Should produce -29 only

SELECT * FROM ONLY base_tbl_parent ORDER BY a;
RESULT:
	postgres: [(-199,), (-99,), (-39,), (-29,), (-20,), (-10,), (100,), (200,)]

-----------
QUERY:

SELECT * FROM base_tbl_child ORDER BY a;
RESULT:
	postgres: [(3,), (4,), (7,), (8,), (11,), (21,)]

-----------
QUERY:


CREATE TABLE other_tbl_parent (id int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE other_tbl_child () INHERITS (other_tbl_parent);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO other_tbl_parent VALUES (7),(200);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO other_tbl_child VALUES (8),(100);
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (costs off)
UPDATE rw_view1 SET a = a + 1000 FROM other_tbl_parent WHERE a = id;
RESULT:
	postgres: [('Update on base_tbl_parent',), ('  Update on base_tbl_parent base_tbl_parent_1',), ('  Update on base_tbl_child base_tbl_parent_2',), ('  ->  Merge Join',), ('        Merge Cond: (base_tbl_parent.a = other_tbl_parent.id)',), ('        ->  Sort',), ('              Sort Key: base_tbl_parent.a',), ('              ->  Append',), ('                    ->  Seq Scan on base_tbl_parent base_tbl_parent_1',), ('                    ->  Seq Scan on base_tbl_child base_tbl_parent_2',), ('        ->  Sort',), ('              Sort Key: other_tbl_parent.id',), ('              ->  Append',), ('                    ->  Seq Scan on other_tbl_parent other_tbl_parent_1',), ('                    ->  Seq Scan on other_tbl_child other_tbl_parent_2',)]

-----------
QUERY:

UPDATE rw_view1 SET a = a + 1000 FROM other_tbl_parent WHERE a = id;
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM ONLY base_tbl_parent ORDER BY a;
RESULT:
	postgres: [(-199,), (-99,), (-39,), (-29,), (-20,), (-10,), (1100,), (1200,)]

-----------
QUERY:

SELECT * FROM base_tbl_child ORDER BY a;
RESULT:
	postgres: [(3,), (4,), (11,), (21,), (1007,), (1008,)]

-----------
QUERY:


DROP TABLE base_tbl_parent, base_tbl_child CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE other_tbl_parent CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- simple WITH CHECK OPTION

CREATE TABLE base_tbl (a int, b int DEFAULT 10);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (1,2), (2,3), (1,-1);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b
  WITH LOCAL CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:

-- \d+ rw_view1
SELECT * FROM information_schema.views WHERE table_name = 'rw_view1';
RESULT:
	postgres: [('regression', 'public', 'rw_view1', ' SELECT a,\n    b\n   FROM base_tbl\n  WHERE (a < b);', 'LOCAL', 'YES', 'YES', 'NO', 'NO', 'NO')]

-----------
QUERY:


INSERT INTO rw_view1 VALUES(3,4);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES(4,3);
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (4, 3).


-----------
QUERY:
 -- should fail
INSERT INTO rw_view1 VALUES(5,null);
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (5, null).


-----------
QUERY:
 -- should fail
UPDATE rw_view1 SET b = 5 WHERE a = 3;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET b = -5 WHERE a = 3;
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (3, -5).


-----------
QUERY:
 -- should fail
INSERT INTO rw_view1(a) VALUES (9);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view1(a) VALUES (10);
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (10, 10).


-----------
QUERY:
 -- should fail
SELECT * FROM base_tbl ORDER BY a, b;
RESULT:
	postgres: [(1, -1), (1, 2), (2, 3), (3, 5), (9, 10)]

-----------
QUERY:


MERGE INTO rw_view1 t USING (VALUES (10)) AS v(a) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a, v.a + 1);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (11)) AS v(a) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a, v.a - 1);
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (11, 10).


-----------
QUERY:
 -- should fail
MERGE INTO rw_view1 t USING (VALUES (1)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a - 1;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
MERGE INTO rw_view1 t USING (VALUES (2)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a + 1;
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (3, 3).


-----------
QUERY:
 -- should fail
SELECT * FROM base_tbl ORDER BY a, b;
RESULT:
	postgres: [(0, 2), (1, -1), (2, 3), (3, 5), (9, 10), (10, 11)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- WITH LOCAL/CASCADED CHECK OPTION

CREATE TABLE base_tbl (a int);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a > 0;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
  WITH CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:
 -- implicitly cascaded
-- \d+ rw_view2
SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
RESULT:
	postgres: [('regression', 'public', 'rw_view2', ' SELECT a\n   FROM rw_view1\n  WHERE (a < 10);', 'CASCADED', 'YES', 'YES', 'NO', 'NO', 'NO')]

-----------
QUERY:


INSERT INTO rw_view2 VALUES (-5);
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (-5).


-----------
QUERY:
 -- should fail
INSERT INTO rw_view2 VALUES (5);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view2 VALUES (15);
RESULT:
	postgres: new row violates check option for view "rw_view2"
DETAIL:  Failing row contains (15).


-----------
QUERY:
 -- should fail
SELECT * FROM base_tbl;
RESULT:
	postgres: [(5,)]

-----------
QUERY:


UPDATE rw_view2 SET a = a - 10;
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (-5).


-----------
QUERY:
 -- should fail
UPDATE rw_view2 SET a = a + 10;
RESULT:
	postgres: new row violates check option for view "rw_view2"
DETAIL:  Failing row contains (15).


-----------
QUERY:
 -- should fail

CREATE OR REPLACE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a < 10
  WITH LOCAL CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:

-- \d+ rw_view2
SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
RESULT:
	postgres: [('regression', 'public', 'rw_view2', ' SELECT a\n   FROM rw_view1\n  WHERE (a < 10);', 'LOCAL', 'YES', 'YES', 'NO', 'NO', 'NO')]

-----------
QUERY:


INSERT INTO rw_view2 VALUES (-10);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view
INSERT INTO rw_view2 VALUES (20);
RESULT:
	postgres: new row violates check option for view "rw_view2"
DETAIL:  Failing row contains (20).


-----------
QUERY:
 -- should fail
SELECT * FROM base_tbl;
RESULT:
	postgres: [(5,), (-10,)]

-----------
QUERY:


ALTER VIEW rw_view1 SET (check_option=here);
RESULT:
	postgres: invalid value for enum option "check_option": here
DETAIL:  Valid values are "local" and "cascaded".


-----------
QUERY:
 -- invalid
ALTER VIEW rw_view1 SET (check_option=local);
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view2 VALUES (-20);
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (-20).


-----------
QUERY:
 -- should fail
INSERT INTO rw_view2 VALUES (30);
RESULT:
	postgres: new row violates check option for view "rw_view2"
DETAIL:  Failing row contains (30).


-----------
QUERY:
 -- should fail

ALTER VIEW rw_view2 RESET (check_option);
RESULT:
	postgres: None

-----------
QUERY:

-- \d+ rw_view2
SELECT * FROM information_schema.views WHERE table_name = 'rw_view2';
RESULT:
	postgres: [('regression', 'public', 'rw_view2', ' SELECT a\n   FROM rw_view1\n  WHERE (a < 10);', 'NONE', 'YES', 'YES', 'NO', 'NO', 'NO')]

-----------
QUERY:

INSERT INTO rw_view2 VALUES (30);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view
SELECT * FROM base_tbl;
RESULT:
	postgres: [(5,), (-10,), (30,)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- WITH CHECK OPTION with no local view qual

CREATE TABLE base_tbl (a int);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WITH CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view2 AS SELECT * FROM rw_view1 WHERE a > 0;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view3 AS SELECT * FROM rw_view2 WITH CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM information_schema.views WHERE table_name LIKE E'rw\\_view_' ORDER BY table_name;
RESULT:
	postgres: [('regression', 'public', 'rw_view1', ' SELECT a\n   FROM base_tbl;', 'CASCADED', 'YES', 'YES', 'NO', 'NO', 'NO'), ('regression', 'public', 'rw_view2', ' SELECT a\n   FROM rw_view1\n  WHERE (a > 0);', 'NONE', 'YES', 'YES', 'NO', 'NO', 'NO'), ('regression', 'public', 'rw_view3', ' SELECT a\n   FROM rw_view2;', 'CASCADED', 'YES', 'YES', 'NO', 'NO', 'NO')]

-----------
QUERY:


INSERT INTO rw_view1 VALUES (-1);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES (1);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view2 VALUES (-2);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view
INSERT INTO rw_view2 VALUES (2);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view3 VALUES (-3);
RESULT:
	postgres: new row violates check option for view "rw_view2"
DETAIL:  Failing row contains (-3).


-----------
QUERY:
 -- should fail
INSERT INTO rw_view3 VALUES (3);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok

DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- WITH CHECK OPTION with scalar array ops

CREATE TABLE base_tbl (a int, b int[]);
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a = ANY (b)
  WITH CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view1 VALUES (1, ARRAY[1,2,3]);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES (10, ARRAY[4,5]);
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (10, {4,5}).


-----------
QUERY:
 -- should fail

UPDATE rw_view1 SET b[2] = -b[2] WHERE a = 1;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET b[1] = -b[1] WHERE a = 1;
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (1, {-1,-2,3}).


-----------
QUERY:
 -- should fail

PREPARE ins(int, int[]) AS INSERT INTO rw_view1 VALUES($1, $2);
RESULT:
	postgres: None

-----------
QUERY:

EXECUTE ins(2, ARRAY[1,2,3]);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
EXECUTE ins(10, ARRAY[4,5]);
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (10, {4,5}).


-----------
QUERY:
 -- should fail
DEALLOCATE PREPARE ins;
RESULT:
	postgres: None

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- WITH CHECK OPTION with subquery

CREATE TABLE base_tbl (a int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE ref_tbl (a int PRIMARY KEY);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO ref_tbl SELECT * FROM generate_series(1,10);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS
  SELECT * FROM base_tbl b
  WHERE EXISTS(SELECT 1 FROM ref_tbl r WHERE r.a = b.a)
  WITH CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view1 VALUES (5);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES (15);
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (15).


-----------
QUERY:
 -- should fail

UPDATE rw_view1 SET a = a + 5;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
UPDATE rw_view1 SET a = a + 5;
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (15).


-----------
QUERY:
 -- should fail

EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (5);
RESULT:
	postgres: [('Insert on base_tbl b',), ('  ->  Result',), ('  SubPlan 1',), ('    ->  Index Only Scan using ref_tbl_pkey on ref_tbl r',), ('          Index Cond: (a = b.a)',)]

-----------
QUERY:

EXPLAIN (costs off) UPDATE rw_view1 SET a = a + 5;
RESULT:
	postgres: [('Update on base_tbl b',), ('  ->  Hash Join',), ('        Hash Cond: (b.a = r.a)',), ('        ->  Seq Scan on base_tbl b',), ('        ->  Hash',), ('              ->  Seq Scan on ref_tbl r',), ('  SubPlan 1',), ('    ->  Index Only Scan using ref_tbl_pkey on ref_tbl r_1',), ('          Index Cond: (a = b.a)',)]

-----------
QUERY:


DROP TABLE base_tbl, ref_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- WITH CHECK OPTION with BEFORE trigger on base table

CREATE TABLE base_tbl (a int, b int);
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION base_tbl_trig_fn()
RETURNS trigger AS
$$
BEGIN
  NEW.b := 10;
  RETURN NEW;
END;
$$
LANGUAGE plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER base_tbl_trig BEFORE INSERT OR UPDATE ON base_tbl
  FOR EACH ROW EXECUTE PROCEDURE base_tbl_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT * FROM base_tbl WHERE a < b WITH CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view1 VALUES (5,0);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view1 VALUES (15, 20);
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (15, 10).


-----------
QUERY:
 -- should fail
UPDATE rw_view1 SET a = 20, b = 30;
RESULT:
	postgres: new row violates check option for view "rw_view1"
DETAIL:  Failing row contains (20, 10).


-----------
QUERY:
 -- should fail

DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP FUNCTION base_tbl_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:


-- WITH LOCAL CHECK OPTION with INSTEAD OF trigger on base view

CREATE TABLE base_tbl (a int, b int);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS SELECT a FROM base_tbl WHERE a < b;
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION rw_view1_trig_fn()
RETURNS trigger AS
$$
BEGIN
  IF TG_OP = 'INSERT' THEN
    INSERT INTO base_tbl VALUES (NEW.a, 10);
    RETURN NEW;
  ELSIF TG_OP = 'UPDATE' THEN
    UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
    RETURN NEW;
  ELSIF TG_OP = 'DELETE' THEN
    DELETE FROM base_tbl WHERE a=OLD.a;
    RETURN OLD;
  END IF;
END;
$$
LANGUAGE plpgsql;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TRIGGER rw_view1_trig
  INSTEAD OF INSERT OR UPDATE OR DELETE ON rw_view1
  FOR EACH ROW EXECUTE PROCEDURE rw_view1_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view2 AS
  SELECT * FROM rw_view1 WHERE a > 0 WITH LOCAL CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO rw_view2 VALUES (-5);
RESULT:
	postgres: new row violates check option for view "rw_view2"
DETAIL:  Failing row contains (-5).


-----------
QUERY:
 -- should fail
MERGE INTO rw_view2 t USING (VALUES (-5)) AS v(a) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a);
RESULT:
	postgres: new row violates check option for view "rw_view2"
DETAIL:  Failing row contains (-5).


-----------
QUERY:
 -- should fail
INSERT INTO rw_view2 VALUES (5);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
MERGE INTO rw_view2 t USING (VALUES (6)) AS v(a) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view2 VALUES (50);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view
MERGE INTO rw_view2 t USING (VALUES (60)) AS v(a) ON t.a = v.a
  WHEN NOT MATCHED THEN INSERT VALUES (v.a);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view
UPDATE rw_view2 SET a = a - 10;
RESULT:
	postgres: new row violates check option for view "rw_view2"
DETAIL:  Failing row contains (-5).


-----------
QUERY:
 -- should fail
MERGE INTO rw_view2 t USING (VALUES (6)) AS v(a) ON t.a = v.a
  WHEN MATCHED THEN UPDATE SET a = t.a - 10;
RESULT:
	postgres: new row violates check option for view "rw_view2"
DETAIL:  Failing row contains (-4).


-----------
QUERY:
 -- should fail
SELECT * FROM base_tbl;
RESULT:
	postgres: [(5, 10), (6, 10), (50, 10), (60, 10)]

-----------
QUERY:


-- Check option won/* REPLACED */''t cascade down to base view with INSTEAD OF triggers

ALTER VIEW rw_view2 SET (check_option=cascaded);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view2 VALUES (100);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view1/* REPLACED */''s check)
UPDATE rw_view2 SET a = 200 WHERE a = 5;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view1/* REPLACED */''s check)
SELECT * FROM base_tbl;
RESULT:
	postgres: [(6, 10), (50, 10), (60, 10), (100, 10), (200, 10)]

-----------
QUERY:


-- Neither local nor cascaded check options work with INSTEAD rules

DROP TRIGGER rw_view1_trig ON rw_view1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a, 10);
RESULT:
	postgres: None

-----------
QUERY:

CREATE RULE rw_view1_upd_rule AS ON UPDATE TO rw_view1
  DO INSTEAD UPDATE base_tbl SET a=NEW.a WHERE a=OLD.a;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view2 VALUES (-10);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view2/* REPLACED */''s check)
INSERT INTO rw_view2 VALUES (5);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO rw_view2 VALUES (20);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view1/* REPLACED */''s check)
UPDATE rw_view2 SET a = 30 WHERE a = 5;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view1/* REPLACED */''s check)
INSERT INTO rw_view2 VALUES (5);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
UPDATE rw_view2 SET a = -5 WHERE a = 5;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view2/* REPLACED */''s check)
SELECT * FROM base_tbl;
RESULT:
	postgres: [(6, 10), (50, 10), (60, 10), (100, 10), (200, 10), (-10, 10), (20, 10), (30, 10), (-5, 10)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP FUNCTION rw_view1_trig_fn();
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE base_tbl (a int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view1 AS SELECT a,10 AS b FROM base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

CREATE RULE rw_view1_ins_rule AS ON INSERT TO rw_view1
  DO INSTEAD INSERT INTO base_tbl VALUES (NEW.a);
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW rw_view2 AS
  SELECT * FROM rw_view1 WHERE a > b WITH LOCAL CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO rw_view2 VALUES (2,3);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok, but not in view (doesn/* REPLACED */''t fail rw_view2/* REPLACED */''s check)
DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- security barrier view

CREATE TABLE base_tbl (person text, visibility text);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES ('Tom', 'public'),
                            ('Dick', 'private'),
                            ('Harry', 'public');
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 AS
  SELECT person FROM base_tbl WHERE visibility = 'public';
RESULT:
	postgres: None

-----------
QUERY:


CREATE FUNCTION snoop(anyelement)
RETURNS boolean AS
$$
BEGIN
  RAISE NOTICE 'snooped value: %', $1;
  RETURN true;
END;
$$
LANGUAGE plpgsql COST 0.000001;
RESULT:
	postgres: None

-----------
QUERY:


CREATE OR REPLACE FUNCTION leakproof(anyelement)
RETURNS boolean AS
$$
BEGIN
  RETURN true;
END;
$$
LANGUAGE plpgsql STRICT IMMUTABLE LEAKPROOF;
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM rw_view1 WHERE snoop(person);
RESULT:
	postgres: [('Tom',), ('Harry',)]

-----------
QUERY:

UPDATE rw_view1 SET person=person WHERE snoop(person);
RESULT:
	postgres: None

-----------
QUERY:

DELETE FROM rw_view1 WHERE NOT snoop(person);
RESULT:
	postgres: None

-----------
QUERY:


ALTER VIEW rw_view1 SET (security_barrier = true);
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name = 'rw_view1';
RESULT:
	postgres: [('rw_view1', 'YES')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name = 'rw_view1';
RESULT:
	postgres: [('rw_view1', 'YES', 'YES')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name = 'rw_view1'
 ORDER BY ordinal_position;
RESULT:
	postgres: [('rw_view1', 'person', 'YES')]

-----------
QUERY:


SELECT * FROM rw_view1 WHERE snoop(person);
RESULT:
	postgres: [('Tom',), ('Harry',)]

-----------
QUERY:

UPDATE rw_view1 SET person=person WHERE snoop(person);
RESULT:
	postgres: None

-----------
QUERY:

DELETE FROM rw_view1 WHERE NOT snoop(person);
RESULT:
	postgres: None

-----------
QUERY:

MERGE INTO rw_view1 t
  USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS v(person) ON t.person = v.person
  WHEN MATCHED AND snoop(t.person) THEN UPDATE SET person = v.person;
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (costs off) SELECT * FROM rw_view1 WHERE snoop(person);
RESULT:
	postgres: [('Subquery Scan on rw_view1',), ('  Filter: snoop(rw_view1.person)',), ('  ->  Seq Scan on base_tbl',), ("        Filter: (visibility = 'public'::text)",)]

-----------
QUERY:

EXPLAIN (costs off) UPDATE rw_view1 SET person=person WHERE snoop(person);
RESULT:
	postgres: [('Update on base_tbl',), ('  ->  Seq Scan on base_tbl',), ("        Filter: ((visibility = 'public'::text) AND snoop(person))",)]

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view1 WHERE NOT snoop(person);
RESULT:
	postgres: [('Delete on base_tbl',), ('  ->  Seq Scan on base_tbl',), ("        Filter: ((visibility = 'public'::text) AND (NOT snoop(person)))",)]

-----------
QUERY:

EXPLAIN (costs off)
MERGE INTO rw_view1 t
  USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS v(person) ON t.person = v.person
  WHEN MATCHED AND snoop(t.person) THEN UPDATE SET person = v.person;
RESULT:
	postgres: [('Merge on base_tbl',), ('  ->  Nested Loop',), ('        Join Filter: (base_tbl.person = "*VALUES*".column1)',), ('        ->  Seq Scan on base_tbl',), ("              Filter: (visibility = 'public'::text)",), ('        ->  Materialize',), ('              ->  Values Scan on "*VALUES*"',)]

-----------
QUERY:


-- security barrier view on top of security barrier view

CREATE VIEW rw_view2 WITH (security_barrier = true) AS
  SELECT * FROM rw_view1 WHERE snoop(person);
RESULT:
	postgres: None

-----------
QUERY:


SELECT table_name, is_insertable_into
  FROM information_schema.tables
 WHERE table_name = 'rw_view2';
RESULT:
	postgres: [('rw_view2', 'YES')]

-----------
QUERY:


SELECT table_name, is_updatable, is_insertable_into
  FROM information_schema.views
 WHERE table_name = 'rw_view2';
RESULT:
	postgres: [('rw_view2', 'YES', 'YES')]

-----------
QUERY:


SELECT table_name, column_name, is_updatable
  FROM information_schema.columns
 WHERE table_name = 'rw_view2'
 ORDER BY ordinal_position;
RESULT:
	postgres: [('rw_view2', 'person', 'YES')]

-----------
QUERY:


SELECT * FROM rw_view2 WHERE snoop(person);
RESULT:
	postgres: [('Tom',), ('Harry',)]

-----------
QUERY:

UPDATE rw_view2 SET person=person WHERE snoop(person);
RESULT:
	postgres: None

-----------
QUERY:

DELETE FROM rw_view2 WHERE NOT snoop(person);
RESULT:
	postgres: None

-----------
QUERY:

MERGE INTO rw_view2 t
  USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS v(person) ON t.person = v.person
  WHEN MATCHED AND snoop(t.person) THEN UPDATE SET person = v.person;
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (costs off) SELECT * FROM rw_view2 WHERE snoop(person);
RESULT:
	postgres: [('Subquery Scan on rw_view2',), ('  Filter: snoop(rw_view2.person)',), ('  ->  Subquery Scan on rw_view1',), ('        Filter: snoop(rw_view1.person)',), ('        ->  Seq Scan on base_tbl',), ("              Filter: (visibility = 'public'::text)",)]

-----------
QUERY:

EXPLAIN (costs off) UPDATE rw_view2 SET person=person WHERE snoop(person);
RESULT:
	postgres: [('Update on base_tbl',), ('  ->  Seq Scan on base_tbl',), ("        Filter: ((visibility = 'public'::text) AND snoop(person) AND snoop(person))",)]

-----------
QUERY:

EXPLAIN (costs off) DELETE FROM rw_view2 WHERE NOT snoop(person);
RESULT:
	postgres: [('Delete on base_tbl',), ('  ->  Seq Scan on base_tbl',), ("        Filter: ((visibility = 'public'::text) AND snoop(person) AND (NOT snoop(person)))",)]

-----------
QUERY:

EXPLAIN (costs off)
MERGE INTO rw_view2 t
  USING (VALUES ('Tom'), ('Dick'), ('Harry')) AS v(person) ON t.person = v.person
  WHEN MATCHED AND snoop(t.person) THEN UPDATE SET person = v.person;
RESULT:
	postgres: [('Merge on base_tbl',), ('  ->  Nested Loop',), ('        Join Filter: (base_tbl.person = "*VALUES*".column1)',), ('        ->  Seq Scan on base_tbl',), ("              Filter: ((visibility = 'public'::text) AND snoop(person))",), ('        ->  Values Scan on "*VALUES*"',)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- security barrier view on top of table with rules

CREATE TABLE base_tbl(id int PRIMARY KEY, data text, deleted boolean);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO base_tbl VALUES (1, 'Row 1', false), (2, 'Row 2', true);
RESULT:
	postgres: None

-----------
QUERY:


CREATE RULE base_tbl_ins_rule AS ON INSERT TO base_tbl
  WHERE EXISTS (SELECT 1 FROM base_tbl t WHERE t.id = new.id)
  DO INSTEAD
    UPDATE base_tbl SET data = new.data, deleted = false WHERE id = new.id;
RESULT:
	postgres: None

-----------
QUERY:


CREATE RULE base_tbl_del_rule AS ON DELETE TO base_tbl
  DO INSTEAD
    UPDATE base_tbl SET deleted = true WHERE id = old.id;
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW rw_view1 WITH (security_barrier=true) AS
  SELECT id, data FROM base_tbl WHERE NOT deleted;
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM rw_view1;
RESULT:
	postgres: [(1, 'Row 1')]

-----------
QUERY:


EXPLAIN (costs off) DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
RESULT:
	postgres: [('Update on base_tbl base_tbl_1',), ('  ->  Nested Loop',), ('        ->  Index Scan using base_tbl_pkey on base_tbl base_tbl_1',), ('              Index Cond: (id = 1)',), ('        ->  Index Scan using base_tbl_pkey on base_tbl',), ('              Index Cond: (id = 1)',), ('              Filter: ((NOT deleted) AND snoop(data))',)]

-----------
QUERY:

DELETE FROM rw_view1 WHERE id = 1 AND snoop(data);
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (costs off) INSERT INTO rw_view1 VALUES (2, 'New row 2');
RESULT:
	postgres: [('Insert on base_tbl',), ('  InitPlan 1',), ('    ->  Index Only Scan using base_tbl_pkey on base_tbl t',), ('          Index Cond: (id = 2)',), ('  ->  Result',), ('        One-Time Filter: ((InitPlan 1).col1 IS NOT TRUE)',), ('',), ('Update on base_tbl',), ('  InitPlan 1',), ('    ->  Index Only Scan using base_tbl_pkey on base_tbl t',), ('          Index Cond: (id = 2)',), ('  ->  Result',), ('        One-Time Filter: (InitPlan 1).col1',), ('        ->  Index Scan using base_tbl_pkey on base_tbl',), ('              Index Cond: (id = 2)',)]

-----------
QUERY:

INSERT INTO rw_view1 VALUES (2, 'New row 2');
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM base_tbl;
RESULT:
	postgres: [(1, 'Row 1', True), (2, 'New row 2', False)]

-----------
QUERY:


DROP TABLE base_tbl CASCADE;
RESULT:
	postgres: None

-----------
QUERY:


-- security barrier view based on inheritance set
CREATE TABLE t1 (a int, b float, c text);
RESULT:
	postgres: None

-----------
QUERY:

CREATE INDEX t1_a_idx ON t1(a);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t1
SELECT i,i,'t1' FROM generate_series(1,10) g(i);
RESULT:
	postgres: None

-----------
QUERY:

ANALYZE t1;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE t11 (d text) INHERITS (t1);
RESULT:
	postgres: None

-----------
QUERY:

CREATE INDEX t11_a_idx ON t11(a);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t11
SELECT i,i,'t11','t11d' FROM generate_series(1,10) g(i);
RESULT:
	postgres: None

-----------
QUERY:

ANALYZE t11;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE t12 (e int[]) INHERITS (t1);
RESULT:
	postgres: None

-----------
QUERY:

CREATE INDEX t12_a_idx ON t12(a);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t12
SELECT i,i,'t12','{1,2}'::int[] FROM generate_series(1,10) g(i);
RESULT:
	postgres: None

-----------
QUERY:

ANALYZE t12;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE t111 () INHERITS (t11, t12);
RESULT:
	postgres: None

-----------
QUERY:

CREATE INDEX t111_a_idx ON t111(a);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t111
SELECT i,i,'t111','t111d','{1,1,1}'::int[] FROM generate_series(1,10) g(i);
RESULT:
	postgres: None

-----------
QUERY:

ANALYZE t111;
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW v1 WITH (security_barrier=true) AS
SELECT *, (SELECT d FROM t11 WHERE t11.a = t1.a LIMIT 1) AS d
FROM t1
WHERE a > 5 AND EXISTS(SELECT 1 FROM t12 WHERE t12.a = t1.a);
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM v1 WHERE a=3;
RESULT:
	postgres: []

-----------
QUERY:
 -- should not see anything
SELECT * FROM v1 WHERE a=8;
RESULT:
	postgres: [(8, 8.0, 't1', 't11d'), (8, 8.0, 't11', 't11d'), (8, 8.0, 't12', 't11d'), (8, 8.0, 't111', 't11d')]

-----------
QUERY:


EXPLAIN (VERBOSE, COSTS OFF)
UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
RESULT:
	postgres: [('Update on public.t1',), ('  Update on public.t1 t1_1',), ('  Update on public.t11 t1_2',), ('  Update on public.t12 t1_3',), ('  Update on public.t111 t1_4',), ('  ->  Result',), ('        Output: 100, t1.tableoid, t1.ctid',), ('        ->  Append',), ('              ->  Index Scan using t1_a_idx on public.t1 t1_1',), ('                    Output: t1_1.tableoid, t1_1.ctid',), ('                    Index Cond: ((t1_1.a > 5) AND (t1_1.a < 7))',), ('                    Filter: ((t1_1.a <> 6) AND EXISTS(SubPlan 1) AND snoop(t1_1.a) AND leakproof(t1_1.a))',), ('                    SubPlan 1',), ('                      ->  Append',), ('                            ->  Seq Scan on public.t12 t12_1',), ('                                  Filter: (t12_1.a = t1_1.a)',), ('                            ->  Seq Scan on public.t111 t12_2',), ('                                  Filter: (t12_2.a = t1_1.a)',), ('              ->  Index Scan using t11_a_idx on public.t11 t1_2',), ('                    Output: t1_2.tableoid, t1_2.ctid',), ('                    Index Cond: ((t1_2.a > 5) AND (t1_2.a < 7))',), ('                    Filter: ((t1_2.a <> 6) AND EXISTS(SubPlan 1) AND snoop(t1_2.a) AND leakproof(t1_2.a))',), ('              ->  Index Scan using t12_a_idx on public.t12 t1_3',), ('                    Output: t1_3.tableoid, t1_3.ctid',), ('                    Index Cond: ((t1_3.a > 5) AND (t1_3.a < 7))',), ('                    Filter: ((t1_3.a <> 6) AND EXISTS(SubPlan 1) AND snoop(t1_3.a) AND leakproof(t1_3.a))',), ('              ->  Index Scan using t111_a_idx on public.t111 t1_4',), ('                    Output: t1_4.tableoid, t1_4.ctid',), ('                    Index Cond: ((t1_4.a > 5) AND (t1_4.a < 7))',), ('                    Filter: ((t1_4.a <> 6) AND EXISTS(SubPlan 1) AND snoop(t1_4.a) AND leakproof(t1_4.a))',)]

-----------
QUERY:

UPDATE v1 SET a=100 WHERE snoop(a) AND leakproof(a) AND a < 7 AND a != 6;
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM v1 WHERE a=100;
RESULT:
	postgres: []

-----------
QUERY:
 -- Nothing should have been changed to 100
SELECT * FROM t1 WHERE a=100;
RESULT:
	postgres: []

-----------
QUERY:
 -- Nothing should have been changed to 100

EXPLAIN (VERBOSE, COSTS OFF)
UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
RESULT:
	postgres: [('Update on public.t1',), ('  Update on public.t1 t1_1',), ('  Update on public.t11 t1_2',), ('  Update on public.t12 t1_3',), ('  Update on public.t111 t1_4',), ('  ->  Result',), ('        Output: (t1.a + 1), t1.tableoid, t1.ctid',), ('        ->  Append',), ('              ->  Index Scan using t1_a_idx on public.t1 t1_1',), ('                    Output: t1_1.a, t1_1.tableoid, t1_1.ctid',), ('                    Index Cond: ((t1_1.a > 5) AND (t1_1.a = 8))',), ('                    Filter: (EXISTS(SubPlan 1) AND snoop(t1_1.a) AND leakproof(t1_1.a))',), ('                    SubPlan 1',), ('                      ->  Append',), ('                            ->  Seq Scan on public.t12 t12_1',), ('                                  Filter: (t12_1.a = t1_1.a)',), ('                            ->  Seq Scan on public.t111 t12_2',), ('                                  Filter: (t12_2.a = t1_1.a)',), ('              ->  Index Scan using t11_a_idx on public.t11 t1_2',), ('                    Output: t1_2.a, t1_2.tableoid, t1_2.ctid',), ('                    Index Cond: ((t1_2.a > 5) AND (t1_2.a = 8))',), ('                    Filter: (EXISTS(SubPlan 1) AND snoop(t1_2.a) AND leakproof(t1_2.a))',), ('              ->  Index Scan using t12_a_idx on public.t12 t1_3',), ('                    Output: t1_3.a, t1_3.tableoid, t1_3.ctid',), ('                    Index Cond: ((t1_3.a > 5) AND (t1_3.a = 8))',), ('                    Filter: (EXISTS(SubPlan 1) AND snoop(t1_3.a) AND leakproof(t1_3.a))',), ('              ->  Index Scan using t111_a_idx on public.t111 t1_4',), ('                    Output: t1_4.a, t1_4.tableoid, t1_4.ctid',), ('                    Index Cond: ((t1_4.a > 5) AND (t1_4.a = 8))',), ('                    Filter: (EXISTS(SubPlan 1) AND snoop(t1_4.a) AND leakproof(t1_4.a))',)]

-----------
QUERY:

UPDATE v1 SET a=a+1 WHERE snoop(a) AND leakproof(a) AND a = 8;
RESULT:
	postgres: None

-----------
QUERY:


SELECT * FROM v1 WHERE b=8;
RESULT:
	postgres: [(9, 8.0, 't1', 't11d'), (9, 8.0, 't11', 't11d'), (9, 8.0, 't12', 't11d'), (9, 8.0, 't111', 't11d')]

-----------
QUERY:


DELETE FROM v1 WHERE snoop(a) AND leakproof(a);
RESULT:
	postgres: None

-----------
QUERY:
 -- should not delete everything, just where a>5

TABLE t1;
RESULT:
	postgres: [(1, 1.0, 't1'), (2, 2.0, 't1'), (3, 3.0, 't1'), (4, 4.0, 't1'), (5, 5.0, 't1'), (1, 1.0, 't11'), (2, 2.0, 't11'), (3, 3.0, 't11'), (4, 4.0, 't11'), (5, 5.0, 't11'), (1, 1.0, 't12'), (2, 2.0, 't12'), (3, 3.0, 't12'), (4, 4.0, 't12'), (5, 5.0, 't12'), (1, 1.0, 't111'), (2, 2.0, 't111'), (3, 3.0, 't111'), (4, 4.0, 't111'), (5, 5.0, 't111')]

-----------
QUERY:
 -- verify all a<=5 are intact

DROP TABLE t1, t11, t12, t111 CASCADE;
RESULT:
	postgres: None

-----------
QUERY:

DROP FUNCTION snoop(anyelement);
RESULT:
	postgres: None

-----------
QUERY:

DROP FUNCTION leakproof(anyelement);
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE tx1 (a integer);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE tx2 (b integer);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE tx3 (c integer);
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO vx1 values (1);
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM tx1;
RESULT:
	postgres: [(1,)]

-----------
QUERY:

SELECT * FROM vx1;
RESULT:
	postgres: []

-----------
QUERY:


DROP VIEW vx1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE tx1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE tx2;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE tx3;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE tx1 (a integer);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE tx2 (b integer);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE tx3 (c integer);
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO vx1 VALUES (1);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO vx1 VALUES (1);
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM tx1;
RESULT:
	postgres: [(1,), (1,)]

-----------
QUERY:

SELECT * FROM vx1;
RESULT:
	postgres: []

-----------
QUERY:


DROP VIEW vx1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE tx1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE tx2;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE tx3;
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE tx1 (a integer, b integer);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE tx2 (b integer, c integer);
RESULT:
	postgres: None

-----------
QUERY:

CREATE TABLE tx3 (c integer, d integer);
RESULT:
	postgres: None

-----------
QUERY:

ALTER TABLE tx1 DROP COLUMN b;
RESULT:
	postgres: None

-----------
QUERY:

ALTER TABLE tx2 DROP COLUMN c;
RESULT:
	postgres: None

-----------
QUERY:

ALTER TABLE tx3 DROP COLUMN d;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW vx1 AS SELECT a FROM tx1 WHERE EXISTS(SELECT 1 FROM tx2 JOIN tx3 ON b=c);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO vx1 VALUES (1);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO vx1 VALUES (1);
RESULT:
	postgres: None

-----------
QUERY:

SELECT * FROM tx1;
RESULT:
	postgres: [(1,), (1,)]

-----------
QUERY:

SELECT * FROM vx1;
RESULT:
	postgres: []

-----------
QUERY:


DROP VIEW vx1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE tx1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE tx2;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE tx3;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test handling of vars from correlated subqueries in quals from outer
-- security barrier views, per bug #13988
--
CREATE TABLE t1 (a int, b text, c int);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t1 VALUES (1, 'one', 10);
RESULT:
	postgres: None

-----------
QUERY:


CREATE TABLE t2 (cc int);
RESULT:
	postgres: None

-----------
QUERY:

INSERT INTO t2 VALUES (10), (20);
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW v1 WITH (security_barrier = true) AS
  SELECT * FROM t1 WHERE (a > 0)
  WITH CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:


CREATE VIEW v2 WITH (security_barrier = true) AS
  SELECT * FROM v1 WHERE EXISTS (SELECT 1 FROM t2 WHERE t2.cc = v1.c)
  WITH CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO v2 VALUES (2, 'two', 20);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO v2 VALUES (-2, 'minus two', 20);
RESULT:
	postgres: new row violates check option for view "v1"
DETAIL:  Failing row contains (-2, minus two, 20).


-----------
QUERY:
 -- not allowed
INSERT INTO v2 VALUES (3, 'three', 30);
RESULT:
	postgres: new row violates check option for view "v2"
DETAIL:  Failing row contains (3, three, 30).


-----------
QUERY:
 -- not allowed

UPDATE v2 SET b = 'ONE' WHERE a = 1;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
UPDATE v2 SET a = -1 WHERE a = 1;
RESULT:
	postgres: new row violates check option for view "v1"
DETAIL:  Failing row contains (-1, ONE, 10).


-----------
QUERY:
 -- not allowed
UPDATE v2 SET c = 30 WHERE a = 1;
RESULT:
	postgres: new row violates check option for view "v2"
DETAIL:  Failing row contains (1, ONE, 30).


-----------
QUERY:
 -- not allowed

DELETE FROM v2 WHERE a = 2;
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
SELECT * FROM v2;
RESULT:
	postgres: [(1, 'ONE', 10)]

-----------
QUERY:


DROP VIEW v2;
RESULT:
	postgres: None

-----------
QUERY:

DROP VIEW v1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE t2;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE t1;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test sub-select in nested security barrier views, per bug #17972
--
CREATE TABLE t1 (a int);
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW v1 WITH (security_barrier = true) AS
  SELECT * FROM t1;
RESULT:
	postgres: None

-----------
QUERY:

CREATE RULE v1_upd_rule AS ON UPDATE TO v1 DO INSTEAD
  UPDATE t1 SET a = NEW.a WHERE a = OLD.a;
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW v2 WITH (security_barrier = true) AS
  SELECT * FROM v1 WHERE EXISTS (SELECT 1);
RESULT:
	postgres: None

-----------
QUERY:


EXPLAIN (COSTS OFF) UPDATE v2 SET a = 1;
RESULT:
	postgres: [('Update on t1',), ('  InitPlan 1',), ('    ->  Result',), ('  ->  Merge Join',), ('        Merge Cond: (t1.a = v1.a)',), ('        ->  Sort',), ('              Sort Key: t1.a',), ('              ->  Seq Scan on t1',), ('        ->  Sort',), ('              Sort Key: v1.a',), ('              ->  Subquery Scan on v1',), ('                    ->  Result',), ('                          One-Time Filter: (InitPlan 1).col1',), ('                          ->  Seq Scan on t1 t1_1',)]

-----------
QUERY:


DROP VIEW v2;
RESULT:
	postgres: None

-----------
QUERY:

DROP VIEW v1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE t1;
RESULT:
	postgres: None

-----------
QUERY:


--
-- Test CREATE OR REPLACE VIEW turning a non-updatable view into an
-- auto-updatable view and adding check options in a single step
--
CREATE TABLE t1 (a int, b text);
RESULT:
	postgres: None

-----------
QUERY:

CREATE VIEW v1 AS SELECT null::int AS a;
RESULT:
	postgres: None

-----------
QUERY:

CREATE OR REPLACE VIEW v1 AS SELECT * FROM t1 WHERE a > 0 WITH CHECK OPTION;
RESULT:
	postgres: None

-----------
QUERY:


INSERT INTO v1 VALUES (1, 'ok');
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
INSERT INTO v1 VALUES (-1, 'invalid');
RESULT:
	postgres: new row violates check option for view "v1"
DETAIL:  Failing row contains (-1, invalid).


-----------
QUERY:
 -- should fail

DROP VIEW v1;
RESULT:
	postgres: None

-----------
QUERY:

DROP TABLE t1;
RESULT:
	postgres: None

-----------
QUERY:


-- check that an auto-updatable view on a partitioned table works correctly
create table uv_pt (a int, b int, v varchar) partition by range (a, b);
RESULT:
	postgres: None

-----------
QUERY:

create table uv_pt1 (b int not null, v varchar, a int not null) partition by range (b);
RESULT:
	postgres: None

-----------
QUERY:

create table uv_pt11 (like uv_pt1);
RESULT:
	postgres: None

-----------
QUERY:

alter table uv_pt11 drop a;
RESULT:
	postgres: None

-----------
QUERY:

alter table uv_pt11 add a int;
RESULT:
	postgres: None

-----------
QUERY:

alter table uv_pt11 drop a;
RESULT:
	postgres: None

-----------
QUERY:

alter table uv_pt11 add a int not null;
RESULT:
	postgres: None

-----------
QUERY:

alter table uv_pt1 attach partition uv_pt11 for values from (2) to (5);
RESULT:
	postgres: None

-----------
QUERY:

alter table uv_pt attach partition uv_pt1 for values from (1, 2) to (1, 10);
RESULT:
	postgres: None

-----------
QUERY:


create view uv_ptv as select * from uv_pt;
RESULT:
	postgres: None

-----------
QUERY:

select events & 4 != 0 AS upd,
       events & 8 != 0 AS ins,
       events & 16 != 0 AS del
  from pg_catalog.pg_relation_is_updatable('uv_pt'::regclass, false) t(events);
RESULT:
	postgres: [(True, True, True)]

-----------
QUERY:

select pg_catalog.pg_column_is_updatable('uv_pt'::regclass, 1::smallint, false);
RESULT:
	postgres: [(True,)]

-----------
QUERY:

select pg_catalog.pg_column_is_updatable('uv_pt'::regclass, 2::smallint, false);
RESULT:
	postgres: [(True,)]

-----------
QUERY:

select table_name, is_updatable, is_insertable_into
  from information_schema.views where table_name = 'uv_ptv';
RESULT:
	postgres: [('uv_ptv', 'YES', 'YES')]

-----------
QUERY:

select table_name, column_name, is_updatable
  from information_schema.columns where table_name = 'uv_ptv' order by column_name;
RESULT:
	postgres: [('uv_ptv', 'a', 'YES'), ('uv_ptv', 'b', 'YES'), ('uv_ptv', 'v', 'YES')]

-----------
QUERY:

insert into uv_ptv values (1, 2);
RESULT:
	postgres: None

-----------
QUERY:

select tableoid::regclass, * from uv_pt;
RESULT:
	postgres: [('uv_pt11', 1, 2, None)]

-----------
QUERY:

create view uv_ptv_wco as select * from uv_pt where a = 0 with check option;
RESULT:
	postgres: None

-----------
QUERY:

insert into uv_ptv_wco values (1, 2);
RESULT:
	postgres: new row violates check option for view "uv_ptv_wco"
DETAIL:  Failing row contains (1, 2, null).


-----------
QUERY:

merge into uv_ptv t
  using (values (1,2), (1,4)) as v(a,b) on t.a = v.a -- fail: matches 2 src rows
  when matched then update set b = t.b + 1
  when not matched then insert values (v.a, v.b + 1);
RESULT:
	postgres: MERGE command cannot affect row a second time
HINT:  Ensure that not more than one source row matches any one target row.


-----------
QUERY:

merge into uv_ptv t
  using (values (1,2), (1,4)) as v(a,b) on t.a = v.a and t.b = v.b
  when matched then update set b = t.b + 1
  when not matched then insert values (v.a, v.b + 1);
RESULT:
	postgres: no partition of relation "uv_pt1" found for row
DETAIL:  Partition key of the failing row contains (b) = (5).


-----------
QUERY:
 -- fail: no partition for b=5
merge into uv_ptv t
  using (values (1,2), (1,3)) as v(a,b) on t.a = v.a and t.b = v.b
  when matched then update set b = t.b + 1
  when not matched then insert values (v.a, v.b + 1);
RESULT:
	postgres: None

-----------
QUERY:
 -- ok
select tableoid::regclass, * from uv_pt order by a, b;
RESULT:
	postgres: [('uv_pt11', 1, 3, None), ('uv_pt11', 1, 4, None)]

-----------
QUERY:

drop view uv_ptv, uv_ptv_wco;
RESULT:
	postgres: None

-----------
QUERY:

drop table uv_pt, uv_pt1, uv_pt11;
RESULT:
	postgres: None

-----------
QUERY:


-- check that wholerow vars appearing in WITH CHECK OPTION constraint expressions
-- work fine with partitioned tables
create table wcowrtest (a int) partition by list (a);
RESULT:
	postgres: None

-----------
QUERY:

create table wcowrtest1 partition of wcowrtest for values in (1);
RESULT:
	postgres: None

-----------
QUERY:

create view wcowrtest_v as select * from wcowrtest where wcowrtest = '(2)'::wcowrtest with check option;
RESULT:
	postgres: None

-----------
QUERY:

insert into wcowrtest_v values (1);
RESULT:
	postgres: new row violates check option for view "wcowrtest_v"
DETAIL:  Failing row contains (1).


-----------
QUERY:


alter table wcowrtest add b text;
RESULT:
	postgres: None

-----------
QUERY:

create table wcowrtest2 (b text, c int, a int);
RESULT:
	postgres: None

-----------
QUERY:

alter table wcowrtest2 drop c;
RESULT:
	postgres: None

-----------
QUERY:

alter table wcowrtest attach partition wcowrtest2 for values in (2);
RESULT:
	postgres: None

-----------
QUERY:


create table sometable (a int, b text);
RESULT:
	postgres: None

-----------
QUERY:

insert into sometable values (1, 'a'), (2, 'b');
RESULT:
	postgres: None

-----------
QUERY:

create view wcowrtest_v2 as
    select *
      from wcowrtest r
      where r in (select s from sometable s where r.a = s.a)
with check option;
RESULT:
	postgres: None

-----------
QUERY:


-- WITH CHECK qual will be processed with wcowrtest2/* REPLACED */''s
-- rowtype after tuple-routing
insert into wcowrtest_v2 values (2, 'no such row in sometable');
RESULT:
	postgres: new row violates check option for view "wcowrtest_v2"
DETAIL:  Failing row contains (2, no such row in sometable).


-----------
QUERY:


drop view wcowrtest_v, wcowrtest_v2;
RESULT:
	postgres: None

-----------
QUERY:

drop table wcowrtest, sometable;
RESULT:
	postgres: None

-----------
QUERY:


-- Check INSERT .. ON CONFLICT DO UPDATE works correctly when the view/* REPLACED */''s
-- columns are named and ordered differently than the underlying table/* REPLACED */''s.
create table uv_iocu_tab (a text unique, b float);
RESULT:
	postgres: None

-----------
QUERY:

insert into uv_iocu_tab values ('xyxyxy', 0);
RESULT:
	postgres: None

-----------
QUERY:

create view uv_iocu_view as
   select b, b+1 as c, a, '2.0'::text as two from uv_iocu_tab;
RESULT:
	postgres: None

-----------
QUERY:


insert into uv_iocu_view (a, b) values ('xyxyxy', 1)
   on conflict (a) do update set b = uv_iocu_view.b;
RESULT:
	postgres: None

-----------
QUERY:

select * from uv_iocu_tab;
RESULT:
	postgres: [('xyxyxy', 0.0)]

-----------
QUERY:

insert into uv_iocu_view (a, b) values ('xyxyxy', 1)
   on conflict (a) do update set b = excluded.b;
RESULT:
	postgres: None

-----------
QUERY:

select * from uv_iocu_tab;
RESULT:
	postgres: [('xyxyxy', 1.0)]

-----------
QUERY:


-- OK to access view columns that are not present in underlying base
-- relation in the ON CONFLICT portion of the query
insert into uv_iocu_view (a, b) values ('xyxyxy', 3)
   on conflict (a) do update set b = cast(excluded.two as float);
RESULT:
	postgres: None

-----------
QUERY:

select * from uv_iocu_tab;
RESULT:
	postgres: [('xyxyxy', 2.0)]

-----------
QUERY:


explain (costs off)
insert into uv_iocu_view (a, b) values ('xyxyxy', 3)
   on conflict (a) do update set b = excluded.b where excluded.c > 0;
RESULT:
	postgres: [('Insert on uv_iocu_tab',), ('  Conflict Resolution: UPDATE',), ('  Conflict Arbiter Indexes: uv_iocu_tab_a_key',), ("  Conflict Filter: ((excluded.b + '1'::double precision) > '0'::double precision)",), ('  ->  Result',)]

-----------
QUERY:


insert into uv_iocu_view (a, b) values ('xyxyxy', 3)
   on conflict (a) do update set b = excluded.b where excluded.c > 0;
RESULT:
	postgres: None

-----------
QUERY:

select * from uv_iocu_tab;
RESULT:
	postgres: [('xyxyxy', 3.0)]

-----------
QUERY:


drop view uv_iocu_view;
RESULT:
	postgres: None

-----------
QUERY:

drop table uv_iocu_tab;
RESULT:
	postgres: None

-----------
QUERY:


-- Test whole-row references to the view
create table uv_iocu_tab (a int unique, b text);
RESULT:
	postgres: None

-----------
QUERY:

create view uv_iocu_view as
    select b as bb, a as aa, uv_iocu_tab::text as cc from uv_iocu_tab;
RESULT:
	postgres: None

-----------
QUERY:


insert into uv_iocu_view (aa,bb) values (1,'x');
RESULT:
	postgres: None

-----------
QUERY:

explain (costs off)
insert into uv_iocu_view (aa,bb) values (1,'y')
   on conflict (aa) do update set bb = 'Rejected: '||excluded.*
   where excluded.aa > 0
   and excluded.bb != ''
   and excluded.cc is not null;
RESULT:
	postgres: [('Insert on uv_iocu_tab',), ('  Conflict Resolution: UPDATE',), ('  Conflict Arbiter Indexes: uv_iocu_tab_a_key',), ("  Conflict Filter: ((excluded.a > 0) AND (excluded.b <> ''::text) AND ((excluded.*)::text IS NOT NULL))",), ('  ->  Result',)]

-----------
QUERY:

insert into uv_iocu_view (aa,bb) values (1,'y')
   on conflict (aa) do update set bb = 'Rejected: '||excluded.*
   where excluded.aa > 0
   and excluded.bb != ''
   and excluded.cc is not null;
RESULT:
	postgres: None

-----------
QUERY:

select * from uv_iocu_view;
RESULT:
	postgres: [('Rejected: (y,1,"(1,y)")', 1, '(1,"Rejected: (y,1,""(1,y)"")")')]

-----------
QUERY:


-- Test omitting a column of the base relation
delete from uv_iocu_view;
RESULT:
	postgres: None

-----------
QUERY:

insert into uv_iocu_view (aa,bb) values (1,'x');
RESULT:
	postgres: None

-----------
QUERY:

insert into uv_iocu_view (aa) values (1)
   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
RESULT:
	postgres: None

-----------
QUERY:

select * from uv_iocu_view;
RESULT:
	postgres: [('Rejected: (,1,"(1,)")', 1, '(1,"Rejected: (,1,""(1,)"")")')]

-----------
QUERY:


alter table uv_iocu_tab alter column b set default 'table default';
RESULT:
	postgres: None

-----------
QUERY:

insert into uv_iocu_view (aa) values (1)
   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
RESULT:
	postgres: None

-----------
QUERY:

select * from uv_iocu_view;
RESULT:
	postgres: [('Rejected: ("table default",1,"(1,""table default"")")', 1, '(1,"Rejected: (""table default"",1,""(1,""""table default"""")"")")')]

-----------
QUERY:


alter view uv_iocu_view alter column bb set default 'view default';
RESULT:
	postgres: None

-----------
QUERY:

insert into uv_iocu_view (aa) values (1)
   on conflict (aa) do update set bb = 'Rejected: '||excluded.*;
RESULT:
	postgres: None

-----------
QUERY:

select * from uv_iocu_view;
RESULT:
	postgres: [('Rejected: ("view default",1,"(1,""view default"")")', 1, '(1,"Rejected: (""view default"",1,""(1,""""view default"""")"")")')]

-----------
QUERY:


-- Should fail to update non-updatable columns
insert into uv_iocu_view (aa) values (1)
   on conflict (aa) do update set cc = 'XXX';
RESULT:
	postgres: cannot insert into column "cc" of view "uv_iocu_view"
DETAIL:  View columns that are not columns of their base relation are not updatable.


-----------
QUERY:


drop view uv_iocu_view;
RESULT:
	postgres: None

-----------
QUERY:

drop table uv_iocu_tab;
RESULT:
	postgres: None

-----------
QUERY:


-- ON CONFLICT DO UPDATE permissions checks
create user regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

create user regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


set session authorization regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

create table base_tbl(a int unique, b text, c float);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tbl values (1,'xxx',1.0);
RESULT:
	postgres: None

-----------
QUERY:

create view rw_view1 as select b as bb, c as cc, a as aa from base_tbl;
RESULT:
	postgres: None

-----------
QUERY:


grant select (aa,bb) on rw_view1 to regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

grant insert on rw_view1 to regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

grant update (bb) on rw_view1 to regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


set session authorization regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

insert into rw_view1 values ('yyy',2.0,1)
  on conflict (aa) do update set bb = excluded.cc;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- Not allowed
insert into rw_view1 values ('yyy',2.0,1)
  on conflict (aa) do update set bb = rw_view1.cc;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- Not allowed
insert into rw_view1 values ('yyy',2.0,1)
  on conflict (aa) do update set bb = excluded.bb;
RESULT:
	postgres: None

-----------
QUERY:
 -- OK
insert into rw_view1 values ('zzz',2.0,1)
  on conflict (aa) do update set bb = rw_view1.bb||'xxx';
RESULT:
	postgres: None

-----------
QUERY:
 -- OK
insert into rw_view1 values ('zzz',2.0,1)
  on conflict (aa) do update set cc = 3.0;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- Not allowed
reset session authorization;
RESULT:
	postgres: None

-----------
QUERY:

select * from base_tbl;
RESULT:
	postgres: [(1, 'yyyxxx', 1.0)]

-----------
QUERY:


set session authorization regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

grant select (a,b) on base_tbl to regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

grant insert (a,b) on base_tbl to regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

grant update (a,b) on base_tbl to regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


set session authorization regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

create view rw_view2 as select b as bb, c as cc, a as aa from base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

insert into rw_view2 (aa,bb) values (1,'xxx')
  on conflict (aa) do update set bb = excluded.bb;
RESULT:
	postgres: permission denied for table base_tbl


-----------
QUERY:
 -- Not allowed
create view rw_view3 as select b as bb, a as aa from base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

insert into rw_view3 (aa,bb) values (1,'xxx')
  on conflict (aa) do update set bb = excluded.bb;
RESULT:
	postgres: None

-----------
QUERY:
 -- OK
reset session authorization;
RESULT:
	postgres: None

-----------
QUERY:

select * from base_tbl;
RESULT:
	postgres: [(1, 'xxx', 1.0)]

-----------
QUERY:


set session authorization regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:

create view rw_view4 as select aa, bb, cc FROM rw_view1;
RESULT:
	postgres: None

-----------
QUERY:

insert into rw_view4 (aa,bb) values (1,'yyy')
  on conflict (aa) do update set bb = excluded.bb;
RESULT:
	postgres: permission denied for view rw_view1


-----------
QUERY:
 -- Not allowed
create view rw_view5 as select aa, bb FROM rw_view1;
RESULT:
	postgres: None

-----------
QUERY:

insert into rw_view5 (aa,bb) values (1,'yyy')
  on conflict (aa) do update set bb = excluded.bb;
RESULT:
	postgres: None

-----------
QUERY:
 -- OK
reset session authorization;
RESULT:
	postgres: None

-----------
QUERY:

select * from base_tbl;
RESULT:
	postgres: [(1, 'yyy', 1.0)]

-----------
QUERY:


drop view rw_view5;
RESULT:
	postgres: None

-----------
QUERY:

drop view rw_view4;
RESULT:
	postgres: None

-----------
QUERY:

drop view rw_view3;
RESULT:
	postgres: None

-----------
QUERY:

drop view rw_view2;
RESULT:
	postgres: None

-----------
QUERY:

drop view rw_view1;
RESULT:
	postgres: None

-----------
QUERY:

drop table base_tbl;
RESULT:
	postgres: None

-----------
QUERY:

drop user regress_view_user1;
RESULT:
	postgres: None

-----------
QUERY:

drop user regress_view_user2;
RESULT:
	postgres: None

-----------
QUERY:


-- Test single- and multi-row inserts with table and view defaults.
-- Table defaults should be used, unless overridden by view defaults.
create table base_tab_def (a int, b text default 'Table default',
                           c text default 'Table default', d text, e text);
RESULT:
	postgres: None

-----------
QUERY:

create view base_tab_def_view as select * from base_tab_def;
RESULT:
	postgres: None

-----------
QUERY:

alter view base_tab_def_view alter b set default 'View default';
RESULT:
	postgres: None

-----------
QUERY:

alter view base_tab_def_view alter d set default 'View default';
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (1);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (2), (3);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (4, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (5, default, default, default, default),
                                (6, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (11);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (12), (13);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (14, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (15, default, default, default, default),
                                     (16, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (17), (default);
RESULT:
	postgres: None

-----------
QUERY:

select * from base_tab_def order by a;
RESULT:
	postgres: [(1, 'Table default', 'Table default', None, None), (2, 'Table default', 'Table default', None, None), (3, 'Table default', 'Table default', None, None), (4, 'Table default', 'Table default', None, None), (5, 'Table default', 'Table default', None, None), (6, 'Table default', 'Table default', None, None), (11, 'View default', 'Table default', 'View default', None), (12, 'View default', 'Table default', 'View default', None), (13, 'View default', 'Table default', 'View default', None), (14, 'View default', 'Table default', 'View default', None), (15, 'View default', 'Table default', 'View default', None), (16, 'View default', 'Table default', 'View default', None), (17, 'View default', 'Table default', 'View default', None), (None, 'View default', 'Table default', 'View default', None)]

-----------
QUERY:


-- Adding an INSTEAD OF trigger should cause NULLs to be inserted instead of
-- table defaults, where there are no view defaults.
create function base_tab_def_view_instrig_func() returns trigger
as
$$
begin
  insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
  return new;
end;
$$
language plpgsql;
RESULT:
	postgres: None

-----------
QUERY:

create trigger base_tab_def_view_instrig instead of insert on base_tab_def_view
  for each row execute function base_tab_def_view_instrig_func();
RESULT:
	postgres: None

-----------
QUERY:

truncate base_tab_def;
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (1);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (2), (3);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (4, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (5, default, default, default, default),
                                (6, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (11);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (12), (13);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (14, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (15, default, default, default, default),
                                     (16, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (17), (default);
RESULT:
	postgres: None

-----------
QUERY:

select * from base_tab_def order by a;
RESULT:
	postgres: [(1, 'Table default', 'Table default', None, None), (2, 'Table default', 'Table default', None, None), (3, 'Table default', 'Table default', None, None), (4, 'Table default', 'Table default', None, None), (5, 'Table default', 'Table default', None, None), (6, 'Table default', 'Table default', None, None), (11, 'View default', None, 'View default', None), (12, 'View default', None, 'View default', None), (13, 'View default', None, 'View default', None), (14, 'View default', None, 'View default', None), (15, 'View default', None, 'View default', None), (16, 'View default', None, 'View default', None), (17, 'View default', None, 'View default', None), (None, 'View default', None, 'View default', None)]

-----------
QUERY:


-- Using an unconditional DO INSTEAD rule should also cause NULLs to be
-- inserted where there are no view defaults.
drop trigger base_tab_def_view_instrig on base_tab_def_view;
RESULT:
	postgres: None

-----------
QUERY:

drop function base_tab_def_view_instrig_func;
RESULT:
	postgres: None

-----------
QUERY:

create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view
  do instead insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
RESULT:
	postgres: None

-----------
QUERY:

truncate base_tab_def;
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (1);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (2), (3);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (4, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (5, default, default, default, default),
                                (6, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (11);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (12), (13);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (14, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (15, default, default, default, default),
                                     (16, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (17), (default);
RESULT:
	postgres: None

-----------
QUERY:

select * from base_tab_def order by a;
RESULT:
	postgres: [(1, 'Table default', 'Table default', None, None), (2, 'Table default', 'Table default', None, None), (3, 'Table default', 'Table default', None, None), (4, 'Table default', 'Table default', None, None), (5, 'Table default', 'Table default', None, None), (6, 'Table default', 'Table default', None, None), (11, 'View default', None, 'View default', None), (12, 'View default', None, 'View default', None), (13, 'View default', None, 'View default', None), (14, 'View default', None, 'View default', None), (15, 'View default', None, 'View default', None), (16, 'View default', None, 'View default', None), (17, 'View default', None, 'View default', None), (None, 'View default', None, 'View default', None)]

-----------
QUERY:


-- A DO ALSO rule should cause each row to be inserted twice. The first
-- insert should behave the same as an auto-updatable view (using table
-- defaults, unless overridden by view defaults). The second insert should
-- behave the same as a rule-updatable view (inserting NULLs where there are
-- no view defaults).
drop rule base_tab_def_view_ins_rule on base_tab_def_view;
RESULT:
	postgres: None

-----------
QUERY:

create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view
  do also insert into base_tab_def values (new.a, new.b, new.c, new.d, new.e);
RESULT:
	postgres: None

-----------
QUERY:

truncate base_tab_def;
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (1);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (2), (3);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (4, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def values (5, default, default, default, default),
                                (6, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (11);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (12), (13);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (14, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (15, default, default, default, default),
                                     (16, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (17), (default);
RESULT:
	postgres: None

-----------
QUERY:

select * from base_tab_def order by a, c NULLS LAST;
RESULT:
	postgres: [(1, 'Table default', 'Table default', None, None), (2, 'Table default', 'Table default', None, None), (3, 'Table default', 'Table default', None, None), (4, 'Table default', 'Table default', None, None), (5, 'Table default', 'Table default', None, None), (6, 'Table default', 'Table default', None, None), (11, 'View default', 'Table default', 'View default', None), (11, 'View default', None, 'View default', None), (12, 'View default', 'Table default', 'View default', None), (12, 'View default', None, 'View default', None), (13, 'View default', 'Table default', 'View default', None), (13, 'View default', None, 'View default', None), (14, 'View default', 'Table default', 'View default', None), (14, 'View default', None, 'View default', None), (15, 'View default', 'Table default', 'View default', None), (15, 'View default', None, 'View default', None), (16, 'View default', 'Table default', 'View default', None), (16, 'View default', None, 'View default', None), (17, 'View default', 'Table default', 'View default', None), (17, 'View default', None, 'View default', None), (None, 'View default', 'Table default', 'View default', None), (None, 'View default', None, 'View default', None)]

-----------
QUERY:


-- Test a DO ALSO INSERT ... SELECT rule
drop rule base_tab_def_view_ins_rule on base_tab_def_view;
RESULT:
	postgres: None

-----------
QUERY:

create rule base_tab_def_view_ins_rule as on insert to base_tab_def_view
  do also insert into base_tab_def (a, b, e) select new.a, new.b, 'xxx';
RESULT:
	postgres: None

-----------
QUERY:

truncate base_tab_def;
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (1, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_def_view values (2, default, default, default, default),
                                     (3, default, default, default, default);
RESULT:
	postgres: None

-----------
QUERY:

select * from base_tab_def order by a, e nulls first;
RESULT:
	postgres: [(1, 'View default', 'Table default', 'View default', None), (1, 'View default', 'Table default', None, 'xxx'), (2, 'View default', 'Table default', 'View default', None), (2, 'View default', 'Table default', None, 'xxx'), (3, 'View default', 'Table default', 'View default', None), (3, 'View default', 'Table default', None, 'xxx')]

-----------
QUERY:


drop view base_tab_def_view;
RESULT:
	postgres: None

-----------
QUERY:

drop table base_tab_def;
RESULT:
	postgres: None

-----------
QUERY:


-- Test defaults with array assignments
create table base_tab (a serial, b int[], c text, d text default 'Table default');
RESULT:
	postgres: None

-----------
QUERY:

create view base_tab_view as select c, a, b from base_tab;
RESULT:
	postgres: None

-----------
QUERY:

alter view base_tab_view alter column c set default 'View default';
RESULT:
	postgres: None

-----------
QUERY:

insert into base_tab_view (b[1], b[2], c, b[5], b[4], a, b[3])
values (1, 2, default, 5, 4, default, 3), (10, 11, 'C value', 14, 13, 100, 12);
RESULT:
	postgres: None

-----------
QUERY:

select * from base_tab order by a;
RESULT:
	postgres: [(1, [1, 2, 3, 4, 5], 'View default', 'Table default'), (100, [10, 11, 12, 13, 14], 'C value', 'Table default')]

-----------
QUERY:

drop view base_tab_view;
RESULT:
	postgres: None

-----------
QUERY:

drop table base_tab;
RESULT:
	postgres: None
